---
title: 雲端原生 DevOps
description: 架構適用于 Azure 的雲端原生 .NET 應用程式 |雲端原生 DevOps
ms.date: 06/30/2019
ms.openlocfilehash: 84d37d14af8a68a51088568ded05ceef2e5e11fb
ms.sourcegitcommit: 2e95559d957a1a942e490c5fd916df04b39d73a9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/16/2019
ms.locfileid: "72393722"
---
# <a name="cloud-native-devops"></a>雲端原生 DevOps

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

軟體顧問的最愛口號是回答「It 相依」的問題。 這不是因為軟體顧問喜歡不接受某一個位置。 這是因為軟體中的任何問題都沒有真正的解答。 絕對不會有任何權利和錯誤，而是相反之間的平衡。

比方說，開發 web 應用程式的兩個主要學校：單一頁面應用程式（Spa）與伺服器端應用程式。 一方面，使用者經驗傾向于 Spa，而網頁伺服器的流量可能會最小化，讓您能夠將它們裝載在簡單的靜態裝載上。 另一方面，Spa 的開發速度較慢，而且更容易測試。 哪一個是正確的選擇？ 這也取決於您的情況。

雲端原生應用程式不會受限於相同的二分法。 它們在開發、穩定性和擴充性方面都有清楚的優勢，但管理起來可能會很困難。

幾年前，將應用程式從開發移至生產環境，再花上一個月，甚至更多的過程並不罕見。 公司以6個月或甚至每年的速度發行軟體。 除了 Microsoft Windows 以外，您還需要在 Windows 10 的過去一天內，瞭解發行的步調。 Windows XP 與 Vista 之間有五年的時間，Vista 與 Windows 7 之間有一個進一步的3個。

現在已妥善建立，可以快速發行軟體，讓更快速的公司在其 sloth 的競爭對手方面有相當大的市場優勢。 這是因為 Windows 10 的重大更新現在大約每六個月。

可讓您更快、更可靠的版本提供價值給企業的模式和實務，統稱為 DevOps。 其中包含跨越整個軟體發展生命週期的各種想法，從指定應用程式一直到傳遞和操作該應用程式都是如此。

DevOps 會在微服務之前出現，而且很可能會在沒有 DevOps 的情況下，讓您更輕鬆地在生產環境中釋出和操作一個但多個應用程式，而不會有更適合的目的服務。 

![圖11-0 搜尋趨勢顯示，微服務的成長不會開始，直到 DevOps 是一個建立良好的想法為止。](./media/microservices-vs-devops.png)

透過良好的 DevOps 實務，可以在實際操作應用程式的山地工作下，實現雲端原生應用程式的優點，而不需要 suffocating。

DevOps 時沒有黃金 hammer。 沒有人可以銷售一套完整且全面的解決方案來發行和操作高品質的應用程式。 這是因為每個應用程式的差異與所有其他應用程式截然不同。 不過，有些工具可以讓 DevOps 的工作更不艱巨。 其中一個工具稱為 Azure DevOps。

## <a name="azure-devops"></a>Azure DevOps

Azure DevOps 具有長歷史。 當 Team Foundation Server 第一次在線上移動，以及透過各種名稱變更時，它可以將其根重新追蹤至： Visual Studio Online 和 Visual Studio Team Services。 不過，過去幾年來，它就會變得遠超過其前身。

Azure DevOps 分成五個主要元件：

![圖 11-1 Azure DevOps 的五個主要區域](./media/devops-components.png)

**Azure Boards** -提供問題和工作專案追蹤工具，致力於讓使用者挑選最適合他們的工作流程。 其中包含一些預先設定的範本，其中包括支援 SCRUM 和看式開發的樣式。 

支援早期 Team Foundation 版本控制（TFVC）和業界最愛 git 的**Azure Repos**原始碼管理。 提取要求提供了一種方式，可讓您在進行變更時進行討論，藉以啟用社交編碼。

**Azure Pipelines** -支援與 Azure 緊密整合的組建和發行管理系統。 組建可以在各種不同的平臺上執行，從 Windows 到 Linux，再到 MacOS。 組建代理程式可能會布建在雲端或內部部署中。

**Azure Test Plans** -Test Plans 功能提供的測試管理和探勘測試支援不會留下任何 QA 人員。

**Azure Artifacts** -一種成品摘要，可讓公司建立自己、內部、版本的 NuGet、npm 及其他專案。 如果集中式存放庫失敗，它會以雙重目的作為上游套件的快取。

Azure DevOps 中的最上層組織單位稱為「專案」（Project）。 在每個專案中，可以開啟和關閉各種元件（例如 Azure Artifacts）。 如果使用者想要在 GitHub 中管理自己的原始程式碼，但仍然利用 Azure Pipelines，那麼就可以做到這一點。 事實上，許多開放原始碼專案會利用 Azure DevOps 所提供的[免費組建](https://azure.microsoft.com/blog/announcing-azure-pipelines-with-unlimited-ci-cd-minutes-for-open-source/)，同時將其原始程式碼保留在 GitHub 上。 某些重要的開放原始碼專案（例如[Visual Studio Code](https://code.visualstudio.com/)、 [yarn](https://yarnpkg.com/en/)、 [gulp](https://gulpjs.com/)和[NumPy](https://www.numpy.org/) ）已進行轉換。

每個元件都提供雲端原生應用程式的一些優點，但最有用的三個是原始檔控制、面板和管線。  

## <a name="source-control"></a>原始檔控制

為雲端原生應用程式組織程式碼可能是一項挑戰。 雲端原生應用程式通常是由彼此通訊的小型應用程式 web 所組成，而不是單一的大型應用程式。 就像計算中的所有專案一樣，程式碼的最佳排列仍然是開放的問題。 有一些使用不同版面配置的成功應用程式範例，但兩個變體似乎最受歡迎。

在進入實際的原始檔控制本身之前，您可能值得決定適當的專案數目。 在單一專案中，支援多個存放庫和組建管線。 面板有點複雜，但是工作也可以輕鬆地指派給單一專案中的多個小組。 從單一 Azure DevOps 專案中，您肯定可以支援數百個甚至數千個開發人員。 這麼做可能是最佳的方法，因為它提供單一位置，讓所有開發人員都能使用，並減少當開發人員不確定該應用程式所在的專案時，發現它的混淆。

分割 Azure DevOps 專案中的微服務程式代碼可能會有更大的挑戰。

![圖11-2 單一與多個存放庫](./media/single-repository-vs-multiple.png)

### <a name="repository-per-microservice"></a>每個微服務的存放庫

乍看之下，這似乎是分割原始程式碼以進行微服務的最邏輯方法。 每個存放庫都可以包含建立一個微服務所需的程式碼。 這種方法的優點很容易看到：

1. 建立和維護應用程式的指示可以新增至每個存放庫根目錄中的讀我檔案。 當您透過存放庫進行翻轉時，很容易就能找到這些指示，縮短開發人員的加速時間。
2. 每個服務都位於邏輯位置，只要知道服務的名稱，就能輕鬆找到。
3. 您可以輕鬆地設定組建，使其只有在對擁有存放庫進行變更時才會觸發。
4. 進入存放庫的變更數僅限於處理專案的少數開發人員。
5. 藉由限制開發人員擁有讀取和寫入權限的儲存機制，可輕鬆設定安全性。
6. 主控小組可以變更存放庫層級設定，與其他人的討論最少。

微服務背後的其中一個重要概念是，服務應該區分開來，並彼此區隔。 使用網域導向設計來決定服務的界限時，服務會作為交易界限。 資料庫更新不應跨越多個服務。 這項相關資料的集合稱為「系結內容」。  這項想法的反映是將微服務資料隔離到資料庫，並獨立于其餘的服務。 這讓您有很大的想法，可以將這種作法帶到原始程式碼。

不過，這種方法並不會有問題。 我們時間的其中一個比較 gnarly 的開發問題是管理相依性。 請考慮組成平均 `node_modules` 目錄的檔案數目。 如 `create-react-app` 的全新安裝可能會攜帶數以千計的套件。 如何管理這些相依性的問題，是一項很棘手的問題。 

如果相依性已更新，下游套件也必須更新此相依性。 可惜的是，這會進行開發工作，因此，`node_modules` 目錄最後會有單一封裝的多個版本，而每個套件的相依性會略有不同的步調版本。 部署應用程式時，應該使用哪個版本的相依性？ 目前在生產環境中的版本？ 目前在搶鮮版（Beta）中，但在取用者進入生產階段時可能會在生產環境中的版本？ 只使用微服務不會解決的困難問題。

有各種不同的專案相依的程式庫。 藉由將微服務除以每個存放庫中的其中一個，可使用內部存放庫（Azure Artifacts）來最佳解析內部相依性。 程式庫的組建會將其最新版本推送至 Azure Artifacts 以供內部使用。 下游專案仍然必須手動更新，才能依賴新更新的套件。

在服務之間移動程式碼時，有另一個缺點會自我呈現。 雖然相信將應用程式的第一個部門分割成微服務是 100% 正確，但事實上，我們很少會 prescient 為不會產生服務部門錯誤。 因此，功能和驅動它的程式碼必須從服務到服務：存放庫移至存放庫。 當您從某個存放庫大幅新增了至另一個儲存機制時，程式碼會失去其歷程記錄。 在許多情況下，尤其是在 audit 的事件中，有一段程式碼的完整歷程記錄非常寶貴。

最後也可能是最重要的缺點，就是協調變更。 在真正的微服務應用程式中，服務之間不應該有任何部署相依性。 您應該依任何順序部署服務 A、B 和 C，因為它們的結合性不盡相同。 不過事實上，有時候會想要同時進行跨多個存放庫的變更。 部分範例包括更新程式庫以關閉安全性漏洞，或變更所有服務所使用的通訊協定。

若要進行跨存放庫變更，必須將每個存放庫的認可連續進行。 每個存放庫中的每個變更都必須個別提取要求和檢查。 這可能很容易協調，而且通常會令人困擾。

使用許多存放庫的另一種方式，是將所有原始程式碼放在一個巨大、所有的單一存放庫中。

### <a name="single-repository"></a>單一存放庫

在此方法中，有時稱為「 [monorepository](https://danluu.com/monorepo/)」，每個服務的所有原始程式碼都會放入相同的儲存機制中。 一開始，這似乎是很可怕的概念，可能會讓您難以處理原始程式碼。 不過，有一些標示的優點可讓您以這種方式運作。

第一個優點是，管理專案之間的相依性比較容易。 專案可以直接彼此匯入，而不是依賴某些外部成品摘要。 這表示更新是即時的，而且在編譯時期可能會在開發人員工作站上找到衝突的版本。 實際上，將一些整合測試轉移到左邊。

在專案之間移動程式碼時，您現在可以更輕鬆地保留歷程記錄，因為檔案會被偵測為已移動，而不是重寫。

另一個優點是跨服務界限的廣泛變更可以在單一認可中進行。 這可減少可能會個別審查變更的額外負荷。

有許多工具可執行程式碼的靜態分析，以偵測不安全的程式設計做法或有問題地使用 Api。 在多存放庫的世界中，每個存放庫都必須反復查看，才能找出問題。 單一存放庫可讓您在同一處執行分析。

單一存放庫方法也有許多缺點。 其中一個最重要的是，讓單一存放庫引發安全性考慮。 如果存放庫的內容在每個服務模型的存放庫中流失，則遺失的程式碼數量最少。 使用單一存放庫，公司擁有的所有專案都可能會遺失。 在過去發生這種情況時，有很多範例會 derailing 整個遊戲開發工作。 擁有多個存放庫會公開較少的介面區，這是大部分安全性作法中非常理想的特性。

單一存放庫的大小可能很快就會變得難以管理。 這會帶來一些有趣的效能影響。 您可能需要使用特定的工具，例如[適用于 Git 的虛擬檔案系統](https://vfsforgit.org/)，其原本是設計來改善開發人員對 Windows 小組的體驗。

使用單一存放庫的引數通常會向下細分為 Facebook 或 Google 使用此方法進行原始程式碼安排的引數。 如果此方法對這些公司而言夠好，那麼就一定是適用于所有公司的正確方法。 事實上，非常少的公司會針對 Facebook 或 Google 的規模等任何專案進行操作。 這些規模所發生的問題與大部分的開發人員會面臨的不同。 適用于 goose 的好處可能不適合看。

最後，這兩個解決方案都可以用來裝載微服務的原始程式碼。 不過，在大多數情況下，在單一存放庫中操作的管理和工程負荷，並不值得 meager 的優點。 將程式碼分割到多個存放庫，鼓勵更好的顧慮區隔，並鼓勵開發團隊之間的自主性。  

### <a name="standard-directory-structure"></a>標準目錄結構

無論單一或多個存放庫都爭論，每個服務都有自己的目錄。 讓開發人員快速地跨專案進行的最佳優化之一，是維護標準目錄結構。

![圖11-3 電子郵件和登入服務的標準目錄結構](./media/dir-struct.png)

每當建立新的專案時，就應該使用放置正確結構的範本。 此範本也可以將這類有用的專案包含為基本架構讀我檔案和 @no__t 0。 在任何微服務架構中，專案之間的高度變異數會使服務的大量作業變得更棘手。

有許多工具可針對整個目錄提供範本化，其中包含數個原始程式碼目錄。 [Yeoman](https://yeoman.io/)在 JavaScript 世界中很熱門，GitHub 有最近發行的存放[庫範本](https://github.blog/2019-06-06-generate-new-repositories-with-repository-templates/)，可提供許多相同的功能。

## <a name="task-management"></a>任務管理

管理任何專案中的工作可能會很棘手。 在前面，有無數的問題需要回答，以確保開發人員能以最佳的生產力進行設定。

雲端原生應用程式通常會比傳統軟體產品小，或至少會分成較小的服務。 追蹤與這些服務相關的問題或工作，與任何其他軟體專案一樣重要。 任何人都不想要追蹤某個工作專案，或向客戶說明未正確記錄其問題。 面板會在專案層級進行設定，但在每個專案中，可以定義區域。 這些可讓您細分數個元件的問題。 將整個應用程式的所有工作都放在同一個位置的優點是，您可以輕鬆地將工作專案從一個小組移到另一個團隊，因為他們已獲得更好的瞭解。

Azure DevOps 隨附一些預先設定的熱門範本。 在最基本的設定中，您只需要知道待處理專案中的內容、人員的工作，以及完成的動作。 請務必讓您瞭解建立軟體的程式，以便將工作設定為優先處理，並向客戶回報已完成的作業。 當然，非常少的軟體專案會以 `to do`、`doing` 和 @no__t 2 等簡單的程式來處理。 人們不需要花很長的時間，就能開始將 `QA` 或 `Detailed Specification` 之類的步驟加入至進程。

Agile 方法的其中一個比較重要的部分，是固定間隔的自我自我檢查。 這些評論的目的是要讓您深入瞭解小組面臨的問題，以及如何改善。 這通常表示透過開發程式來變更問題和功能的流程。 因此，以額外的階段擴展面板的版面配置，會是完美的狀況。

面板中的階段並不是唯一的組織工具。 視面板的設定而定，有一個工作專案階層。 最細微的專案可以出現在面板上，這是一項任務。 根據預設，工作包含標題、描述、優先順序、剩餘工作量，以及連結至其他工作專案或開發專案（分支、認可、提取要求、組建等等）之能力的欄位。 工作專案可以分類到應用程式的不同區域和不同的反復專案（短期衝刺），以便更輕鬆地找到它們。

![圖 11-4 Azure DevOps 中的範例工作](./media/task-details.png)

[描述] 欄位支援您預期的一般樣式（粗體、斜體底線和刪除線），以及插入影像的能力。 這讓它成為一種功能強大的工具，可在指定工作或 bug 時使用。

工作可以匯總成功能，以定義較大的工作單位。 接著，您可以將功能[匯總到 epics](https://docs.microsoft.com/azure/devops/boards/backlogs/define-features-epics?view=azure-devops)。 將此階層中的工作分類，可讓您更輕鬆地瞭解如何關閉大型功能。

![圖11-5 基本流程範本中預設設定的工作專案類型](./media/board-issue-types.png)

Azure Boards 中的問題有不同類型的觀點。 尚未排程的專案會出現在待處理專案中。 您可以從該處將它們指派給短期衝刺。 短期衝刺是一個時間方塊，在這段期間內，將會完成一些工作數量。 這項工作可以包含工作，但也包括票證的解決方式。 之後，就可以從 [短期衝刺面板] 區段管理整個短期衝刺。 此視圖會顯示工作的進度，並包含 [向下燒錄] 圖表，以便在短期衝刺成功時，提供更新的評估。

![圖11-6 已定義短期衝刺的面板](./media/sprint-board.png)

現在，Azure DevOps 的面板中應該會有大量的電源。 對於開發人員而言，會有很簡單的觀點來處理。 專案經理可以查看即將推出的工作，以及現有工作的總覽。 對於管理員而言，有許多關於「空間」和「容量」的報告。 可惜的是，雲端原生應用程式沒有任何神奇，因此不需要追蹤工作。 但是，如果您必須追蹤工作，有幾個地方的經驗優於 Azure DevOps。

## <a name="cicd-pipelines"></a>CI/CD 管線

軟體發展生命週期幾乎不會有任何改變，因為持續整合（CI）和持續傳遞（CD）的問世。 一旦簽入變更時，立即針對專案的原始程式碼建立和執行自動化測試，會提早攔截錯誤。 在持續整合組建的出現之前，從存放庫提取程式碼，並找出它未通過測試或甚至無法建立的情況並不常見。 這會導致大量追蹤破壞的來源。

傳統上，將軟體運送到生產環境需要大量的檔和步驟清單。 這些步驟中的每一個都需要以手動方式在容易出錯的程式中完成。

![圖11-7 檢查清單](./media/checklist.png)

持續整合的備用是持續傳遞，其中全新建立的封裝會部署至環境。 手動程式無法調整以符合開發的速度，因此自動化變得更重要。 檢查清單是由腳本所取代，可以更快速且更精確地執行相同的工作。

持續傳遞所提供的環境可能是測試環境，或由許多主要技術公司所完成，可能是生產環境。 後者需要投資高品質的測試，讓您確信變更不會中斷使用者的生產環境。 與持續整合程式碼早期持續傳遞中的問題相同，會及早攔截部署程式中的問題。

將組建和傳遞程式自動化的重要性，是由雲端原生應用程式所 accentuated。 部署會更頻繁且更多環境，因此在不可能的情況中手動部署框線。

### <a name="azure-builds"></a>Azure 組建

Azure DevOps 提供一組工具，讓持續整合和部署比以往更容易。 這些工具位於 Azure Pipelines 之下。 第一個是 Azure 組建，這是一種可大規模執行以 YAML 為基礎之組建定義的工具。 使用者可以攜帶自己的組建電腦（適用于組建需要精心的環境），或使用來自 Azure 託管虛擬機器之經常重新整理集區的機器。 這些裝載的組建代理程式已預先安裝了各種不同的開發工具，不僅適用于 .NET 開發，還可用於從 JAVA 到 Python 到 iPhone 開發的所有專案。

DevOps 包含各種現成的組建定義，可以針對任何組建進行自訂。 組建定義定義于名為 `azure-pipelines.yml` 的檔案中，並簽入存放庫中，以便與原始程式碼一起進行版本設定。 這可讓您更輕鬆地對分支中的組建管線進行變更，因為可以將變更簽入到該分支中。 如圖11-8 所示，在完整架構上建立 ASP.NET web 應用程式的範例 `azure-pipelines.yml`。

```yml
name: $(rev:r)

variables:
  version: 9.2.0.$(Build.BuildNumber)
  solution: Portals.sln
  artifactName: drop
  buildPlatform: any cpu
  buildConfiguration: release
  
pool:
  name: Hosted VS2017
  demands:
  - msbuild
  - visualstudio
  - vstest

steps:
- task: NuGetToolInstaller@0
  displayName: 'Use NuGet 4.4.1'
  inputs:
    versionSpec: 4.4.1

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    restoreSolution: '$(solution)'
    
- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '-p:DeployOnBuild=true -p:WebPublishMethod=Package -p:PackageAsSingleFile=true -p:SkipInvalidConfigurations=true -p:PackageLocation="$(build.artifactstagingdirectory)\\"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: VSTest@2
  displayName: 'Test Assemblies'
  inputs:
    testAssemblyVer2: |
     **\$(buildConfiguration)\**\*test*.dll
     !**\obj\**
     !**\*testadapter.dll
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: CopyFiles@2
  displayName: 'Copy UI Test Files to: $(build.artifactstagingdirectory)'
  inputs:
    SourceFolder: UITests
    TargetFolder: '$(build.artifactstagingdirectory)/uitests'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact'
  inputs:
    PathtoPublish: '$(build.artifactstagingdirectory)'
    ArtifactName: '$(artifactName)'
  condition: succeededOrFailed()
```

**圖 11-8** -範例 azure-pipelines。 yml

此組建定義會使用一些內建工作，讓建立組建的程式變得簡單，就像建立一組（比巨型 Millennium Falcon 更簡單）。 例如，NuGet 工作會還原 NuGet 套件，而 VSBuild 工作會呼叫 Visual Studio 組建工具來執行實際的編譯。 Azure DevOps 中有數百種不同的工作可供使用，其中有數以千計的社區維護。 無論您想要執行的組建工作為何，都有可能是有人已經建立的工作。

組建可以透過簽入、排程或完成另一個組建來手動觸發。 在大多數情況下，都需要在每個簽入上建立。 您可以篩選組建，讓不同的組建針對存放庫的不同部分或針對不同的分支執行。 這可讓您在執行快速組建的案例中，減少對提取要求的測試，並在夜間針對主幹執行完整的回歸套件。

組建的最後結果是稱為「組建成品」的檔案集合。 這些成品可以傳遞至組建程式中的下一個步驟，或新增至 Azure 成品摘要，讓其他組建可以使用這些成品。

### <a name="azure-devops-releases"></a>Azure DevOps 版本

組建會負責將軟體編譯成可交付的套件，但仍需將成品推送至測試環境，才能完成持續傳遞。 為此，Azure DevOps 使用稱為「發行」的個別工具。 發行會使用與組建相同的工作程式庫，但會引進「階段」的概念。 階段是安裝套件的隔離環境。 例如，產品可能會使用開發、QA 和生產環境。 程式碼會持續傳遞至開發環境，讓您可以對其執行自動化測試。 一旦這些測試通過，發行就會移至 QA 環境進行手動測試。 最後，程式碼會推送至生產環境，讓每個人都可以看到它。

![圖11-9 具有開發、QA 和生產階段的範例發行管線](./media/release-pipeline.png)

在上一個階段完成後，組建中的每個階段都可以自動觸發。 不過，在許多情況下，這並不是理想的做法。 將程式碼移至生產環境可能需要有人核准。 版本藉由允許發行管線的每個步驟中的核准者，來支援這項功能。 您可以設定規則，讓特定人員或人員群組必須在發行進入生產環境之前先登出。 這些閘道允許手動執行品質檢查，同時也會遵循與控制要進入生產環境的相關法規需求。

### <a name="everybody-gets-a-build-pipeline"></a>每個人都會取得組建管線

設定許多組建管線並不會產生任何費用，因此，每個微服務至少有一個組建管線是有利的。 在理想的情況下，微服務可獨立部署到任何環境，讓每一個都能透過自己的管線發行，而不需要釋出不相關的程式碼。 每個管線可以有自己的一組核准，以允許每個服務的組建程式變體。

### <a name="versioning-releases"></a>版本控制版本

使用發行功能的一個缺點是，它無法在已簽入的 `azure-pipelines.yml` 檔案中定義。 有許多原因您可能想要從每個分支版本定義中，將發行基本架構包含在專案範本中。 幸好，工作正在將一些階段支援轉移到組建元件中。 這就是所謂的多階段組建，而[第一個版本現在已可供使用](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)！

>[!div class="step-by-step"]
>[上一頁](azure-security.md)
>[下一頁](infrastructure-as-code.md)
