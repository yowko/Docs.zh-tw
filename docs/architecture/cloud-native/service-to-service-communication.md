---
title: 服務對服務通訊
description: 瞭解後端雲端原生微服務如何與其他後端微服務通訊。
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: e9f27309fd6b03830ab3098d0fb08a7ecf5c0eaa
ms.sourcegitcommit: 56f1d1203d0075a461a10a301459d3aa452f4f47
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/24/2019
ms.locfileid: "71214395"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="ceba7-103">服務對服務通訊</span><span class="sxs-lookup"><span data-stu-id="ceba7-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="ceba7-104">從前端用戶端移動之後，我們現在會解決後端微服務彼此通訊的情形。</span><span class="sxs-lookup"><span data-stu-id="ceba7-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="ceba7-105">在建立雲端原生應用程式時，您會想要區分後端服務彼此通訊的方式。</span><span class="sxs-lookup"><span data-stu-id="ceba7-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="ceba7-106">在理想的情況下，服務間的通訊越少越好。</span><span class="sxs-lookup"><span data-stu-id="ceba7-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="ceba7-107">不過，不一定可以避免使用，因為後端服務通常會依賴另一個來完成操作。</span><span class="sxs-lookup"><span data-stu-id="ceba7-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="ceba7-108">有數個廣為接受的方法可執行跨服務通訊。</span><span class="sxs-lookup"><span data-stu-id="ceba7-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="ceba7-109">*通訊互動的類型*通常會決定最佳的方法。</span><span class="sxs-lookup"><span data-stu-id="ceba7-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="ceba7-110">請考慮下列互動類型：</span><span class="sxs-lookup"><span data-stu-id="ceba7-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="ceba7-111">*查詢*–呼叫微服務需要來自所呼叫微服務的回應，例如「嘿，為我提供指定客戶識別碼的買方資訊」。</span><span class="sxs-lookup"><span data-stu-id="ceba7-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="ceba7-112">*命令*–呼叫微服務需要另一個微服務來執行動作，但不需要回應，例如「嘿，只要寄出此訂單」。</span><span class="sxs-lookup"><span data-stu-id="ceba7-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="ceba7-113">*事件*–微服務（稱為「發行者」）會引發狀態已變更或已發生動作的事件。</span><span class="sxs-lookup"><span data-stu-id="ceba7-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="ceba7-114">其他有興趣的微服務稱為「訂閱者」，可以適當地回應事件。</span><span class="sxs-lookup"><span data-stu-id="ceba7-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="ceba7-115">「發行者」和「訂閱者」彼此不知道。</span><span class="sxs-lookup"><span data-stu-id="ceba7-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="ceba7-116">微服務系統通常會在執行需要跨服務互動的作業時，使用這些互動類型的組合。</span><span class="sxs-lookup"><span data-stu-id="ceba7-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="ceba7-117">讓我們仔細看一下每一種方法，以及您可以如何執行它們。</span><span class="sxs-lookup"><span data-stu-id="ceba7-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="ceba7-118">查詢</span><span class="sxs-lookup"><span data-stu-id="ceba7-118">Queries</span></span>

<span data-ttu-id="ceba7-119">許多時候，一個微服務可能需要*查詢*另一個，而需要立即回應才能完成作業。</span><span class="sxs-lookup"><span data-stu-id="ceba7-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="ceba7-120">購物籃微服務可能需要產品資訊和價格，才能將專案新增至購物籃。</span><span class="sxs-lookup"><span data-stu-id="ceba7-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="ceba7-121">有數種方法可以執行查詢作業。</span><span class="sxs-lookup"><span data-stu-id="ceba7-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="ceba7-122">要求/回應訊息</span><span class="sxs-lookup"><span data-stu-id="ceba7-122">Request/Response Messaging</span></span>

<span data-ttu-id="ceba7-123">執行此案例的其中一個選項是呼叫後端微服務，對它需要查詢的微服務提出直接的 HTTP 要求，如圖4-8 所示。</span><span class="sxs-lookup"><span data-stu-id="ceba7-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![直接 HTTP 通訊](./media/direct-http-communication.png)

<span data-ttu-id="ceba7-125">**圖 4-8**：</span><span class="sxs-lookup"><span data-stu-id="ceba7-125">**Figure 4-8**.</span></span> <span data-ttu-id="ceba7-126">直接 HTTP 通訊</span><span class="sxs-lookup"><span data-stu-id="ceba7-126">Direct HTTP communication</span></span>

<span data-ttu-id="ceba7-127">雖然微服務之間的直接 HTTP 呼叫相對較簡單，但還是應採取措施來將這種作法降到最低。</span><span class="sxs-lookup"><span data-stu-id="ceba7-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="ceba7-128">首先，這些呼叫一律是*同步*的，而且會封鎖作業，直到傳回結果或要求超時為止。</span><span class="sxs-lookup"><span data-stu-id="ceba7-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="ceba7-129">獨立、獨立的服務、能夠獨立開發和經常部署的功能，現在會彼此結合。</span><span class="sxs-lookup"><span data-stu-id="ceba7-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="ceba7-130">隨著微服務增加，其架構優勢也會降低。</span><span class="sxs-lookup"><span data-stu-id="ceba7-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="ceba7-131">針對某些系統，執行對另一個微服務進行單一直接 HTTP 呼叫的不常要求可能是可接受的。</span><span class="sxs-lookup"><span data-stu-id="ceba7-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="ceba7-132">不過，不建議對多個微服務叫用直接 HTTP 呼叫的高容量呼叫。</span><span class="sxs-lookup"><span data-stu-id="ceba7-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="ceba7-133">它們可以增加延遲，並對系統的效能、擴充性和可用性造成負面影響。</span><span class="sxs-lookup"><span data-stu-id="ceba7-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="ceba7-134">更糟的是，一長串的直接 HTTP 通訊可能會導致同步微服務呼叫的深度和複雜鏈，如圖4-9 所示：</span><span class="sxs-lookup"><span data-stu-id="ceba7-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![連結 HTTP 查詢](./media/chaining-http-queries.png)

<span data-ttu-id="ceba7-136">**圖 4-9**。</span><span class="sxs-lookup"><span data-stu-id="ceba7-136">**Figure 4-9**.</span></span> <span data-ttu-id="ceba7-137">連結 HTTP 查詢</span><span class="sxs-lookup"><span data-stu-id="ceba7-137">Chaining HTTP queries</span></span>

<span data-ttu-id="ceba7-138">您當然可以想像上圖所示的設計風險。</span><span class="sxs-lookup"><span data-stu-id="ceba7-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="ceba7-139">如果步驟\#3 失敗，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="ceba7-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="ceba7-140">或步驟\#8 失敗？</span><span class="sxs-lookup"><span data-stu-id="ceba7-140">Or Step \#8 fails?</span></span> <span data-ttu-id="ceba7-141">如何復原？</span><span class="sxs-lookup"><span data-stu-id="ceba7-141">How do you recover?</span></span> <span data-ttu-id="ceba7-142">如果步驟\#6 因為基礎服務忙碌而變慢，該怎麼辦？</span><span class="sxs-lookup"><span data-stu-id="ceba7-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="ceba7-143">您要如何繼續？</span><span class="sxs-lookup"><span data-stu-id="ceba7-143">How do you continue?</span></span> <span data-ttu-id="ceba7-144">即使所有作業都正常運作，您也可以考慮此呼叫會產生的延遲，這是每個步驟的延遲總和。</span><span class="sxs-lookup"><span data-stu-id="ceba7-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="ceba7-145">上圖中的大量結合性建議服務無法以最佳模式進行模型化。</span><span class="sxs-lookup"><span data-stu-id="ceba7-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="ceba7-146">它會 behoove 小組來重新審視其設計。</span><span class="sxs-lookup"><span data-stu-id="ceba7-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="ceba7-147">具體化視圖模式</span><span class="sxs-lookup"><span data-stu-id="ceba7-147">Materialized View pattern</span></span>

<span data-ttu-id="ceba7-148">移除微服務的結合常用的選項是 [[具體化視圖模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)]。</span><span class="sxs-lookup"><span data-stu-id="ceba7-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="ceba7-149">使用此模式時，微服務會儲存其本身的本機、反正規化的資料複本（由其他服務所擁有）。</span><span class="sxs-lookup"><span data-stu-id="ceba7-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="ceba7-150">除了購物籃微服務查詢產品目錄和定價微服務，它還會維護自己的本機資料複本。</span><span class="sxs-lookup"><span data-stu-id="ceba7-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="ceba7-151">此模式可排除不必要的結合性並改善可靠性和回應時間。</span><span class="sxs-lookup"><span data-stu-id="ceba7-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="ceba7-152">整個作業會在單一進程中執行。</span><span class="sxs-lookup"><span data-stu-id="ceba7-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="ceba7-153">我們將在第5章探討此模式和其他資料顧慮。</span><span class="sxs-lookup"><span data-stu-id="ceba7-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="ceba7-154">服務匯總工具模式</span><span class="sxs-lookup"><span data-stu-id="ceba7-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="ceba7-155">排除微服務對微服務結合的另一個選項是匯總程式[微服務](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/)，如圖4-10 中的紫色所示。</span><span class="sxs-lookup"><span data-stu-id="ceba7-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span> 

![匯總工具服務](./media/aggregator-service.png)

<span data-ttu-id="ceba7-157">**圖 4-10**：</span><span class="sxs-lookup"><span data-stu-id="ceba7-157">**Figure 4-10**.</span></span> <span data-ttu-id="ceba7-158">匯總工具微服務</span><span class="sxs-lookup"><span data-stu-id="ceba7-158">Aggregator microservice</span></span>

<span data-ttu-id="ceba7-159">此模式會隔離呼叫多個後端微服務的作業，並將其邏輯集中到專門的微服務。</span><span class="sxs-lookup"><span data-stu-id="ceba7-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="ceba7-160">上圖中的紫色結帳匯總工具微服務會協調結帳作業的工作流程。</span><span class="sxs-lookup"><span data-stu-id="ceba7-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="ceba7-161">其中包括以排序次序呼叫數個後端微服務。</span><span class="sxs-lookup"><span data-stu-id="ceba7-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="ceba7-162">工作流程中的資料會匯總並傳回給呼叫者。</span><span class="sxs-lookup"><span data-stu-id="ceba7-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="ceba7-163">雖然它仍然會執行直接的 HTTP 呼叫，但匯總工具微服務會減少後端微服務間的直接相依性。</span><span class="sxs-lookup"><span data-stu-id="ceba7-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span> 

### <a name="requestreply-pattern"></a><span data-ttu-id="ceba7-164">要求/回復模式</span><span class="sxs-lookup"><span data-stu-id="ceba7-164">Request/Reply Pattern</span></span>

<span data-ttu-id="ceba7-165">將同步 HTTP 訊息分離的另一種方法是[要求-回復模式](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)，它會使用佇列通訊。</span><span class="sxs-lookup"><span data-stu-id="ceba7-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="ceba7-166">使用佇列的通訊一律是單向通道，其中產生者會傳送訊息和接收它。</span><span class="sxs-lookup"><span data-stu-id="ceba7-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="ceba7-167">使用此模式時，會同時執行要求佇列和回應佇列，如圖4-11 所示。</span><span class="sxs-lookup"><span data-stu-id="ceba7-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![要求-回復模式](./media/request-reply-pattern.png)

<span data-ttu-id="ceba7-169">**圖 4-11**：</span><span class="sxs-lookup"><span data-stu-id="ceba7-169">**Figure 4-11**.</span></span> <span data-ttu-id="ceba7-170">要求-回復模式</span><span class="sxs-lookup"><span data-stu-id="ceba7-170">Request-reply pattern</span></span>

<span data-ttu-id="ceba7-171">在這裡，訊息產生者會建立包含唯一相互關聯識別碼的查詢訊息，並將其放入要求佇列中。</span><span class="sxs-lookup"><span data-stu-id="ceba7-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="ceba7-172">取用服務會清除訊息、加以處理，並將回應放入具有相同相互關聯識別碼的回應佇列中。</span><span class="sxs-lookup"><span data-stu-id="ceba7-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="ceba7-173">生產者服務會清除訊息，並與相互關聯識別碼相符並繼續處理。</span><span class="sxs-lookup"><span data-stu-id="ceba7-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="ceba7-174">我們將在下一節詳細討論佇列。</span><span class="sxs-lookup"><span data-stu-id="ceba7-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="ceba7-175">命令</span><span class="sxs-lookup"><span data-stu-id="ceba7-175">Commands</span></span>

<span data-ttu-id="ceba7-176">另一種通訊互動類型是*命令*。</span><span class="sxs-lookup"><span data-stu-id="ceba7-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="ceba7-177">微服務可能需要另一個微服務來執行動作。</span><span class="sxs-lookup"><span data-stu-id="ceba7-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="ceba7-178">訂購微服務可能需要出貨微服務，才能建立已核准訂單的出貨。</span><span class="sxs-lookup"><span data-stu-id="ceba7-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="ceba7-179">在圖4-12 中，一個稱為生產者的微服務會將訊息傳送給另一個微服務，也就是取用者，將它命令來執行某個動作。</span><span class="sxs-lookup"><span data-stu-id="ceba7-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span> 

![與佇列的命令互動](./media/command-interaction-with-queue.png)

<span data-ttu-id="ceba7-181">**圖 4-12**.</span><span class="sxs-lookup"><span data-stu-id="ceba7-181">**Figure 4-12**.</span></span> <span data-ttu-id="ceba7-182">與佇列的命令互動</span><span class="sxs-lookup"><span data-stu-id="ceba7-182">Command interaction with a queue</span></span>

<span data-ttu-id="ceba7-183">最常見的情況是，產生者不需要回應，而且可能會*引發並忘記*訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="ceba7-184">如果需要回復，取用者會將個別的訊息傳回給另一個通道上的生產者。</span><span class="sxs-lookup"><span data-stu-id="ceba7-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="ceba7-185">命令訊息最適合透過訊息佇列以非同步方式傳送。</span><span class="sxs-lookup"><span data-stu-id="ceba7-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="ceba7-186">輕量訊息代理程式所支援。</span><span class="sxs-lookup"><span data-stu-id="ceba7-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="ceba7-187">在上圖中，請注意佇列如何分隔和分離這兩項服務。</span><span class="sxs-lookup"><span data-stu-id="ceba7-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="ceba7-188">「訊息佇列」是一種中繼結構，生產者和取用者會透過它來傳遞訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="ceba7-189">佇列會執行非同步點對點訊息模式。</span><span class="sxs-lookup"><span data-stu-id="ceba7-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="ceba7-190">產生者知道需要傳送命令和適當路由的位置。</span><span class="sxs-lookup"><span data-stu-id="ceba7-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="ceba7-191">佇列保證訊息只由其中一個從通道讀取的取用者實例處理。</span><span class="sxs-lookup"><span data-stu-id="ceba7-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="ceba7-192">在此案例中，生產者或取用者服務可以相應放大，而不會影響另一個。</span><span class="sxs-lookup"><span data-stu-id="ceba7-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="ceba7-193">同樣地，各端的技術可能會不同，這表示我們可能會有 JAVA 微服務呼叫[Golang](https://golang.org)微服務。</span><span class="sxs-lookup"><span data-stu-id="ceba7-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span> 

<span data-ttu-id="ceba7-194">在第1章中，我們討論了*支援服務*。</span><span class="sxs-lookup"><span data-stu-id="ceba7-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="ceba7-195">支援服務是雲端原生系統所依賴的輔助資源。</span><span class="sxs-lookup"><span data-stu-id="ceba7-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="ceba7-196">訊息佇列是支援服務。</span><span class="sxs-lookup"><span data-stu-id="ceba7-196">Message queues are backing services.</span></span> <span data-ttu-id="ceba7-197">Azure 雲端支援兩種類型的訊息佇列，讓您的雲端原生系統可使用它來執行命令訊息：Azure 儲存體佇列和 Azure 服務匯流排佇列。</span><span class="sxs-lookup"><span data-stu-id="ceba7-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="ceba7-198">Azure 儲存體佇列</span><span class="sxs-lookup"><span data-stu-id="ceba7-198">Azure Storage Queues</span></span>

<span data-ttu-id="ceba7-199">Azure 儲存體佇列提供簡單的佇列基礎結構，以快速、實惠且受到 Azure 儲存體帳戶的支援。</span><span class="sxs-lookup"><span data-stu-id="ceba7-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="ceba7-200">[Azure 儲存體佇列](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction)的功能是以 REST 為基礎的佇列機制，具備可靠且持續性的訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="ceba7-201">它們提供最基本的功能集，但成本低廉，並儲存數百萬則訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="ceba7-202">其容量範圍上限為 500 TB。</span><span class="sxs-lookup"><span data-stu-id="ceba7-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="ceba7-203">單一訊息的大小最高可達 64 KB。</span><span class="sxs-lookup"><span data-stu-id="ceba7-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="ceba7-204">您可以透過使用 HTTP 或 HTTPS 的已驗證呼叫，從世界各地存取訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="ceba7-205">儲存體佇列可相應放大為大量的並行用戶端，以處理流量尖峰。</span><span class="sxs-lookup"><span data-stu-id="ceba7-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="ceba7-206">話雖如此，服務的限制如下：</span><span class="sxs-lookup"><span data-stu-id="ceba7-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="ceba7-207">不保證訊息順序。</span><span class="sxs-lookup"><span data-stu-id="ceba7-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="ceba7-208">訊息只能保存七天，才會自動移除。</span><span class="sxs-lookup"><span data-stu-id="ceba7-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="ceba7-209">無法支援狀態管理、重複偵測或交易。</span><span class="sxs-lookup"><span data-stu-id="ceba7-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="ceba7-210">圖4-13 顯示 Azure 儲存體佇列的階層。</span><span class="sxs-lookup"><span data-stu-id="ceba7-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![儲存體佇列階層](./media/storage-queue-hierarchy.png)

<span data-ttu-id="ceba7-212">**圖 4-13**.</span><span class="sxs-lookup"><span data-stu-id="ceba7-212">**Figure 4-13**.</span></span> <span data-ttu-id="ceba7-213">儲存體佇列階層</span><span class="sxs-lookup"><span data-stu-id="ceba7-213">Storage queue hierarchy</span></span>

<span data-ttu-id="ceba7-214">在上圖中，請注意儲存體佇列如何將其訊息儲存在基礎 Azure 儲存體帳戶中。</span><span class="sxs-lookup"><span data-stu-id="ceba7-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="ceba7-215">對於開發人員，Microsoft 提供數個用戶端和伺服器端程式庫來處理儲存體佇列。</span><span class="sxs-lookup"><span data-stu-id="ceba7-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="ceba7-216">支援大部分的主要平臺，包括 .NET、JAVA、JavaScript、Ruby、Python 和 Go。</span><span class="sxs-lookup"><span data-stu-id="ceba7-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="ceba7-217">開發人員絕對不應直接與這些程式庫通訊。</span><span class="sxs-lookup"><span data-stu-id="ceba7-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="ceba7-218">這麼做會將您的微服務程式代碼緊密地帶到 Azure 儲存體佇列服務。</span><span class="sxs-lookup"><span data-stu-id="ceba7-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="ceba7-219">更好的作法是將 API 的執行細節隔離。</span><span class="sxs-lookup"><span data-stu-id="ceba7-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="ceba7-220">引進會公開一般作業並封裝具體程式庫的 intermediation 層或中繼 API。</span><span class="sxs-lookup"><span data-stu-id="ceba7-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="ceba7-221">這種鬆散結合可讓您交換另一個佇列服務，而不需要對主線服務程式代碼進行變更。</span><span class="sxs-lookup"><span data-stu-id="ceba7-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span> 

<span data-ttu-id="ceba7-222">Azure 儲存體佇列是在您的雲端原生應用程式中執行命令訊息的經濟實惠選項。</span><span class="sxs-lookup"><span data-stu-id="ceba7-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="ceba7-223">特別是當佇列大小超過 80 GB 時，或簡單的功能集是可接受的。</span><span class="sxs-lookup"><span data-stu-id="ceba7-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="ceba7-224">您只需支付訊息的儲存空間，沒有固定的每小時費用。</span><span class="sxs-lookup"><span data-stu-id="ceba7-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="ceba7-225">Azure 服務匯流排佇列</span><span class="sxs-lookup"><span data-stu-id="ceba7-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="ceba7-226">如需更複雜的訊息處理需求，請考慮 Azure 服務匯流排的佇列。</span><span class="sxs-lookup"><span data-stu-id="ceba7-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="ceba7-227">坐在強大的訊息基礎結構上， [Azure 服務匯流排](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview)支援代理*訊息模型*。</span><span class="sxs-lookup"><span data-stu-id="ceba7-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="ceba7-228">訊息會可靠地儲存在 broker （佇列）中，直到取用者收到為止。</span><span class="sxs-lookup"><span data-stu-id="ceba7-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="ceba7-229">佇列保證先進先出（FIFO）訊息傳遞，遵循訊息新增至佇列的順序。</span><span class="sxs-lookup"><span data-stu-id="ceba7-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="ceba7-230">訊息的大小可能會大很多，最高可達 256 KB。</span><span class="sxs-lookup"><span data-stu-id="ceba7-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="ceba7-231">訊息會保存在佇列中一段無限期的時間。</span><span class="sxs-lookup"><span data-stu-id="ceba7-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="ceba7-232">服務匯流排不只支援以 HTTP 為基礎的呼叫，也會提供[AMPQ 通訊協定](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)的完整支援。</span><span class="sxs-lookup"><span data-stu-id="ceba7-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="ceba7-233">AMPQ 是跨廠商的開放式標準，可支援二進位通訊協定和較高程度的可靠性。</span><span class="sxs-lookup"><span data-stu-id="ceba7-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="ceba7-234">服務匯流排提供一組豐富的功能，包括[交易支援](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)和[重複的偵測功能](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)。</span><span class="sxs-lookup"><span data-stu-id="ceba7-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="ceba7-235">佇列保證每個訊息「最多一次傳遞」。</span><span class="sxs-lookup"><span data-stu-id="ceba7-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="ceba7-236">它會自動捨棄已經傳送的訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="ceba7-237">如果產生者不確定，它可以重新傳送相同的訊息，服務匯流排保證只會處理一個複本。</span><span class="sxs-lookup"><span data-stu-id="ceba7-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="ceba7-238">重複偵測可讓您不必建立額外的基礎結構配管。</span><span class="sxs-lookup"><span data-stu-id="ceba7-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="ceba7-239">另外兩個企業功能是分割和會話。</span><span class="sxs-lookup"><span data-stu-id="ceba7-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="ceba7-240">傳統服務匯流排佇列是由單一訊息代理程式處理，並儲存在單一訊息存放區中。</span><span class="sxs-lookup"><span data-stu-id="ceba7-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="ceba7-241">但是，[服務匯流排資料分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)會將佇列散佈到多個訊息代理程式和訊息存放區。</span><span class="sxs-lookup"><span data-stu-id="ceba7-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="ceba7-242">整體輸送量不再受限於單一訊息代理程式或訊息存放區的效能。</span><span class="sxs-lookup"><span data-stu-id="ceba7-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="ceba7-243">訊息存放區暫時中斷不會導致分割的佇列無法使用。</span><span class="sxs-lookup"><span data-stu-id="ceba7-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="ceba7-244">[服務匯流排會話](https://codingcanvas.com/azure-service-bus-sessions/)提供一種方式來分組相關的訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="ceba7-245">假設有一個工作流程案例，也就是必須一起處理訊息，並在結尾完成作業。</span><span class="sxs-lookup"><span data-stu-id="ceba7-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="ceba7-246">若要利用，必須為佇列明確啟用會話，而且每個相關的 messaged 都必須包含相同的會話識別碼。</span><span class="sxs-lookup"><span data-stu-id="ceba7-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="ceba7-247">不過，有一些重要的警告：服務匯流排佇列大小限制為 80 GB，這遠小於存放區佇列中的可用空間。</span><span class="sxs-lookup"><span data-stu-id="ceba7-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="ceba7-248">此外，服務匯流排佇列會產生每個作業的基本成本和費用。</span><span class="sxs-lookup"><span data-stu-id="ceba7-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="ceba7-249">圖4-14 概述服務匯流排佇列的高階架構。</span><span class="sxs-lookup"><span data-stu-id="ceba7-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![服務匯流排佇列](./media/service-bus-queue.png)

<span data-ttu-id="ceba7-251">**圖 4-14**.</span><span class="sxs-lookup"><span data-stu-id="ceba7-251">**Figure 4-14**.</span></span> <span data-ttu-id="ceba7-252">服務匯流排佇列</span><span class="sxs-lookup"><span data-stu-id="ceba7-252">Service Bus queue</span></span>

<span data-ttu-id="ceba7-253">在上圖中，請注意點對點關聯性。</span><span class="sxs-lookup"><span data-stu-id="ceba7-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="ceba7-254">相同提供者的兩個實例會佇列訊息至單一服務匯流排佇列。</span><span class="sxs-lookup"><span data-stu-id="ceba7-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="ceba7-255">每個訊息只會由右邊的三個取用者實例的其中一個使用。</span><span class="sxs-lookup"><span data-stu-id="ceba7-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="ceba7-256">接下來，我們會討論如何執行訊息，其中不同的取用者可能會對相同的訊息感興趣。</span><span class="sxs-lookup"><span data-stu-id="ceba7-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="ceba7-257">事件</span><span class="sxs-lookup"><span data-stu-id="ceba7-257">Events</span></span>

<span data-ttu-id="ceba7-258">「訊息佇列」是一種有效的方法，可讓產生者以非同步方式傳送訊息給取用者的通訊。</span><span class="sxs-lookup"><span data-stu-id="ceba7-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="ceba7-259">不過，當有*許多不同*的取用者對相同訊息感興趣時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="ceba7-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="ceba7-260">每個取用者的專用訊息佇列不會適當地進行調整，因而變得難以管理。</span><span class="sxs-lookup"><span data-stu-id="ceba7-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span> 

<span data-ttu-id="ceba7-261">為了解決這種情況，我們會移至第三種類型的訊息互動，也就是*事件*。</span><span class="sxs-lookup"><span data-stu-id="ceba7-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="ceba7-262">一個微服務宣佈已發生動作。</span><span class="sxs-lookup"><span data-stu-id="ceba7-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="ceba7-263">其他微服務（如果有興趣）回應動作或事件。</span><span class="sxs-lookup"><span data-stu-id="ceba7-263">Other microservices, if interested, react to the action, or event.</span></span> 

<span data-ttu-id="ceba7-264">事件處理是兩個步驟的程式。</span><span class="sxs-lookup"><span data-stu-id="ceba7-264">Eventing is a two-step process.</span></span> <span data-ttu-id="ceba7-265">針對指定的狀態變更，微服務會將事件發佈到訊息代理程式，使其可供任何其他感興趣的微服務使用。</span><span class="sxs-lookup"><span data-stu-id="ceba7-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="ceba7-266">有興趣的微服務會在訊息代理程式中訂閱事件時收到通知。</span><span class="sxs-lookup"><span data-stu-id="ceba7-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="ceba7-267">您可以使用[發佈/訂閱](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber)模式來執行以[事件為基礎的通訊](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)。</span><span class="sxs-lookup"><span data-stu-id="ceba7-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="ceba7-268">圖4-15 顯示的購物籃微服務發佈了兩個其他微服務訂閱的事件。</span><span class="sxs-lookup"><span data-stu-id="ceba7-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![事件驅動的訊息](./media/event-driven-messaging.png)

<span data-ttu-id="ceba7-270">**圖 4-15**：</span><span class="sxs-lookup"><span data-stu-id="ceba7-270">**Figure 4-15**.</span></span> <span data-ttu-id="ceba7-271">事件驅動的訊息</span><span class="sxs-lookup"><span data-stu-id="ceba7-271">Event-Driven messaging</span></span>

<span data-ttu-id="ceba7-272">請注意位於通道中央的*事件匯流排*元件。</span><span class="sxs-lookup"><span data-stu-id="ceba7-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="ceba7-273">這是一個自訂類別，它會封裝訊息代理程式，並將它與基礎應用程式分離。</span><span class="sxs-lookup"><span data-stu-id="ceba7-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="ceba7-274">訂購和清查微服務會獨立操作事件，而不知道彼此或購物籃微服務。</span><span class="sxs-lookup"><span data-stu-id="ceba7-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="ceba7-275">當註冊的事件發佈至事件匯流排時，它們會對它採取動作。</span><span class="sxs-lookup"><span data-stu-id="ceba7-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="ceba7-276">有了事件，我們會從佇列技術移至*主題*。</span><span class="sxs-lookup"><span data-stu-id="ceba7-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="ceba7-277">[主題](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)與佇列類似，但支援一對多訊息模式。</span><span class="sxs-lookup"><span data-stu-id="ceba7-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="ceba7-278">一個微服務會發佈訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-278">One microservice publishes a message.</span></span> <span data-ttu-id="ceba7-279">多個訂閱微服務可以選擇接收該訊息並採取行動。</span><span class="sxs-lookup"><span data-stu-id="ceba7-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="ceba7-280">圖4-16 顯示主題架構。</span><span class="sxs-lookup"><span data-stu-id="ceba7-280">Figure 4-16 shows a topic architecture.</span></span>

![主題架構](./media/topic-architecture.png)

<span data-ttu-id="ceba7-282">**圖 4-16**：</span><span class="sxs-lookup"><span data-stu-id="ceba7-282">**Figure 4-16**.</span></span> <span data-ttu-id="ceba7-283">主題架構</span><span class="sxs-lookup"><span data-stu-id="ceba7-283">Topic architecture</span></span>

<span data-ttu-id="ceba7-284">在上圖中，發行者會將訊息傳送至主題。</span><span class="sxs-lookup"><span data-stu-id="ceba7-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="ceba7-285">最後，訂閱者會從訂用帳戶接收訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="ceba7-286">在中間，主題會根據一組*規則*（以暗藍色方塊顯示），將訊息轉送至訂閱。</span><span class="sxs-lookup"><span data-stu-id="ceba7-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="ceba7-287">規則會作為將特定訊息轉寄至訂用帳戶的篩選準則。</span><span class="sxs-lookup"><span data-stu-id="ceba7-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="ceba7-288">在這裡，"CreateOrder" 事件會傳送到訂\#用帳戶1和訂\#用帳戶3，但\#不會傳送到訂用帳戶2。</span><span class="sxs-lookup"><span data-stu-id="ceba7-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="ceba7-289">「OrderCompleted」事件會傳送到訂\#用帳戶2和訂\#用帳戶3。</span><span class="sxs-lookup"><span data-stu-id="ceba7-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="ceba7-290">Azure 雲端支援兩種不同的主題服務：Azure 服務匯流排主題和 Azure EventGrid。</span><span class="sxs-lookup"><span data-stu-id="ceba7-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="ceba7-291">Azure 服務匯流排主題</span><span class="sxs-lookup"><span data-stu-id="ceba7-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="ceba7-292">在 Azure 服務匯流排佇列的相同健全代理訊息模型上， [Azure 服務匯流排主題](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。</span><span class="sxs-lookup"><span data-stu-id="ceba7-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="ceba7-293">主題可以接收來自多個獨立發行者的訊息，並將訊息傳送到最多2000的訂閱者。</span><span class="sxs-lookup"><span data-stu-id="ceba7-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="ceba7-294">您可以在執行時間動態加入或移除訂閱，而不需要停止系統或重新建立主題。</span><span class="sxs-lookup"><span data-stu-id="ceba7-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="ceba7-295">許多來自 Azure 服務匯流排佇列的先進功能也適用于主題，包括[重複的偵測](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)和[交易支援](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)。</span><span class="sxs-lookup"><span data-stu-id="ceba7-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="ceba7-296">根據預設，服務匯流排主題是由單一訊息代理程式處理，並儲存在單一訊息存放區中。</span><span class="sxs-lookup"><span data-stu-id="ceba7-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="ceba7-297">但是，[服務匯流排資料分割](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)會將主題分散到許多訊息代理程式和訊息存放區來調整其規模。</span><span class="sxs-lookup"><span data-stu-id="ceba7-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="ceba7-298">[排定的訊息傳遞](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing)會標記特定時間進行處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="ceba7-299">訊息將不會出現在該時間之前的主題中。</span><span class="sxs-lookup"><span data-stu-id="ceba7-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="ceba7-300">[訊息延遲](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral)可讓您將訊息的抓取延後一段時間。</span><span class="sxs-lookup"><span data-stu-id="ceba7-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="ceba7-301">這兩者通常用於工作流程處理案例，其中的作業會以特定連續處理。</span><span class="sxs-lookup"><span data-stu-id="ceba7-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="ceba7-302">您可以延後處理已接收的訊息，直到先前的工作完成為止。</span><span class="sxs-lookup"><span data-stu-id="ceba7-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="ceba7-303">服務匯流排主題是強大且經過證實的技術，可在您的雲端原生系統中啟用發佈/訂閱通訊。</span><span class="sxs-lookup"><span data-stu-id="ceba7-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="ceba7-304">Azure 事件方格</span><span class="sxs-lookup"><span data-stu-id="ceba7-304">Azure Event Grid</span></span>

<span data-ttu-id="ceba7-305">雖然 Azure 服務匯流排是具有一組完整企業功能的經過測試的訊息代理程式，但[Azure 事件方格](https://docs.microsoft.com/azure/event-grid/overview)是此新的孩子。</span><span class="sxs-lookup"><span data-stu-id="ceba7-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="ceba7-306">乍看之下，事件方格看起來就像是另一個以主題為基礎的訊息系統。</span><span class="sxs-lookup"><span data-stu-id="ceba7-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="ceba7-307">不過，它在許多方面都不同。</span><span class="sxs-lookup"><span data-stu-id="ceba7-307">However, it's different in many ways.</span></span> <span data-ttu-id="ceba7-308">它著重于事件導向的工作負載，可啟用即時事件處理、深度 Azure 整合和開放平臺-全部都在無伺服器基礎結構上。</span><span class="sxs-lookup"><span data-stu-id="ceba7-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="ceba7-309">它是專為現代雲端原生和無伺服器應用程式所設計</span><span class="sxs-lookup"><span data-stu-id="ceba7-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="ceba7-310">作為*集中式事件後*擋板或管道，事件方格會回應 Azure 資源內和您自己的服務中的事件。</span><span class="sxs-lookup"><span data-stu-id="ceba7-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="ceba7-311">事件通知會發佈至事件方格主題，接著會將每個事件路由至訂用帳戶。</span><span class="sxs-lookup"><span data-stu-id="ceba7-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="ceba7-312">訂閱者對應至訂閱並取用事件。</span><span class="sxs-lookup"><span data-stu-id="ceba7-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="ceba7-313">如同服務匯流排，事件方格支援已*篩選的訂閱者模型*，其中的訂用帳戶會針對它想要接收的事件設定規則。</span><span class="sxs-lookup"><span data-stu-id="ceba7-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="ceba7-314">事件方格可提供快速的輸送量，並保證每秒10000000個事件的傳送速率遠超過 Azure 服務匯流排可以產生的時間。</span><span class="sxs-lookup"><span data-stu-id="ceba7-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="ceba7-315">事件方格的最佳位置是其深入整合到 Azure 基礎結構的網狀架構。</span><span class="sxs-lookup"><span data-stu-id="ceba7-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="ceba7-316">Azure 資源（例如 Cosmos DB）可以將內建事件直接發行到其他感興趣的 Azure 資源，而不需要自訂程式碼。</span><span class="sxs-lookup"><span data-stu-id="ceba7-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="ceba7-317">事件方格可以發佈來自 Azure 訂用帳戶、資源群組或服務的事件，讓開發人員更精細地控制雲端資源的生命週期。</span><span class="sxs-lookup"><span data-stu-id="ceba7-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="ceba7-318">不過，事件方格並不限於 Azure。</span><span class="sxs-lookup"><span data-stu-id="ceba7-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="ceba7-319">它是一個開放式平臺，可使用從應用程式或協力廠商服務發佈的自訂 HTTP 事件，並將事件路由至外部訂閱者。</span><span class="sxs-lookup"><span data-stu-id="ceba7-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="ceba7-320">發佈和訂閱 Azure 資源的原生事件時，不需要撰寫任何程式碼。</span><span class="sxs-lookup"><span data-stu-id="ceba7-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="ceba7-321">透過簡單的設定，您可以將事件從一個 Azure 資源整合到另一個使用主題和訂用帳戶內建的管道。</span><span class="sxs-lookup"><span data-stu-id="ceba7-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="ceba7-322">圖4-17 顯示事件方格的剖析。</span><span class="sxs-lookup"><span data-stu-id="ceba7-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![事件方格剖析](./media/event-grid-anatomy.png)

<span data-ttu-id="ceba7-324">**圖 4-17**：</span><span class="sxs-lookup"><span data-stu-id="ceba7-324">**Figure 4-17**.</span></span> <span data-ttu-id="ceba7-325">事件方格剖析</span><span class="sxs-lookup"><span data-stu-id="ceba7-325">Event Grid anatomy</span></span>

<span data-ttu-id="ceba7-326">EventGrid 和服務匯流排之間的主要差異在於基礎*訊息交換模式*。</span><span class="sxs-lookup"><span data-stu-id="ceba7-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="ceba7-327">服務匯流排會執行較舊的樣式*提取模型*，下游訂閱者會在其中主動輪詢主題訂用帳戶中的新訊息。</span><span class="sxs-lookup"><span data-stu-id="ceba7-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="ceba7-328">這種方法的優點是，訂閱者可以完全掌控其處理訊息的步調。</span><span class="sxs-lookup"><span data-stu-id="ceba7-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="ceba7-329">它會控制在任何指定時間要處理的訊息和數目。</span><span class="sxs-lookup"><span data-stu-id="ceba7-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="ceba7-330">未讀取的訊息會保留在訂用帳戶中，直到處理為止。</span><span class="sxs-lookup"><span data-stu-id="ceba7-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="ceba7-331">重大缺點是產生事件的時間與將該訊息提取至訂閱者以進行處理的輪詢作業之間的延遲。</span><span class="sxs-lookup"><span data-stu-id="ceba7-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="ceba7-332">此外，持續輪詢下一個事件的額外負荷會耗用資源和金錢。</span><span class="sxs-lookup"><span data-stu-id="ceba7-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="ceba7-333">不過，EventGrid 是不同的。</span><span class="sxs-lookup"><span data-stu-id="ceba7-333">EventGrid, however, is different.</span></span> <span data-ttu-id="ceba7-334">它會執行*推送模型*，其中事件會以接收的方式傳送至 EventHandlers，提供近乎即時的事件傳遞。</span><span class="sxs-lookup"><span data-stu-id="ceba7-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="ceba7-335">它也會降低成本，因為只有在需要取用事件時才會觸發服務，而不是隨著輪詢而持續使用。</span><span class="sxs-lookup"><span data-stu-id="ceba7-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="ceba7-336">話雖如此，事件處理常式必須處理傳入的負載，並提供節流機制來保護自己免于被淹沒。</span><span class="sxs-lookup"><span data-stu-id="ceba7-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="ceba7-337">許多使用這些事件的 Azure 服務，例如 Azure Functions 和 Logic Apps 會提供自動調整功能，以處理增加的負載。</span><span class="sxs-lookup"><span data-stu-id="ceba7-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="ceba7-338">事件方格是完全受控的無伺服器雲端服務。</span><span class="sxs-lookup"><span data-stu-id="ceba7-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="ceba7-339">它會根據您的流量動態調整，並只針對實際使用量收費，而不是預先購買的容量。</span><span class="sxs-lookup"><span data-stu-id="ceba7-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="ceba7-340">每月前100000作業是免費的–作業會定義為事件輸入（傳入事件通知）、訂用帳戶傳遞嘗試、管理呼叫，以及依主旨篩選。</span><span class="sxs-lookup"><span data-stu-id="ceba7-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="ceba7-341">使用 99.99% 的可用性，EventGrid 可保證在24小時期間內傳遞事件，並提供不成功傳遞的內建重試功能。</span><span class="sxs-lookup"><span data-stu-id="ceba7-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="ceba7-342">未傳遞的訊息可以移至「寄不出的信件」佇列進行解析。</span><span class="sxs-lookup"><span data-stu-id="ceba7-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="ceba7-343">不同于 Azure 服務匯流排，事件方格已針對快速效能進行微調，且不支援已排序訊息、交易和會話等功能。</span><span class="sxs-lookup"><span data-stu-id="ceba7-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="ceba7-344">在 Azure 雲端中串流處理訊息</span><span class="sxs-lookup"><span data-stu-id="ceba7-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="ceba7-345">Azure 服務匯流排和事件方格針對公開單一獨立事件的應用程式提供絕佳的支援，例如，新檔已插入 Cosmos DB）。</span><span class="sxs-lookup"><span data-stu-id="ceba7-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document been inserted into a Cosmos DB).</span></span> <span data-ttu-id="ceba7-346">但是，如果您的雲端原生系統需要處理*相關事件的資料流程*，該怎麼辦？</span><span class="sxs-lookup"><span data-stu-id="ceba7-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="ceba7-347">[事件資料流程](https://msdn.microsoft.com/magazine/dn904671.aspx?f=255&MSPPError=-2147217396)較複雜。</span><span class="sxs-lookup"><span data-stu-id="ceba7-347">[Event streams](https://msdn.microsoft.com/magazine/dn904671.aspx?f=255&MSPPError=-2147217396) are more complex.</span></span> <span data-ttu-id="ceba7-348">它們通常是依時間排序、相互關聯，而且必須以群組的方式處理。</span><span class="sxs-lookup"><span data-stu-id="ceba7-348">They're typically time-ordered, interrelated and must be processed as a group.</span></span>

<span data-ttu-id="ceba7-349">[Azure 事件中樞](https://azure.microsoft.com/services/event-hubs/)是一種資料串流平臺和事件內嵌服務，可收集、轉換及儲存事件。</span><span class="sxs-lookup"><span data-stu-id="ceba7-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="ceba7-350">它會微調以捕捉串流資料，例如從遙測內容發出的連續事件通知。</span><span class="sxs-lookup"><span data-stu-id="ceba7-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="ceba7-351">此服務具有高度擴充性，而且每秒可儲存和[處理數百萬個事件](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)。</span><span class="sxs-lookup"><span data-stu-id="ceba7-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="ceba7-352">如圖4-18 所示，這通常是事件管線的前端，可將內嵌資料流程從事件耗用量分離出來。</span><span class="sxs-lookup"><span data-stu-id="ceba7-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure 事件中樞](./media/azure-event-hub.png)

<span data-ttu-id="ceba7-354">**圖 4-18**.</span><span class="sxs-lookup"><span data-stu-id="ceba7-354">**Figure 4-18**.</span></span> <span data-ttu-id="ceba7-355">Azure 事件中樞</span><span class="sxs-lookup"><span data-stu-id="ceba7-355">Azure Event Hub</span></span>

<span data-ttu-id="ceba7-356">事件中樞支援低延遲和可設定的保留時間。</span><span class="sxs-lookup"><span data-stu-id="ceba7-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="ceba7-357">不同于佇列和主題，事件中樞會在取用者讀取事件資料之後加以保留。</span><span class="sxs-lookup"><span data-stu-id="ceba7-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="ceba7-358">這項功能可讓其他資料分析服務（內部和外部）重新執行資料，以進行進一步的分析。</span><span class="sxs-lookup"><span data-stu-id="ceba7-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="ceba7-359">儲存在事件中樞中的事件只會在保留期限到期時刪除（預設為一天，但可設定）。</span><span class="sxs-lookup"><span data-stu-id="ceba7-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="ceba7-360">事件中樞支援常見的事件發佈通訊協定，包括 HTTPS 和 AMQP。</span><span class="sxs-lookup"><span data-stu-id="ceba7-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="ceba7-361">它也支援 Kafka 1.0。</span><span class="sxs-lookup"><span data-stu-id="ceba7-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="ceba7-362">[現有的 Kafka 應用程式可以使用 Kafka 通訊協定與事件中樞通訊](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview)，以提供管理大型 Kafka 叢集的替代方法。</span><span class="sxs-lookup"><span data-stu-id="ceba7-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="ceba7-363">許多開放原始碼雲端原生系統採用 Kafka。</span><span class="sxs-lookup"><span data-stu-id="ceba7-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="ceba7-364">事件中樞透過[分割取用者模型](https://docs.microsoft.com/azure/event-hubs/event-hubs-features)來執行訊息串流，而每個取用者只會讀取訊息資料流程的特定子集或資料分割。</span><span class="sxs-lookup"><span data-stu-id="ceba7-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="ceba7-365">此模式可讓您大規模地進行事件處理，並提供佇列和主題中無法使用的其他資料流程導向功能。</span><span class="sxs-lookup"><span data-stu-id="ceba7-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="ceba7-366">「分割區」（partition）是保留在事件中樞內之事件的排序次序。</span><span class="sxs-lookup"><span data-stu-id="ceba7-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="ceba7-367">當較新的事件抵達時，它們會新增至此順序的結尾。</span><span class="sxs-lookup"><span data-stu-id="ceba7-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="ceba7-368"> 圖4-19 顯示事件中樞內的資料分割。</span><span class="sxs-lookup"><span data-stu-id="ceba7-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![事件中樞資料分割](./media/event-hub-partitioning.png)

<span data-ttu-id="ceba7-370">**圖 4-19**.</span><span class="sxs-lookup"><span data-stu-id="ceba7-370">**Figure 4-19**.</span></span> <span data-ttu-id="ceba7-371">事件中樞資料分割</span><span class="sxs-lookup"><span data-stu-id="ceba7-371">Event Hub partitioning</span></span>

<span data-ttu-id="ceba7-372">每個取用者群組會讀取訊息資料流程的子集或分割區，而不是從相同的資源讀取。</span><span class="sxs-lookup"><span data-stu-id="ceba7-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span> 

<span data-ttu-id="ceba7-373">對於必須串流大量事件的雲端原生應用程式，Azure 事件中樞可以是健全且實惠的解決方案。</span><span class="sxs-lookup"><span data-stu-id="ceba7-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="ceba7-374">[上一頁](front-end-communication.md)
>[下一頁](rest-grpc.md)</span><span class="sxs-lookup"><span data-stu-id="ceba7-374">[Previous](front-end-communication.md)
[Next](rest-grpc.md)</span></span>
