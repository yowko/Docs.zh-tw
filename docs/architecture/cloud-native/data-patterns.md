---
title: 雲端原生資料模式
description: 架構適用于 Azure 的雲端原生 .NET 應用程式 |雲端原生資料模式
ms.date: 06/30/2019
ms.openlocfilehash: 8fc5a09dca61e6644fdcaa692ff1a21f40ebf179
ms.sourcegitcommit: 55f438d4d00a34b9aca9eedaac3f85590bb11565
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/23/2019
ms.locfileid: "71183410"
---
# <a name="cloud-native-data-patterns"></a>雲端原生資料模式

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

雖然分散的資料可能會導致效能、擴充性和節省成本，但也會帶來許多挑戰。 跨微服務查詢資料是很複雜的。 跨微服務的交易必須以程式設計方式管理，因為雲端原生應用程式中不支援分散式交易。 您可以從*立即一致性*的世界轉移到*最終一致性*。

我們現在會討論這些挑戰。

## <a name="cross-service-queries"></a>跨服務查詢

應用程式如何查詢分散到多個獨立微服務的資料？

圖5-4 顯示這種情況。

![跨微服務查詢](./media/cross-service-query.png)

**圖 5-4**。 跨微服務查詢

請注意，在上圖中，我們會看到 [購物籃] 微服務，將專案新增至使用者的購物車。 雖然購物籃的資料存放區包含購物籃和 lineItem 資料表，但它不包含產品或定價資料，因為在產品和價格微服務中找到這些專案。 若要新增專案，購物籃微服務需要產品資料和定價資料。 取得產品和定價資料的選項有哪些？

圖5-5 顯示購物籃微服務對產品目錄和定價微服務進行直接的 HTTP 呼叫。

![直接 HTTP 通訊](./media/direct-http-communication.png)

**圖 5-5**。 直接 HTTP 通訊

雖然可以實現，但在第4章中，我們討論了如何在微服務之間進行 HTTP 呼叫，而不是很好的作法。

我們可以執行如圖5-6 所示的匯總工具微服務。

![匯總工具微服務](./media/aggregator-microservice.png)

**圖 5-6。** 匯總工具微服務

雖然這種方法會在個別微服務中封裝商務作業工作流程，但它會增加複雜性，而且仍然會產生直接的 HTTP 呼叫。

執行跨服務查詢的常見方法是使用[具體化視圖模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)，如圖5-7 所示。

![具體化視圖模式](./media/materialized-view-pattern.png)

**Figure5-7**。 具體化視圖模式

使用此模式時，您可以直接將本機資料表（稱為「*讀取模型*」）放在「購物籃」服務中，其中包含「產品」和「定價微服務所需之資料的反正規化複本。 將該資料放在 [購物籃] 微服務中，就不需要叫用昂貴的跨服務呼叫。 在服務的本機資料中，您可以改善回應時間和可靠性。

這種方法的 catch 是您的系統中現在有重複的資料。 在雲端原生系統中，重複的資料不會被視為[反模式](https://en.wikipedia.org/wiki/Anti-pattern)，而且通常會在雲端原生系統中執行。 不過，只有一個系統可以是任何資料集的擁有者，而且您必須針對記錄的系統執行同步處理機制，以便在每次變更基礎資料時，更新所有相關聯的讀取模型。

## <a name="transactional-support"></a>交易式支援

雖然跨微服務的查詢很具挑戰性，但跨微服務執行交易可能會很複雜。 維護位於不同微服務之資料來源間資料一致性的固有挑戰，無法 understated。 圖5-8 顯示問題。

![Saga 模式中的交易](./media/saga-transaction-operation.png)

**圖 5-8**。 跨微服務執行交易

請注意上圖中的五個獨立微服務如何參與分散式的「*建立訂單*」交易。 不過，五個個別微服務的每個都必須成功，或全部都必須中止和復原作業。 雖然內建交易支援在每個微服務中都有提供，但並不支援這五個服務中的分散式交易。

由於交易式支援對於這項作業而言是不可或缺的，因此在每個微服務中保持資料一致，您必須以程式設計方式建立分散式交易。

以程式設計方式加入交易式支援的常用模式是[Saga 模式](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/)。 其執行方式是將本機交易分組在一起，並依序叫用每一個。 如果本機交易失敗，Saga 會中止作業，並叫用一組[補償交易](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)來復原前一個本機交易所做的變更。 圖5-9 顯示具有 Saga 模式的失敗交易。

![在 saga 模式中復原](./media/saga-rollback-operation.png)

**圖 5-9**。 復原交易

請注意上圖中的*GenerateContent*作業在 [音樂] 微服務中失敗的情況。 Saga 會叫用補償交易（以紅色表示）以移除內容、取消付款並取消訂單，並將每個微服務的資料傳回一致的狀態。

Saga 模式通常會單純為一系列相關的事件，或協調成一組相關的命令。

## <a name="cqrs-pattern"></a>CQRS 模式

CQRS 或[命令與查詢責任隔離](https://docs.microsoft.com/azure/architecture/patterns/cqrs)是一種架構模式，可將讀取資料的作業與寫入資料的工作分開。 此模式可協助最大化效能、擴充性和安全性。

在一般的資料存取案例中，您會執行單一模型（實體和儲存機制物件），*以執行讀取*和寫入資料作業。

不過，更先進的資料存取案例可能受益于不同的模型，以及用於讀取和寫入的資料表。 為了改善效能，讀取作業（稱為「*查詢*」）可能會查詢資料的高度反正規化標記法，以避免產生昂貴的重複性資料表聯結。 雖然*寫入*作業（也稱為*命令*）可能會針對資料的完全正規化表示進行更新。 接著，您必須執行機制，讓這兩種標記法保持同步。一般來說，每當修改寫入資料表時，就會引發事件，將資料修改複寫到讀取資料表。

圖5-10 顯示 CQRS 模式的執行。

![CQRS 執行](./media/cqrs-implementation.png)

**圖 5-10**。 CQRS 執行

請注意上圖中如何執行個別的命令和查詢模型。 此外，每個資料寫入作業都會儲存到寫入存放區，然後傳播到讀取存放區。 請密切注意傳播程式如何在[最終一致性](https://www.cloudcomputingpatterns.org/eventual_consistency/)原則上運作，而讀取模型最終會與寫入模型進行同步處理，但進程中可能會有一些延遲。

藉由執行分隔，您可以個別調整讀取和寫入的能力。 同樣地，您可能會對寫入作業施加更緊密的安全性，而不是讀取的相關資訊。

根據特定需求，CQRS 模式通常會套用至系統的有限區段。

## <a name="relational-vs-nosql"></a>關聯式與 NoSQL

[NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/)技術的影響無法十分出色，特別是針對分散式雲端原生系統。 這個空間中的新資料技術激增，有一次只依賴關係資料庫而中斷的解決方案。

一側，關係資料庫在數十年已經是一項普遍的技術。 這些是成熟、經過證明且廣泛實行的。 競爭資料庫產品、專業知識和工具 abounds。 關係資料庫會提供相關資料表的存放區。 這些資料表具有固定的架構，使用 SQL （結構化查詢語言 (SQL)）來管理資料，並具有[ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) （也稱為不可部分完成性、一致性、隔離和耐久性）保證。

另一方面，非 SQL 資料庫則是指高效能、非關聯式資料存放區。 他們在 excel 中使用易用性、擴充性、彈性和可用性等特性。 NoSQL 會將自我描述（無架構）資料儲存在 JSON 檔中，而不是聯結正規化資料的資料表。 它們不提供[ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/)保證。

如需瞭解這些資料庫類型之間差異的方法，請參閱[CAP 定理](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e)，這是一組可套用至儲存狀態之分散式系統的原則。 圖5-11 顯示 CAP 定理的三個屬性。

![CAP 定理](./media/cap-theorem.png)

**圖 5-11**。 CAP 定理

定理說明任何分散式資料系統都能在一致性、可用性及分割區容錯之間提供取捨，而且任何資料庫只能保證三個屬性的其中兩個：

- *一致性*：叢集中的每個節點都會回應最新的資料，即使它需要封鎖要求，直到所有複本都已正確更新為止。

- *可用性*：每個節點都會在合理的時間內傳迴響應，即使該回應不是最新的資料也一樣。

- *分割區容錯*：保證如果節點失敗或失去與其他節點的連線，系統將會繼續運作。

關係資料庫呈現一致性和可用性，但不會顯示分割區容錯。 分割關係資料庫（例如分區化）很艱難，而且可能會影響效能。

另一方面，NoSQL 資料庫通常會展現資料分割容錯，又稱為水準擴充性和高可用性。 當 CAP 定理指定時，您只能有三個原則中的兩個，而您會遺失一致性屬性。

NoSQL 資料庫會散佈在不同的商用伺服器上，而且通常會相應放大。 這麼做可以降低成本，同時在地理區域內外提供絕佳的可用性。 資料可以在這些機器或節點之間進行分割和複寫，以提供冗余和容錯功能。 缺點是一致的。 對某個 NoSQL 節點上的資料所做的變更，可能需要一些時間才能傳播至其他節點。 一般來說，即使呈現的資料已過時而且尚未更新，NoSQL 資料庫節點還是會立即對查詢提供回應。

這是已知的[最終一致性](https://www.cloudcomputingpatterns.org/eventual_consistency/)，也就是不支援 ACID 交易的分散式資料系統特性。 資料項目目的更新和將該更新傳播到每個複本節點所需的時間之間，會有短暫的延遲。 如果您在美國的 NoSQL 資料庫中更新產品專案，但同時從歐洲的複本節點查詢該相同資料項目，您可能會抓取先前的產品資訊-直到歐洲節點已更新產品變更為止。 取捨是藉由提供[強式一致性](https://en.wikipedia.org/wiki/Strong_consistency)，等待所有複本節點更新後，再傳回查詢結果，您可以支援龐大的規模和流量，但可能會呈現較舊的資料。

NoSQL 資料庫可透過下列四個模型來分類： 

- *檔存放區*（MongoDB、CouchDB、Couchbase）：資料（和對應的中繼資料）會在資料庫內以不正規化 JSON 為基礎的檔中儲存非 relationally。

- 索引*鍵/值存放區*（Redis，Riak，memcached）：資料會儲存為簡單的索引鍵/值組，並針對對應至使用者資料值的唯一存取金鑰來執行系統作業。

- *寬資料行存放區*（HBase，Cassandra）：相關資料會以單欄式格式儲存為單一資料行中的一組嵌套索引鍵/值組，其中資料通常會以單一單位的形式抓取，而不需要將多個資料表聯結在一起。

- *圖形商店*（neo4j，titan）：資料會儲存為節點內的圖形表示，以及指定節點之間關聯性的邊緣。

NoSQL 資料庫可以優化來處理大規模的資料，特別是當資料相當簡單時。 當下列情況時，請考慮 NoSQL 資料庫：

- 您的工作負載需要大規模和高並行。
- 您有大量的使用者。
- 您的資料可以單純地表示，而不需要關聯性。
- 您必須將資料分散在不同的地理位置。
- 您不需要 ACID 保證。
- 將會部署到商用硬體。

然後，在下列情況考慮關係資料庫：

- 您的工作負載需要中型到大規模的規模。
- 平行存取並不是主要的考慮。
- 需要 ACID 保證。
- 資料最適合以 relationally 表示。
- 您的應用程式將會部署到大型的高階硬體。

接下來，我們會查看 Azure 雲端中的資料儲存體。

>[!div class="step-by-step"]
>[上一頁](distributed-data.md)
>[下一頁](azure-data-storage.md)
