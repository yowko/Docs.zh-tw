---
title: 定義雲端原生
description: 瞭解為雲端原生系統提供探源的基本要素
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 6a4a63f003c8ff0c7381d29f4e569838e45bd669
ms.sourcegitcommit: 55f438d4d00a34b9aca9eedaac3f85590bb11565
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/23/2019
ms.locfileid: "71183466"
---
# <a name="defining-cloud-native"></a>定義雲端原生

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

停止您正在進行的工作，以及您的同事的文字10。 要求他們定義「雲端原生」一詞。 好的，您可能會收到八種不同的答案。 有趣的是，從現在起算的六個月，隨著雲端原生技術和實務的發展，其定義也會跟著演變。

雲端原生的重點在於改變我們對建立重要商務系統的想法。

雲端原生系統的設計目的是要採用快速的變更、大規模和復原能力。 

雲端原生運算基礎提供[官方定義](https://github.com/cncf/foundation/blob/master/charter.md)：

> *雲端原生技術讓組織能夠在現代化的動態環境（例如公用、私人和混合式雲端）中建立並執行可擴充的應用程式。容器、服務網格、微服務、不可變的基礎結構和宣告式 Api 會範例說明點此方法。*

> *這些技術可讓您以具有彈性、容易管理和觀察的鬆散耦合系統。結合強大的自動化功能，讓工程師能夠以最少的辛勞，經常且可預測的方式進行高影響力的變更。*

隨著使用者的需求越來越多，應用程式也變得越來越複雜。 使用者預期快速回應能力、創新功能和零停機時間。 效能問題、週期性錯誤和無法移動的速度已不再接受。 他們可以輕鬆地移到您的競爭對手。

雲端原生的*速度*與*靈活性*很多。 商務系統的發展，是讓商業功能能夠在策略轉型的武器，加速業務速度和成長。 請務必立即將想法推向市場。 

以下是一些已實行這些技術的公司。 思考他們所達成的速度、靈活性和擴充性。

| 公司 | 遇到 | 
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 在生產環境中有600個以上的服務。 每天部署一百次。 |
| [Uber](https://eng.uber.com/micro-deploy/) | 在生產環境中儲存了1000項以上的服務。 每週部署數千個組建。 | 
| [WeChat](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 在生產環境中有300個以上的服務。 每天會進行大約1000的變更。 |

如您所見，Netflix、Uber 和 WeChat 會公開由數百個獨立微服務所組成的系統。 此架構樣式可讓他們快速回應市場狀況。 他們可以立即更新即時、複雜應用程式的小型區域，並視需要個別調整這些區域。

雲端原生的速度與靈活性來自數個因素。 最重要的是雲端基礎結構。 圖1-1 中所示的五個額外基礎要素也會提供雲端原生系統的探源。

![雲端原生基本要素](./media/cloud-native-foundational-pillars.png)

**圖 1-1**。 雲端原生基本要素

讓我們花一些時間進一步瞭解每個要件的重要性。

## <a name="the-cloud"></a>雲端 。

雲端原生系統會充分利用雲端服務模型。

這些系統是設計成在動態、虛擬化的雲端環境中，可廣泛使用[平臺即服務（PaaS）](https://azure.microsoft.com/overview/what-is-paas/)計算基礎結構和受控服務。 它們會在幾分鐘內將基礎結構視為可*處置*布建，並在需要時調整大小、縮放、移動或損毀–透過自動化。

考慮到廣為接受的[寵物 DevOps 概念與牛群完全轉換](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)。 在傳統的資料中心，伺服器會被視為*寵物*：實體機器、指定有意義的名稱，以及的關心。 您可以將更多資源新增至同一部電腦（相應增加）來調整規模。 如果伺服器變成病假，您會將它返回健康狀態。 萬一伺服器變得無法使用，每個人都會注意到。

*牛群完全轉換*服務模型不同。 您會將每個實例布建為虛擬機器或容器。 它們是相同的，而且指派了系統識別碼，例如，服務-01、Service-02 等等。 您可以藉由建立更多專案來進行調整（向外延展）。 當其中一個變成無法使用時，沒有人會注意到。

牛群完全轉換模型會涵蓋固定的*基礎結構*。 伺服器不會進行修復或修改。 如果其中一個失敗或需要更新，它會被終結並布建一個新的–全都透過自動化完成。

雲端原生系統採用牛群完全轉換服務模型。 它們會繼續執行，因為基礎結構會相應縮小或相應放大，而不考慮其執行所在的電腦。

Azure 雲端平臺支援這種高度彈性的基礎結構，其中包含自動調整、自我修復和監視功能。

## <a name="modern-design"></a>現代化設計

您要如何設計雲端原生應用程式？ 您的架構看起來是什麼樣子？ 您會遵守哪些原則、模式和最佳作法？ 什麼是基礎結構和操作考慮很重要？

### <a name="the-twelve-factor-application"></a>十二因素應用程式

可廣泛接受用來建立雲端式應用程式的方法是[十二因素應用程式](https://12factor.net/)。 其中說明開發人員遵循的一組原則和作法，來建造針對現代化雲端環境優化的應用程式。 在環境和宣告式自動化之間提供可攜性的特別注意。

在適用于任何 web 應用程式的情況下，許多開發人員會將其視為建立雲端原生應用程式的穩固基礎。 根據這些原則建立的系統可以快速部署和調整規模，並新增功能，以快速回應市場變化。

下表將重點放在十二個要素的方法：

|    |  因素 | 說明  |
| :-------- | :-------- | :-------- |
| 1 | 程式碼基底 | 每個微服務的單一程式碼基底，儲存在自己的存放庫中。 透過版本控制進行追蹤，它可以部署到多個環境（QA、預備、生產）。 |
| 2 | 相依性 | 每個微服務都會隔離並封裝自己的相依性，並在不影響整個系統的情況下進行變更。 |
| 3 | 組態  | 設定資訊會從微服務和外部化移出，並透過程式碼之外的設定管理工具。 相同的部署可以跨已套用正確設定的環境進行傳播。  |
| 4 | 支援服務 | 輔助資源（資料存放區、快取、訊息代理程式）應透過可定址的 URL 公開。 這麼做會將資源與應用程式分離，使其可互換。  |
| 5 | 組建、發行、執行 | 每個版本都必須在組建、發行和執行階段強制執行嚴格的分隔。 每個都應該以唯一識別碼標記，並支援復原的能力。 新式 CI/CD 系統有助於滿足此原則。 |
| 6 | 處理序 | 每個微服務都應該在它自己的進程中執行，與其他正在執行的服務隔離。 將需要的狀態外部化至支援服務，例如分散式快取或資料存放區。 |
| 7 | 埠系結 | 每個微服務都應該各自獨立于其本身的埠上公開的介面和功能。 這麼做會提供與其他微服務的隔離。 |
| 8 | 並行 | 服務會在大量的小型相同進程（複本）上相應放大，而不是在最強大的電腦上相應增加單一大型實例。 |
| 9 | Disposability | 服務實例應可處置，優先列出快速新創公司，以增加擴充性機會和正常關機，讓系統處於正確的狀態。 Docker 容器和協調器原本就能滿足這項需求。 |
| 10 | 開發/生產同位 | 盡可能讓應用程式生命週期中的環境保持相似，以避免昂貴的快捷方式。 在這裡，您可以藉由升級相同的執行環境，大幅提升容器的採用。 |
| 11 | 記錄 | 將微服務產生的記錄視為事件資料流程。 使用事件匯總工具處理它們，並將資料傳播至資料採礦/記錄管理工具，例如 Azure 監視器或 Splunk，以及最終長期保存。 |
| 12 | 管理進程 | 以一次性程式的形式執行系統管理/管理工作。 工作可以包含資料清除和提取報表的分析。 執行這些工作的工具應從生產環境叫用，但與應用程式分開。 |

除了 [12 個要素的應用程式之外](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)，作者古柯 Hoffman 會詳細說明每一個原始12因素（以2011撰寫）。 此外，本書還提供其他三個因素來反映現今現代化的雲端應用程式設計。

|    |  新因素 | 說明  |
| :-------- | :-------- | :-------- |
| 13 | API 第一個 | 將所有專案變成一項服務。 假設您的程式碼將由前端用戶端使用。 閘道或其他服務。 |
| 14 | 遙測 | 在工作站上，您可以深入瞭解您的應用程式及其行為。 在雲端中，您不會這麼做。 請確定您的設計包含「監視」、「網域特定」和「健康情況/系統」資料的集合。 |
| 15 | 驗證/授權  | 從起始處執行身分識別。 請考慮公用雲端中可用的[RBAC （角色型存取控制）](https://docs.microsoft.com/azure/role-based-access-control/overview)功能。  |

我們將在這一章和整本書中參考許多12個以上的因素。

### <a name="critical-design-considerations"></a>重大設計考慮

除了12因素方法所提供的指引之外，在您建立分散式系統時，您必須進行幾項重要的設計決策。

*交流*

前端用戶端應用程式會如何與支援的端核心服務通訊？ 您是否允許直接通訊？ 或者，您可以使用提供彈性、控制和安全性的閘道外觀來抽象化後端服務嗎？

後端核心服務會如何彼此通訊？ 您是否允許直接 HTTP 呼叫導致結合性和影響效能和靈活性？ 或者，您可以考慮使用佇列和主題技術來分離訊息嗎？

通訊詳述于第4章，也就是*雲端原生通訊模式*。

*恢復*

微服務架構會將您的系統從同進程移動到網路通訊。 在分散式環境中，當服務 B 未回應來自服務 A 的呼叫時，您會怎麼做？ 當服務 C 暫時無法使用，且其他服務呼叫它堆疊並降低系統效能時，會發生什麼事？

復原功能詳述于第6章，也就是*雲端原生復原*。

*分散式資料*

根據設計，每個微服務都會封裝自己的資料，透過其公用介面公開作業。 若是如此，您要如何查詢資料或跨多個服務執行交易？

分散式資料詳述于第5章，也就是*雲端原生資料模式*。

*身分識別*

您的服務如何識別誰正在存取它，以及他們有哪些許可權？

身分識別詳述于第8章，身分*識別*。

## <a name="microservices"></a>微服務
雲端原生系統採用微服務，這是用來建立現代化應用程式的熱門架構樣式。

建立為一組分散式的小型獨立服務，透過共用網狀架構進行互動，微服務會共用下列特性：

- 每個都會在較大的網域內容中執行特定的商務功能。

- 每個都是自主開發，而且可以獨立部署。

- 各自獨立封裝自己的資料儲存技術（SQL、NoSQL）和程式設計平臺。

- 每個都會在自己的進程中執行，並使用標準通訊協定（例如 HTTP/HTTPS、Websocket 或[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)）與其他人進行通訊。

- 它們組合在一起，以形成應用程式。

圖1-2 將整合型應用程式方法與微服務方法做對比。 請注意單體如何由多層式架構組成，這會在單一進程中執行。 它通常會使用關係資料庫。 不過，微服務方法會將功能都會隔離到包含邏輯和資料的獨立服務中。 每個微服務都會裝載自己的資料存放區。

![整合型部署與微服務](./media/monolithic-vs-microservices.png)

**圖 1-2。** 整合型部署與微服務

請注意，微服務如何從[十二個要素的應用程式](https://12factor.net/)升級「一個程式碼基底，一個應用程式」原則，這章節稍早所討論。

> *因數\#1 指定每個微服務的單一程式碼基底，儲存在自己的存放庫中。以版本控制進行追蹤，它可以部署到多個環境」*

### <a name="why-microservices"></a>為什麼要微服務？

微服務提供靈活性。

稍早在章節中，我們比較了以單體建立的電子商務應用程式與微服務。 在此範例中，我們看到一些清楚的好處： 

- 每個微服務都有自發的生命週期，而且可以獨立且經常地進行部署。 您不需要等候每季版本來部署新功能或更新。 您可以更新複雜應用程式的小型區域，降低中斷整個系統的風險。

- 每個微服務都可以獨立調整。 您不會將整個應用程式調整為單一單位，而是只向外延展那些需要更多處理能力或網路頻寬的服務。 這個更細緻的調整方法可提供更好的系統控制，並在您調整系統的部分（而非所有專案）時，協助降低整體成本。

.Net 微服務是[瞭解微服務的絕佳參考指南：容器化 .NET 應用程式的架構](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。 本書深入探討微服務的設計與架構。 這是隨附于 Microsoft 免費下載的[完整堆疊微服務參考架構](https://github.com/dotnet-architecture/eShopOnContainers)。

### <a name="developing-microservices"></a>開發微服務

您可以使用任何現代化開發平臺來建立微服務。

Microsoft .NET Core 平臺是絕佳的選擇。 免費且開放的原始碼提供許多內建功能，可簡化微服務的開發。 .NET Core 是跨平臺。 應用程式可以在 Windows、macOS 及大部分的 Linux 類別上建立和執行。

.NET Core 的效能非常高效，相較于 node.js 和其他正在完成的平臺，其計分程度也相當良好。 有趣的是， [TechEmpower](https://www.techempower.com/)在許多 web 應用程式平臺和架構上執行了一組廣泛的[效能基準](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)檢驗。 .NET Core 在前10大-良好的 node.js 和其他競爭平臺上評分。 

.NET Core 是由 Microsoft 和 GitHub 上的 .NET 社區維護。 

## <a name="containers"></a>容器

現今，它很自然地知道任何關於*雲端原生*的交談中所述的「*容器*」一詞。 在本書中，[雲端原生模式](https://www.manning.com/books/cloud-native-patterns)，作者 Cornelia Davis 會觀察到「容器是雲端原生軟體的絕佳促成者」。 雲端原生運算基礎將微服務容器化作為其[雲端原生線索對應](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一個步驟-開始進行雲端原生旅程的企業指導方針。

容器化微服務簡單明瞭。 程式碼、其相依性和執行時間會封裝成稱為[容器映射](https://docs.docker.com/glossary/?term=image)的二進位檔。 映射會儲存在[容器](https://caylent.com/container-registries/)登錄中，作為映射的存放庫或程式庫。 登錄可以位於您的開發電腦、資料中心或公用雲端中。 Docker 本身會透過[Docker Hub](https://hub.docker.com/)維護公用登錄。 Azure 雲端具有[容器](https://azure.microsoft.com/services/container-registry/)登錄，可將容器映射儲存在即將執行它們的雲端應用程式附近。

如有需要，您可以將映射轉換成執行中的容器實例。 此實例會在已安裝[容器運行](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)時間引擎的任何電腦上執行。 您可以視需要擁有容器化服務的多個實例。

圖1-3 顯示三個不同的微服務，每個都在自己的容器中，在單一主機上執行。

![在容器主機上執行的多個容器](./media/hosting-mulitple-containers.png)  

**圖 1-3**。 在容器主機上執行的多個容器

請注意，每個容器如何維護自己的相依性和執行時間集合，這可能會有所不同。 在這裡，我們會看到在相同主機上執行的不同版本的產品微服務。 每個容器會共用基礎主機作業系統、記憶體和處理器的配量，但會彼此隔離。 

請注意，容器模型從[十二個要素應用程式](https://12factor.net/)中納入「相依性」原則的效果。

> *因素\#2 指定「每個微服務會隔離和封裝自己的相依性，並在不影響整個系統的情況下進行變更。」*

容器同時支援 Linux 和 Windows 工作負載。 Azure 雲端公開同時採用這兩種。 有趣的是，它是 Linux，而不是 Windows Server，已成為 Azure 中最受歡迎的作業系統。

雖然有數個容器廠商存在，但 Docker 已捕捉到 lion 的市場份額。 公司已推動軟體容器的移動。 它已成為封裝、部署和執行雲端原生應用程式的事實上標準。

### <a name="why-containers"></a>為何選擇容器？

容器提供可攜性，並確保環境之間的一致性。 藉由將所有專案封裝成單一套件，您可以*隔離*微服務及其相依性與基礎結構。 

您可以在任何具有 Docker 執行時間引擎的環境中部署該相同容器。 容器化工作負載也可消除使用架構、軟體程式庫和執行時間引擎預先設定各個環境的費用。

藉由共用基礎作業系統和主機資源，容器的使用量會比完整虛擬機器更小。 較小的大小會增加指定的主機一次可以執行的*密度*，或微服務的數目。

### <a name="container-orchestration"></a>容器協調流程

雖然 Docker 之類的工具會建立映射和執行容器，但您也需要工具來管理它們。 容器管理是以稱為容器協調器的特殊軟體程式來完成。 在大規模運作時，容器協調流程是不可或缺的。 

圖1-4 顯示 container 協調器所提供的管理工作。

![容器協調器的用途](./media/what-container-orchestrators-do.png)

**圖 1-4**。 容器協調器的用途

下表說明常見的協調流程工作。

|  工作 | 說明  |
| :-------- | :-------- |
| 功能 | 自動布建容器實例。|
| 親和性/反親和性 | 布建附近或遠離彼此的容器，以協助提供可用性和效能。 |
| 健康狀態監視 | 自動偵測並更正失敗。|
| 容錯移轉 | 自動將失敗的實例重新布建至狀況良好的機器。|
| 縮放 | 自動新增或移除容器實例以符合需求。|
| 網路 | 管理容器通訊的網路重迭。|
| 服務探索 | 讓容器彼此尋找。|
| 輪流升級 | 協調增量升級，而不需要停機部署。 自動復原有問題的變更。|

請注意，協調器如何從[十二個要素的應用程式](https://12factor.net/)中採用 disposability 和並行原則，這章節稍早討論過。

> *第\#9 個要素指定「服務實例應可處置，優先列出快速新創公司」，以增加擴充性機會和正常關機，讓系統處於正確狀態。Docker 容器和協調器原本就能滿足這項需求。」*

> *因數\#8 指定「服務在大量的小型相同進程（複本）上相應放大，而不是相應增加最強大電腦上的單一大型實例。」*

雖然有數個容器協調器存在，但[Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)已經成為雲端原生世界的既定標準。 它是一種可移植、可擴充的開放原始碼平臺，用於管理容器化的工作負載。 

您可以裝載自己的 Kubernetes 實例，但是您會負責布建和管理其資源，這可能很複雜。 Azure 雲端功能 Kubernetes 為受控服務， [Azure Kubernetes Service （AKS）](https://azure.microsoft.com/services/kubernetes-service/)。 受控服務可讓您充分利用其功能，而不需要安裝及維護它。

Azure Kubernetes Services 的詳細資訊請在第2章（*調整雲端原生應用程式*）中討論。

## <a name="backing-services"></a>支援服務

雲端原生系統取決於許多不同的輔助資源，例如資料存放區、訊息代理程式、監視和身分識別服務。 這些服務稱為「[支援服務](https://12factor.net/backing-services)」。

 圖1-5 顯示雲端原生系統使用的許多常見的支援服務。

![一般支援服務](./media/common-backing-services.png)

**圖 1-5**。 一般支援服務

備份服務會從[12 個要素的應用程式](https://12factor.net/)升級「Statelessness」原則，本章稍早所討論。

>*係數\#6*指定，「每個微服務都應該在自己的進程中執行，並與其他執行中的服務隔離。 將必要狀態外部化到支援服務，例如分散式快取或資料存放區。」

您可以裝載自己的支援服務，但您會負責授權、布建及管理這些資源。

雲端提供者提供各式各樣的*受控支援服務。* 而不是擁有服務，而是只使用它。 提供者會大規模地操作資源，並擁有效能、安全性和維護的責任。 服務內建監視、冗余和可用性。 提供者完全支援其受控服務-開啟票證，並修正您的問題。

雲端原生系統優先于雲端廠商提供的受控支援服務。 節省時間和人力很棒。 裝載您自己和遇到問題的作業風險，可能很快就會變得昂貴。

最佳做法是將支援服務視為連結的*資源*，並以動態方式系結至微服務，並將資訊（URL 和認證）儲存在外部設定中。 這項指導方針已在[十二個要素的應用程式](https://12factor.net/)中說明，如稍早的章節所述。

>*係數\#4*指定應該透過可定址的 URL 公開支援服務。 這麼做會將資源與應用程式分離，讓它能夠互換。」

>*第\#3 個因素*是指定「設定資訊會透過程式碼外的設定管理工具移出微服務和外部化。」

使用此模式時，可以附加及卸離支援服務，而不需要變更程式碼。 您可以將微服務從 QA 升級至預備環境。 您可以更新微服務設定，以指向預備環境中的支援服務，並透過環境變數將設定插入您的容器中。

雲端廠商會提供 Api，讓您與專屬的支援服務進行通訊。 這些程式庫會封裝管線和複雜度。 直接與這些 Api 通訊會讓您的程式碼緊密結合到支援服務。 更好的作法是將廠商 API 的執行細節隔離。 引進 intermediation 層或中繼 API，將一般作業公開至您的服務程式代碼。 這種鬆散結合可讓您交換另一個支援服務，或將程式碼移至不同的公用雲端，而不需要對主線服務程式代碼進行變更。

支援服務會詳細討論第5章、*雲端原生資料模式*和第4章*雲端原生通訊模式*。

## <a name="automation"></a>Automation

如您所見，雲端原生系統採用了微服務、容器和現代化的系統設計，以達成速度和靈活性。 不過，這只是故事的一部分。 您要如何布建這些系統執行所在的雲端環境？ 如何快速部署應用程式功能與更新？ 您要如何將整個圖片四捨五入？

輸入[基礎結構](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)即程式碼或 IaC 的廣為接受做法。

透過 IaC，您可以將平臺布建和應用程式部署自動化。 您基本上會將軟體工程實務（例如測試和版本控制）套用至您的 DevOps 實務。 您的基礎結構和部署會自動化、一致且可重複。

### <a name="automating-infrastructure"></a>自動化基礎結構

[Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、[Terraform] 和[Azure CLI](https://docs.microsoft.com/cli/azure/?view=azure-cli-latest)等工具，可讓您以宣告方式編寫腳本所需的雲端基礎結構。 [資源名稱]、[位置]、[容量] 和 [密碼] 是參數化和動態。 腳本會進行版本設定，並簽入原始檔控制做為專案的成品。 您叫用腳本以在系統內容中布建一致且可重複的基礎結構，例如 QA、預備及生產。 

實際上，IaC 是等冪的，這表示您可以執行相同的腳本，而不會產生副作用。 如果小組需要進行變更，他們會編輯並重新執行腳本。 只有更新的資源會受到影響。

在本文中，[什麼是基礎結構即程式碼](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)，作者 Sam 作者: guckenheimer 說明如何，「執行 IaC 的小組可以快速且大規模地提供穩定的環境。 小組會避免手動設定環境，並藉由透過程式碼來表示其環境的期望狀態來強制執行一致性。 使用 IaC 的基礎結構部署可重複，並防止設定漂移或遺失相依性所造成的執行時間問題。 DevOps 小組可以與一組整合的實務和工具搭配運作，以快速、可靠且大規模地傳遞應用程式及其支援的基礎結構。」

### <a name="automating-deployments"></a>自動化部署

稍早所討論的[十二個要素應用程式](https://12factor.net/)，會在將完成的程式碼轉換成執行中的應用程式時，呼叫個別的步驟。

> *第\#5 因數*指定「每個版本都必須強制執行組建、發行和執行階段之間嚴格的分隔。 每個都應該以唯一識別碼標記，並支援復原的能力。」

新式 CI/CD 系統有助於滿足此原則。 它們提供個別的部署步驟，並協助確保可立即提供給使用者的一致和品質程式碼。 

圖1.6 顯示整個部署程式的分隔。

![CI/CD 管線中的部署步驟](./media/build-release-run-pipeline.png)

**圖 1-6**。 CI/CD 管線中的部署步驟

在上圖中，請特別注意工作的分隔。 

開發人員會在其開發環境中建立功能，逐一查看程式碼的「內部迴圈」、執行和 debug。 完成時，會將該程式碼*推送*至程式碼存放庫，例如 GitHub、Azure DevOps 或 BitBucket。 

推送會觸發將程式碼轉換成二進位成品的組建階段。 此工作是透過[持續整合（CI）](https://martinfowler.com/articles/continuousIntegration.html)管線來執行。 它會自動建立、測試和封裝應用程式。 

發行階段會挑選二進位成品、套用外部應用程式和環境設定資訊，並產生不可變的版本。 發行會部署到指定的環境。 此工作會使用[持續傳遞（CD）](https://martinfowler.com/bliki/ContinuousDelivery.html)管線來執行。 每個版本都應該是可辨識的。 您可以說：「這個部署正在執行應用程式的版本2.1.1」。

最後，已釋放的功能會在目標執行環境中執行。 版本是不可變的，這表示任何變更都必須建立新的版本。 

套用這些實務後，組織就已經徹底演變出軟體的方式。 許多已從季度版本移至隨選更新。 其目標是要及早在開發週期中攔截問題，而不需要修正這項成本。 整合之間的持續時間愈長，解決的問題就愈昂貴。  隨著整合程式的一致性，小組可以更頻繁地認可程式碼變更，進而提供更好的共同作業和軟體品質。  

### <a name="azure-pipelines"></a>Azure Pipelines

Azure 雲端包含一項新的 CI/CD 服務，其標題為[Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/)，這是如圖1-7 所示之[Azure DevOps](https://azure.microsoft.com/services/devops/)供應專案的一部分。

![DevOps 中的 Azure Pipelines](./media/devops-components.png)

**圖 1-7**。 Azure DevOps 供應專案

Azure Pipelines 是結合持續整合（CI）與持續傳遞（CD）的雲端服務。 您可以自動測試、建立程式碼，並將其傳送至任何目標。

您會在 YAML 檔案中的程式碼中定義管線，連同應用程式的其餘程式碼。

- 管線會以您的程式碼建立版本，並遵循相同的分支結構。
- 您可以透過提取要求和分支組建原則中的程式碼審查，取得變更的驗證。
- 您使用的每個分支都可以藉由修改 azure-pipelines. yml 檔案來自訂群組建原則。
- 管線檔案會簽入版本控制，並可在發生問題時進行調查。

Azure Pipelines 服務支援大部分的 Git 提供者，而且可以針對在 Linux、macOS 或 Windows 平臺上撰寫的應用程式產生部署管線。 其中包括 JAVA、.NET、JavaScript、Python、PHP、Go、XCode 和C++的支援。

>[!div class="step-by-step"]
>[上一頁](introduction.md)
>[下一頁](candidate-apps.md)
