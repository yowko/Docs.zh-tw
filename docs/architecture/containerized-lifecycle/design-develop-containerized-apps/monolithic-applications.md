---
title: 整合型應用程式
description: 了解如何將整合型應用程式容器化的核心概念。
ms.date: 02/15/2019
ms.openlocfilehash: 1d4b54017e431bd9775bf2aee8c88f56e0489367
ms.sourcegitcommit: 2e95559d957a1a942e490c5fd916df04b39d73a9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/16/2019
ms.locfileid: "72394687"
---
# <a name="monolithic-applications"></a><span data-ttu-id="04724-103">整合型應用程式</span><span class="sxs-lookup"><span data-stu-id="04724-103">Monolithic applications</span></span>

<span data-ttu-id="04724-104">在本案例中，您會建置單一且整合型的 Web 應用程式或服務，並將它部署為容器。</span><span class="sxs-lookup"><span data-stu-id="04724-104">In this scenario, you're building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="04724-105">從應用程式內部來看，其結構可能不是整合型，而是由數個程式庫、元件，甚至層級 (應用程式層、網域層、資料存取層等) 所組成。</span><span class="sxs-lookup"><span data-stu-id="04724-105">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="04724-106">從外部來看，它是單一容器，像是單一處理序、單一 Web 應用程式或單一服務。</span><span class="sxs-lookup"><span data-stu-id="04724-106">Externally, it's a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="04724-107">為了管理此模型，您會部署單一容器來代表應用程式。</span><span class="sxs-lookup"><span data-stu-id="04724-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="04724-108">若要進行擴充，只要透過前端負載平衡器多新增幾個複本即可。</span><span class="sxs-lookup"><span data-stu-id="04724-108">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="04724-109">由於您可以在單一容器或虛擬機器 (VM) 中管理單一部署，因此相對簡單。</span><span class="sxs-lookup"><span data-stu-id="04724-109">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="04724-110">當您遵循「容器僅執行一項動作並在一個處理序中執行該動作」的原則時，整合型模式可能會產生衝突。</span><span class="sxs-lookup"><span data-stu-id="04724-110">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="04724-111">您可以在每個容器中包含多個元件/程式庫或內部層級，如圖 4-1 所示。</span><span class="sxs-lookup"><span data-stu-id="04724-111">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![此圖顯示透過複製應用程式相應放大的整合型應用程式。](./media/monolithic-applications/monolithic-application-architecture-example.png)

<span data-ttu-id="04724-113">**圖 4-1.**</span><span class="sxs-lookup"><span data-stu-id="04724-113">**Figure 4-1.**</span></span> <span data-ttu-id="04724-114">整合型應用程式的架構範例</span><span class="sxs-lookup"><span data-stu-id="04724-114">An example of monolithic application architecture</span></span>

<span data-ttu-id="04724-115">整合型應用程式的單一處理序或容器內即具有其全部或大部分功能，且在內部層或程式庫中經元件化處理。</span><span class="sxs-lookup"><span data-stu-id="04724-115">A monolithic app has all or most of its functionality within a single process or container and it's componentized in internal layers or libraries.</span></span> <span data-ttu-id="04724-116">如果應用程式因成長而需要擴充，則此方法的缺點便會浮現。</span><span class="sxs-lookup"><span data-stu-id="04724-116">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="04724-117">若整個應用程式都擴充，則不成問題。</span><span class="sxs-lookup"><span data-stu-id="04724-117">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="04724-118">不過，在大多數情況下，應用程式只需要擴充幾個造成阻礙的部分，其他元件則較少使用。</span><span class="sxs-lookup"><span data-stu-id="04724-118">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="04724-119">若是一般的電子商務範例，您可能需要調整的是產品資訊元件。</span><span class="sxs-lookup"><span data-stu-id="04724-119">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="04724-120">瀏覽產品的客戶比購買的人多。</span><span class="sxs-lookup"><span data-stu-id="04724-120">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="04724-121">比起使用付款管道，會有更多客戶使用其購物籃。</span><span class="sxs-lookup"><span data-stu-id="04724-121">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="04724-122">新增留言或檢視其購買歷程記錄的客戶較少。</span><span class="sxs-lookup"><span data-stu-id="04724-122">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="04724-123">而且在單一區域中，您可能只有少數幾個員工來管理內容和行銷活動。</span><span class="sxs-lookup"><span data-stu-id="04724-123">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="04724-124">藉由擴充整合型設計，即可多次部署所有程式碼。</span><span class="sxs-lookup"><span data-stu-id="04724-124">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="04724-125">除了「全部調整」的問題之外，當您變更單一元件時，必須徹底重新測試整個應用程式，並重新部署所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="04724-125">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="04724-126">整合型方法很常見，許多組織也開始使用這個架構方法進行開發。</span><span class="sxs-lookup"><span data-stu-id="04724-126">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="04724-127">其中有許多組織獲得良好的結果，但其他組織卻遭遇到限制。</span><span class="sxs-lookup"><span data-stu-id="04724-127">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="04724-128">由於工具和基礎結構太難建置 SOA，因此許多組織按照此模型來設計應用程式，但是在應用程式成長之後需求才會顯現出來。</span><span class="sxs-lookup"><span data-stu-id="04724-128">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="04724-129">從基礎結構的觀點來看，每部伺服器都可以在相同主機內執行許多應用程式，並具備可接受的資源使用效率比，如圖 4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="04724-129">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![圖表，顯示在不同的容器中有多個應用程式的主控制項。](./media/monolithic-applications/host-with-multiple-apps-containers.png)

<span data-ttu-id="04724-131">**圖 4-2.**</span><span class="sxs-lookup"><span data-stu-id="04724-131">**Figure 4-2.**</span></span> <span data-ttu-id="04724-132">執行多個應用程式/容器的主機</span><span class="sxs-lookup"><span data-stu-id="04724-132">A host running multiple apps/containers</span></span>

<span data-ttu-id="04724-133">最後，從可用性的觀點來看，整合型應用程式必須以整體方式部署；這表示萬一您必須「停止和啟動」時，會影響部署期間的所有功能和所有使用者。</span><span class="sxs-lookup"><span data-stu-id="04724-133">Finally, from an availability perspective, monolithic applications must be deployed as a whole; that means that in case you must *stop and start*, all functionality and all users will be affected during the deployment window.</span></span> <span data-ttu-id="04724-134">在某些情況下，使用 Azure 和容器可以盡量避免這些情況，並降低應用程式停機的可能性，如圖 4-3 所示。</span><span class="sxs-lookup"><span data-stu-id="04724-134">In certain situations, the use of Azure and containers can minimize these situations and reduce the probability of downtime of your application, as you can see in Figure 4-3.</span></span>

<span data-ttu-id="04724-135">您可以針對每個執行個體使用專用 VM，在 Azure 中部署整合型應用程式。</span><span class="sxs-lookup"><span data-stu-id="04724-135">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="04724-136">您可以使用 [Azure VM 擴展集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)來調整 VM。</span><span class="sxs-lookup"><span data-stu-id="04724-136">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span>

<span data-ttu-id="04724-137">您也可以使用 [Azure App Service](https://azure.microsoft.com/services/app-service/) 來執行整合型應用程式並輕鬆調整執行個體，而不必管理 VM。</span><span class="sxs-lookup"><span data-stu-id="04724-137">You can also use [Azure App Services](https://azure.microsoft.com/services/app-service/) to run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="04724-138">Azure App Service 也可以執行 Docker 容器的單一執行個體，以簡化部署。</span><span class="sxs-lookup"><span data-stu-id="04724-138">Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span>

<span data-ttu-id="04724-139">您可以將多個 VM 部署為 Docker 主機，並在每個 VM 執行任意數目的容器。</span><span class="sxs-lookup"><span data-stu-id="04724-139">You can deploy multiple VMs as Docker hosts and run any number of containers per VM.</span></span> <span data-ttu-id="04724-140">然後，您可以使用 Azure Load Balancer 來管理調整，如圖 4-3 所示。</span><span class="sxs-lookup"><span data-stu-id="04724-140">Then, by using an Azure Load Balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![圖表，顯示相應放大至不同主機的整合型應用程式。](./media/monolithic-applications/multiple-hosts-from-single-docker-container.png)

<span data-ttu-id="04724-142">**圖 4-3**：</span><span class="sxs-lookup"><span data-stu-id="04724-142">**Figure 4-3**.</span></span> <span data-ttu-id="04724-143">多部主機相應放大單一 Docker 應用程式</span><span class="sxs-lookup"><span data-stu-id="04724-143">Multiple hosts scaling out a single Docker application</span></span>

<span data-ttu-id="04724-144">您可以透過傳統部署技術來管理主機本身的部署。</span><span class="sxs-lookup"><span data-stu-id="04724-144">You can manage the deployment of the hosts themselves via traditional deployment techniques.</span></span>

<span data-ttu-id="04724-145">您可以使用 `docker run` 和 `docker-compose up` 等命令，從命令列管理 Docker 容器；您也可以在持續傳遞 (CD) 管線中將其自動化，並從 Azure DevOps Services 部署到 Docker 主機。</span><span class="sxs-lookup"><span data-stu-id="04724-145">You can manage Docker containers from the command line by using commands like `docker run` and `docker-compose up`, and you can also automate it in Continuous Delivery (CD) pipelines and deploy to Docker hosts from Azure DevOps Services, for instance.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="04724-146">整合型應用程式部署為容器</span><span class="sxs-lookup"><span data-stu-id="04724-146">Monolithic application deployed as a container</span></span>

<span data-ttu-id="04724-147">使用容器來管理整合型部署有許多優點。</span><span class="sxs-lookup"><span data-stu-id="04724-147">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="04724-148">調整容器執行個體遠比部署額外的 VM 更輕鬆快速。</span><span class="sxs-lookup"><span data-stu-id="04724-148">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span>

<span data-ttu-id="04724-149">以 Docker 映像來部署更新會更快且網路效率更高。</span><span class="sxs-lookup"><span data-stu-id="04724-149">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="04724-150">Docker 容器通常只要幾秒鐘就能啟動，因此可加速推出。</span><span class="sxs-lookup"><span data-stu-id="04724-150">Docker containers typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="04724-151">您只要叫用 `docker stop` 命令即可輕鬆卸除 Docker 容器，且通常不到一秒就會完成。</span><span class="sxs-lookup"><span data-stu-id="04724-151">Tearing down a Docker container is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="04724-152">容器的設計原本即為固定，因此您永遠不需要擔心會因為更新指令碼忘記處理部分特定設定或是檔案殘留在磁碟上而導致 VM 損毀。</span><span class="sxs-lookup"><span data-stu-id="04724-152">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="04724-153">雖然整合型應用程式可以從 Docker 獲益，但這只是一小部分優點。</span><span class="sxs-lookup"><span data-stu-id="04724-153">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="04724-154">管理容器的主要優點來自於使用容器協調器進行部署，透過此方式來管理各種執行個體和每個容器執行個體的生命週期。</span><span class="sxs-lookup"><span data-stu-id="04724-154">The larger benefits of managing containers come from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="04724-155">將整合型應用程式分成可個別擴充、開發及部署的多個子系統，是您開始使用微服務的不錯起點。</span><span class="sxs-lookup"><span data-stu-id="04724-155">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

<span data-ttu-id="04724-156">若要深入了解如何「隨即轉移」整合型應用程式與容器，以及如何將應用程式現代化，您可以另外參閱[使用 Azure 雲端及 Windows 容器將現有 .NET 應用程式轉換成現代化的應用程式](../../modernize-with-azure-containers/index.md)此 Microsoft 指南，您也可以從 <https://aka.ms/LiftAndShiftWithContainersEbook> 下載 PDF。</span><span class="sxs-lookup"><span data-stu-id="04724-156">To learn about how to “lift and shift” monolithic applications with containers and how you can modernize your applications, you can read this additional Microsoft guide, [Modernize existing .NET applications with Azure cloud and Windows Containers](../../modernize-with-azure-containers/index.md), that you can also download as PDF from <https://aka.ms/LiftAndShiftWithContainersEbook>.</span></span>

## <a name="publish-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="04724-157">將單一 Docker 容器應用程式發佈至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="04724-157">Publish a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="04724-158">不論您是為了想要快速取得部署至 Azure 的容器驗證，還是基於應用程式只是單一容器應用程式等原因，Azure App Service 都有絕佳方法來提供可擴充的單一容器服務。</span><span class="sxs-lookup"><span data-stu-id="04724-158">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="04724-159">Azure App Service 提供與 Git 的絕佳整合，讓您可以輕鬆地取得程式碼、在 Microsoft Visual Studio 中建置，並將它直接部署至 Azure，其使用方式為直覺式，因此您可以快速啟動並執行。</span><span class="sxs-lookup"><span data-stu-id="04724-159">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="04724-160">但是，以傳統方式來說 (不含任何 Docker)，如果您需要 Azure App Service 不支援的其他功能、架構或相依性，您必須等 Azure 小組更新 Azure App Service 中的這些相依性或切換到其他服務 (例如 Service Fabric、雲端服務，甚至單純的 VM)，才能進一步控制並為應用程式安裝必要的元件或架構。</span><span class="sxs-lookup"><span data-stu-id="04724-160">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="04724-161">現在，當您使用 Visual Studio 2017 時，Azure App Service 的容器支援可讓您在應用程式環境中包含所想要任何項目，如圖 4-4 所示。</span><span class="sxs-lookup"><span data-stu-id="04724-161">Now, as shown in Figure 4-4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="04724-162">如果您已將相依性新增至應用程式，並在容器中加以執行，即可在 Dockerfile 或 Docker 映像中包括這些相依性。</span><span class="sxs-lookup"><span data-stu-id="04724-162">If you added a dependency to your app, because you're running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![顯示容器登錄的 [建立 App Service] 對話方塊的螢幕擷取畫面。](./media/monolithic-applications/publish-azure-app-service-container.png)

<span data-ttu-id="04724-164">**圖 4-4**：</span><span class="sxs-lookup"><span data-stu-id="04724-164">**Figure 4-4**.</span></span> <span data-ttu-id="04724-165">將容器從 Visual Studio 應用程式/容器發佈至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="04724-165">Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="04724-166">如圖 4-4 所示，發佈流程會透過容器登錄推送映像，而這可能是 Azure Container Registry (接近您 Azure 部署並受到 Azure Active Directory 群組和帳戶保護的登錄)，或任何其他 Docker 登錄，例如 Docker Hub 或內部部署登錄。</span><span class="sxs-lookup"><span data-stu-id="04724-166">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="04724-167">[上一頁](common-container-design-principles.md)
>[下一頁](state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="04724-167">[Previous](common-container-design-principles.md)
[Next](state-and-data-in-docker-applications.md)</span></span>
