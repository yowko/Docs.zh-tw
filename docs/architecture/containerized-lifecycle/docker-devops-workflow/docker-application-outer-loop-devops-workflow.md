---
title: Docker 應用程式之外部迴圈 DevOps 工作流程中的步驟
description: 了解 DevOps 工作流程的「外部迴圈」步驟
ms.date: 02/15/2019
ms.openlocfilehash: 735f92c00cd6279649ec3b0c35cfb00543f21a8c
ms.sourcegitcommit: 7e2128d4a4c45b4274bea3b8e5760d4694569ca1
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/14/2020
ms.locfileid: "75936786"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="3ba4a-103">Docker 應用程式之外部迴圈 DevOps 工作流程中的步驟</span><span class="sxs-lookup"><span data-stu-id="3ba4a-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="3ba4a-104">圖 5-1 顯示 DevOps 外部迴圈工作流程中所包含步驟的端對端描述。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="3ba4a-105">它會顯示 DevOps 的「外部迴圈」。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="3ba4a-106">將程式碼推送到存放庫之後會啟動 CI 管線，然後開始 CD 管線以將應用程式部署在其中。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="3ba4a-107">從已部署應用程式收集的計量會回饋給開發工作負載，其中會出現「內部迴圈」，讓開發小組有實際資料可回應使用者和商務需求。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![此圖顯示 DevOps 外部迴圈工作流程的6個步驟。](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="3ba4a-109">**圖 5-1**.</span><span class="sxs-lookup"><span data-stu-id="3ba4a-109">**Figure 5-1**.</span></span> <span data-ttu-id="3ba4a-110">使用 Microsoft 工具的 Docker 應用程式 DevOps 外部迴圈工作流程</span><span class="sxs-lookup"><span data-stu-id="3ba4a-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="3ba4a-111">現在，讓我們更詳細地探討每個步驟。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="3ba4a-112">步驟1：內部迴圈開發工作流程</span><span class="sxs-lookup"><span data-stu-id="3ba4a-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="3ba4a-113">此步驟會在第 4 章中詳細說明，但概括而言，這是外部迴圈開始的位置，此時開發人員會將程式碼推送到原始檔控制管理系統 (例如 Git) 以起始 CI 管線動作。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="3ba4a-114">步驟2：使用 Azure DevOps Services 和 Git 的原始程式碼控制整合和管理</span><span class="sxs-lookup"><span data-stu-id="3ba4a-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="3ba4a-115">在此步驟中，您需要有版本控制系統，才能收集來自小組中不同開發人員的所有程式碼合併版本。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="3ba4a-116">即使大多數開發人員對於原始程式碼控制 (SCC) 和原始程式碼管理似乎很熟悉，但在 DevOps 生命週期中建立 Docker 應用程式時，請務必強調您不得從開發人員電腦將具有應用程式的 Docker 映像直接提交給全域 Docker 登錄 (例如 Azure Container Registry 或 Docker Hub)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="3ba4a-117">相反地，若要將 Docker 映像發行並部署到生產環境，則只能在根據原始程式碼存放庫 (例如 Git) 整合到全域組建或 CI 管線的原始程式碼上建立這些映像。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="3ba4a-118">開發人員所產生的本機映像，只能供他們用來在自己的電腦內進行測試。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="3ba4a-119">這就是為什麼必須從 SCC 程式碼啟用 DevOps 管線。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="3ba4a-120">Azure DevOps Services 和 Team Foundation Server 支援 Git 和 Team Foundation 版本控制。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="3ba4a-121">您可以在兩者之間進行選擇，並用於端對端 Microsoft 體驗。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="3ba4a-122">不過，您也可以在外部存放庫 (例如 GitHub、內部部署 Git 存放庫或 Subversion) 中管理您的程式碼，且仍然能夠與其連線，並取得程式碼作為 DevOps CI 管線的起點。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-122">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="3ba4a-123">步驟3：使用 Azure DevOps Services 和 Docker 建立、CI、整合和測試</span><span class="sxs-lookup"><span data-stu-id="3ba4a-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="3ba4a-124">CI 已脫穎而出成為現代軟體測試和傳遞的標準。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="3ba4a-125">Docker 解決方案會在開發小組與作業小組之間維持清楚的關注點分離。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="3ba4a-126">Docker 映像的不變性確保在已開發、已透過 CI 測試並在生產環境中執行的項目之間可重複部署。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="3ba4a-127">跨開發人員膝上型電腦與測試基礎結構部署的 Docker 引擎，可讓容器移植到不同的環境。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="3ba4a-128">此時，在您讓版本控制系統提交正確的程式碼之後，您需要「組建服務」才能選擇程式碼並執行全域建置和測試。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="3ba4a-129">此步驟的內部工作流程 (CI、建置、測試) 與 CI 管線的建構相關，其中包含您的程式碼存放庫 (Git 等)、您的組建伺服器 (Azure DevOps Services)、Docker 引擎和 Docker 登錄。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="3ba4a-130">您可以使用 Azure DevOps Services 作為基礎，來建置您的應用程式並設定 CI 管線，以及將組建「成品」發佈到「成品存放庫」，其將在下一個步驟中進行說明。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="3ba4a-131">使用 Docker 進行部署時，所要部署的「最終成品」是 Docker 映像，其中內嵌您的應用程式或服務。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="3ba4a-132">這些映像會推送或發佈到「Docker 登錄」(例如您可以在 Azure Container Registry 中擁有的私人存放庫，或 Docker Hub Registry 之類的公用存放庫，後者通常會用於官方基底映像)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="3ba4a-133">以下是基本概念： CI 管線將會藉由認可至 SCC 存放庫（例如 Git）來啟動。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="3ba4a-134">認可會使 Azure DevOps Services 在 Docker 容器中執行組建作業，並在該作業成功完成時，將 Docker 映像推送到 Docker 登錄，如圖 5-2 示。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="3ba4a-135">外部迴圈的第一個部分牽涉到步驟1到3，從程式碼、執行、debug 和 validate，然後再到組建和測試 CI 步驟為止的程式碼存放庫。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![此圖顯示 CI 工作流程中涉及的三個步驟。](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="3ba4a-137">**圖 5-2**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-137">**Figure 5-2**.</span></span> <span data-ttu-id="3ba4a-138">CI 中的相關步驟</span><span class="sxs-lookup"><span data-stu-id="3ba4a-138">The steps involved in CI</span></span>

<span data-ttu-id="3ba4a-139">以下是使用 Docker 和 Azure DevOps Services 的基本 CI 工作流程步驟：</span><span class="sxs-lookup"><span data-stu-id="3ba4a-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="3ba4a-140">開發人員將認可推送到 SCC 存放庫 (Git/Azure DevOps Services、GitHub 等)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="3ba4a-141">如果您使用 Azure DevOps Services 或 Git，則會內建 CI，這表示會與在 Azure DevOps Services 中選取核取方塊一樣簡單。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="3ba4a-142">如果您使用外部 SCC (例如 GitHub)，則 `webhook` 會通知 Azure DevOps Services 更新或推送到 Git/GitHub。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="3ba4a-143">Azure DevOps Services 提取 SCC 存放庫，包括描述映像的 Dockerfile，以及應用程式和測試程式碼。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="3ba4a-144">Azure DevOps Services 建置 Docker 映像並使用組建編號來標記它。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="3ba4a-145">Azure DevOps Services 具現化已佈建 Docker 主機中的 Docker 容器，並執行適當的測試。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="3ba4a-146">如果測試成功，映像會先重新標記為有意義的名稱，讓您知道這是「經過驗證的組建」(例如 "/1.0.0" 或任何其他標籤)，然後向上推送到您的 Docker 登錄 (Docker Hub、Azure Container Registry、DTR 等)</span><span class="sxs-lookup"><span data-stu-id="3ba4a-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="3ba4a-147">使用 Azure DevOps Services 和 Azure DevOps Services 的 Docker 延伸模組來實作 CI 管線</span><span class="sxs-lookup"><span data-stu-id="3ba4a-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="3ba4a-148">Visual Studio Azure DevOps Services 包含組建與發行範本，您可以在 CI/CD 管線中用來建置 Docker 映像，將 Docker 映像推送到已驗證的 Docker 登錄、執行 Docker 映像，或執行 Docker CLI 所提供的其他作業。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="3ba4a-149">它也會新增 Docker Compose 工作，讓您用來建置、推送及執行多容器 Docker 應用程式，或執行 Docker Compose CLI 所提供的其他作業，如圖 5-3 所示。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Azure DevOps 中 Docker CI 管線的螢幕擷取畫面。](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="3ba4a-151">**圖 5-3**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-151">**Figure 5-3**.</span></span> <span data-ttu-id="3ba4a-152">Azure DevOps Services 中的 Docker CI 管線，包括組建與發行範本以及相關聯的工作。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="3ba4a-153">您可以使用這些範本和工作，來建構要在 Azure Service Fabric、Azure Kubernetes Service 和類似供應項目中建置/測試及部署的 CI/CD 成品。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="3ba4a-154">有了這些 Visual Studio Team Services 工作、Linux-Docker 主機/VM 佈建在 Azure 中的組建，以及您慣用的 Docker 登錄 (Azure Container Registry、Docker Hub、私人 Docker DTR 或任何其他 Docker 登錄)，您就能夠以非常一致的方式來組合 Docker CI 管線。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="3ba4a-155">***需求：***</span><span class="sxs-lookup"><span data-stu-id="3ba4a-155">***Requirements:***</span></span>

- <span data-ttu-id="3ba4a-156">Azure DevOps Services，或是 Team Foundation Server 2015 Update 3 或更新版本 (適用於內部部署安裝)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="3ba4a-157">具有 Docker 二進位檔的 Azure DevOps Services 代理程式。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="3ba4a-158">建立其中一個代理程式的一個簡單方法就是使用 Docker 來執行以 Azure DevOps Services 代理程式 Docker 映像為基礎的容器。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> [!INFORMATION]<span data-ttu-id="3ba4a-159"> 若要深入了解如何組合Azure DevOps Services Docker CI 管線並檢視逐步解說，請瀏覽下列網站：</span><span class="sxs-lookup"><span data-stu-id="3ba4a-159"> To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="3ba4a-160">以 Docker 容器執行 Visual Studio Team Services (現在為 Azure DevOps Services) 代理程式：</span><span class="sxs-lookup"><span data-stu-id="3ba4a-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="3ba4a-161">使用 Azure DevOps Services 建置 .NET Core Linux Docker 映像：</span><span class="sxs-lookup"><span data-stu-id="3ba4a-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="3ba4a-162">透過 Docker 支援建置 Linux 型 Visual Studio Team Service 組建電腦：</span><span class="sxs-lookup"><span data-stu-id="3ba4a-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="3ba4a-163">整合、測試及驗證多容器 Docker 應用程式</span><span class="sxs-lookup"><span data-stu-id="3ba4a-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="3ba4a-164">一般而言，大多數 Docker 應用程式是由多個容器而不是單一容器所組成。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="3ba4a-165">一個良好的範例是微服務導向應用程式，其中每個微服務會有一個容器。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="3ba4a-166">但即使沒有嚴格遵循微服務方法模式，您的 Docker 應用程式還是有可能由多個容器或服務所組成。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="3ba4a-167">因此，在 CI 管線中建置應用程式容器之後，您還必須部署、整合及測試整體應用程式，以及其在整合 Docker 主機內或甚至在容器散發目標測試叢集中的所有容器。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="3ba4a-168">如果您使用單一主機，您可以使用 Docker 命令 (例如 docker-compose) 來建置及部署相關容器，以測試及驗證單一 VM 中的 Docker 環境。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="3ba4a-169">但如果您使用協調器叢集 (例如 DC/OS、Kubernetes 或 Docker Swarm)，則需要根據您所選取的叢集/排程器，透過不同機制或協調器來部署您的容器。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="3ba4a-170">以下是您可以針對 Docker 容器執行的幾種測試類型：</span><span class="sxs-lookup"><span data-stu-id="3ba4a-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="3ba4a-171">Docker 容器的單元測試</span><span class="sxs-lookup"><span data-stu-id="3ba4a-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="3ba4a-172">相互關聯應用程式或微服務的測試群組</span><span class="sxs-lookup"><span data-stu-id="3ba4a-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="3ba4a-173">生產環境和 "Canary" 發行中的測試</span><span class="sxs-lookup"><span data-stu-id="3ba4a-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="3ba4a-174">重點是當執行整合與功能測試時，您必須從容器外部執行這些測試。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="3ba4a-175">測試不會包含在您要部署的容器中或在其中執行，因為容器是以靜態映像為基礎，應該與您要部署到生產環境的映像完全相同。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="3ba4a-176">測試更進階的案例時，例如包括數個叢集 (測試叢集、預備叢集和生產叢集)，一個實用的選項是將映像發佈到登錄，以便可在各種叢集中測試。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="3ba4a-177">將自訂應用程式 Docker 映像推送到全域 Docker 登錄</span><span class="sxs-lookup"><span data-stu-id="3ba4a-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="3ba4a-178">測試和驗證 Docker 映像之後，您會想要標記映像並將其發佈到您的 Docker 登錄。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="3ba4a-179">Docker 登錄是 Docker 應用程式生命週期中很重要的一部分，因為這是您儲存自訂測試 (也稱為「經過驗證的映像」) 以部署到 QA 和生產環境的中央位置。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="3ba4a-180">與應用程式程式碼儲存在 SCC 存放庫 (Git 等) 的方式相似之處在於您的「信任來源」，Docker 登錄是您將二進位應用程式或位元部署到 QA 或生產環境的「信任來源」。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="3ba4a-181">一般而言，您可能想要有存放自訂映像的私人存放庫，可以存放在 Azure Container Registry 或內部部署登錄 (例如 Docker Trusted Registry) 的私人存放庫中，也可以存放在限制存取的公用雲端登錄中 (例如 Docker Hub)；但在後者的情況下，如果您的程式碼不是開放原始碼，您必須信任廠商的安全性。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="3ba4a-182">無論如何，所使用的方法都很類似且會採用 `docker push` 命令，如圖 5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![此圖顯示如何將自訂映射推送至容器登錄。](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="3ba4a-184">**圖 5-4**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-184">**Figure 5-4**.</span></span> <span data-ttu-id="3ba4a-185">將自訂映像發佈到 Docker 登錄</span><span class="sxs-lookup"><span data-stu-id="3ba4a-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="3ba4a-186">在步驟 3 中，針對建置整合與測試 (CI)，您可能會將產生的 docker 映像發佈到私人或公用登錄。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="3ba4a-187">Azure Container Registry、Amazon Web Services Container Registry、Google Container Registry、Quay Registry 等雲端廠商提供多種 Docker 登錄服務。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="3ba4a-188">使用 Docker 工作，您可以將 `docker-compose.yml` 檔案所定義並具有多個標記的一組服務映像，推送到已驗證的 Docker 登錄 (例如 Azure Container Registry)，如圖 5-5 所示。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![螢幕擷取畫面：顯示將映射發佈至登錄的步驟。](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="3ba4a-190">**圖 5-5**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-190">**Figure 5-5**.</span></span> <span data-ttu-id="3ba4a-191">使用 Azure DevOps Services 將自訂映像發佈到 Docker 登錄</span><span class="sxs-lookup"><span data-stu-id="3ba4a-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> [!INFORMATION]<span data-ttu-id="3ba4a-192"> 如需 Azure Container Registry 的詳細資訊，請參閱 <https://aka.ms/azurecontainerregistry>。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-192"> For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="3ba4a-193">步驟4： CD、部署</span><span class="sxs-lookup"><span data-stu-id="3ba4a-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="3ba4a-194">Docker 映像的不變性確保可重複部署已開發、已透過 CI 測試並在生產環境中執行的項目。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="3ba4a-195">當您在 Docker 登錄 (私人或公用) 中發佈應用程式 Docker 映像之後，您可以使用 Azure DevOps Services 管線工作或 Azure DevOps Services Release Management，從您的 CD 管線將這些映像部署到您可能擁有的數個環境 (生產環境、QA、預備環境等)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="3ba4a-196">不過，此時取決於您要部署的 Docker 應用程式類型。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="3ba4a-197">部署簡單的應用程式 (從撰寫和部署觀點來看)，例如由一些容器或服務所組成並部署到一些伺服器或 VM 的整合型應用程式，會不同於部署較複雜的應用程式，例如具有超大規模功能的微服務導向應用程式。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="3ba4a-198">下列各節將說明這兩個案例。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="3ba4a-199">將組合的 Docker 應用程式部署到多個 Docker 環境</span><span class="sxs-lookup"><span data-stu-id="3ba4a-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="3ba4a-200">首先討論較不複雜的案例：部署到單一環境或多個環境 (QA、預備環境和生產環境) 中的簡單 Docker 主機 (VM 或伺服器)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="3ba4a-201">在此案例中，CD 管線可以在內部使用 docker-compose (從您的 Azure DevOps Services 部署工作)，來部署 Docker 應用程式及一組相關容器或服務，如圖 5-6 所示。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![此圖顯示部署至三個環境的 CD 部署步驟。](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="3ba4a-203">**圖 5-6**.</span><span class="sxs-lookup"><span data-stu-id="3ba4a-203">**Figure 5-6**.</span></span> <span data-ttu-id="3ba4a-204">將應用程式容器部署到簡單的 Docker 主機環境登錄</span><span class="sxs-lookup"><span data-stu-id="3ba4a-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="3ba4a-205">圖 5-7 顯示您如何按一下 [新增工作] 對話方塊中的 [Docker Compose]，透過 Azure DevOps Services 將您的組建 CI 連線到 QA/測試環境。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="3ba4a-206">不過，部署到預備環境或生產環境時，您通常會使用 Release Management 功能來處理多個環境 (例如 QA、預備環境和生產環境)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="3ba4a-207">如果您要部署到單一 Docker 主機，它會使用 Azure DevOps Services "Docker Compose" 工作 (這會在幕後叫用 `docker-compose up` 命令)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="3ba4a-208">如果您要部署到 Azure Kubernetes Service (AKS)，它會使用 Docker 部署工作，如下一節中所述。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![顯示 Docker Compose 工作之 [新增工作] 對話方塊的螢幕擷取畫面。](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="3ba4a-210">**圖 5-7**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-210">**Figure 5-7**.</span></span> <span data-ttu-id="3ba4a-211">在 Azure DevOps Services 管線中新增 Docker Compose 工作</span><span class="sxs-lookup"><span data-stu-id="3ba4a-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="3ba4a-212">當您在 Azure DevOps Services 中建立發行時，它會接受一組輸入成品。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="3ba4a-213">這些成品在所有不同環境的發行存留期中會保持不變。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="3ba4a-214">當您引進容器時，輸入成品會識別登錄中要部署的映像。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="3ba4a-215">根據這些映像的識別方式，不保證會在發行期間保持相同的輸送量，最明顯的例子是當您從 `docker-compose` 檔案參考 `myimage:latest` 時。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="3ba4a-216">Azure DevOps Services 範本可讓您產生包含特定登錄映像摘要的組建成品，保證可唯一識別相同的映像二進位檔。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="3ba4a-217">這些是您真正想要用作發行輸入的檔案。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="3ba4a-218">使用 Azure DevOps Services Release Management 管理對 Docker 環境的發行</span><span class="sxs-lookup"><span data-stu-id="3ba4a-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="3ba4a-219">透過 Azure DevOps Services 範本，您可以建置新的映像、將其發佈到 Docker 登錄、在 Linux 或 Windows 主機上執行，以及使用 `docker-compose` 等命令將多個容器部署為整個應用程式，全部都是透過適用於多個環境的 Azure DevOps Services Release Management 功能，如圖 5-8 所示。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![顯示 Docker 撰寫版本設定的螢幕擷取畫面。](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="3ba4a-221">**圖 5-8**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-221">**Figure 5-8**.</span></span> <span data-ttu-id="3ba4a-222">從 Azure DevOps Services Release Management 設定 Azure DevOps Services Docker Compose 工作</span><span class="sxs-lookup"><span data-stu-id="3ba4a-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="3ba4a-223">不過請記住，在圖 5-6 中顯示並在圖 5-8 中實作的案例是一個簡單案例 (部署到單一 Docker 主機和 VM，每個映像會有一個容器或執行個體)，可能僅適用於開發或測試案例。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="3ba4a-224">在大多數企業生產案例中，您會想要在多個節點、伺服器和 VM 之間進行負載平衡，以取得高可用性 (HA) 和便於管理的延展性；此外，您也想要有「智慧型容錯移轉」，以便在伺服器或節點失敗時，可將其服務和容器移至另一個主機伺服器或 VM。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="3ba4a-225">在此情況下，您需要更進階的技術，例如容器叢集、協調器和排程器。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="3ba4a-226">因此，部署到這些叢集的方式是藉由處理下一節中所述的進階案例。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="3ba4a-227">將 Docker 應用程式部署到 Docker 叢集</span><span class="sxs-lookup"><span data-stu-id="3ba4a-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="3ba4a-228">分散式應用程式的本質需要同時散發計算資源。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="3ba4a-229">若要取得生產級別功能，您必須擁有可根據集區資源提供高延展性和高可用性的叢集功能。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="3ba4a-230">您可以從 CLI 工具或 Web UI 手動將容器部署到這些叢集，但您應該將這類手動工作保留給位置部署測試或管理目的使用，例如向外延展或監視。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="3ba4a-231">從 CD 觀點來看，特別是 Azure DevOps Services，您可以從 Azure DevOps Services Release Management 環境執行特別建立的部署工作，這會將容器化應用程式部署到 Container Service 中的分散式叢集，如圖 5-9 所示。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![此圖顯示部署至協調器的 CD 部署步驟。](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="3ba4a-233">**圖 5-9**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-233">**Figure 5-9**.</span></span> <span data-ttu-id="3ba4a-234">將分散式應用程式部署到 Container Service</span><span class="sxs-lookup"><span data-stu-id="3ba4a-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="3ba4a-235">一開始，當部署到特定叢集或協調器時，傳統上會使用每個協調器的特定部署指令碼和機制 (亦即，Kubernetes 與 Service Fabric 會有不同的部署機制)，而不是更簡單且便於使用的 `docker-compose` 工具 (以 `docker-compose.yml` 定義檔為基礎)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="3ba4a-236">不過，幸好有 Azure DevOps Services Docker 部署工作 (如圖 5-10 所示)，您現在也可以直接使用熟悉的 `docker-compose.yml` 檔案部署到支援的協調器，因為此工具會為您執行該「轉譯」(從您的 `docker-compose.yml` 檔案轉譯為協調器所需的格式)。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that “translation” for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![顯示 [部署至 Kubernetes] 工作的螢幕擷取畫面。](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="3ba4a-238">**圖 5-10**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-238">**Figure 5-10**.</span></span> <span data-ttu-id="3ba4a-239">將 [部署至 Kubernetes] 工作新增至您的環境</span><span class="sxs-lookup"><span data-stu-id="3ba4a-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="3ba4a-240">圖 5-11 示範如何使用可設定的區段來編輯 [部署至 Kubernetes] 工作。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="3ba4a-241">此工作會擷取可供使用的自訂 Docker 映像，以部署為叢集中的容器。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![顯示 [部署至 Kubernetes] 工作設定的螢幕擷取畫面。](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="3ba4a-243">**圖 5-11**。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-243">**Figure 5-11**.</span></span> <span data-ttu-id="3ba4a-244">部署到 ACS DC/OS 的 Docker 部署工作定義</span><span class="sxs-lookup"><span data-stu-id="3ba4a-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> [!INFORMATION]<span data-ttu-id="3ba4a-245"> 若要深入了解使用 Azure DevOps Services 和 Docker 的 CD 管線，請瀏覽 <https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="3ba4a-245"> To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="3ba4a-246">步驟5：執行和管理</span><span class="sxs-lookup"><span data-stu-id="3ba4a-246">Step 5: Run and manage</span></span>

<span data-ttu-id="3ba4a-247">由於在企業生產層級執行和管理應用程式本身就是個重要的主題，且由於在該層級執行之作業和人員類型 (IT 作業) 及此領域的廣大範圍，因此下一章將全部用來說明該主題。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="3ba4a-248">步驟6：監視和診斷</span><span class="sxs-lookup"><span data-stu-id="3ba4a-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="3ba4a-249">本主題也會在下一章中討論，這是 IT 人員在生產系統中執行工作的一部分；不過，值得注意的是，此步驟中取得的見解必須回饋給開發小組，以便持續改善應用程式。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="3ba4a-250">從該觀點來看，這也是 DevOps 的一部分，但通常會由 IT 人員來執行工作和作業。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="3ba4a-251">只有在監視和診斷 100% 位於 DevOps 領域內時，開發小組才會對測試或搶鮮版 (Beta) 環境執行監視程序和分析。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="3ba4a-252">這會藉由執行負載測試，或是藉由監視搶鮮版 (Beta) 或 QA 環境來完成，其中搶鮮版 (Beta) 測試人員會嘗試新版本。</span><span class="sxs-lookup"><span data-stu-id="3ba4a-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="3ba4a-253">[上一頁](index.md)
>[下一頁](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="3ba4a-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
