---
title: 適用於平行程式設計的資料結構
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- data structures, multi-threading
ms.assetid: bdc82f2f-4754-45a1-a81e-fe2e9c30cef9
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: b346da9174d77fbc6a861a8b12f2cc5035b6c291
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54517613"
---
# <a name="data-structures-for-parallel-programming"></a><span data-ttu-id="9f476-102">適用於平行程式設計的資料結構</span><span class="sxs-lookup"><span data-stu-id="9f476-102">Data Structures for Parallel Programming</span></span>
<span data-ttu-id="9f476-103">.NET Framework 4 版導入了數個適用於平行程式設計的新類型，包括一系列並行集合類別、輕量型同步處理原始物件，以及適用於延遲初始設定的類型。</span><span class="sxs-lookup"><span data-stu-id="9f476-103">The .NET Framework version 4 introduces several new types that are useful in parallel programming, including a set of concurrent collection classes, lightweight synchronization primitives, and types for lazy initialization.</span></span> <span data-ttu-id="9f476-104">您可以搭配任何多執行緒應用程式程式碼使用這些類型，其中包括工作平行程式庫和 PLINQ。</span><span class="sxs-lookup"><span data-stu-id="9f476-104">You can use these types with any multithreaded application code, including the Task Parallel Library and PLINQ.</span></span>  
  
## <a name="concurrent-collection-classes"></a><span data-ttu-id="9f476-105">並行集合類別</span><span class="sxs-lookup"><span data-stu-id="9f476-105">Concurrent Collection Classes</span></span>  
 <span data-ttu-id="9f476-106"><xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空間中的集合類別能提供安全執行緒新增和移除作業，以盡量避免鎖定情況，並在需要鎖定時使用細部鎖定。</span><span class="sxs-lookup"><span data-stu-id="9f476-106">The collection classes in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace provide thread-safe add and remove operations that avoid locks wherever possible and use fine-grained locking where locks are necessary.</span></span> <span data-ttu-id="9f476-107">並行集合類別與在 .NET Framework 1.0 和 2.0 版中導入的集合不同，它並不會要求使用者程式碼在存取項目時採用任何鎖定。</span><span class="sxs-lookup"><span data-stu-id="9f476-107">Unlike collections that were introduced in the .NET Framework versions 1.0 and 2.0, a concurrent collection class does not require user code to take any locks when it accesses items.</span></span> <span data-ttu-id="9f476-108">並行集合類別可在多執行緒針對集合新增和移除項目的案例中，大幅提升 <xref:System.Collections.ArrayList?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (搭配使用者實作的鎖定) 等類型的效能。</span><span class="sxs-lookup"><span data-stu-id="9f476-108">The concurrent collection classes can significantly improve performance over types such as <xref:System.Collections.ArrayList?displayProperty=nameWithType> and <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> (with user-implemented locking) in scenarios where multiple threads add and remove items from a collection.</span></span>  
  
 <span data-ttu-id="9f476-109">下表列出新的並行集合類別：</span><span class="sxs-lookup"><span data-stu-id="9f476-109">The following table lists the new concurrent collection classes:</span></span>  
  
|<span data-ttu-id="9f476-110">類型</span><span class="sxs-lookup"><span data-stu-id="9f476-110">Type</span></span>|<span data-ttu-id="9f476-111">說明</span><span class="sxs-lookup"><span data-stu-id="9f476-111">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType>|<span data-ttu-id="9f476-112">提供安全執行緒集合適用的封鎖和界限容量，這個集合會實作 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9f476-112">Provides blocking and bounding capabilities for thread-safe collections that implement <xref:System.Collections.Concurrent.IProducerConsumerCollection%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9f476-113">在沒有可用插槽或集合已滿的情況下封鎖產生者執行緒。</span><span class="sxs-lookup"><span data-stu-id="9f476-113">Producer threads block if no slots are available or if the collection is full.</span></span> <span data-ttu-id="9f476-114">在集合為空的情況下封鎖取用者執行緒。</span><span class="sxs-lookup"><span data-stu-id="9f476-114">Consumer threads block if the collection is empty.</span></span> <span data-ttu-id="9f476-115">此類型也支援由取用者和產生者所進行的非封鎖存取。</span><span class="sxs-lookup"><span data-stu-id="9f476-115">This type also supports non-blocking access by consumers and producers.</span></span> <span data-ttu-id="9f476-116"><xref:System.Collections.Concurrent.BlockingCollection%601> 可以作為基底類別或備份存放區使用，以針對任何支援 <xref:System.Collections.Generic.IEnumerable%601>的集合類別提供封鎖和繫結。</span><span class="sxs-lookup"><span data-stu-id="9f476-116"><xref:System.Collections.Concurrent.BlockingCollection%601> can be used as a base class or backing store to provide blocking and bounding for any collection class that supports <xref:System.Collections.Generic.IEnumerable%601>.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType>|<span data-ttu-id="9f476-117">能提供可調整之新增和取得作業的安全執行緒包實作。</span><span class="sxs-lookup"><span data-stu-id="9f476-117">A thread-safe bag implementation that provides scalable add and get operations.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType>|<span data-ttu-id="9f476-118">並行且可調整的字典類型。</span><span class="sxs-lookup"><span data-stu-id="9f476-118">A concurrent and scalable dictionary type.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType>|<span data-ttu-id="9f476-119">並行且可調整的 FIFO 佇列。</span><span class="sxs-lookup"><span data-stu-id="9f476-119">A concurrent and scalable FIFO queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType>|<span data-ttu-id="9f476-120">並行且可調整的 LIFO 堆疊。</span><span class="sxs-lookup"><span data-stu-id="9f476-120">A concurrent and scalable LIFO stack.</span></span>|  
  
 <span data-ttu-id="9f476-121">如需詳細資訊，請參閱[安全執行緒集合](../../../docs/standard/collections/thread-safe/index.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-121">For more information, see [Thread-Safe Collections](../../../docs/standard/collections/thread-safe/index.md).</span></span>  
  
## <a name="synchronization-primitives"></a><span data-ttu-id="9f476-122">同步處理原始物件</span><span class="sxs-lookup"><span data-stu-id="9f476-122">Synchronization Primitives</span></span>  
 <span data-ttu-id="9f476-123"><xref:System.Threading?displayProperty=nameWithType> 中的新同步處理原始物件能透過避免舊版多執行緒程式碼中耗費資源的鎖定機制，提供細微的並行及更快的效能。</span><span class="sxs-lookup"><span data-stu-id="9f476-123">The new synchronization primitives in the <xref:System.Threading?displayProperty=nameWithType> namespace enable fine-grained concurrency and faster performance by avoiding expensive locking mechanisms found in legacy multithreading code.</span></span> <span data-ttu-id="9f476-124">某些新的類型 (例如 <xref:System.Threading.Barrier?displayProperty=nameWithType> 和 <xref:System.Threading.CountdownEvent?displayProperty=nameWithType>) 在較舊版本的 .NET Framework 中並沒有相對應的項目。</span><span class="sxs-lookup"><span data-stu-id="9f476-124">Some of the new types, such as <xref:System.Threading.Barrier?displayProperty=nameWithType> and <xref:System.Threading.CountdownEvent?displayProperty=nameWithType> have no counterparts in earlier releases of the .NET Framework.</span></span>  
  
 <span data-ttu-id="9f476-125">下表列出新的同步處理類型：</span><span class="sxs-lookup"><span data-stu-id="9f476-125">The following table lists the new synchronization types:</span></span>  
  
|<span data-ttu-id="9f476-126">類型</span><span class="sxs-lookup"><span data-stu-id="9f476-126">Type</span></span>|<span data-ttu-id="9f476-127">說明</span><span class="sxs-lookup"><span data-stu-id="9f476-127">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Threading.Barrier?displayProperty=nameWithType>|<span data-ttu-id="9f476-128">透過提供一個點，可讓每個工作發出其抵達的訊號並在部分或所有工作皆已抵達之前持續封鎖，來使多執行緒能以平行方式處理演算法。</span><span class="sxs-lookup"><span data-stu-id="9f476-128">Enables multiple threads to work on an algorithm in parallel by providing a point at which each task can signal its arrival and then block until some or all tasks have arrived.</span></span> <span data-ttu-id="9f476-129">如需詳細資訊，請參閱[屏障](../../../docs/standard/threading/barrier.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-129">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>|  
|<xref:System.Threading.CountdownEvent?displayProperty=nameWithType>|<span data-ttu-id="9f476-130">透過提供簡單的會合機制來簡化分岔和連結案例。</span><span class="sxs-lookup"><span data-stu-id="9f476-130">Simplifies fork and join scenarios by providing an easy rendezvous mechanism.</span></span> <span data-ttu-id="9f476-131">如需詳細資訊，請參閱 [CountdownEvent](../../../docs/standard/threading/countdownevent.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-131">For more information, see [CountdownEvent](../../../docs/standard/threading/countdownevent.md).</span></span>|  
|<xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType>|<span data-ttu-id="9f476-132">與 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 類似的同步處理原始物件。</span><span class="sxs-lookup"><span data-stu-id="9f476-132">A synchronization primitive similar to <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9f476-133"><xref:System.Threading.ManualResetEventSlim> 雖為輕量型，但只能用於內部處理序通訊。</span><span class="sxs-lookup"><span data-stu-id="9f476-133"><xref:System.Threading.ManualResetEventSlim> is lighter-weight but can only be used for intra-process communication.</span></span> <span data-ttu-id="9f476-134">如需詳細資訊，請參閱 [ManualResetEvent 和 ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-134">For more information, see [ManualResetEvent and ManualResetEventSlim](../../../docs/standard/threading/manualresetevent-and-manualreseteventslim.md).</span></span>|  
|<xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType>|<span data-ttu-id="9f476-135">能限制可並行存取資源或資源集區之執行緒數目的同步處理原始物件。</span><span class="sxs-lookup"><span data-stu-id="9f476-135">A synchronization primitive that limits the number of threads that can concurrently access a resource or a pool of resources.</span></span> <span data-ttu-id="9f476-136">如需詳細資訊，請參閱 [Semaphore 和 SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-136">For more information, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>|  
|<xref:System.Threading.SpinLock?displayProperty=nameWithType>|<span data-ttu-id="9f476-137">能使嘗試取得鎖定的執行緒在產生其配量之前，於迴圈中等候 (或*旋轉*) 一段時間的互斥鎖定原始物件。</span><span class="sxs-lookup"><span data-stu-id="9f476-137">A mutual exclusion lock primitive that causes the thread that is trying to acquire the lock to wait in a loop, or *spin*, for a period of time before yielding its quantum.</span></span> <span data-ttu-id="9f476-138">在預期等候鎖定時間較短的案例中，<xref:System.Threading.SpinLock> 能提供比其他鎖定形式更佳的效能。</span><span class="sxs-lookup"><span data-stu-id="9f476-138">In scenarios where the wait for the lock is expected to be short, <xref:System.Threading.SpinLock> offers better performance than other forms of locking.</span></span> <span data-ttu-id="9f476-139">如需詳細資訊，請參閱 [SpinLock](../../../docs/standard/threading/spinlock.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-139">For more information, see [SpinLock](../../../docs/standard/threading/spinlock.md).</span></span>|  
|<xref:System.Threading.SpinWait?displayProperty=nameWithType>|<span data-ttu-id="9f476-140">會旋轉一段特定的時間，並於最終超過旋轉計數時將執行緒置於等候狀態的小型輕量型類型。</span><span class="sxs-lookup"><span data-stu-id="9f476-140">A small, lightweight type that will spin for a specified time and eventually put the thread into a wait state if the spin count is exceeded.</span></span>  <span data-ttu-id="9f476-141">如需詳細資訊，請參閱 [SpinWait](../../../docs/standard/threading/spinwait.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-141">For more information, see [SpinWait](../../../docs/standard/threading/spinwait.md).</span></span>|  
  
 <span data-ttu-id="9f476-142">如需詳細資訊，請參閱:</span><span class="sxs-lookup"><span data-stu-id="9f476-142">For more information, see:</span></span>  
  
-   [<span data-ttu-id="9f476-143">如何：使用 SpinLock 進行低階同步處理</span><span class="sxs-lookup"><span data-stu-id="9f476-143">How to: Use SpinLock for Low-Level Synchronization</span></span>](../../../docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)  
  
-   <span data-ttu-id="9f476-144">[如何：使用屏障同步處理並行作業](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-144">[How to: Synchronize Concurrent Operations with a Barrier](../../../docs/standard/threading/how-to-synchronize-concurrent-operations-with-a-barrier.md).</span></span>  
  
## <a name="lazy-initialization-classes"></a><span data-ttu-id="9f476-145">延遲初始設定類別</span><span class="sxs-lookup"><span data-stu-id="9f476-145">Lazy Initialization Classes</span></span>  
 <span data-ttu-id="9f476-146">使用延遲初始設定時，物件的記憶體只會在有需要時才會配置。</span><span class="sxs-lookup"><span data-stu-id="9f476-146">With lazy initialization, the memory for an object is not allocated until it is needed.</span></span> <span data-ttu-id="9f476-147">延遲初始設定可透過將物件配置平均分配於程式的存留期來提升效能。</span><span class="sxs-lookup"><span data-stu-id="9f476-147">Lazy initialization can improve performance by spreading object allocations evenly across the lifetime of a program.</span></span> <span data-ttu-id="9f476-148">您可以透過包裝類型 <xref:System.Lazy%601>，來針對任何自訂類型啟用延遲初始設定。</span><span class="sxs-lookup"><span data-stu-id="9f476-148">You can enable lazy initialization for any custom type by wrapping the type <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="9f476-149">下表列出延遲初始設定類型：</span><span class="sxs-lookup"><span data-stu-id="9f476-149">The following table lists the lazy initialization types:</span></span>  
  
|<span data-ttu-id="9f476-150">類型</span><span class="sxs-lookup"><span data-stu-id="9f476-150">Type</span></span>|<span data-ttu-id="9f476-151">說明</span><span class="sxs-lookup"><span data-stu-id="9f476-151">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601?displayProperty=nameWithType>|<span data-ttu-id="9f476-152">提供輕量型的安全執行緒延遲初始設定。</span><span class="sxs-lookup"><span data-stu-id="9f476-152">Provides lightweight, thread-safe lazy-initialization.</span></span>|  
|<xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType>|<span data-ttu-id="9f476-153">以針對每個執行緒的方式提供延遲初始化的值，其中每個執行緒都會延遲叫用初始化函式。</span><span class="sxs-lookup"><span data-stu-id="9f476-153">Provides a lazily-initialized value on a per-thread basis, with each thread lazily-invoking the initialization function.</span></span>|  
|<xref:System.Threading.LazyInitializer?displayProperty=nameWithType>|<span data-ttu-id="9f476-154">提供能避免需要指派專用延遲初始設定執行個體的靜態方法。</span><span class="sxs-lookup"><span data-stu-id="9f476-154">Provides static methods that avoid the need to allocate a dedicated, lazy-initialization instance.</span></span> <span data-ttu-id="9f476-155">反之，它們會使用參考以確保目標在被存取時已經初始化。</span><span class="sxs-lookup"><span data-stu-id="9f476-155">Instead, they use references to ensure targets have been initialized as they are accessed.</span></span>|  
  
 <span data-ttu-id="9f476-156">如需詳細資訊，請參閱[延遲初始化](../../../docs/framework/performance/lazy-initialization.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-156">For more information, see [Lazy Initialization](../../../docs/framework/performance/lazy-initialization.md).</span></span>  
  
## <a name="aggregate-exceptions"></a><span data-ttu-id="9f476-157">彙總例外狀況</span><span class="sxs-lookup"><span data-stu-id="9f476-157">Aggregate Exceptions</span></span>  
 <span data-ttu-id="9f476-158"><xref:System.AggregateException?displayProperty=nameWithType> 類型可以用來擷取在個別執行緒上並行擲出的多個例外狀況，並將它們以單一例外狀況的形式傳回聯結執行緒。</span><span class="sxs-lookup"><span data-stu-id="9f476-158">The <xref:System.AggregateException?displayProperty=nameWithType> type can be used to capture multiple exceptions that are thrown concurrently on separate threads, and return them to the joining thread as a single exception.</span></span> <span data-ttu-id="9f476-159"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> 類型，以及 PLINQ 都會針對此目的廣泛使用 <xref:System.AggregateException>。</span><span class="sxs-lookup"><span data-stu-id="9f476-159">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType> types and PLINQ use <xref:System.AggregateException> extensively for this purpose.</span></span> <span data-ttu-id="9f476-160">如需詳細資訊，請參閱[例外狀況處理](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)和[如何：處理 PLINQ 查詢中的例外狀況](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="9f476-160">For more information, see [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md) and [How to: Handle Exceptions in a PLINQ Query](../../../docs/standard/parallel-programming/how-to-handle-exceptions-in-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9f476-161">另請參閱</span><span class="sxs-lookup"><span data-stu-id="9f476-161">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- <xref:System.Threading?displayProperty=nameWithType>
- [<span data-ttu-id="9f476-162">平行程式設計</span><span class="sxs-lookup"><span data-stu-id="9f476-162">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
