---
title: 認識 PLINQ 中的加速
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 26128e5d707d3f331dc2b691f5a5f798bdf84c25
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/18/2019
ms.locfileid: "59322988"
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="af9aa-102">認識 PLINQ 中的加速</span><span class="sxs-lookup"><span data-stu-id="af9aa-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="af9aa-103">PLINQ 的主要目的是要藉由在多核心電腦上平行執行查詢委派，來加快 LINQ to Objects 查詢的執行速度。</span><span class="sxs-lookup"><span data-stu-id="af9aa-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="af9aa-104">當來源集合中每個元素的處理各自獨立，個別委派之間沒有涉及任何共用狀態時，PLINQ 能夠發揮最佳執行效能。</span><span class="sxs-lookup"><span data-stu-id="af9aa-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="af9aa-105">這類作業在 LINQ to Objects 和 PLINQ 中相當常見，通常稱為「令人愉快的平行」，因為它們很容易出借本身供多個執行緒上的排程使用。</span><span class="sxs-lookup"><span data-stu-id="af9aa-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="af9aa-106">不過，並非所有查詢都全部由令人愉快的平行作業所組成；在大多數情況下，查詢會涉及一些無法平行處理或是會拖慢平行執行速度的運算子。</span><span class="sxs-lookup"><span data-stu-id="af9aa-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="af9aa-107">而且，即使查詢是完全令人愉快的平行查詢，PLINQ 仍然必須分割資料來源並在執行緒上排定工作，通常還會在查詢完成時合併結果。</span><span class="sxs-lookup"><span data-stu-id="af9aa-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="af9aa-108">所有這些作業都會計入平行處理的計算成本中；這些添加平行處理的成本稱為「額外負荷」。</span><span class="sxs-lookup"><span data-stu-id="af9aa-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="af9aa-109">若要在 PLINQ 查詢中達到最佳效能，目標就是要將令人愉快的平行部分提升到最高，並將需要額外負荷的部分降到最低。</span><span class="sxs-lookup"><span data-stu-id="af9aa-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="af9aa-110">本文提供資訊來協助您撰寫儘可能發揮最高效率又仍然能產生正確結果的 PLINQ 查詢。</span><span class="sxs-lookup"><span data-stu-id="af9aa-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="af9aa-111">影響 PLINQ 查詢效能的因素</span><span class="sxs-lookup"><span data-stu-id="af9aa-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="af9aa-112">下列各節列出一些影響平行查詢效能的最重要因素。</span><span class="sxs-lookup"><span data-stu-id="af9aa-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="af9aa-113">這些是一般陳述，本身並不足以預測所有情況下的查詢效能。</span><span class="sxs-lookup"><span data-stu-id="af9aa-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="af9aa-114">如往常一般，請務必在電腦上使用一系列代表性設定和負載來測量特定查詢的實際效能。</span><span class="sxs-lookup"><span data-stu-id="af9aa-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1. <span data-ttu-id="af9aa-115">整體工作的計算成本。</span><span class="sxs-lookup"><span data-stu-id="af9aa-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="af9aa-116">若要達到加速的效果，PLINQ 查詢必須有足夠的令人愉快平行工作來抵銷額外負荷。</span><span class="sxs-lookup"><span data-stu-id="af9aa-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="af9aa-117">此工作可以用每個委派的計算成本乘以來源集合中的元素數目來表示。</span><span class="sxs-lookup"><span data-stu-id="af9aa-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="af9aa-118">假設某個作業可以平行處理，則其計算成本越高，加速的機會也越大。</span><span class="sxs-lookup"><span data-stu-id="af9aa-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="af9aa-119">例如，如果某個函式所需的執行時間為 1 毫秒，則循序查詢 1000 個元素將需要 1 秒的時間來執行該作業，但如果在四核心電腦上執行平行查詢，則可能只需要 250 毫秒。</span><span class="sxs-lookup"><span data-stu-id="af9aa-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="af9aa-120">這樣就會產生 750 毫秒的加速效果。</span><span class="sxs-lookup"><span data-stu-id="af9aa-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="af9aa-121">如果該函式針對每個元素需要 1 秒的執行時間，則加速效果會是 750 秒。</span><span class="sxs-lookup"><span data-stu-id="af9aa-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="af9aa-122">如果委派的成本相當高，則 PLINQ 可能只要利用來源集合中的一些項目，就可以提供明顯的加速效果。</span><span class="sxs-lookup"><span data-stu-id="af9aa-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="af9aa-123">相反地，含有瑣碎委派的小型來源集合通常不是 PLINQ 的理想適用對象。</span><span class="sxs-lookup"><span data-stu-id="af9aa-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="af9aa-124">在下列範例中，假設 queryA 的 Select 函式涉及很多工作，則 queryA 就可能是 PLINQ 的理想適用對象。</span><span class="sxs-lookup"><span data-stu-id="af9aa-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="af9aa-125">queryB 可能不是理想的適用對象，因為 Select 陳述式中並沒有足夠的工作，而平行處理的額外負荷將會抵銷大部分或全部的加速效果。</span><span class="sxs-lookup"><span data-stu-id="af9aa-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2. <span data-ttu-id="af9aa-126">系統上的邏輯核心數目 (平行處理程度)。</span><span class="sxs-lookup"><span data-stu-id="af9aa-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="af9aa-127">此點是上一節的明顯必然結果，令人愉快的平行查詢在有較多核心的電腦上執行速度較快，因為可以在更多並行執行緒之間分配工作。</span><span class="sxs-lookup"><span data-stu-id="af9aa-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="af9aa-128">整體加速效果的大小取決於整體查詢工作的可平行處理百分比。</span><span class="sxs-lookup"><span data-stu-id="af9aa-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="af9aa-129">不過，請不要認為所有查詢在八核心電腦上的執行速度會是四核心電腦的兩倍。</span><span class="sxs-lookup"><span data-stu-id="af9aa-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="af9aa-130">調整查詢以獲得最佳效能時，請務必在各種不同核心數的電腦上測量實際的結果。</span><span class="sxs-lookup"><span data-stu-id="af9aa-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="af9aa-131">此點與第 1 點相關：必須要有較大型的資料集，才能利用較多的計算資源。</span><span class="sxs-lookup"><span data-stu-id="af9aa-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3. <span data-ttu-id="af9aa-132">作業的數量和種類。</span><span class="sxs-lookup"><span data-stu-id="af9aa-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="af9aa-133">PLINQ 針對必須維持來源序列中元素順序的情況，提供 AsOrdered 運算子。</span><span class="sxs-lookup"><span data-stu-id="af9aa-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="af9aa-134">排序有相關的成本，但此成本通常不是太大。</span><span class="sxs-lookup"><span data-stu-id="af9aa-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="af9aa-135">GroupBy 和 Join 作業同樣也會造成額外負荷。</span><span class="sxs-lookup"><span data-stu-id="af9aa-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="af9aa-136">在允許以任何順序處理來源集合中的元素，並在一備妥這些元素就立即傳遞給下一個運算子的情況下，PLINQ 能夠發揮最佳執行效能。</span><span class="sxs-lookup"><span data-stu-id="af9aa-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="af9aa-137">如需詳細資訊，請參閱 [PLINQ 中的順序保留](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="af9aa-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4. <span data-ttu-id="af9aa-138">查詢執行的形式。</span><span class="sxs-lookup"><span data-stu-id="af9aa-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="af9aa-139">如果您藉由呼叫 ToArray 或 ToList 來儲存查詢的結果，就必須將來自所有平行執行緒的結果合併成單一資料結構。</span><span class="sxs-lookup"><span data-stu-id="af9aa-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="af9aa-140">這會涉及無法避免的計算成本。</span><span class="sxs-lookup"><span data-stu-id="af9aa-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="af9aa-141">同樣地，如果您藉由使用 foreach (在 Visual Basic 中為 For Each) 迴圈來逐一查看結果，就必須將來自背景工作執行緒的結果序列化至列舉值執行緒。</span><span class="sxs-lookup"><span data-stu-id="af9aa-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="af9aa-142">但如果您只是想要根據來自每個執行緒的結果執行某個動作，則可以使用 ForAll 方法在多個執行緒上執行此工作。</span><span class="sxs-lookup"><span data-stu-id="af9aa-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5. <span data-ttu-id="af9aa-143">合併作業的類型。</span><span class="sxs-lookup"><span data-stu-id="af9aa-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="af9aa-144">您可以將 PLINQ 設定成緩衝處理其輸出，然後在產生整個結果集後再以區塊方式產生它或全部一次產生，或是在產生結果時串流處理個別的結果。</span><span class="sxs-lookup"><span data-stu-id="af9aa-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="af9aa-145">前者的結果是縮短整體執行時間，後者的結果則是縮短產生元素之間的延遲時間。</span><span class="sxs-lookup"><span data-stu-id="af9aa-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="af9aa-146">雖然合併選項並不一定對整體查詢效能造成重大影響，但可影響察覺到的效能，因為它們可以控制使用者必須等待多久才能看到結果。</span><span class="sxs-lookup"><span data-stu-id="af9aa-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="af9aa-147">如需詳細資訊，請參閱 [PLINQ 中的合併選項](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="af9aa-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6. <span data-ttu-id="af9aa-148">資料分割的種類。</span><span class="sxs-lookup"><span data-stu-id="af9aa-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="af9aa-149">在某些情況下，在可編製索引之來源集合上執行的 PLINQ 查詢可能會導致工作負載不平衡。</span><span class="sxs-lookup"><span data-stu-id="af9aa-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="af9aa-150">當發生這種情況時，您或許能夠藉由建立自訂 Partitioner 來提升查詢效能。</span><span class="sxs-lookup"><span data-stu-id="af9aa-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="af9aa-151">如需詳細資訊，請參閱 [PLINQ 和 TPL 的自訂 Partitioner](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="af9aa-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="af9aa-152">當 PLINQ 選擇循序模式時</span><span class="sxs-lookup"><span data-stu-id="af9aa-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="af9aa-153">PLINQ 會一律嘗試至少以和查詢循序執行時一樣快的速度來執行查詢。</span><span class="sxs-lookup"><span data-stu-id="af9aa-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="af9aa-154">雖然 PLINQ 並不會考慮使用者委派的計算成本有多高，或是輸入來源有多大，但確實會尋找特定的查詢「型態」。</span><span class="sxs-lookup"><span data-stu-id="af9aa-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="af9aa-155">具體而言，它會尋找通常造成查詢在平行執行模式下執行速度變慢的查詢運算子或運算子組合。</span><span class="sxs-lookup"><span data-stu-id="af9aa-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="af9aa-156">當 PLINQ 找到該型態時，預設會回復成循序模式。</span><span class="sxs-lookup"><span data-stu-id="af9aa-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="af9aa-157">不過，在測量特定查詢的效能之後，您可能會判斷出實際上以平行模式執行的速度較快。</span><span class="sxs-lookup"><span data-stu-id="af9aa-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="af9aa-158">在這類情況下，您可以透過 <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> 方法使用 <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType>旗標，來指示 PLINQ 平行處理查詢。</span><span class="sxs-lookup"><span data-stu-id="af9aa-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="af9aa-159">如需詳細資訊，請參閱[如何：在 PLINQ 中指定執行模式](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="af9aa-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="af9aa-160">以下清單描述 PLINQ 預設將以循序模式執行的查詢型態：</span><span class="sxs-lookup"><span data-stu-id="af9aa-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="af9aa-161">在已移除或已重新排列原始索引的排序或篩選運算子之後包含 Select、已編製索引的 Where、已編製索引的 SelectMany 或 ElementAt 子句的查詢。</span><span class="sxs-lookup"><span data-stu-id="af9aa-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="af9aa-162">包含 Take、TakeWhile、Skip、SkipWhile 運算子且來源序列中的索引不是按原始順序排列的查詢。</span><span class="sxs-lookup"><span data-stu-id="af9aa-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="af9aa-163">包含 Zip 或 SequenceEquals 的查詢，除非其中一個資料來源具有原始排序的索引，而且另一個資料來源也可以索引 (也就是陣列或 IList(T))。</span><span class="sxs-lookup"><span data-stu-id="af9aa-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="af9aa-164">包含 Concat 的查詢 (但套用至可編製索引的資料來源時除外)</span><span class="sxs-lookup"><span data-stu-id="af9aa-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="af9aa-165">包含 Reverse 的查詢 (但套用至可編製索引的資料來源時除外)</span><span class="sxs-lookup"><span data-stu-id="af9aa-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="af9aa-166">另請參閱</span><span class="sxs-lookup"><span data-stu-id="af9aa-166">See also</span></span>

- [<span data-ttu-id="af9aa-167">平行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="af9aa-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
