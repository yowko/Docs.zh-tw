---
title: "例外狀況處理 (工作平行程式庫)"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, exceptions
ms.assetid: beb51e50-9061-4d3d-908c-56a4f7c2e8c1
caps.latest.revision: "21"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: e62498376d321d8ff22a53315b9d5f18a8865056
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/18/2017
---
# <a name="exception-handling-task-parallel-library"></a><span data-ttu-id="b01d5-102">例外狀況處理 (工作平行程式庫)</span><span class="sxs-lookup"><span data-stu-id="b01d5-102">Exception Handling (Task Parallel Library)</span></span>
<span data-ttu-id="b01d5-103">由在工作中執行的使用者程式碼所擲回的未處理例外狀況，會傳播回到呼叫執行緒，本主題稍後所述的特定情況除外。</span><span class="sxs-lookup"><span data-stu-id="b01d5-103">Unhandled exceptions that are thrown by user code that is running inside a task are propagated back to the calling thread, except in certain scenarios that are described later in this topic.</span></span> <span data-ttu-id="b01d5-104">例外狀況會傳播，當您使用其中一個靜態或執行個體<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>或<!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  -->`Wait`方法和您處理這類包住呼叫中的`try` / `catch`陳述式。</span><span class="sxs-lookup"><span data-stu-id="b01d5-104">Exceptions are propagated when you use one of the static or instance <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` methods, and you handle them by enclosing the call in a `try`/`catch` statement.</span></span> <span data-ttu-id="b01d5-105">如果工作是已連結子工作的父代，或如果您在等候多個工作，就可能會擲回多個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-105">If a task is the parent of attached child tasks, or if you are waiting on multiple tasks, multiple exceptions could be thrown.</span></span>  
  
 <span data-ttu-id="b01d5-106">若要將所有例外狀況傳播回呼叫執行緒，工作基礎結構會將它們包裝在 <xref:System.AggregateException> 執行個體中。</span><span class="sxs-lookup"><span data-stu-id="b01d5-106">To propagate all the exceptions back to the calling thread, the Task infrastructure wraps them in an <xref:System.AggregateException> instance.</span></span> <span data-ttu-id="b01d5-107"><xref:System.AggregateException> 例外狀況有 <xref:System.AggregateException.InnerExceptions%2A> 屬性，您可以列舉這個屬性來檢查所有擲回的原始例外狀況，並且個別處理 (或不處理) 每個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-107">The <xref:System.AggregateException> exception has an <xref:System.AggregateException.InnerExceptions%2A> property that can be enumerated to examine all the original exceptions that were thrown, and handle (or not handle) each one individually.</span></span> <span data-ttu-id="b01d5-108">您也可以使用處理原始的例外狀況<xref:System.AggregateException.Handle%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="b01d5-108">You can also handle the original exceptions by using the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b01d5-109">即使只擲回一個例外狀況，它仍然會包裝在 <xref:System.AggregateException> 例外狀況裡，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="b01d5-109">Even if only one exception is thrown, it is still wrapped in an <xref:System.AggregateException> exception, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_Exceptions#21](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling21.cs#21)]
 [!code-vb[TPL_Exceptions#21](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling21.vb#21)]  
  
 <span data-ttu-id="b01d5-110">只要攔截 <xref:System.AggregateException> 而且沒有觀察到任何內部的例外狀況，就可以避免未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-110">You could avoid an unhandled exception by just catching the <xref:System.AggregateException> and not observing any of the inner exceptions.</span></span> <span data-ttu-id="b01d5-111">不過，建議您不要這麼做，因為它在非平行案例中類似於攔截基底 <xref:System.Exception> 類型。</span><span class="sxs-lookup"><span data-stu-id="b01d5-111">However, we recommend that you do not do this because it is analogous to catching the base <xref:System.Exception> type in non-parallel scenarios.</span></span> <span data-ttu-id="b01d5-112">攔截例外狀況卻不採取特定動作從它復原，可能會讓您的程式處於不確定狀態。</span><span class="sxs-lookup"><span data-stu-id="b01d5-112">To catch an exception without taking specific actions to recover from it can leave your program in an indeterminate state.</span></span>  
  
 <span data-ttu-id="b01d5-113">如果您不想要呼叫<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>或<!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  -->`Wait`方法等候工作完成時，您也可以擷取<xref:System.AggregateException>來自工作的例外狀況<xref:System.Threading.Tasks.Task.Exception%2A>屬性，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="b01d5-113">If you do not want to call the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` method to wait for a task's completion, you can also retrieve the <xref:System.AggregateException> exception from the task's <xref:System.Threading.Tasks.Task.Exception%2A> property, as the following example shows.</span></span> <span data-ttu-id="b01d5-114">如需詳細資訊，請參閱本主題的 [使用 Task.Exception 屬性觀察例外狀況](#ExceptionProp) 一節。</span><span class="sxs-lookup"><span data-stu-id="b01d5-114">For more information, see the [Observing Exceptions By Using the Task.Exception Property](#ExceptionProp) section in this topic.</span></span>  
  
 [!code-csharp[TPL_Exceptions#29](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handling22.cs#29)]
 [!code-vb[TPL_Exceptions#29](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handling22.vb#29)]  
  
 <span data-ttu-id="b01d5-115">如果您不需要等候工作傳播例外狀況，或存取其 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性，當工作回收時就會根據 .NET 例外狀況原則提昇例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-115">If you do not wait on a task that propagates an exception, or access its <xref:System.Threading.Tasks.Task.Exception%2A> property, the exception is escalated according to the .NET exception policy when the task is garbage-collected.</span></span>  
  
 <span data-ttu-id="b01d5-116">當允許例外狀況反昇至聯結的執行緒時，工作可能就可以在引發例外狀況之後，繼續處理某些項目。</span><span class="sxs-lookup"><span data-stu-id="b01d5-116">When exceptions are allowed to bubble up back to the joining thread, it is possible that a task may continue to process some items after the exception is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b01d5-117">啟用 [Just My Code] 時，Visual Studio 在某些情況下會在擲回例外狀況的字行上中斷，並顯示錯誤訊息，指出「使用者程式碼未處理例外狀況」。</span><span class="sxs-lookup"><span data-stu-id="b01d5-117">When "Just My Code" is enabled, Visual Studio in some cases will break on the line that throws the exception and display an error message that says "exception not handled by user code."</span></span> <span data-ttu-id="b01d5-118">這個錯誤是良性的。</span><span class="sxs-lookup"><span data-stu-id="b01d5-118">This error is benign.</span></span> <span data-ttu-id="b01d5-119">您可以按 F5 繼續，並查看下面範例中示範的例外狀況處理行為。</span><span class="sxs-lookup"><span data-stu-id="b01d5-119">You can press F5 to continue and see the exception-handling behavior that is demonstrated in these examples.</span></span> <span data-ttu-id="b01d5-120">若要防止 Visual Studio 在遇到第一個錯誤時就中斷，只要取消核取 [工具]、[選項]、[偵錯]、[一般]  下的 [ **啟用 Just My Code**] 核取方塊即可。</span><span class="sxs-lookup"><span data-stu-id="b01d5-120">To prevent Visual Studio from breaking on the first error, just uncheck the **Enable Just My Code** checkbox under **Tools, Options, Debugging, General**.</span></span>  
  
## <a name="attached-child-tasks-and-nested-aggregateexceptions"></a><span data-ttu-id="b01d5-121">已連結子工作和巢狀的 AggregateExceptions</span><span class="sxs-lookup"><span data-stu-id="b01d5-121">Attached Child Tasks and Nested AggregateExceptions</span></span>  
 <span data-ttu-id="b01d5-122">如果工作有會擲回例外狀況的已連結子工作，該例外狀況就會先包裝在 <xref:System.AggregateException> 再傳播到父工作，這會先把此例外狀況包裝在它自己的 <xref:System.AggregateException> 再傳播回呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="b01d5-122">If a task has an attached child task that throws an exception, that exception is wrapped in an <xref:System.AggregateException> before it is propagated to the parent task, which wraps that exception in its own <xref:System.AggregateException> before it propagates it back to the calling thread.</span></span> <span data-ttu-id="b01d5-123">在這種情況下，<xref:System.AggregateException.InnerExceptions%2A>屬性<xref:System.AggregateException>會攔截的例外狀況<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>或<!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  -->`Wait`或<xref:System.Threading.Tasks.Task.WaitAny%2A>或<xref:System.Threading.Tasks.Task.WaitAll%2A>方法包含一或多個<xref:System.AggregateException>不執行個體造成錯誤的原始例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-123">In such cases, the <xref:System.AggregateException.InnerExceptions%2A> property of the <xref:System.AggregateException> exception that is caught at the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> or <!--zz <xref:System.Threading.Tasks.Task%601.Wait%2A?displayProperty=nameWithType>  --> `Wait` or <xref:System.Threading.Tasks.Task.WaitAny%2A> or <xref:System.Threading.Tasks.Task.WaitAll%2A> method contains one or more <xref:System.AggregateException> instances, not the original exceptions that caused the fault.</span></span> <span data-ttu-id="b01d5-124">若要避免必須逐一查看巢狀<xref:System.AggregateException>例外狀況，您可以使用<xref:System.AggregateException.Flatten%2A>方法移除所有的巢狀<xref:System.AggregateException>例外狀況，以便<xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>屬性包含原始例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-124">To avoid having to iterate over nested <xref:System.AggregateException> exceptions, you can use the <xref:System.AggregateException.Flatten%2A> method to remove all the nested <xref:System.AggregateException> exceptions, so that the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains the original exceptions.</span></span> <span data-ttu-id="b01d5-125">下例中，巢狀 <xref:System.AggregateException> 執行個體被扁平化，並只在一個迴圈中處理。</span><span class="sxs-lookup"><span data-stu-id="b01d5-125">In the following example, nested <xref:System.AggregateException> instances are flattened and handled in just one loop.</span></span>  
  
 [!code-csharp[TPL_Exceptions#22](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/flatten2.cs#22)]
 [!code-vb[TPL_Exceptions#22](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/flatten2.vb#22)]  
  
 <span data-ttu-id="b01d5-126">您也可以使用<xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType>方法，以從多個內部的例外狀況重新擲回<xref:System.AggregateException>在單一的多個工作擲回的執行個體<xref:System.AggregateException>執行個體，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="b01d5-126">You can also use the <xref:System.AggregateException.Flatten%2A?displayProperty=nameWithType> method to rethrow the inner exceptions from multiple <xref:System.AggregateException> instances thrown by multiple tasks in a single <xref:System.AggregateException> instance, as the following example shows.</span></span>  
  
 [!code-csharp[TPL_Exceptions#13](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions2.cs#13)]
 [!code-vb[TPL_Exceptions#13](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions2.vb#13)]  
  
## <a name="exceptions-from-detached-child-tasks"></a><span data-ttu-id="b01d5-127">來自中斷連結子工作的例外狀況</span><span class="sxs-lookup"><span data-stu-id="b01d5-127">Exceptions from Detached Child Tasks</span></span>  
 <span data-ttu-id="b01d5-128">子工作預設的建立狀態為中斷連結。</span><span class="sxs-lookup"><span data-stu-id="b01d5-128">By default, child tasks are created as detached.</span></span> <span data-ttu-id="b01d5-129">從已中斷連結工作擲回的例外狀況，必須在緊鄰的父工作中處理或重新擲回；它們傳播回呼叫執行緒的方式，和已連結子工作傳播回的方式不一樣。</span><span class="sxs-lookup"><span data-stu-id="b01d5-129">Exceptions thrown from detached tasks must be handled or rethrown in the immediate parent task; they are not propagated back to the calling thread in the same way as attached child tasks propagated back.</span></span> <span data-ttu-id="b01d5-130">最上層的父代可以從中斷連結的子代手動重新擲回例外狀況，讓它包裝在 <xref:System.AggregateException> 中並傳播回呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="b01d5-130">The topmost parent can manually rethrow an exception from a detached child to cause it to be wrapped in an <xref:System.AggregateException> and propagated back to the calling thread.</span></span>  
  
 [!code-csharp[TPL_Exceptions#23](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/detached21.cs#23)]
 [!code-vb[TPL_Exceptions#23](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/detached21.vb#23)]  
  
 <span data-ttu-id="b01d5-131">即使您持續觀察子工作中的例外狀況，父工作也仍然必須觀察此例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-131">Even if you use a continuation to observe an exception in a child task, the exception still must be observed by the parent task.</span></span>  
  
## <a name="exceptions-that-indicate-cooperative-cancellation"></a><span data-ttu-id="b01d5-132">指出合作式取消的例外狀況</span><span class="sxs-lookup"><span data-stu-id="b01d5-132">Exceptions That Indicate Cooperative Cancellation</span></span>  
 <span data-ttu-id="b01d5-133">當工作中的使用者程式碼回應取消要求時，正確的程序會擲回 <xref:System.OperationCanceledException> 傳入已在其中通訊過要求的取消語彙基元。</span><span class="sxs-lookup"><span data-stu-id="b01d5-133">When user code in a task responds to a cancellation request, the correct procedure is to throw an <xref:System.OperationCanceledException> passing in the cancellation token on which the request was communicated.</span></span> <span data-ttu-id="b01d5-134">在它嘗試傳播例外狀況之前，工作執行個體會比較例外狀況中的語彙基元和個體建立時傳來的語彙基元。</span><span class="sxs-lookup"><span data-stu-id="b01d5-134">Before it attempts to propagate the exception, the task instance compares the token in the exception to the one that was passed to it when it was created.</span></span> <span data-ttu-id="b01d5-135">如果它們是相同的，工作會傳播包裝在 <xref:System.Threading.Tasks.TaskCanceledException> 中的 <xref:System.AggregateException>，而且在檢查內部例外狀況時可以看到它。</span><span class="sxs-lookup"><span data-stu-id="b01d5-135">If they are the same, the task propagates a <xref:System.Threading.Tasks.TaskCanceledException> wrapped in the <xref:System.AggregateException>, and it can be seen when the inner exceptions are examined.</span></span> <span data-ttu-id="b01d5-136">不過，如果呼叫執行緒並未等待工作，就不會傳播這個特定的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-136">However, if the calling thread is not waiting on the task, this specific exception will not be propagated.</span></span> <span data-ttu-id="b01d5-137">如需詳細資訊，請參閱 [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="b01d5-137">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 [!code-csharp[TPL_Exceptions#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptions.cs#4)]
 [!code-vb[TPL_Exceptions#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/tpl_exceptions.vb#4)]  
  
## <a name="using-the-handle-method-to-filter-inner-exceptions"></a><span data-ttu-id="b01d5-138">使用控制方法篩選內部例外狀況</span><span class="sxs-lookup"><span data-stu-id="b01d5-138">Using the Handle Method to Filter Inner Exceptions</span></span>  
 <span data-ttu-id="b01d5-139">您可以使用<xref:System.AggregateException.Handle%2A?displayProperty=nameWithType>方法，而不使用任何進一步的邏輯篩選出您可以視為 「 處理 」 的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-139">You can use the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to filter out exceptions that you can treat as "handled" without using any further logic.</span></span> <span data-ttu-id="b01d5-140">提供給使用者委派中<xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType>方法，您可以檢查例外狀況類型、 其<xref:System.Exception.Message%2A>屬性或任何其他相關資訊，讓您判斷其是否為良性。</span><span class="sxs-lookup"><span data-stu-id="b01d5-140">In the user delegate that is supplied to the <xref:System.AggregateException.Handle%28System.Func%7BSystem.Exception%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method, you can examine the exception type, its <xref:System.Exception.Message%2A> property, or any other information about it that will let you determine whether it is benign.</span></span> <span data-ttu-id="b01d5-141">在委派傳回的任何例外狀況`false`重新擲回新<xref:System.AggregateException>之後立即執行個體<xref:System.AggregateException.Handle%2A?displayProperty=nameWithType>方法會傳回。</span><span class="sxs-lookup"><span data-stu-id="b01d5-141">Any exceptions for which the delegate returns `false` are rethrown in a new <xref:System.AggregateException> instance immediately after the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method returns.</span></span>  
  
 <span data-ttu-id="b01d5-142">下列範例會在功能上等同於本主題中，這會檢查每個例外狀況中的第一個範例<xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>集合。</span><span class="sxs-lookup"><span data-stu-id="b01d5-142">The following example is functionally equivalent to the first example in this topic, which examines each exception in the <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> collection.</span></span>  <span data-ttu-id="b01d5-143">相反地，此例外狀況處理常式會呼叫<xref:System.AggregateException.Handle%2A?displayProperty=nameWithType>每個例外狀況，而不是只重新擲回例外狀況的方法物件`CustomException`執行個體。</span><span class="sxs-lookup"><span data-stu-id="b01d5-143">Instead, this exception handler calls the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method object for each exception, and only rethrows exceptions that are not `CustomException` instances.</span></span>  
  
 [!code-csharp[TPL_Exceptions#26](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/handlemethod21.cs#26)]
 [!code-vb[TPL_Exceptions#26](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/handlemethod21.vb#26)]  
  
 <span data-ttu-id="b01d5-144">以下是更完整的範例，其使用<xref:System.AggregateException.Handle%2A?displayProperty=nameWithType>方法以提供的特殊處理<xref:System.UnauthorizedAccessException>列舉檔案時的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b01d5-144">The following is a more complete example that uses the <xref:System.AggregateException.Handle%2A?displayProperty=nameWithType> method to provide special handling for an <xref:System.UnauthorizedAccessException> exception when enumerating files.</span></span>  
  
 [!code-csharp[TPL_Exceptions#12](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/taskexceptions.cs#12)]
 [!code-vb[TPL_Exceptions#12](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/taskexceptions.vb#12)]  
  
<a name="ExceptionProp"></a>   
## <a name="observing-exceptions-by-using-the-taskexception-property"></a><span data-ttu-id="b01d5-145">使用 Task.Exception 屬性觀察例外狀況</span><span class="sxs-lookup"><span data-stu-id="b01d5-145">Observing Exceptions by Using the Task.Exception Property</span></span>  
 <span data-ttu-id="b01d5-146">當工作在<xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>狀態，其<xref:System.Threading.Tasks.Task.Exception%2A>屬性可檢查以探查哪些特定的例外狀況導致這個錯誤。</span><span class="sxs-lookup"><span data-stu-id="b01d5-146">If a task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state, its <xref:System.Threading.Tasks.Task.Exception%2A> property can be examined to discover which specific exception caused the fault.</span></span> <span data-ttu-id="b01d5-147">使用唯有在前項工作發生錯誤時才執行的接續，是觀察 <xref:System.Threading.Tasks.Task.Exception%2A> 屬性的好方法，如下例所示。</span><span class="sxs-lookup"><span data-stu-id="b01d5-147">A good way to observe the <xref:System.Threading.Tasks.Task.Exception%2A> property is to use a continuation that runs only if the antecedent task faults, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Exceptions#27](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_exceptions/cs/exceptionprop21.cs#27)]
 [!code-vb[TPL_Exceptions#27](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_exceptions/vb/exceptionprop21.vb#27)]  
  
 <span data-ttu-id="b01d5-148">在實際應用中，接續委派會記錄例外狀況的詳細資訊，並可能產生從例外狀況復原的新工作。</span><span class="sxs-lookup"><span data-stu-id="b01d5-148">In a real application, the continuation delegate could log detailed information about the exception and possibly spawn new tasks to recover from the exception.</span></span>  
  
## <a name="unobservedtaskexception-event"></a><span data-ttu-id="b01d5-149">UnobservedTaskException 事件</span><span class="sxs-lookup"><span data-stu-id="b01d5-149">UnobservedTaskException Event</span></span>  
 <span data-ttu-id="b01d5-150">在某些情況下，例如裝載時不受信任的外掛程式，良性的例外狀況可能很常見，而要手動觀察全部太困難。</span><span class="sxs-lookup"><span data-stu-id="b01d5-150">In some scenarios, such as when hosting untrusted plug-ins, benign exceptions might be common, and it might be too difficult to manually observe them all.</span></span> <span data-ttu-id="b01d5-151">在這些情況下，您可以處理<xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="b01d5-151">In these cases, you can handle the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="b01d5-152"><xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType>傳遞至您的處理常式的執行個體可以用來防止未觀察到的例外狀況傳播回聯結執行緒。</span><span class="sxs-lookup"><span data-stu-id="b01d5-152">The <xref:System.Threading.Tasks.UnobservedTaskExceptionEventArgs?displayProperty=nameWithType> instance that is passed to your handler can be used to prevent the unobserved exception from being propagated back to the joining thread.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b01d5-153">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b01d5-153">See Also</span></span>  
 [<span data-ttu-id="b01d5-154">工作平行程式庫 (TPL)</span><span class="sxs-lookup"><span data-stu-id="b01d5-154">Task Parallel Library (TPL)</span></span>](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)
