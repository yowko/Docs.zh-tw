---
title: .NET 組件檔格式
description: 了解用來描述並包含 .NET 應用程式和程式庫的 .NET 組件檔格式。
author: richlander
ms.author: mairaw
ms.date: 08/20/2019
ms.technology: dotnet-standard
ms.assetid: 6520323e-ff28-4c8a-ba80-e64a413199e6
ms.openlocfilehash: c9396c45e3c6cdbc9360485f6286a1746bf81fdd
ms.sourcegitcommit: 7b1ce327e8c84f115f007be4728d29a89efe11ef
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/13/2019
ms.locfileid: "70970158"
---
# <a name="net-assembly-file-format"></a><span data-ttu-id="19656-103">.NET 組件檔格式</span><span class="sxs-lookup"><span data-stu-id="19656-103">.NET assembly file format</span></span>

<span data-ttu-id="19656-104">.NET 會定義用來完整描述並包含 .NET 程式的二進位檔案格式（*元件*）。</span><span class="sxs-lookup"><span data-stu-id="19656-104">.NET defines a binary file format, *assembly*, that is used to fully describe and contain .NET programs.</span></span> <span data-ttu-id="19656-105">組件用於程式本身以及任何相依的程式庫。</span><span class="sxs-lookup"><span data-stu-id="19656-105">Assemblies are used for the programs themselves as well as any dependent libraries.</span></span> <span data-ttu-id="19656-106">除了適當的 .NET 實作之外，.NET 程式也可以執行為一或多個沒有其他必要成品的組件。</span><span class="sxs-lookup"><span data-stu-id="19656-106">A .NET program can be executed as one or more assemblies, with no other required artifacts, beyond the appropriate .NET implementation.</span></span> <span data-ttu-id="19656-107">原生相依性（包括作業系統 Api）是一項不同的考慮，而且不包含在 .NET 元件格式中，但有時會以這種格式（例如 WinRT）來描述。</span><span class="sxs-lookup"><span data-stu-id="19656-107">Native dependencies, including operating system APIs, are a separate concern and are not contained within the .NET assembly format, although they are sometimes described with this format (for example, WinRT).</span></span>

> <span data-ttu-id="19656-108">每個 CLI 元件都會攜帶該元件特定宣告、實作和參考的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="19656-108">Each CLI component carries the metadata for declarations, implementations, and references specific to that component.</span></span> <span data-ttu-id="19656-109">因此，元件特定中繼資料是指元件中繼資料，而且產生的元件即為來自 ECMA 335 I.9.1 的自我描述元件和組件。</span><span class="sxs-lookup"><span data-stu-id="19656-109">Therefore, the component-specific metadata is referred to as component metadata, and the resulting component is said to be self-describing – from ECMA 335 I.9.1, Components and assemblies.</span></span>

<span data-ttu-id="19656-110">格式會依 [ECMA 335](https://www.ecma-international.org/publications/standards/Ecma-335.htm) 來完整指定並標準化。</span><span class="sxs-lookup"><span data-stu-id="19656-110">The format is fully specified and standardized as [ECMA 335](https://www.ecma-international.org/publications/standards/Ecma-335.htm).</span></span> <span data-ttu-id="19656-111">所有 .NET 編譯器和執行階段都會使用這種格式。</span><span class="sxs-lookup"><span data-stu-id="19656-111">All .NET compilers and runtimes use this format.</span></span> <span data-ttu-id="19656-112">所記載且不常更新的二進位格式目前狀態，已是互通性的主要優點 (即需求)。</span><span class="sxs-lookup"><span data-stu-id="19656-112">The presence of a documented and infrequently updated binary format has been a major benefit (arguably a requirement) for interoperability.</span></span> <span data-ttu-id="19656-113">這種格式上次在 2005 年進行重大更新 (.NET 2.0)，可容納泛型和處理器架構。</span><span class="sxs-lookup"><span data-stu-id="19656-113">The format was last updated in a substantive way in 2005 (.NET 2.0) to accommodate generics and processor architecture.</span></span>

<span data-ttu-id="19656-114">格式為 CPU 並且無作業系統無關。</span><span class="sxs-lookup"><span data-stu-id="19656-114">The format is CPU- and OS-agnostic.</span></span> <span data-ttu-id="19656-115">它已用作將目標設為許多晶片和 CPU 之 .NET 實作的一部分。</span><span class="sxs-lookup"><span data-stu-id="19656-115">It has been used as part of .NET implementations that target many chips and CPUs.</span></span> <span data-ttu-id="19656-116">雖然格式本身具有 Windows 傳承，但是可在任何作業系統上實作。</span><span class="sxs-lookup"><span data-stu-id="19656-116">While the format itself has Windows heritage, it is implementable on any operating system.</span></span> <span data-ttu-id="19656-117">為達 OS 互通性，大部分的值皆以位元組由小到大的格式儲存，這可說是最重大的選擇。</span><span class="sxs-lookup"><span data-stu-id="19656-117">Its arguably most significant choice for OS interoperability is that most values are stored in little-endian format.</span></span> <span data-ttu-id="19656-118">它沒有電腦指標大小 (例如，32 位元、64 位元) 的特定同質性。</span><span class="sxs-lookup"><span data-stu-id="19656-118">It doesn’t have a specific affinity to machine pointer size (for example, 32-bit, 64-bit).</span></span>

<span data-ttu-id="19656-119">.NET 組件格式對於指定的程式或程式庫結構也具有相當的描述性。</span><span class="sxs-lookup"><span data-stu-id="19656-119">The .NET assembly format is also very descriptive about the structure of a given program or library.</span></span> <span data-ttu-id="19656-120">它描述元件的內部元件，特別是定義的元件參考和類型，以及其內部結構。</span><span class="sxs-lookup"><span data-stu-id="19656-120">It describes the internal components of an assembly, specifically assembly references and types defined and their internal structure.</span></span> <span data-ttu-id="19656-121">工具或 API 可以讀取和處理這項資訊以供顯示，或進行程式設計決策。</span><span class="sxs-lookup"><span data-stu-id="19656-121">Tools or APIs can read and process this information for display or to make programmatic decisions.</span></span>

## <a name="format"></a><span data-ttu-id="19656-122">格式</span><span class="sxs-lookup"><span data-stu-id="19656-122">Format</span></span>

<span data-ttu-id="19656-123">.NET 二進位格式是根據 Windows [PE 檔案](https://en.wikipedia.org/wiki/Portable_Executable)格式。</span><span class="sxs-lookup"><span data-stu-id="19656-123">The .NET binary format is based on the Windows [PE file](https://en.wikipedia.org/wiki/Portable_Executable) format.</span></span> <span data-ttu-id="19656-124">事實上，.NET 類別庫是一致的 Windows PE，並且顯示在第一次看到 Windows 動態連結程式庫 (DLL) 或應用程式執行檔 (EXE) 時。</span><span class="sxs-lookup"><span data-stu-id="19656-124">In fact, .NET class libraries are conformant Windows PEs, and appear on first glance to be Windows dynamic link libraries (DLLs) or application executables (EXEs).</span></span> <span data-ttu-id="19656-125">這是 Windows 上極為實用的特性，在此，它們可以偽裝為原生可執行二進位檔，並進行一些相同的處理 (例如，OS 載入、PE 工具)。</span><span class="sxs-lookup"><span data-stu-id="19656-125">This is a very useful characteristic on Windows, where they can masquerade as native executable binaries and get some of the same treatment (for example, OS load, PE tools).</span></span>

![組件標頭](../media/assembly-format/assembly-headers.png)

<span data-ttu-id="19656-127">來自 ECMA 335 II.25.1 的組件標頭 (執行階段檔案格式的結構)。</span><span class="sxs-lookup"><span data-stu-id="19656-127">Assembly Headers from ECMA 335 II.25.1, Structure of the runtime file format.</span></span>

## <a name="process-the-assemblies"></a><span data-ttu-id="19656-128">處理元件</span><span class="sxs-lookup"><span data-stu-id="19656-128">Process the assemblies</span></span>

<span data-ttu-id="19656-129">可能會撰寫工具或 API 來處理組件。</span><span class="sxs-lookup"><span data-stu-id="19656-129">It is possible to write tools or APIs to process assemblies.</span></span> <span data-ttu-id="19656-130">組件資訊可在執行階段進行程式設計決策、重新撰寫組件、在編輯器中提供 API IntelliSense，以及產生文件。</span><span class="sxs-lookup"><span data-stu-id="19656-130">Assembly information enables making programmatic decisions at runtime, re-writing assemblies, providing API IntelliSense in an editor and generating documentation.</span></span> <span data-ttu-id="19656-131"><xref:System.Reflection?displayProperty=nameWithType>、<xref:System.Reflection.MetadataLoadContext?displayProperty=nameWithType> 和 [Mono.Cecil](https://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/) 是常用於此目的工具的不錯範例。</span><span class="sxs-lookup"><span data-stu-id="19656-131"><xref:System.Reflection?displayProperty=nameWithType>, <xref:System.Reflection.MetadataLoadContext?displayProperty=nameWithType>, and [Mono.Cecil](https://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/) are good examples of tools that are frequently used for this purpose.</span></span>
