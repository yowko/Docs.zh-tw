---
title: Managed 執行緒中的取消作業
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- cancellation in .NET, overview
ms.assetid: eea11fe5-d8b0-4314-bb5d-8a58166fb1c3
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: a764912e46707b6f10e720f95a7d971ec4fc8e15
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
---
# <a name="cancellation-in-managed-threads"></a><span data-ttu-id="3620d-102">Managed 執行緒中的取消作業</span><span class="sxs-lookup"><span data-stu-id="3620d-102">Cancellation in Managed Threads</span></span>
<span data-ttu-id="3620d-103">隨著 [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] 一起啟動， .NET Framework 使用統一的模型來進行非同步或長時間執行的同步作業的合作式取消。</span><span class="sxs-lookup"><span data-stu-id="3620d-103">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], the .NET Framework uses a unified model for cooperative cancellation of asynchronous or long-running synchronous operations.</span></span> <span data-ttu-id="3620d-104">此模型是根據一個被稱為取消權杖的輕量級物件。</span><span class="sxs-lookup"><span data-stu-id="3620d-104">This model is based on a lightweight object called a cancellation token.</span></span> <span data-ttu-id="3620d-105">叫用一或多個可取消作業的物件，例如藉由建立新的執行緒或工作，會將權杖傳遞至每個作業。</span><span class="sxs-lookup"><span data-stu-id="3620d-105">The object that invokes one or more cancelable operations, for example by creating new threads or tasks, passes the token to each operation.</span></span> <span data-ttu-id="3620d-106">個別作業可以依序將權杖的複本傳遞至其他作業。</span><span class="sxs-lookup"><span data-stu-id="3620d-106">Individual operations can in turn pass copies of the token to other operations.</span></span> <span data-ttu-id="3620d-107">之後的某些時候 ，建立權杖的物件可以使用它來要求作業停止活動。</span><span class="sxs-lookup"><span data-stu-id="3620d-107">At some later time, the object that created the token can use it to request that the operations stop what they are doing.</span></span> <span data-ttu-id="3620d-108">只有要求的物件可以發出取消要求，而且每個接聽程式負責留意要求，並且以適當且即時的方式回應。</span><span class="sxs-lookup"><span data-stu-id="3620d-108">Only the requesting object can issue the cancellation request, and each listener is responsible for noticing the request and responding to it in an appropriate and timely manner.</span></span>  
  
 <span data-ttu-id="3620d-109">合作式取消模型的一般實作模式是：</span><span class="sxs-lookup"><span data-stu-id="3620d-109">The general pattern for implementing the cooperative cancellation model is:</span></span>  
  
-   <span data-ttu-id="3620d-110">具現化 <xref:System.Threading.CancellationTokenSource> 物件，該物件會管理並傳送取消通知給個別的取消權杖。</span><span class="sxs-lookup"><span data-stu-id="3620d-110">Instantiate a <xref:System.Threading.CancellationTokenSource> object, which manages and sends cancellation notification to the individual cancellation tokens.</span></span>  
  
-   <span data-ttu-id="3620d-111">傳遞由 <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> 屬性傳回的權杖給每個接聽取消的工作或執行緒。</span><span class="sxs-lookup"><span data-stu-id="3620d-111">Pass the token returned by the <xref:System.Threading.CancellationTokenSource.Token%2A?displayProperty=nameWithType> property to each task or thread that listens for cancellation.</span></span>  
  
-   <span data-ttu-id="3620d-112">提供一種機制讓每個工作或執行緒都能回應取消作業。</span><span class="sxs-lookup"><span data-stu-id="3620d-112">Provide a mechanism for each task or thread to respond to cancellation.</span></span>  
  
-   <span data-ttu-id="3620d-113">呼叫 <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> 方法以提供取消的通知。</span><span class="sxs-lookup"><span data-stu-id="3620d-113">Call the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to provide notification of cancellation.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3620d-114"><xref:System.Threading.CancellationTokenSource> 類別會實作 <xref:System.IDisposable> 介面。</span><span class="sxs-lookup"><span data-stu-id="3620d-114">The <xref:System.Threading.CancellationTokenSource> class implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="3620d-115">當您完成使用取消權杖來釋放任何它所保留的 Unmanaged 資源之後，您一定要呼叫 <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="3620d-115">You should be sure to call the <xref:System.Threading.CancellationTokenSource.Dispose%2A?displayProperty=nameWithType> method when you have finished using the cancellation token source to free any unmanaged resources it holds.</span></span>  
  
 <span data-ttu-id="3620d-116">下圖顯示權杖來源和其權杖的所有複本兩者之間的關係。</span><span class="sxs-lookup"><span data-stu-id="3620d-116">The following illustration shows the relationship between a token source and all the copies of its token.</span></span>  
  
 <span data-ttu-id="3620d-117">![CancellationTokenSource 和取消權杖](../../../docs/standard/threading/media/vs-cancellationtoken.png "VS_CancellationToken")</span><span class="sxs-lookup"><span data-stu-id="3620d-117">![CancellationTokenSource and cancellation tokens](../../../docs/standard/threading/media/vs-cancellationtoken.png "VS_CancellationToken")</span></span>  
  
 <span data-ttu-id="3620d-118">新的取消模型可讓您更輕鬆地建立取消感知應用程式和程式庫，它可支援下列功能：</span><span class="sxs-lookup"><span data-stu-id="3620d-118">The new cancellation model makes it easier to create cancellation-aware applications and libraries, and it supports the following features:</span></span>  
  
-   <span data-ttu-id="3620d-119">取消作業為合作式且對於接聽程式為非強制。</span><span class="sxs-lookup"><span data-stu-id="3620d-119">Cancellation is cooperative and is not forced on the listener.</span></span> <span data-ttu-id="3620d-120">接聽程式會決定如何依正常程序來終止以回應取消要求。</span><span class="sxs-lookup"><span data-stu-id="3620d-120">The listener determines how to gracefully terminate in response to a cancellation request.</span></span>  
  
-   <span data-ttu-id="3620d-121">要求與接聽有所不同。</span><span class="sxs-lookup"><span data-stu-id="3620d-121">Requesting is distinct from listening.</span></span> <span data-ttu-id="3620d-122">當 (如果有的話) 要求取消作業時，可以控制叫用可取消作業的物件。</span><span class="sxs-lookup"><span data-stu-id="3620d-122">An object that invokes a cancelable operation can control when (if ever) cancellation is requested.</span></span>  
  
-   <span data-ttu-id="3620d-123">送出要求的物件藉著只使用一個方法呼叫，來發出取消要求給權杖的所有複本。</span><span class="sxs-lookup"><span data-stu-id="3620d-123">The requesting object issues the cancellation request to all copies of the token by using just one method call.</span></span>  
  
-   <span data-ttu-id="3620d-124">接聽程式可以透過將這些權杖聯結成單一個「連結的權杖」(linked token) 來同時接聽多個權杖。</span><span class="sxs-lookup"><span data-stu-id="3620d-124">A listener can listen to multiple tokens simultaneously by joining them into one *linked token*.</span></span>  
  
-   <span data-ttu-id="3620d-125">使用者程式碼可以注意並回應來自程式庫程式碼的取消要求，並且程式庫程式碼可以注意並回應來自使用者程式碼的取消要求。</span><span class="sxs-lookup"><span data-stu-id="3620d-125">User code can notice and respond to cancellation requests from library code, and library code can notice and respond to cancellation requests from user code.</span></span>  
  
-   <span data-ttu-id="3620d-126">接聽程式可以收到取消要求，藉由輪詢、回呼註冊，或等候等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="3620d-126">Listeners can be notified of cancellation requests by polling, callback registration, or waiting on wait handles.</span></span>  
  
## <a name="cancellation-types"></a><span data-ttu-id="3620d-127">取消類型</span><span class="sxs-lookup"><span data-stu-id="3620d-127">Cancellation Types</span></span>  
 <span data-ttu-id="3620d-128">取消架構被實作為一組相關的類型，這些會在下表中列出。</span><span class="sxs-lookup"><span data-stu-id="3620d-128">The cancellation framework is implemented as a set of related types, which are listed in the following table.</span></span>  
  
|<span data-ttu-id="3620d-129">類型名稱</span><span class="sxs-lookup"><span data-stu-id="3620d-129">Type name</span></span>|<span data-ttu-id="3620d-130">描述</span><span class="sxs-lookup"><span data-stu-id="3620d-130">Description</span></span>|  
|---------------|-----------------|  
|<xref:System.Threading.CancellationTokenSource>|<span data-ttu-id="3620d-131">建立取消權杖，並發出取消要求給該權杖所有複本的物件。</span><span class="sxs-lookup"><span data-stu-id="3620d-131">Object that creates a cancellation token, and also issues the cancellation request for all copies of that token.</span></span>|  
|<xref:System.Threading.CancellationToken>|<span data-ttu-id="3620d-132">輕量型的實值類型通常做為方法參數傳遞至一或多個接聽程式。</span><span class="sxs-lookup"><span data-stu-id="3620d-132">Lightweight value type passed to one or more listeners, typically as a method parameter.</span></span> <span data-ttu-id="3620d-133">接聽程式會監控權杖中 `IsCancellationRequested` 屬性的值，藉由輪詢、回呼，或等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="3620d-133">Listeners monitor the value of the `IsCancellationRequested` property of the token by polling, callback, or wait handle.</span></span>|  
|<xref:System.OperationCanceledException>|<span data-ttu-id="3620d-134">此例外狀況之建構函式的多載接受 <xref:System.Threading.CancellationToken> 做為參數。</span><span class="sxs-lookup"><span data-stu-id="3620d-134">Overloads of this exception's constructor accept a <xref:System.Threading.CancellationToken> as a parameter.</span></span> <span data-ttu-id="3620d-135">接聽程式可以選擇性地擲回這個例外狀況來驗證取消來源，並通知其他接聽程式它已經回應取消要求。</span><span class="sxs-lookup"><span data-stu-id="3620d-135">Listeners can optionally throw this exception to verify the source of the cancellation and notify others that it has responded to a cancellation request.</span></span>|  
  
 <span data-ttu-id="3620d-136">新的取消模型已整合至 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 的數種類型中。</span><span class="sxs-lookup"><span data-stu-id="3620d-136">The new cancellation model is integrated into the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] in several types.</span></span> <span data-ttu-id="3620d-137">最重要的部分包括 <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Task?displayProperty=nameWithType>、<xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 和 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3620d-137">The most important ones are <xref:System.Threading.Tasks.Parallel?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>, <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3620d-138">我們建議您針對所有新程式庫和應用程式程式碼使用這個新的取消模型。</span><span class="sxs-lookup"><span data-stu-id="3620d-138">We recommend that you use this new cancellation model for all new library and application code.</span></span>  
  
## <a name="code-example"></a><span data-ttu-id="3620d-139">程式碼範例</span><span class="sxs-lookup"><span data-stu-id="3620d-139">Code Example</span></span>  
 <span data-ttu-id="3620d-140">在下列範例中，要求的物件會建立 <xref:System.Threading.CancellationTokenSource> 物件，然後傳遞其 <xref:System.Threading.CancellationTokenSource.Token%2A> 屬性給可取消作業。</span><span class="sxs-lookup"><span data-stu-id="3620d-140">In the following example, the requesting object creates a <xref:System.Threading.CancellationTokenSource> object, and then passes its <xref:System.Threading.CancellationTokenSource.Token%2A> property to the cancelable operation.</span></span> <span data-ttu-id="3620d-141">接收要求的作業會藉由輪詢來監視權杖之 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 屬性的值。</span><span class="sxs-lookup"><span data-stu-id="3620d-141">The operation that receives the request monitors the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token by polling.</span></span> <span data-ttu-id="3620d-142">當此值變成 `true`  時，接聽程式能夠以任何合適的方式來結束。</span><span class="sxs-lookup"><span data-stu-id="3620d-142">When the value becomes `true`, the listener can terminate in whatever manner is appropriate.</span></span> <span data-ttu-id="3620d-143">在此範例中，方法只會結束，就如同在許多情況下所要求的。</span><span class="sxs-lookup"><span data-stu-id="3620d-143">In this example, the method just exits, which is all that is required in many cases.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3620d-144">此範例會使用 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 方法來示範新的取消架構與舊版應用程式開發介面相容。</span><span class="sxs-lookup"><span data-stu-id="3620d-144">The example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to demonstrate that the new cancellation framework is compatible with legacy APIs.</span></span> <span data-ttu-id="3620d-145">如需使用慣用的新 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 類型之範例，請參閱[如何：取消工作及其子系](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)。</span><span class="sxs-lookup"><span data-stu-id="3620d-145">For an example that uses the new, preferred <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> type, see [How to: Cancel a Task and Its Children](../../../docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
 [!code-csharp[Cancellation#1](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex1.cs#1)]
 [!code-vb[Cancellation#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex1.vb#1)]  
  
## <a name="operation-cancellation-versus-object-cancellation"></a><span data-ttu-id="3620d-146">作業取消與物件取消</span><span class="sxs-lookup"><span data-stu-id="3620d-146">Operation Cancellation Versus Object Cancellation</span></span>  
 <span data-ttu-id="3620d-147">在新的取消架構中，取消指的是作業而不是物件。</span><span class="sxs-lookup"><span data-stu-id="3620d-147">In the new cancellation framework, cancellation refers to operations, not objects.</span></span> <span data-ttu-id="3620d-148">取消要求意味著作業應該在任何必要的清除執行之後盡快停止。</span><span class="sxs-lookup"><span data-stu-id="3620d-148">The cancellation request means that the operation should stop as soon as possible after any required cleanup is performed.</span></span> <span data-ttu-id="3620d-149">一個取消權杖所指的應該是一個「可取消作業」，但是該作業可能會在程式中實作。</span><span class="sxs-lookup"><span data-stu-id="3620d-149">One cancellation token should refer to one "cancelable operation," however that operation may be implemented in your program.</span></span> <span data-ttu-id="3620d-150">在權杖的 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> 屬性已設定為 `true` 之後，無法被重設為 `false`。</span><span class="sxs-lookup"><span data-stu-id="3620d-150">After the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property of the token has been set to `true`, it cannot be reset to `false`.</span></span> <span data-ttu-id="3620d-151">因此，取消權杖在被取消之後無法重複使用。</span><span class="sxs-lookup"><span data-stu-id="3620d-151">Therefore, cancellation tokens cannot be reused after they have been canceled.</span></span>  
  
 <span data-ttu-id="3620d-152">如果您需要物件取消機制，您可以藉由呼叫 <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> 方法來根據其作業取消機制，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3620d-152">If you require an object cancellation mechanism, you can base it on the operation cancellation mechanism by calling the <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> method, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#2](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/objectcancellation1.cs#2)]
 [!code-vb[Cancellation#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/objectcancellation1.vb#2)]  
  
 <span data-ttu-id="3620d-153">如果物件支援多個並行的可取消作業，會將個別的權杖做為輸入傳遞給每個不同的可取消作業。</span><span class="sxs-lookup"><span data-stu-id="3620d-153">If an object supports more than one concurrent cancelable operation, pass a separate token as input to each distinct cancelable operation.</span></span> <span data-ttu-id="3620d-154">如此一來，可以取消一項作業而不會對其他造成影響。</span><span class="sxs-lookup"><span data-stu-id="3620d-154">That way, one operation can be cancelled without affecting the others.</span></span>  
  
## <a name="listening-and-responding-to-cancellation-requests"></a><span data-ttu-id="3620d-155">接聽並回應取消要求</span><span class="sxs-lookup"><span data-stu-id="3620d-155">Listening and Responding to Cancellation Requests</span></span>  
 <span data-ttu-id="3620d-156">在使用者委派，可取消作業的實作器會決定如何終止作業以取消要求的回應。</span><span class="sxs-lookup"><span data-stu-id="3620d-156">In the user delegate, the implementer of a cancelable operation determines how to terminate the operation in response to a cancellation request.</span></span> <span data-ttu-id="3620d-157">在許多情況下，使用者委派可以只執行任何必要的清除作業，然後立即傳回。</span><span class="sxs-lookup"><span data-stu-id="3620d-157">In many cases, the user delegate can just perform any required cleanup and then return immediately.</span></span>  
  
 <span data-ttu-id="3620d-158">不過，在更複雜的情況下，使用者委派可能需要通知程式庫程式碼已發生取消。</span><span class="sxs-lookup"><span data-stu-id="3620d-158">However, in more complex cases, it might be necessary for the user delegate to notify library code that cancellation has occurred.</span></span> <span data-ttu-id="3620d-159">在這種情況下，終止作業的正確方式是委派要呼叫會導致擲回 <xref:System.OperationCanceledException> 的 <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="3620d-159">In such cases, the correct way to terminate the operation is for the delegate to call the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>, method, which will cause an <xref:System.OperationCanceledException> to be thrown.</span></span> <span data-ttu-id="3620d-160">程式庫程式碼可以在使用者委派執行緒上攔截此例外狀況，並檢查例外狀況的權杖來判斷此例外狀況是否表示合作式取消或一些其他的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="3620d-160">Library code can catch this exception on the user delegate thread and examine the exception's token to determine whether the exception indicates cooperative cancellation or some other exceptional situation.</span></span>  
  
 <span data-ttu-id="3620d-161"><xref:System.Threading.Tasks.Task> 類別以這種方式控制 <xref:System.OperationCanceledException> 。</span><span class="sxs-lookup"><span data-stu-id="3620d-161">The <xref:System.Threading.Tasks.Task> class handles <xref:System.OperationCanceledException> in this way.</span></span> <span data-ttu-id="3620d-162">如需詳細資訊，請參閱[工作取消](../../../docs/standard/parallel-programming/task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="3620d-162">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
### <a name="listening-by-polling"></a><span data-ttu-id="3620d-163">透過輪詢接聽</span><span class="sxs-lookup"><span data-stu-id="3620d-163">Listening by Polling</span></span>  
 <span data-ttu-id="3620d-164">針對長時間執行計算的迴圈或遞迴，您可以透過定期輪詢 <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> 屬性的值來接聽取消要求。</span><span class="sxs-lookup"><span data-stu-id="3620d-164">For long-running computations that loop or recurse, you can listen for a cancellation request by periodically polling the value of the <xref:System.Threading.CancellationToken.IsCancellationRequested%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="3620d-165">如果其值為 `true` ，方法應該清除並盡快結束。</span><span class="sxs-lookup"><span data-stu-id="3620d-165">If its value is `true`, the method should clean up and terminate as quickly as possible.</span></span> <span data-ttu-id="3620d-166">最佳的輪詢頻率取決於應用程式的類型。</span><span class="sxs-lookup"><span data-stu-id="3620d-166">The optimal frequency of polling depends on the type of application.</span></span> <span data-ttu-id="3620d-167">其由開發人員決定任何指定程式的最佳輪詢頻率。</span><span class="sxs-lookup"><span data-stu-id="3620d-167">It is up to the developer to determine the best polling frequency for any given program.</span></span> <span data-ttu-id="3620d-168">輪詢本身不會大幅影響效能。</span><span class="sxs-lookup"><span data-stu-id="3620d-168">Polling itself does not significantly impact performance.</span></span> <span data-ttu-id="3620d-169">下列範例會示範一個輪詢的可行方法。</span><span class="sxs-lookup"><span data-stu-id="3620d-169">The following example shows one possible way to poll.</span></span>  
  
 [!code-csharp[Cancellation#3](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex11.cs#3)]
 [!code-vb[Cancellation#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex11.vb#3)]  
  
 <span data-ttu-id="3620d-170">如需更完整的範例，請參閱[如何：透過輪詢接聽取消要求](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-by-polling.md)。</span><span class="sxs-lookup"><span data-stu-id="3620d-170">For a more complete example, see [How to: Listen for Cancellation Requests by Polling](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-by-polling.md).</span></span>  
  
### <a name="listening-by-registering-a-callback"></a><span data-ttu-id="3620d-171">藉由註冊回呼來接聽</span><span class="sxs-lookup"><span data-stu-id="3620d-171">Listening by Registering a Callback</span></span>  
 <span data-ttu-id="3620d-172">某些作業可能會被封鎖，原因是它們無法及時檢查取消權杖的值。</span><span class="sxs-lookup"><span data-stu-id="3620d-172">Some operations can become blocked in such a way that they cannot check the value of the cancellation token in a timely manner.</span></span> <span data-ttu-id="3620d-173">在這些情況下，您可以註冊一個會在收到取消要求時解鎖該方法的回呼方法。</span><span class="sxs-lookup"><span data-stu-id="3620d-173">For these cases, you can register a callback method that unblocks the method when a cancellation request is received.</span></span>  
  
 <span data-ttu-id="3620d-174"><xref:System.Threading.CancellationToken.Register%2A> 方法會傳回一個專門用於此用途的 <xref:System.Threading.CancellationTokenRegistration> 物件。</span><span class="sxs-lookup"><span data-stu-id="3620d-174">The <xref:System.Threading.CancellationToken.Register%2A> method returns a <xref:System.Threading.CancellationTokenRegistration> object that is used specifically for this purpose.</span></span> <span data-ttu-id="3620d-175">下列範例示範如何使用 <xref:System.Threading.CancellationToken.Register%2A> 方法來取消非同步的 Web 要求。</span><span class="sxs-lookup"><span data-stu-id="3620d-175">The following example shows how to use the <xref:System.Threading.CancellationToken.Register%2A> method to cancel an asynchronous Web request.</span></span>  
  
 [!code-csharp[Cancellation#4](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex4.cs#4)]
 [!code-vb[Cancellation#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex4.vb#4)]  
  
 <span data-ttu-id="3620d-176"><xref:System.Threading.CancellationTokenRegistration> 物件管理執行緒同步處理，並確保回呼會及時在精準的時間點停止執行。</span><span class="sxs-lookup"><span data-stu-id="3620d-176">The <xref:System.Threading.CancellationTokenRegistration> object manages thread synchronization and ensures that the callback will stop executing at a precise point in time.</span></span>  
  
 <span data-ttu-id="3620d-177">為了確保系統的回應能力並避免死結，註冊回呼時必須遵循下列指導方針：</span><span class="sxs-lookup"><span data-stu-id="3620d-177">In order to ensure system responsiveness and to avoid deadlocks, the following guidelines must be followed when registering callbacks:</span></span>  
  
-   <span data-ttu-id="3620d-178">回呼方法應該快速，因為它會以同步方式呼叫，因此對 <xref:System.Threading.CancellationTokenSource.Cancel%2A> 的呼叫在回呼傳回之前不會傳回。</span><span class="sxs-lookup"><span data-stu-id="3620d-178">The callback method should be fast because it is called synchronously and therefore the call to <xref:System.Threading.CancellationTokenSource.Cancel%2A> does not return until the callback returns.</span></span>  
  
-   <span data-ttu-id="3620d-179">如果您在回呼執行時呼叫 <xref:System.Threading.CancellationTokenRegistration.Dispose%2A>，並且您保存了回呼正在等候的鎖定，您的程式可能會發生死結。</span><span class="sxs-lookup"><span data-stu-id="3620d-179">If you call <xref:System.Threading.CancellationTokenRegistration.Dispose%2A> while the callback is running, and you hold a lock that the callback is waiting on, your program can deadlock.</span></span> <span data-ttu-id="3620d-180">在 `Dispose` 傳回後，您可以釋放回呼所需的任何資源。</span><span class="sxs-lookup"><span data-stu-id="3620d-180">After `Dispose` returns, you can free any resources required by the callback.</span></span>  
  
-   <span data-ttu-id="3620d-181">回呼不應該執行任何手動執行緒或 <xref:System.Threading.SynchronizationContext> 使用方式於回呼中。</span><span class="sxs-lookup"><span data-stu-id="3620d-181">Callbacks should not perform any manual thread or <xref:System.Threading.SynchronizationContext> usage in a callback.</span></span> <span data-ttu-id="3620d-182">如果回呼必須在特定執行緒上執行，請使用 <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> 建構函式，它可讓您指定目標 syncContext 為作用中的 <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3620d-182">If a callback must run on a particular thread, use the <xref:System.Threading.CancellationTokenRegistration?displayProperty=nameWithType> constructor that enables you to specify that the target syncContext is the active <xref:System.Threading.SynchronizationContext.Current%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3620d-183">於回呼中執行手動執行緒可能會導致死結。</span><span class="sxs-lookup"><span data-stu-id="3620d-183">Performing manual threading in a callback can cause deadlock.</span></span>  
  
 <span data-ttu-id="3620d-184">如需更完整的範例，請參閱[如何：註冊用於取消要求的回呼](../../../docs/standard/threading/how-to-register-callbacks-for-cancellation-requests.md)。</span><span class="sxs-lookup"><span data-stu-id="3620d-184">For a more complete example, see [How to: Register Callbacks for Cancellation Requests](../../../docs/standard/threading/how-to-register-callbacks-for-cancellation-requests.md).</span></span>  
  
### <a name="listening-by-using-a-wait-handle"></a><span data-ttu-id="3620d-185">使用等候控制代碼來接聽</span><span class="sxs-lookup"><span data-stu-id="3620d-185">Listening by Using a Wait Handle</span></span>  
 <span data-ttu-id="3620d-186">當可取消的作業等候同步處理基本類型，例如 <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> 或 <xref:System.Threading.Semaphore?displayProperty=nameWithType>，而可以封鎖可取消作業時，您可以使用 <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> 屬性，來啟用事件以等候前述兩種事件以及取消要求。</span><span class="sxs-lookup"><span data-stu-id="3620d-186">When a cancelable operation can block while it waits on a synchronization primitive such as a <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType> or <xref:System.Threading.Semaphore?displayProperty=nameWithType>, you can use the <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType> property to enable the operation to wait on both the event and the cancellation request.</span></span> <span data-ttu-id="3620d-187">取消權杖的等候控制代碼會被通知以回應取消要求，而且方法可以使用 <xref:System.Threading.WaitHandle.WaitAny%2A> 方法被傳回的值，以判斷它是否是被通知的取消權杖。</span><span class="sxs-lookup"><span data-stu-id="3620d-187">The wait handle of the cancellation token will become signaled in response to a cancellation request, and the method can use the return value of the <xref:System.Threading.WaitHandle.WaitAny%2A> method to determine whether it was the cancellation token that signaled.</span></span> <span data-ttu-id="3620d-188">作業可以就在那時結束，或在適當的情況擲回 <xref:System.OperationCanceledException> 。</span><span class="sxs-lookup"><span data-stu-id="3620d-188">The operation can then just exit, or throw a <xref:System.OperationCanceledException>, as appropriate.</span></span>  
  
 [!code-csharp[Cancellation#5](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex9.cs#5)]
 [!code-vb[Cancellation#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex9.vb#5)]  
  
 <span data-ttu-id="3620d-189">標記 [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] 、 <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> 和 <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> 的新程式碼中兩者都能以其 `Wait` 方法支援新的取消架構。</span><span class="sxs-lookup"><span data-stu-id="3620d-189">In new code that targets the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], <xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> and <xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> both support the new cancellation framework in their `Wait` methods.</span></span> <span data-ttu-id="3620d-190">您可以傳遞 <xref:System.Threading.CancellationToken> 給該方法，並且當要求取消作業時，事件會甦醒並擲回 <xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="3620d-190">You can pass the <xref:System.Threading.CancellationToken> to the method, and when the cancellation is requested, the event wakes up and throws an <xref:System.OperationCanceledException>.</span></span>  
  
 [!code-csharp[Cancellation#6](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex10.cs#6)]
 [!code-vb[Cancellation#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex10.vb#6)]  
  
 <span data-ttu-id="3620d-191">如需更完整的範例，請參閱[如何：透過等候處理來接聽取消要求](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-that-have-wait-handles.md)。</span><span class="sxs-lookup"><span data-stu-id="3620d-191">For a more complete example, see [How to: Listen for Cancellation Requests That Have Wait Handles](../../../docs/standard/threading/how-to-listen-for-cancellation-requests-that-have-wait-handles.md).</span></span>  
  
### <a name="listening-to-multiple-tokens-simultaneously"></a><span data-ttu-id="3620d-192">同時接聽多個權杖</span><span class="sxs-lookup"><span data-stu-id="3620d-192">Listening to Multiple Tokens Simultaneously</span></span>  
 <span data-ttu-id="3620d-193">在某些情況下，接聽程式可能必須同時接聽多個取消權杖。</span><span class="sxs-lookup"><span data-stu-id="3620d-193">In some cases, a listener may have to listen to multiple cancellation tokens simultaneously.</span></span> <span data-ttu-id="3620d-194">例如，可取消的作業可能需要監視內部的取消權杖，除了在外部做為引數傳遞至方法參數的權杖。</span><span class="sxs-lookup"><span data-stu-id="3620d-194">For example, a cancelable operation may have to monitor an internal cancellation token in addition to a token passed in externally as an argument to a method parameter.</span></span> <span data-ttu-id="3620d-195">若要達成此目的，建立連結的權杖來源，它可以將兩個或多個權杖聯結到一個權杖，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="3620d-195">To accomplish this, create a linked token source that can join two or more tokens into one token, as shown in the following example.</span></span>  
  
 [!code-csharp[Cancellation#7](../../../samples/snippets/csharp/VS_Snippets_Misc/cancellation/cs/cancellationex13.cs#7)]
 [!code-vb[Cancellation#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/cancellation/vb/cancellationex13.vb#7)]  
  
 <span data-ttu-id="3620d-196">請注意，當您完成聯結後，必須在連結的權杖來源上呼叫 `Dispose` 。</span><span class="sxs-lookup"><span data-stu-id="3620d-196">Notice that you must call `Dispose` on the linked token source when you are done with it.</span></span> <span data-ttu-id="3620d-197">如需更完整的範例，請參閱[如何：接聽多個取消要求](../../../docs/standard/threading/how-to-listen-for-multiple-cancellation-requests.md)。</span><span class="sxs-lookup"><span data-stu-id="3620d-197">For a more complete example, see [How to: Listen for Multiple Cancellation Requests](../../../docs/standard/threading/how-to-listen-for-multiple-cancellation-requests.md).</span></span>  
  
## <a name="cooperation-between-library-code-and-user-code"></a><span data-ttu-id="3620d-198">程式庫程式碼和使用者程式碼之間的合作</span><span class="sxs-lookup"><span data-stu-id="3620d-198">Cooperation Between Library Code and User Code</span></span>  
 <span data-ttu-id="3620d-199">統一的取消架構可讓程式庫程式碼取消使用者程式碼，並且讓使用者程式碼以合作方式取消程式庫程式碼。</span><span class="sxs-lookup"><span data-stu-id="3620d-199">The unified cancellation framework makes it possible for library code to cancel user code, and for user code to cancel library code in a cooperative manner.</span></span> <span data-ttu-id="3620d-200">平滑合作取決於每一邊都遵循下列方針：</span><span class="sxs-lookup"><span data-stu-id="3620d-200">Smooth cooperation depends on each side following these guidelines:</span></span>  
  
-   <span data-ttu-id="3620d-201">如果程式庫程式碼提供取消作業，它也應該提供一個接受外部取消權杖而進一步讓使用者程式碼可以要求取消的公用方法。</span><span class="sxs-lookup"><span data-stu-id="3620d-201">If library code provides cancelable operations, it should also provide public methods that accept an external cancellation token so that user code can request cancellation.</span></span>  
  
-   <span data-ttu-id="3620d-202">如果程式庫程式碼呼叫使用者程式碼，程式庫程式碼應該將 OperationCanceledException(externalToken) 解譯為*合作式取消*，且不一定解譯為失敗例外狀況。</span><span class="sxs-lookup"><span data-stu-id="3620d-202">If library code calls into user code, the library code should interpret an OperationCanceledException(externalToken) as *cooperative cancellation*, and not necessarily as a failure exception.</span></span>  
  
-   <span data-ttu-id="3620d-203">使用者委派應該及時嘗試回應來自程式庫程式碼的取消要求。</span><span class="sxs-lookup"><span data-stu-id="3620d-203">User-delegates should attempt to respond to cancellation requests from library code in a timely manner.</span></span>  
  
 <span data-ttu-id="3620d-204"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 和 <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> 是遵循這些指導方針之類別的範例。</span><span class="sxs-lookup"><span data-stu-id="3620d-204"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Linq.ParallelEnumerable?displayProperty=nameWithType> are examples of classes that follows these guidelines.</span></span> <span data-ttu-id="3620d-205">如需詳細資訊，請參閱[工作取消](../../../docs/standard/parallel-programming/task-cancellation.md)和[如何：取消 PLINQ 查詢](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md)。</span><span class="sxs-lookup"><span data-stu-id="3620d-205">For more information, see [Task Cancellation](../../../docs/standard/parallel-programming/task-cancellation.md)and [How to: Cancel a PLINQ Query](../../../docs/standard/parallel-programming/how-to-cancel-a-plinq-query.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3620d-206">請參閱</span><span class="sxs-lookup"><span data-stu-id="3620d-206">See Also</span></span>  
 [<span data-ttu-id="3620d-207">Managed 執行緒處理的基本概念</span><span class="sxs-lookup"><span data-stu-id="3620d-207">Managed Threading Basics</span></span>](../../../docs/standard/threading/managed-threading-basics.md)
