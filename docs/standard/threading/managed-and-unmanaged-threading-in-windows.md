---
title: Windows 中的 Managed 和 Unmanaged 執行緒處理
ms.date: 10/24/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], unmanaged
- threading [.NET Framework], managed
- threading [.NET], managed
- threads and fibers [.NET]
- managed threading
ms.assetid: 4fb6452f-c071-420d-9e71-da16dee7a1eb
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 04ef2ea6bf9d10baabea39133b2e0a9a72a6ce4f
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54674842"
---
# <a name="managed-and-unmanaged-threading-in-windows"></a><span data-ttu-id="7da39-102">Windows 中的受控與非受控執行緒處理</span><span class="sxs-lookup"><span data-stu-id="7da39-102">Managed and unmanaged threading in Windows</span></span>

<span data-ttu-id="7da39-103">所有執行緒的管理都會透過 <xref:System.Threading.Thread> 類別進行，包括 Common Language Runtime 建立的執行緒，以及在執行階段外部建立但進入 Managed 環境執行程式碼的執行緒。</span><span class="sxs-lookup"><span data-stu-id="7da39-103">Management of all threads is done through the <xref:System.Threading.Thread> class, including threads created by the common language runtime and those created outside the runtime that enter the managed environment to execute code.</span></span> <span data-ttu-id="7da39-104">執行階段會監視在其處理序中所有曾在 Managed 執行環境中執行程式碼的執行緒，</span><span class="sxs-lookup"><span data-stu-id="7da39-104">The runtime monitors all the threads in its process that have ever executed code within the managed execution environment.</span></span> <span data-ttu-id="7da39-105">但不會追蹤其他任何執行緒。</span><span class="sxs-lookup"><span data-stu-id="7da39-105">It does not track any other threads.</span></span> <span data-ttu-id="7da39-106">執行緒可透過 COM Interop (因為執行階段會將 Managed 物件當做 COM 物件公開給 Unmanaged 世界)、COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) 函式和平台叫用來進入 Managed 執行環境。</span><span class="sxs-lookup"><span data-stu-id="7da39-106">Threads can enter the managed execution environment through COM interop (because the runtime exposes managed objects as COM objects to the unmanaged world), the COM [DllGetClassObject](/windows/desktop/api/combaseapi/nf-combaseapi-dllgetclassobject) function, and platform invoke.</span></span>  
  
 <span data-ttu-id="7da39-107">當 Unmanaged 執行緒透過類似 COM 可呼叫包裝函式來進入執行階段時，系統會檢查此執行緒的執行緒本機存放區，以尋找內部 Managed <xref:System.Threading.Thread> 物件。</span><span class="sxs-lookup"><span data-stu-id="7da39-107">When an unmanaged thread enters the runtime through, for example, a COM callable wrapper, the system checks the thread-local store of that thread to look for an internal managed <xref:System.Threading.Thread> object.</span></span> <span data-ttu-id="7da39-108">如果找到一個物件，表示執行階段已感知此執行緒。</span><span class="sxs-lookup"><span data-stu-id="7da39-108">If one is found, the runtime is already aware of this thread.</span></span> <span data-ttu-id="7da39-109">但是，如果找不到任何 <xref:System.Threading.Thread> 物件，執行階段會建置新物件並安裝到此執行緒的執行緒本機存放區中。</span><span class="sxs-lookup"><span data-stu-id="7da39-109">If it cannot find one, however, the runtime builds a new <xref:System.Threading.Thread> object and installs it in the thread-local store of that thread.</span></span>  
  
 <span data-ttu-id="7da39-110">在 Managed 執行緒中， <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> 是穩定的 Managed 執行緒識別。</span><span class="sxs-lookup"><span data-stu-id="7da39-110">In managed threading, <xref:System.Threading.Thread.GetHashCode%2A?displayProperty=nameWithType> is the stable managed thread identification.</span></span> <span data-ttu-id="7da39-111">在執行緒的存留期間，此值不會與其他任何執行緒的值相衝突，不論您是從哪一個應用程式定義域取得此值。</span><span class="sxs-lookup"><span data-stu-id="7da39-111">For the lifetime of your thread, it will not collide with the value from any other thread, regardless of the application domain from which you obtain this value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7da39-112">作業系統的 **ThreadId** 與 Managed 執行緒之間沒有固定的關係，因為未受管理的主機可控制 Managed 執行緒與 Unmanaged 執行緒之間的關係。</span><span class="sxs-lookup"><span data-stu-id="7da39-112">An operating-system **ThreadId** has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="7da39-113">具體來說，精密的主機可使用 Fiber 應用程式開發介面，對同一個作業系統執行緒排程許多 Managed 執行緒，或是在不同的作業系統執行緒之間移動 Managed 執行緒。</span><span class="sxs-lookup"><span data-stu-id="7da39-113">Specifically, a sophisticated host can use the Fiber API to schedule many managed threads against the same operating system thread, or to move a managed thread among different operating system threads.</span></span>  
  
## <a name="mapping-from-win32-threading-to-managed-threading"></a><span data-ttu-id="7da39-114">從 Win32 執行緒處理對應至受控執行緒處理</span><span class="sxs-lookup"><span data-stu-id="7da39-114">Mapping from Win32 threading to managed threading</span></span>

 <span data-ttu-id="7da39-115">下表將 Win32 執行緒項目對應至其近似的執行階段對等項目。</span><span class="sxs-lookup"><span data-stu-id="7da39-115">The following table maps Win32 threading elements to their approximate runtime equivalent.</span></span> <span data-ttu-id="7da39-116">請注意，此對應並不代表功能完全一樣。</span><span class="sxs-lookup"><span data-stu-id="7da39-116">Note that this mapping does not represent identical functionality.</span></span> <span data-ttu-id="7da39-117">例如， **TerminateThread** 不會執行 **finally** 子句或釋放資源，並且無法防止。</span><span class="sxs-lookup"><span data-stu-id="7da39-117">For example, **TerminateThread** does not execute **finally** clauses or free up resources, and cannot be prevented.</span></span> <span data-ttu-id="7da39-118">但是， <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> 會執行所有復原程式碼、回收所有資源，並且可使用 <xref:System.Threading.Thread.ResetAbort%2A>加以拒絕。</span><span class="sxs-lookup"><span data-stu-id="7da39-118">However, <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> executes all your rollback code, reclaims all the resources, and can be denied using <xref:System.Threading.Thread.ResetAbort%2A>.</span></span> <span data-ttu-id="7da39-119">在揣測功能之前，請務必仔細閱讀相關文件。</span><span class="sxs-lookup"><span data-stu-id="7da39-119">Be sure to read the documentation closely before making assumptions about functionality.</span></span>  
  
|<span data-ttu-id="7da39-120">在 Win32 中</span><span class="sxs-lookup"><span data-stu-id="7da39-120">In Win32</span></span>|<span data-ttu-id="7da39-121">在 Common Language Runtime 中</span><span class="sxs-lookup"><span data-stu-id="7da39-121">In the common language runtime</span></span>|  
|--------------|------------------------------------|  
|<span data-ttu-id="7da39-122">**CreateThread**</span><span class="sxs-lookup"><span data-stu-id="7da39-122">**CreateThread**</span></span>|<span data-ttu-id="7da39-123">**Thread** 和 <xref:System.Threading.ThreadStart>的組合</span><span class="sxs-lookup"><span data-stu-id="7da39-123">Combination of **Thread** and <xref:System.Threading.ThreadStart></span></span>|  
|<span data-ttu-id="7da39-124">**TerminateThread**</span><span class="sxs-lookup"><span data-stu-id="7da39-124">**TerminateThread**</span></span>|<xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-125">**SuspendThread**</span><span class="sxs-lookup"><span data-stu-id="7da39-125">**SuspendThread**</span></span>|<xref:System.Threading.Thread.Suspend%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-126">**ResumeThread**</span><span class="sxs-lookup"><span data-stu-id="7da39-126">**ResumeThread**</span></span>|<xref:System.Threading.Thread.Resume%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-127">**Sleep**</span><span class="sxs-lookup"><span data-stu-id="7da39-127">**Sleep**</span></span>|<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-128">執行緒控制代碼上的**WaitForSingleObject** </span><span class="sxs-lookup"><span data-stu-id="7da39-128">**WaitForSingleObject** on the thread handle</span></span>|<xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-129">**ExitThread**</span><span class="sxs-lookup"><span data-stu-id="7da39-129">**ExitThread**</span></span>|<span data-ttu-id="7da39-130">沒有對等項目</span><span class="sxs-lookup"><span data-stu-id="7da39-130">No equivalent</span></span>|  
|<span data-ttu-id="7da39-131">**GetCurrentThread**</span><span class="sxs-lookup"><span data-stu-id="7da39-131">**GetCurrentThread**</span></span>|<xref:System.Threading.Thread.CurrentThread%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-132">**SetThreadPriority**</span><span class="sxs-lookup"><span data-stu-id="7da39-132">**SetThreadPriority**</span></span>|<xref:System.Threading.Thread.Priority%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-133">沒有對等項目</span><span class="sxs-lookup"><span data-stu-id="7da39-133">No equivalent</span></span>|<xref:System.Threading.Thread.Name%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-134">沒有對等項目</span><span class="sxs-lookup"><span data-stu-id="7da39-134">No equivalent</span></span>|<xref:System.Threading.Thread.IsBackground%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="7da39-135">近似 **CoInitializeEx** (OLE32.DLL)</span><span class="sxs-lookup"><span data-stu-id="7da39-135">Close to **CoInitializeEx** (OLE32.DLL)</span></span>|<xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>|  
  
## <a name="managed-threads-and-com-apartments"></a><span data-ttu-id="7da39-136">受控執行緒與 COM Apartment</span><span class="sxs-lookup"><span data-stu-id="7da39-136">Managed threads and COM apartments</span></span>

<span data-ttu-id="7da39-137">可標記 Managed 執行緒，以表示它將裝載 [單一執行緒](/windows/desktop/com/single-threaded-apartments) 或 [多執行緒](/windows/desktop/com/multithreaded-apartments) Apartment。</span><span class="sxs-lookup"><span data-stu-id="7da39-137">A managed thread can be marked to indicate that it will host a [single-threaded](/windows/desktop/com/single-threaded-apartments) or [multithreaded](/windows/desktop/com/multithreaded-apartments) apartment.</span></span> <span data-ttu-id="7da39-138">(如需 COM 執行緒架構的詳細資訊，請參閱[處理序、執行緒和 Apartment](/windows/desktop/com/processes--threads--and-apartments) \(英文\))。<xref:System.Threading.Thread.GetApartmentState%2A> 類別的 <xref:System.Threading.Thread.SetApartmentState%2A>、<xref:System.Threading.Thread.TrySetApartmentState%2A> 和 <xref:System.Threading.Thread> 方法會傳回並指派執行緒的 Apartment 狀態。</span><span class="sxs-lookup"><span data-stu-id="7da39-138">(For more information on the COM threading architecture, see [Processes, Threads, and Apartments](/windows/desktop/com/processes--threads--and-apartments).) The <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods of the <xref:System.Threading.Thread> class return and assign the apartment state of a thread.</span></span> <span data-ttu-id="7da39-139">如果尚未設定此狀態，則 <xref:System.Threading.Thread.GetApartmentState%2A> 會傳回 <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="7da39-139">If the state has not been set, <xref:System.Threading.Thread.GetApartmentState%2A> returns <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7da39-140">只有在執行緒處於 <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> 狀態時，才能設定此屬性；每個執行緒只能設定此屬性一次。</span><span class="sxs-lookup"><span data-stu-id="7da39-140">The property can be set only when the thread is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state; it can be set only once for a thread.</span></span>  
  
 <span data-ttu-id="7da39-141">如果啟動執行緒之前未設定 Apartment 狀態，則會將執行緒初始化為多執行緒 Apartment (MTA)。</span><span class="sxs-lookup"><span data-stu-id="7da39-141">If the apartment state is not set before the thread is started, the thread is initialized as a multithreaded apartment (MTA).</span></span> <span data-ttu-id="7da39-142">受到 <xref:System.Threading.ThreadPool> 控制的完成項執行緒及所有執行緒都是 MTA。</span><span class="sxs-lookup"><span data-stu-id="7da39-142">The finalizer thread and all threads controlled by <xref:System.Threading.ThreadPool> are MTA.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="7da39-143">對於應用程式啟動程式碼而言，控制 Apartment 狀態的唯一方式是將 <xref:System.MTAThreadAttribute> 或 <xref:System.STAThreadAttribute> 套用至進入點程序。</span><span class="sxs-lookup"><span data-stu-id="7da39-143">For application startup code, the only way to control apartment state is to apply the <xref:System.MTAThreadAttribute> or the <xref:System.STAThreadAttribute> to the entry point procedure.</span></span> <span data-ttu-id="7da39-144">在 .NET Framework 1.0 和 1.1 中， <xref:System.Threading.Thread.ApartmentState%2A> 屬性可設定為程式碼的第一行。</span><span class="sxs-lookup"><span data-stu-id="7da39-144">In the .NET Framework 1.0 and 1.1, the <xref:System.Threading.Thread.ApartmentState%2A> property can be set as the first line of code.</span></span> <span data-ttu-id="7da39-145">在 .NET Framework 2.0 中則不允許這麼做。</span><span class="sxs-lookup"><span data-stu-id="7da39-145">This is not permitted in the .NET Framework 2.0.</span></span>  
  
 <span data-ttu-id="7da39-146">公開至 COM 之 Managed 物件的行為會像是已彙總無限制執行緒封送處理器。</span><span class="sxs-lookup"><span data-stu-id="7da39-146">Managed objects that are exposed to COM behave as if they had aggregated the free-threaded marshaler.</span></span> <span data-ttu-id="7da39-147">換句話說，您可以使用無限制執行緒方式從任何 COM Apartment 呼叫 Managed 物件。</span><span class="sxs-lookup"><span data-stu-id="7da39-147">In other words, they can be called from any COM apartment in a free-threaded manner.</span></span> <span data-ttu-id="7da39-148">只有衍生自 <xref:System.EnterpriseServices.ServicedComponent> 或 <xref:System.Runtime.InteropServices.StandardOleMarshalObject> 的 Managed 物件才不會表現出無限制執行緒行為。</span><span class="sxs-lookup"><span data-stu-id="7da39-148">The only managed objects that do not exhibit this free-threaded behavior are those objects that derive from <xref:System.EnterpriseServices.ServicedComponent> or <xref:System.Runtime.InteropServices.StandardOleMarshalObject>.</span></span>  
  
 <span data-ttu-id="7da39-149">在 Managed 世界中，除非您使用內容及內容繫結 Managed 執行個體，否則不支援 <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> 。</span><span class="sxs-lookup"><span data-stu-id="7da39-149">In the managed world, there is no support for the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> unless you use contexts and context-bound managed instances.</span></span> <span data-ttu-id="7da39-150">如果您正在使用 Enterprise Services，則您的物件必須衍生自 <xref:System.EnterpriseServices.ServicedComponent> (其本身係衍生自 <xref:System.ContextBoundObject>)。</span><span class="sxs-lookup"><span data-stu-id="7da39-150">If you are using Enterprise Services, then your object must derive from <xref:System.EnterpriseServices.ServicedComponent> (which is itself derived from <xref:System.ContextBoundObject>).</span></span>  
  
 <span data-ttu-id="7da39-151">當 Managed 程式碼呼叫 COM 物件時，一律會遵循 COM 規則。</span><span class="sxs-lookup"><span data-stu-id="7da39-151">When managed code calls out to COM objects, it always follows COM rules.</span></span> <span data-ttu-id="7da39-152">換句話說，程式碼會依照 OLE32 指示，透過 COM Apartment Proxy 和 COM+ 1.0 內容包裝函式來呼叫。</span><span class="sxs-lookup"><span data-stu-id="7da39-152">In other words, it calls through COM apartment proxies and COM+ 1.0 context wrappers as dictated by OLE32.</span></span>  
  
## <a name="blocking-issues"></a><span data-ttu-id="7da39-153">封鎖問題</span><span class="sxs-lookup"><span data-stu-id="7da39-153">Blocking issues</span></span>  

<span data-ttu-id="7da39-154">如果執行緒對作業系統發出 Unmanaged 呼叫，而此呼叫在 Unmanaged 程式碼中封鎖了執行緒，則執行階段將不會針對 <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> 或 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>取得其控制權。</span><span class="sxs-lookup"><span data-stu-id="7da39-154">If a thread makes an unmanaged call into the operating system that has blocked the thread in unmanaged code, the runtime will not take control of it for <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> or <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7da39-155">如果是 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>，執行階段會為 **Abort** 標記執行緒，並在它重新進入 Managed 程式碼時取得其控制權。</span><span class="sxs-lookup"><span data-stu-id="7da39-155">In the case of <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>, the runtime marks the thread for **Abort** and takes control of it when it re-enters managed code.</span></span> <span data-ttu-id="7da39-156">建議您使用 Managed 封鎖，而不要使用 Unmanaged 封鎖。</span><span class="sxs-lookup"><span data-stu-id="7da39-156">It is preferable for you to use managed blocking rather than unmanaged blocking.</span></span> <span data-ttu-id="7da39-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>、<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>等對於 <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> 和 <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>都會有回應。</span><span class="sxs-lookup"><span data-stu-id="7da39-157"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>,<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>, <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, <xref:System.Threading.Thread.Join%2A?displayProperty=nameWithType>, <xref:System.GC.WaitForPendingFinalizers%2A?displayProperty=nameWithType>, and so on are all responsive to <xref:System.Threading.Thread.Interrupt%2A?displayProperty=nameWithType> and to <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7da39-158">此外，如果執行緒位在單一執行緒 Apartment 中，則當執行緒被封鎖時，所有這些 Managed 封鎖作業都會正確提取 Apartment 中的訊息。</span><span class="sxs-lookup"><span data-stu-id="7da39-158">Also, if your thread is in a single-threaded apartment, all these managed blocking operations will correctly pump messages in your apartment while your thread is blocked.</span></span>  

## <a name="threads-and-fibers"></a><span data-ttu-id="7da39-159">執行緒與 Fiber</span><span class="sxs-lookup"><span data-stu-id="7da39-159">Threads and fibers</span></span>

<span data-ttu-id="7da39-160">.NET 執行緒模式不支援 [Fiber](/windows/desktop/procthread/fibers)。</span><span class="sxs-lookup"><span data-stu-id="7da39-160">The .NET threading model does not support [fibers](/windows/desktop/procthread/fibers).</span></span> <span data-ttu-id="7da39-161">您不應該呼叫至使用 Fiber 實作的任何非受控函式。</span><span class="sxs-lookup"><span data-stu-id="7da39-161">You should not call into any unmanaged function that is implemented by using fibers.</span></span> <span data-ttu-id="7da39-162">此類呼叫可能會導致 .NET 執行階段當掉。</span><span class="sxs-lookup"><span data-stu-id="7da39-162">Such calls may result in a crash of the .NET runtime.</span></span>

## <a name="see-also"></a><span data-ttu-id="7da39-163">另請參閱</span><span class="sxs-lookup"><span data-stu-id="7da39-163">See also</span></span>

- <xref:System.Threading.Thread.ApartmentState%2A?displayProperty=nameWithType>
- <xref:System.Threading.ThreadState>
- <xref:System.EnterpriseServices.ServicedComponent>
- <xref:System.Threading.Thread>
- <xref:System.Threading.Monitor>
