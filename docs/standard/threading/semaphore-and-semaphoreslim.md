---
title: 旗號與 SemaphoreSlim
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- counting semaphores
- semaphores
- threading [.NET Framework], cross-process synchronization
- Semaphore class, about Semaphore class
- SemaphoreSlim class, about SemaphoreSlim class
- threading [.NET Framework], Semaphore class
ms.assetid: 7722a333-b974-47a2-a7c0-f09097fb644e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: e7d7f791fbc68a526f428f4f79d9b379a23ca771
ms.sourcegitcommit: c93fd5139f9efcf6db514e3474301738a6d1d649
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/28/2018
ms.locfileid: "50199483"
---
# <a name="semaphore-and-semaphoreslim"></a><span data-ttu-id="1d3a2-102">旗號與 SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="1d3a2-102">Semaphore and SemaphoreSlim</span></span>
<span data-ttu-id="1d3a2-103"><xref:System.Threading.Semaphore?displayProperty=nameWithType> 類別代表具名 (系統) 或區域旗號。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-103">The <xref:System.Threading.Semaphore?displayProperty=nameWithType> class represents a named (systemwide) or local semaphore.</span></span> <span data-ttu-id="1d3a2-104">它是 Win32 旗號物件周圍的精簡型包裝函式。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-104">It is a thin wrapper around the Win32 semaphore object.</span></span> <span data-ttu-id="1d3a2-105">Win32 旗號是計算的旗號，可以用來控制資源集區的存取。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-105">Win32 semaphores are counting semaphores, which can be used to control access to a pool of resources.</span></span>  
  
 <span data-ttu-id="1d3a2-106"><xref:System.Threading.SemaphoreSlim> 類別表示輕量型、快速的旗號，可以用於在預期等候時間較短的單一處理序內進行等候。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-106">The <xref:System.Threading.SemaphoreSlim> class represents a lightweight, fast semaphore that can be used for waiting within a single process when wait times are expected to be very short.</span></span> <span data-ttu-id="1d3a2-107"><xref:System.Threading.SemaphoreSlim> 會盡可能依賴通用語言執行階段 (CLR) 所提供的同步處理原始物件。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-107"><xref:System.Threading.SemaphoreSlim> relies as much as possible on synchronization primitives provided by the common language runtime (CLR).</span></span> <span data-ttu-id="1d3a2-108">不過，它也提供延遲初始化、核心架構的等候控制代碼，視需要支援等待多個旗號。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-108">However, it also provides lazily initialized, kernel-based wait handles as necessary to support waiting on multiple semaphores.</span></span> <span data-ttu-id="1d3a2-109"><xref:System.Threading.SemaphoreSlim> 也支援使用取消語彙基元，但它不支援具名旗號或使用等候控制代碼進行同步處理。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-109"><xref:System.Threading.SemaphoreSlim> also supports the use of cancellation tokens, but it does not support named semaphores or the use of a wait handle for synchronization.</span></span>  
  
## <a name="managing-a-limited-resource"></a><span data-ttu-id="1d3a2-110">管理有限的資源</span><span class="sxs-lookup"><span data-stu-id="1d3a2-110">Managing a Limited Resource</span></span>  
 <span data-ttu-id="1d3a2-111">執行緒進入旗號的方法是呼叫 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法，它是繼承自 <xref:System.Threading.WaitHandle> 類別 (如果是 <xref:System.Threading.Semaphore?displayProperty=nameWithType> 物件)，或是 <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> 或 <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> 方法 (如果是 <xref:System.Threading.SemaphoreSlim> 物件)。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-111">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, in the case of a <xref:System.Threading.Semaphore?displayProperty=nameWithType> object, or the <xref:System.Threading.SemaphoreSlim.Wait%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.WaitAsync%2A?displayProperty=nameWithType> method, in the case of a <xref:System.Threading.SemaphoreSlim> object.</span></span> <span data-ttu-id="1d3a2-112">當呼叫傳回時，旗號計數會遞減。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-112">When the call returns, the count on the semaphore is decremented.</span></span> <span data-ttu-id="1d3a2-113">當執行緒要求進入，而計數為零時，則執行緒會封鎖。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-113">When a thread requests entry and the count is zero, the thread blocks.</span></span> <span data-ttu-id="1d3a2-114">當執行緒透過呼叫 <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> 或 <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> 方法釋放旗號時，會允許封鎖的執行緒進入。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-114">As threads release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> method, blocked threads are allowed to enter.</span></span> <span data-ttu-id="1d3a2-115">封鎖的執行緒進入旗號時沒有任何保證的順序，例如先進先出 (FIFO) 或後進先出 (LIFO)。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-115">There is no guaranteed order, such as first-in, first-out (FIFO) or last-in, first-out (LIFO), for blocked threads to enter the semaphore.</span></span>  
  
 <span data-ttu-id="1d3a2-116">執行緒可以重複呼叫 <xref:System.Threading.Semaphore?displayProperty=nameWithType> 物件的 <xref:System.Threading.WaitHandle.WaitOne%2A> 方法或 <xref:System.Threading.SemaphoreSlim> 物件的 <xref:System.Threading.SemaphoreSlim.Wait%2A> 方法，多次進入旗號。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-116">A thread can enter the semaphore multiple times by calling the <xref:System.Threading.Semaphore?displayProperty=nameWithType> object's <xref:System.Threading.WaitHandle.WaitOne%2A> method or the  <xref:System.Threading.SemaphoreSlim> object's <xref:System.Threading.SemaphoreSlim.Wait%2A> method repeatedly.</span></span> <span data-ttu-id="1d3a2-117">若要釋放旗號，執行緒可以呼叫 <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> 或 <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> 方法多載相同的次數，或呼叫 <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> 或 <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> 方法多載，並指定要釋放的項目數。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-117">To release the semaphore, the thread can either call the <xref:System.Threading.Semaphore.Release?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release?displayProperty=nameWithType> method overload the same number of times, or call the <xref:System.Threading.Semaphore.Release%28System.Int32%29?displayProperty=nameWithType> or <xref:System.Threading.SemaphoreSlim.Release%28System.Int32%29?displayProperty=nameWithType> method overload and specify the number of entries to be released.</span></span>  
  
### <a name="semaphores-and-thread-identity"></a><span data-ttu-id="1d3a2-118">旗號與執行緒識別</span><span class="sxs-lookup"><span data-stu-id="1d3a2-118">Semaphores and Thread Identity</span></span>  
 <span data-ttu-id="1d3a2-119">兩種旗號類型不會在 <xref:System.Threading.WaitHandle.WaitOne%2A>、<xref:System.Threading.SemaphoreSlim.Wait%2A>、<xref:System.Threading.Semaphore.Release%2A> 和 <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> 方法的呼叫上強制執行執行緒識別。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-119">The two semaphore types do not enforce thread identity on calls to the <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.SemaphoreSlim.Wait%2A>, <xref:System.Threading.Semaphore.Release%2A>, and <xref:System.Threading.SemaphoreSlim.Release%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="1d3a2-120">例如，一個旗號的常見使用案例，其涉及一個產生者執行緒和一個消費者執行緒，之中一個執行緒始終都會遞增旗號計數，另一個則始終遞減它。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-120">For example, a common usage scenario for semaphores involves a producer thread and a consumer thread, with one thread always incrementing the semaphore count and the other always decrementing it.</span></span>  
  
 <span data-ttu-id="1d3a2-121">程式設計人員要負責確保執行緒不會釋放旗號太多次。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-121">It is the programmer's responsibility to ensure that a thread does not release the semaphore too many times.</span></span> <span data-ttu-id="1d3a2-122">例如，假設某個旗號的最大計數為 2，且執行緒 A 和執行緒 B 都進入旗號。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-122">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="1d3a2-123">如果執行緒 B 中的程式設計錯誤導致呼叫 `Release` 兩次，兩次呼叫都會成功。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-123">If a programming error in thread B causes it to call  `Release` twice, both calls succeed.</span></span> <span data-ttu-id="1d3a2-124">此時旗號計數已滿，當執行緒 A 終於呼叫 `Release` 時，就會擲回 <xref:System.Threading.SemaphoreFullException>。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-124">The count on the semaphore is full, and when thread A eventually calls `Release`, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
## <a name="named-semaphores"></a><span data-ttu-id="1d3a2-125">具名旗號</span><span class="sxs-lookup"><span data-stu-id="1d3a2-125">Named Semaphores</span></span>  
 <span data-ttu-id="1d3a2-126">Windows 作業系統允許有名稱的旗號。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-126">The Windows operating system allows semaphores to have names.</span></span> <span data-ttu-id="1d3a2-127">具名旗號是全系統性的。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-127">A named semaphore is system wide.</span></span> <span data-ttu-id="1d3a2-128">也就是說，一旦建立具名旗號，所有處理序中的所有執行緒都可看到它。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-128">That is, once the named semaphore is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="1d3a2-129">因此，具名旗號可以用來同步處理序及執行緒的活動。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-129">Thus, named semaphore can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="1d3a2-130">您可以建立 <xref:System.Threading.Semaphore> 物件，使用其中一個指定名稱的建構函式來代表具名系統旗號。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-130">You can create a <xref:System.Threading.Semaphore> object that represents a named system semaphore by using one of the constructors that specifies a name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1d3a2-131">由於具名旗號是全系統性的，因此可能有多個 <xref:System.Threading.Semaphore> 物件，代表相同的具名旗號。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-131">Because named semaphores are system wide, it is possible to have multiple <xref:System.Threading.Semaphore> objects that represent the same named semaphore.</span></span> <span data-ttu-id="1d3a2-132">每次呼叫建構函式或 <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> 方法時，便會建立新的 <xref:System.Threading.Semaphore> 物件。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-132">Each time you call a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A?displayProperty=nameWithType> method, a new <xref:System.Threading.Semaphore> object is created.</span></span> <span data-ttu-id="1d3a2-133">重複指定相同的名稱，會建立多個代表相同具名旗號的物件。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-133">Specifying the same name repeatedly creates multiple objects that represent the same named semaphore.</span></span>  
  
 <span data-ttu-id="1d3a2-134">使用具名旗號時請小心。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-134">Be careful when you use named semaphores.</span></span> <span data-ttu-id="1d3a2-135">因為它們是全系統性的，使用相同名稱的另一個處理序可能會意外地進入您的旗號。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-135">Because they are system wide, another process that uses the same name can enter your semaphore unexpectedly.</span></span> <span data-ttu-id="1d3a2-136">在同一部電腦上執行的惡意程式碼便可使用此點作為拒絕服務攻擊的基礎。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-136">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="1d3a2-137">使用存取控制安全性來保護代表具名旗號的 <xref:System.Threading.Semaphore> 物件，最好是使用指定 <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> 物件的建構函式。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-137">Use access control security to protect a <xref:System.Threading.Semaphore> object that represents a named semaphore, preferably by using a constructor that specifies a <xref:System.Security.AccessControl.SemaphoreSecurity?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="1d3a2-138">您也可以使用 <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> 方法套用存取控制安全性，但這會在建立旗號的時間與它受保護的時間之間留下弱點時段。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-138">You can also apply access control security using the <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> method, but this leaves a window of vulnerability between the time the semaphore is created and the time it is protected.</span></span> <span data-ttu-id="1d3a2-139">使用存取控制安全性來保護旗號，有助於防止惡意攻擊，但不能解決意外名稱衝突的問題。</span><span class="sxs-lookup"><span data-stu-id="1d3a2-139">Protecting semaphores with access control security helps prevent malicious attacks, but does not solve the problem of unintentional name collisions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1d3a2-140">另請參閱</span><span class="sxs-lookup"><span data-stu-id="1d3a2-140">See also</span></span>

- <xref:System.Threading.Semaphore>  
- <xref:System.Threading.SemaphoreSlim>  
- [<span data-ttu-id="1d3a2-141">執行緒物件和功能</span><span class="sxs-lookup"><span data-stu-id="1d3a2-141">Threading Objects and Features</span></span>](../../../docs/standard/threading/threading-objects-and-features.md)
