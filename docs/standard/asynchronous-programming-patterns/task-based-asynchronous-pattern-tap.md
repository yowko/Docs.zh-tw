---
title: "以工作為基礎的非同步模式 (TAP)"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
caps.latest.revision: 
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 3c3d768414a5cd8a8a9fd4a7e120f74d70827729
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/23/2017
---
# <a name="task-based-asynchronous-pattern-tap"></a><span data-ttu-id="73842-102">以工作為基礎的非同步模式 (TAP)</span><span class="sxs-lookup"><span data-stu-id="73842-102">Task-based Asynchronous Pattern (TAP)</span></span>
<span data-ttu-id="73842-103">工作式非同步模式 (TAP) 是以 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 命名空間中的 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> 和 <xref:System.Threading.Tasks?displayProperty=nameWithType> 類型為基礎，這兩種類別用於表示任意非同步作業。</span><span class="sxs-lookup"><span data-stu-id="73842-103">The Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="73842-104">TAP 是進行新的開發工作時，建議使用的非同步設計模式。</span><span class="sxs-lookup"><span data-stu-id="73842-104">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="73842-105">命名、參數和傳回型別</span><span class="sxs-lookup"><span data-stu-id="73842-105">Naming, Parameters, and Return Types</span></span>  
 <span data-ttu-id="73842-106">TAP 使用單一方法表示非同步作業的啟始和完成。</span><span class="sxs-lookup"><span data-stu-id="73842-106">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="73842-107">這個方法與非同步程式設計模型 (APM 或 `IAsyncResult`) 相反，該模型要求使用 `Begin` 和 `End` 方法，另外也與事件式非同步模式 (EAP) 相反，該模式要求使用具有 `Async` 尾碼的方法，同時必須有一個或多個事件、事件處理常式委派類型，以及 `EventArg` 衍生類型。</span><span class="sxs-lookup"><span data-stu-id="73842-107">This is in contrast to the Asynchronous Programming Model (APM or `IAsyncResult`) pattern, which requires `Begin` and `End` methods, and in contrast to the Event-based Asynchronous Pattern (EAP), which requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="73842-108">TAP 中的非同步方法會在作業名稱後面包括 `Async` 尾碼，例如 `GetAsync` 代表 `Get` 作業。</span><span class="sxs-lookup"><span data-stu-id="73842-108">Asynchronous methods in TAP include the `Async` suffix after the operation name; for example, `GetAsync` for a `Get` operation.</span></span> <span data-ttu-id="73842-109">如果您將 TAP 方法加入至已包含具有 `Async` 尾碼之方法名稱的類別，請改用 `TaskAsync` 尾碼。</span><span class="sxs-lookup"><span data-stu-id="73842-109">If you're adding a TAP method to a class that already contains that method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="73842-110">例如，如果類別已經有 `GetAsync` 方法，請使用 `GetTaskAsync` 這個名稱。</span><span class="sxs-lookup"><span data-stu-id="73842-110">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span>  
  
 <span data-ttu-id="73842-111">TAP 方法會傳回 <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> 或 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>，取決於對應的同步方法傳回 void 或 `TResult` 類型。</span><span class="sxs-lookup"><span data-stu-id="73842-111">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="73842-112">TAP 方法的參數應該與其同步對應項目的參數相符，並且應該以相同順序提供。</span><span class="sxs-lookup"><span data-stu-id="73842-112">The parameters of a TAP method should match the parameters of its synchronous counterpart, and should be provided in the same order.</span></span>  <span data-ttu-id="73842-113">不過，`out` 和 `ref` 參數不受限於這項規則，因此應完全避免使用。</span><span class="sxs-lookup"><span data-stu-id="73842-113">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="73842-114">所有可能會透過 `out` 或 `ref` 參數傳回的資料，都應該改成做為 `TResult` 所傳回 <xref:System.Threading.Tasks.Task%601> 的一部分傳回，而且應使用 Tuple 或自訂資料結構來容納多個值。</span><span class="sxs-lookup"><span data-stu-id="73842-114">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> 
 
 <span data-ttu-id="73842-115">專門用於建立、管理或組合工作的方法 (其中方法的非同步用意以方法名稱或方法所屬的類型名稱清楚表示) 不需要遵循這個命名模式，這類方法通常稱為「組合器」。</span><span class="sxs-lookup"><span data-stu-id="73842-115">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="73842-116">組合器的範例包括 <xref:System.Threading.Tasks.Task.WhenAll%2A> 和 <xref:System.Threading.Tasks.Task.WhenAny%2A>，並且將在[使用以工作為基礎的非同步模式](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)文件的[使用內建工作式組合器](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators)一節中加以討論。</span><span class="sxs-lookup"><span data-stu-id="73842-116">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="73842-117">如需說明 TAP 語法與舊有非同步程式設計模式 (例如非同步程式設計模型 (APM) 和事件式非同步模式 (EAP)) 的語法之間差異的範例，請參閱[非同步程式設計模式](../../../docs/standard/asynchronous-programming-patterns/index.md)。</span><span class="sxs-lookup"><span data-stu-id="73842-117">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="73842-118">啟始非同步作業</span><span class="sxs-lookup"><span data-stu-id="73842-118">Initiating an Asynchronous Operation</span></span>  
 <span data-ttu-id="73842-119">以 TAP 為基礎的非同步方法可以先同步處理少量供作，例如驗證引數和啟始非同步作業，再傳回產生的工作。</span><span class="sxs-lookup"><span data-stu-id="73842-119">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="73842-120">同步工作量應盡量維持最少，這樣非同步方法才可以快速傳回。</span><span class="sxs-lookup"><span data-stu-id="73842-120">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="73842-121">快速傳回的原因如下：</span><span class="sxs-lookup"><span data-stu-id="73842-121">Reasons for a quick return include the following:</span></span>  
  
-   <span data-ttu-id="73842-122">非同步方法可能是從使用者介面 (UI) 執行緒叫用，而任何長時間執行的同步工作都可能影響應用程式的回應。</span><span class="sxs-lookup"><span data-stu-id="73842-122">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
-   <span data-ttu-id="73842-123">可能有多個非同步方法同時啟動。</span><span class="sxs-lookup"><span data-stu-id="73842-123">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="73842-124">因此，在非同步方法的同步處理部分中，所有長時間執行的工作都可能延遲啟始其他非同步作業，因而降低並行的優勢。</span><span class="sxs-lookup"><span data-stu-id="73842-124">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="73842-125">在某些情況下，完成作業所需的工作量會比以非同步方式啟動作業所需的工作量還少。</span><span class="sxs-lookup"><span data-stu-id="73842-125">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="73842-126">若資料流中的讀取作業可以藉由已在記憶體中緩衝的資料獲得滿足，則從該資料流進行讀取就是這類情境的範例。</span><span class="sxs-lookup"><span data-stu-id="73842-126">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="73842-127">在這類情況下，作業會同步完成，而且可能會傳回已完成的工作。</span><span class="sxs-lookup"><span data-stu-id="73842-127">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="73842-128">例外狀況</span><span class="sxs-lookup"><span data-stu-id="73842-128">Exceptions</span></span>  
 <span data-ttu-id="73842-129">非同步方法應只有在回應使用方式錯誤時，才引發從非同步方法呼叫擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="73842-129">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="73842-130">使用方式錯誤一律不應發生在實際執行程式碼中。</span><span class="sxs-lookup"><span data-stu-id="73842-130">Usage errors should never occur in production code.</span></span> <span data-ttu-id="73842-131">例如，如果傳遞 Null 參考 (在 Visual Basic 中為 `Nothing`) 做為方法的其中一個引數造成了錯誤狀態 (通常是以 <xref:System.ArgumentNullException> 例外狀況表示)，您可以修改呼叫程式碼，確保絕不會傳遞 Null 參考。</span><span class="sxs-lookup"><span data-stu-id="73842-131">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="73842-132">對於所有其他錯誤，非同步方法執行時發生的例外狀況應該指派給傳回的工作，即使非同步方法剛好在工作傳回前同步完成也一樣。</span><span class="sxs-lookup"><span data-stu-id="73842-132">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="73842-133">通常，工作最多只能包含一個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="73842-133">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="73842-134">不過，如果工作表示多項作業 (例如 <xref:System.Threading.Tasks.Task.WhenAll%2A>)，則可能會有多個例外狀況與單一工作相關聯。</span><span class="sxs-lookup"><span data-stu-id="73842-134">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="73842-135">目標環境</span><span class="sxs-lookup"><span data-stu-id="73842-135">Target Environment</span></span>  
 <span data-ttu-id="73842-136">當您實作 TAP 方法時，可以判斷非同步執行發生的位置。</span><span class="sxs-lookup"><span data-stu-id="73842-136">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="73842-137">您可以選擇在執行緒集區上執行工作負載、使用非同步 I/O (在作業執行過程中大部分時間未繫結至執行緒) 實作它、在特定執行緒 (例如 UI 執行緒) 上執行它，或是使用任意數量的可能內容。</span><span class="sxs-lookup"><span data-stu-id="73842-137">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="73842-138">TAP 方法甚至可能沒有可執行的項目，而且可能只傳回 <xref:System.Threading.Tasks.Task>，指出系統中其他位置發生的情形 (例如，代表資料的工作抵達佇列的資料結構)。</span><span class="sxs-lookup"><span data-stu-id="73842-138">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>
 
 <span data-ttu-id="73842-139">TAP 方法的呼叫端可能會透過同步等待產生的工作來阻止等待 TAP 方法完成，或是在非同步作業完成時執行其他 (接續) 程式碼。</span><span class="sxs-lookup"><span data-stu-id="73842-139">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="73842-140">接續程式碼 (Continuation Code) 的建立者可以控制執行程式碼的位置。</span><span class="sxs-lookup"><span data-stu-id="73842-140">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="73842-141">您可以明確建立接續程式碼、透過 <xref:System.Threading.Tasks.Task> 類別的方法建立 (例如 <xref:System.Threading.Tasks.Task.ContinueWith%2A>)，或使用建置於接續之上的語言支援以隱含方式建立 (例如 C# 中的 `await`、Visual Basic 中的 `Await`，或 F# 中的 `AwaitValue`)。</span><span class="sxs-lookup"><span data-stu-id="73842-141">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="73842-142">工作狀態</span><span class="sxs-lookup"><span data-stu-id="73842-142">Task Status</span></span>  
 <span data-ttu-id="73842-143"><xref:System.Threading.Tasks.Task> 類別會提供非同步作業的生命週期，而該週期是以 <xref:System.Threading.Tasks.TaskStatus> 列舉表示。</span><span class="sxs-lookup"><span data-stu-id="73842-143">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="73842-144">為了支援從 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 衍生的類型隱密案例，以及支援分隔建構與排程，<xref:System.Threading.Tasks.Task> 類別會公開 <xref:System.Threading.Tasks.Task.Start%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="73842-144">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="73842-145">由公用 <xref:System.Threading.Tasks.Task> 建構函式所建立的工作稱為「靜止工作」(Cold Task)，因為這類工作的生命週期是從非排程的 <xref:System.Threading.Tasks.TaskStatus.Created> 狀態開始，而且只有在這些執行個體上呼叫 <xref:System.Threading.Tasks.Task.Start%2A> 時才會排程。</span><span class="sxs-lookup"><span data-stu-id="73842-145">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span> 
 
 <span data-ttu-id="73842-146">所有其他工作都是從作用狀態開始其生命週期，也就是說，它們所代表的非同步作業已啟始，而且其工作狀態是 <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType> 以外的列舉值。</span><span class="sxs-lookup"><span data-stu-id="73842-146">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="73842-147">從 TAP 方法傳回的所有工作都必須為啟用狀態。</span><span class="sxs-lookup"><span data-stu-id="73842-147">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="73842-148">**如果 TAP 方法在內部使用工作的建構函式將所要傳回的工作具現化，則 TAP 方法必須先在 <xref:System.Threading.Tasks.Task> 物件上呼叫 <xref:System.Threading.Tasks.Task.Start%2A>，再將它傳回。**</span><span class="sxs-lookup"><span data-stu-id="73842-148">**If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="73842-149">TAP 方法的消費者可以安全地假設傳回的工作為作用中，並且不應嘗試在任何從 TAP 方法傳回的 <xref:System.Threading.Tasks.Task.Start%2A> 上呼叫 <xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="73842-149">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="73842-150">在作用中工作上呼叫 <xref:System.Threading.Tasks.Task.Start%2A> 會導致 <xref:System.InvalidOperationException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="73842-150">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="73842-151">取消 (選擇性)</span><span class="sxs-lookup"><span data-stu-id="73842-151">Cancellation (Optional)</span></span>  
 <span data-ttu-id="73842-152">在 TAP 中，取消對於非同步方法實作者和非同步方法消費者而言都是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="73842-152">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="73842-153">如果作業允許取消，則會公開可接受取消語彙基元 (<xref:System.Threading.CancellationToken> 執行個體) 的非同步方法多載。</span><span class="sxs-lookup"><span data-stu-id="73842-153">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="73842-154">依照慣例，參數會命名為 `cancellationToken`。</span><span class="sxs-lookup"><span data-stu-id="73842-154">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="73842-155">非同步作業會監視取消要求的這個語彙基元。</span><span class="sxs-lookup"><span data-stu-id="73842-155">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="73842-156">如果收到取消要求，它可以選擇接受該要求和取消作業。</span><span class="sxs-lookup"><span data-stu-id="73842-156">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="73842-157">如果取消要求導致工作尚未完成就結束，則 TAP 方法會傳回以 <xref:System.Threading.Tasks.TaskStatus.Canceled> 狀態結束的工作，而且沒有可用的結果，也不會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="73842-157">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="73842-158"><xref:System.Threading.Tasks.TaskStatus.Canceled> 狀態會視為工作的最後 (已完成) 狀態，並且包括 <xref:System.Threading.Tasks.TaskStatus.Faulted> 和 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 狀態。</span><span class="sxs-lookup"><span data-stu-id="73842-158">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="73842-159">因此，如果工作處於 <xref:System.Threading.Tasks.TaskStatus.Canceled> 狀態，其 <xref:System.Threading.Tasks.Task.IsCompleted%2A> 屬性就會傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="73842-159">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="73842-160">當工作以 <xref:System.Threading.Tasks.TaskStatus.Canceled> 狀態完成時，工作中註冊的任何接續都會排程或執行，除非指定了像是 <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> 這類選項來選擇不接續。</span><span class="sxs-lookup"><span data-stu-id="73842-160">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="73842-161">任何藉由使用語言功能以非同步方式等候已取消之工作的程式碼都會繼續執行，但是會收到 <xref:System.OperationCanceledException> 或從其衍生的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="73842-161">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="73842-162">透過 <xref:System.Threading.Tasks.Task.Wait%2A> 和 <xref:System.Threading.Tasks.Task.WaitAll%2A> 這類方法封鎖同步等候工作的程式碼也會繼續執行，但會產生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="73842-162">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="73842-163">如果取消語彙基元在呼叫接受語彙基元的 TAP 方法之前就已要求取消，則 TAP 方法應傳回 <xref:System.Threading.Tasks.TaskStatus.Canceled> 工作。</span><span class="sxs-lookup"><span data-stu-id="73842-163">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="73842-164">不過，如果是在非同步作業執行時要求取消，則非同步作業不需要接受取消要求。</span><span class="sxs-lookup"><span data-stu-id="73842-164">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="73842-165">只有在作業因取消要求而結束時，傳回的工作才應該以 <xref:System.Threading.Tasks.TaskStatus.Canceled> 狀態結束。</span><span class="sxs-lookup"><span data-stu-id="73842-165">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="73842-166">如果已要求取消，但是仍然產生結果或例外狀況，則工作應以 <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> 或 <xref:System.Threading.Tasks.TaskStatus.Faulted> 狀態結束。</span><span class="sxs-lookup"><span data-stu-id="73842-166">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span> 
 
 <span data-ttu-id="73842-167">對於想要公開最先取消之能力的非同步方法，您不需要提供不接受取消語彙基元的多載。</span><span class="sxs-lookup"><span data-stu-id="73842-167">For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token.</span></span> <span data-ttu-id="73842-168">對於無法取消的方法，請不要提供接受取消語彙基元的多載，這樣有助於向呼叫端表明目標方法實際上是否可以取消。</span><span class="sxs-lookup"><span data-stu-id="73842-168">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="73842-169">不需要取消的消費者程式碼可以呼叫接受 <xref:System.Threading.CancellationToken> 的方法，並且提供 <xref:System.Threading.CancellationToken.None%2A> 做為引數值。</span><span class="sxs-lookup"><span data-stu-id="73842-169">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="73842-170"><xref:System.Threading.CancellationToken.None%2A> 在功能上相當於預設的 <xref:System.Threading.CancellationToken>。</span><span class="sxs-lookup"><span data-stu-id="73842-170"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="73842-171">進度報告 (選擇性)</span><span class="sxs-lookup"><span data-stu-id="73842-171">Progress Reporting (Optional)</span></span>  
 <span data-ttu-id="73842-172">某些非同步作業會因為提供進度通知而受益，這些通知通常用來更新使用者介面並提供有關非同步作業進度的資訊。</span><span class="sxs-lookup"><span data-stu-id="73842-172">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span> 
 
 <span data-ttu-id="73842-173">在 TAP 中，進度是透過 <xref:System.IProgress%601> 介面處理，並且做為通常名為 `progress` 的參數傳遞至非同步方法。</span><span class="sxs-lookup"><span data-stu-id="73842-173">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="73842-174">在呼叫非同步方法時提供進度介面，有助於排除不當使用所造成的競爭情形 (也就是說，事件處理常式在作業啟動後才註冊是不正確的，而這樣可能導致遺失更新)。</span><span class="sxs-lookup"><span data-stu-id="73842-174">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="73842-175">更重要的是，進度介面支援各種不同的進度實作，取決於使用的程式碼。</span><span class="sxs-lookup"><span data-stu-id="73842-175">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="73842-176">例如，使用的程式碼可能只在意最新的進度更新，或是想要緩衝所有更新，也可能想要對每一個更新叫用一個動作，或是想要控制是否要將引動過程封送處理置特定執行緒。</span><span class="sxs-lookup"><span data-stu-id="73842-176">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="73842-177">這些選項全都可以使用不同的介面實作達成，並依照消費者的特殊需要自訂。</span><span class="sxs-lookup"><span data-stu-id="73842-177">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.</span></span>  <span data-ttu-id="73842-178">就像處理取消一樣，TAP 實作應只在 API 支援進度通知時才提供 <xref:System.IProgress%601> 參數。</span><span class="sxs-lookup"><span data-stu-id="73842-178">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span> 
 
 <span data-ttu-id="73842-179">例如，如果本文前面所討論的 `ReadAsync` 方法能夠以目前為止讀取之位元組數目的形式報告中繼進度，則進度回呼就可以是 <xref:System.IProgress%601> 介面：</span><span class="sxs-lookup"><span data-stu-id="73842-179">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="73842-180">如果 `FindFilesAsync` 方法傳回符合特定搜尋模式之所有檔案的清單，則進度回呼可提供工作已完成的百分比估計以及目前的部分結果集。</span><span class="sxs-lookup"><span data-stu-id="73842-180">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.</span></span>  <span data-ttu-id="73842-181">執行方式可以是使用 Tuple：</span><span class="sxs-lookup"><span data-stu-id="73842-181">It could do this either with a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="73842-182">或是使用專屬於 API 的資料類型：</span><span class="sxs-lookup"><span data-stu-id="73842-182">or with a data type that is specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="73842-183">在後者的情況下，特殊資料類型通常會加上 `ProgressInfo` 尾碼。</span><span class="sxs-lookup"><span data-stu-id="73842-183">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="73842-184">如果 TAP 實作提供接受 `progress` 參數的多載，則必須允許 `null` 引數，而這種情況下就不會報告進度。</span><span class="sxs-lookup"><span data-stu-id="73842-184">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported.</span></span> <span data-ttu-id="73842-185">TAP 實作應對 <xref:System.Progress%601> 物件同步報告進度，如此可讓非同步方法快速提供進度，並且讓進度消費者判斷處理資訊的最佳方式和位置。</span><span class="sxs-lookup"><span data-stu-id="73842-185">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="73842-186">例如，進度執行個體可以選擇在擷取的同步處理內容上封送處理回呼並引發事件。</span><span class="sxs-lookup"><span data-stu-id="73842-186">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="73842-187">IProgress\<T> 實作</span><span class="sxs-lookup"><span data-stu-id="73842-187">IProgress\<T> Implementations</span></span>  
 <span data-ttu-id="73842-188">[!INCLUDE[net_v45](../../../includes/net-v45-md.md)] 提供單一 <xref:System.IProgress%601> 實作：<xref:System.Progress%601>。</span><span class="sxs-lookup"><span data-stu-id="73842-188">The [!INCLUDE[net_v45](../../../includes/net-v45-md.md)] provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>.</span></span> <span data-ttu-id="73842-189"><xref:System.Progress%601> 類別的宣告方式如下：</span><span class="sxs-lookup"><span data-stu-id="73842-189">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T> ProgressChanged;  
}  
```  
  
```vb  
Public Class Progress(Of T) : Inherits IProgress(Of T)  
    Public Sub New()  
    Public Sub New(handler As Action(Of T))  
    Protected Overridable Sub OnReport(value As T)  
    Public Event ProgressChanged As EventHandler(Of T>  
End Class  
```  
  
 <span data-ttu-id="73842-190"><xref:System.Progress%601> 執行個體會公開 <xref:System.Progress%601.ProgressChanged> 事件，該事件是在每次非同步作業報告進度更新時引發。</span><span class="sxs-lookup"><span data-stu-id="73842-190">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="73842-191"><xref:System.Progress%601.ProgressChanged> 事件是在具現化 <xref:System.Threading.SynchronizationContext> 執行個體時所擷取的 <xref:System.Progress%601> 物件上引發。</span><span class="sxs-lookup"><span data-stu-id="73842-191">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="73842-192">如果沒有可用的同步處理內容，則會使用以執行緒集區為目標的預設內容。</span><span class="sxs-lookup"><span data-stu-id="73842-192">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="73842-193">處理常式可能會向這個事件註冊。</span><span class="sxs-lookup"><span data-stu-id="73842-193">Handlers may be registered with this event.</span></span> <span data-ttu-id="73842-194">為了方便起見，您也可以對 <xref:System.Progress%601> 建構函式提供單一處理常式，該處理常式的行為就像是 <xref:System.Progress%601.ProgressChanged> 事件的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="73842-194">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="73842-195">進度更新會以非同步方式引發，以避免在事件處理常式執行時延遲非同步作業。</span><span class="sxs-lookup"><span data-stu-id="73842-195">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="73842-196">另一個 <xref:System.IProgress%601> 實作可以選擇套用不同的語意。</span><span class="sxs-lookup"><span data-stu-id="73842-196">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="73842-197">選擇要提供的多載</span><span class="sxs-lookup"><span data-stu-id="73842-197">Choosing the Overloads to Provide</span></span>  
 <span data-ttu-id="73842-198">如果 TAP 實作同時使用了選擇性的 <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> 和選擇性的 <xref:System.IProgress%601> 參數，則最多可能會需要四個多載：</span><span class="sxs-lookup"><span data-stu-id="73842-198">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);   
public Task MethodNameAsync(…,   
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task   
Public MethodNameAsync(…, cancellationToken As CancellationToken,   
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="73842-199">然而，許多 TAP 實作都不提供取消或進度功能，因此這些實作需要單一方法：</span><span class="sxs-lookup"><span data-stu-id="73842-199">However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="73842-200">如果 TAP 實作支援取消或進度，但不是同時支援兩者，它可能會提供兩個多載：</span><span class="sxs-lookup"><span data-stu-id="73842-200">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="73842-201">如果 TAP 實作同時支援取消和進度，它可能會公開全部四個多載。</span><span class="sxs-lookup"><span data-stu-id="73842-201">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="73842-202">但是，它只會提供下列兩者：</span><span class="sxs-lookup"><span data-stu-id="73842-202">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,   
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,   
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="73842-203">為了彌補兩個遺漏的中繼組合，開發人員可以針對 <xref:System.Threading.CancellationToken.None%2A> 參數傳遞 <xref:System.Threading.CancellationToken> 或預設的 `cancellationToken`，並且針對 `null` 參數傳遞 `progress`。</span><span class="sxs-lookup"><span data-stu-id="73842-203">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="73842-204">如果您期望 TAP 方法的每一種用法都支援取消或進度，可以省略不接受相關參數的多載。</span><span class="sxs-lookup"><span data-stu-id="73842-204">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="73842-205">如果您決定公開多個多載，讓取消或進度成為選擇項，則不支援取消或進度的多載行為應該就像已針對取消傳遞 <xref:System.Threading.CancellationToken.None%2A> 或針對進度傳遞 `null` 至支援兩者的多載。</span><span class="sxs-lookup"><span data-stu-id="73842-205">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="73842-206">相關主題</span><span class="sxs-lookup"><span data-stu-id="73842-206">Related Topics</span></span>  
  
|<span data-ttu-id="73842-207">標題</span><span class="sxs-lookup"><span data-stu-id="73842-207">Title</span></span>|<span data-ttu-id="73842-208">描述</span><span class="sxs-lookup"><span data-stu-id="73842-208">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="73842-209">非同步程式設計模式</span><span class="sxs-lookup"><span data-stu-id="73842-209">Asynchronous Programming Patterns</span></span>](../../../docs/standard/asynchronous-programming-patterns/index.md)|<span data-ttu-id="73842-210">介紹執行非同步作業的三種模式：工作式非同步模式 (TAP)、非同步程式設計模型 (APM) 和事件式非同步模式 (EAP)。</span><span class="sxs-lookup"><span data-stu-id="73842-210">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="73842-211">實作以工作為基礎的非同步模式</span><span class="sxs-lookup"><span data-stu-id="73842-211">Implementing the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="73842-212">描述三種實作工作式非同步模式 (TAP) 的方式：使用 Visual Studio 中的 C# 和 Visual Basic 編譯器、手動，或是透過編譯器和手動方法的組合。</span><span class="sxs-lookup"><span data-stu-id="73842-212">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="73842-213">使用以工作為基礎的非同步模式</span><span class="sxs-lookup"><span data-stu-id="73842-213">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="73842-214">描述如何使用工作和回呼達到等待的目的，而不會遭到封鎖。</span><span class="sxs-lookup"><span data-stu-id="73842-214">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="73842-215">與其他非同步模式和型別互通</span><span class="sxs-lookup"><span data-stu-id="73842-215">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="73842-216">描述如何使用工作式非同步模式 (TAP) 實作非同步程式設計模型 (APM) 和事件式非同步模式 (EAP)。</span><span class="sxs-lookup"><span data-stu-id="73842-216">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
