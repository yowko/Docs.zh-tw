---
title: 實作事件架構非同步模式的最佳作法
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- Event-based Asynchronous Pattern
- ProgressChangedEventArgs class
- BackgroundWorker component
- events [.NET Framework], asynchronous
- AsyncOperationManager class
- threading [.NET Framework], asynchronous features
- AsyncOperation class
- AsyncCompletedEventArgs class
ms.assetid: 4acd2094-4f46-4eff-9190-92d0d9ff47db
ms.openlocfilehash: 519c22e3c2647e2ae3423688b468e133a3e5eb84
ms.sourcegitcommit: 7d13f17bf901751d0169f921a02a6b34541a9eca
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/16/2018
ms.locfileid: "37937110"
---
# <a name="best-practices-for-implementing-the-event-based-asynchronous-pattern"></a><span data-ttu-id="b54cb-102">實作事件架構非同步模式的最佳作法</span><span class="sxs-lookup"><span data-stu-id="b54cb-102">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>
<span data-ttu-id="b54cb-103">事件架構非同步模式提供有效率的方式，讓您運用熟悉的事件和委派語意，公開類別中的非同步行為。</span><span class="sxs-lookup"><span data-stu-id="b54cb-103">The Event-based Asynchronous Pattern provides you with an effective way to expose asynchronous behavior in classes, with familiar event and delegate semantics.</span></span> <span data-ttu-id="b54cb-104">若要實作事件架構非同步模式，您需要遵循一些特定的行為需求。</span><span class="sxs-lookup"><span data-stu-id="b54cb-104">To implement Event-based Asynchronous Pattern, you need to follow some specific behavioral requirements.</span></span> <span data-ttu-id="b54cb-105">以下各節說明在實作遵循事件架構非同步模式的類別時，所應考量的需求和方針。</span><span class="sxs-lookup"><span data-stu-id="b54cb-105">The following sections describe requirements and guidelines you should consider when you implement a class that follows the Event-based Asynchronous Pattern.</span></span>  
  
 <span data-ttu-id="b54cb-106">如需概觀，請參閱[實作事件架構非同步模式](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="b54cb-106">For an overview, see [Implementing the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="required-behavioral-guarantees"></a><span data-ttu-id="b54cb-107">需要的行為保證</span><span class="sxs-lookup"><span data-stu-id="b54cb-107">Required Behavioral Guarantees</span></span>  
 <span data-ttu-id="b54cb-108">如果您實作事件架構非同步模式，則必須提供一些保證，以確保類別的行為正確，並且類別的用戶端可依賴此行為。</span><span class="sxs-lookup"><span data-stu-id="b54cb-108">If you implement the Event-based Asynchronous Pattern, you must provide a number of guarantees to ensure that your class will behave properly and clients of your class can rely on such behavior.</span></span>  
  
### <a name="completion"></a><span data-ttu-id="b54cb-109">完成</span><span class="sxs-lookup"><span data-stu-id="b54cb-109">Completion</span></span>  
 <span data-ttu-id="b54cb-110">在成功完成、發生錯誤或取消時，一律會叫用 <em>MethodName</em>**Completed** 事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="b54cb-110">Always invoke the <em>MethodName</em>**Completed** event handler when you have successful completion, an error, or a cancellation.</span></span> <span data-ttu-id="b54cb-111">應用程式絕對不應該發生保持閒置狀態和永遠無法完成的情況。</span><span class="sxs-lookup"><span data-stu-id="b54cb-111">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span> <span data-ttu-id="b54cb-112">此規則的唯一例外，是在非同步作業本身設計為永遠無法完成的時候。</span><span class="sxs-lookup"><span data-stu-id="b54cb-112">One exception to this rule is if the asynchronous operation itself it designed so that it never completes.</span></span>  
  
### <a name="completed-event-and-eventargs"></a><span data-ttu-id="b54cb-113">Completed 事件和 EventArgs</span><span class="sxs-lookup"><span data-stu-id="b54cb-113">Completed Event and EventArgs</span></span>  
 <span data-ttu-id="b54cb-114">對每個 <em>MethodName</em>**Async** 方法，會套用下列設計需求：</span><span class="sxs-lookup"><span data-stu-id="b54cb-114">For each separate <em>MethodName</em>**Async** method, apply the following design requirements:</span></span>  
  
-   <span data-ttu-id="b54cb-115">在與此方法相同的類別上定義 <em>MethodName</em>**Completed** 事件。</span><span class="sxs-lookup"><span data-stu-id="b54cb-115">Define a <em>MethodName</em>**Completed** event on the same class as the method.</span></span>  
  
-   <span data-ttu-id="b54cb-116">對衍生自 <xref:System.ComponentModel.AsyncCompletedEventArgs> 類別的 <em>MethodName</em>**Completed** 事件，定義 <xref:System.EventArgs> 類別和伴隨的委派。</span><span class="sxs-lookup"><span data-stu-id="b54cb-116">Define an <xref:System.EventArgs> class and accompanying delegate for the <em>MethodName</em>**Completed** event that derives from the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span> <span data-ttu-id="b54cb-117">預設類別名稱的格式應該為 <em>MethodName</em>**CompletedEventArgs**。</span><span class="sxs-lookup"><span data-stu-id="b54cb-117">The default class name should be of the form <em>MethodName</em>**CompletedEventArgs**.</span></span>  
  
-   <span data-ttu-id="b54cb-118">確定 <xref:System.EventArgs> 類別是 <em>MethodName</em> 方法的傳回值所特有。</span><span class="sxs-lookup"><span data-stu-id="b54cb-118">Ensure that the <xref:System.EventArgs> class is specific to the return values of the <em>MethodName</em> method.</span></span> <span data-ttu-id="b54cb-119">當您使用 <xref:System.EventArgs> 類別時，應該不需要開發人員將結果轉型。</span><span class="sxs-lookup"><span data-stu-id="b54cb-119">When you use the <xref:System.EventArgs> class, you should never require developers to cast the result.</span></span>  
  
     <span data-ttu-id="b54cb-120">下列程式碼範例分別示範此設計需求的良好和不良實作。</span><span class="sxs-lookup"><span data-stu-id="b54cb-120">The following code example shows good and bad implementation of this design requirement respectively.</span></span>  
  
```csharp  
// Good design  
private void Form1_MethodNameCompleted(object sender, xxxCompletedEventArgs e)   
{   
    DemoType result = e.Result;  
}  
  
// Bad design  
private void Form1_MethodNameCompleted(object sender, MethodNameCompletedEventArgs e)   
{   
    DemoType result = (DemoType)(e.Result);  
}  
```  
  
-   <span data-ttu-id="b54cb-121">請勿對傳回 <xref:System.EventArgs> 的傳回方法定義 `void` 類別，</span><span class="sxs-lookup"><span data-stu-id="b54cb-121">Do not define an <xref:System.EventArgs> class for returning methods that return `void`.</span></span> <span data-ttu-id="b54cb-122">而是使用 <xref:System.ComponentModel.AsyncCompletedEventArgs> 類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b54cb-122">Instead, use an instance of the <xref:System.ComponentModel.AsyncCompletedEventArgs> class.</span></span>  
  
-   <span data-ttu-id="b54cb-123">確定一律引發 <em>MethodName</em>**Completed** 事件。</span><span class="sxs-lookup"><span data-stu-id="b54cb-123">Ensure that you always raise the <em>MethodName</em>**Completed** event.</span></span> <span data-ttu-id="b54cb-124">此事件應該在成功完成、發生錯誤或取消時引發。</span><span class="sxs-lookup"><span data-stu-id="b54cb-124">This event should be raised on successful completion, on an error, or on cancellation.</span></span> <span data-ttu-id="b54cb-125">應用程式絕對不應該發生保持閒置狀態和永遠無法完成的情況。</span><span class="sxs-lookup"><span data-stu-id="b54cb-125">Applications should never encounter a situation where they remain idle and completion never occurs.</span></span>  
  
-   <span data-ttu-id="b54cb-126">確定攔截非同步作業中發生的任何例外狀況，並且將攔截到的例外狀況指派給 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="b54cb-126">Ensure that you catch any exceptions that occur in the asynchronous operation and assign the caught exception to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
-   <span data-ttu-id="b54cb-127">如果完成工作時發生錯誤，應該會無法存取結果。</span><span class="sxs-lookup"><span data-stu-id="b54cb-127">If there was an error completing the task, the results should not be accessible.</span></span> <span data-ttu-id="b54cb-128">當 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 屬性不是 `null` 時，確定存取 <xref:System.EventArgs> 結構中的任何屬性都會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b54cb-128">When the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property is not `null`, ensure that accessing any property in the <xref:System.EventArgs> structure raises an exception.</span></span> <span data-ttu-id="b54cb-129">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 方法來執行此驗證。</span><span class="sxs-lookup"><span data-stu-id="b54cb-129">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method to perform this verification.</span></span>  
  
-   <span data-ttu-id="b54cb-130">將逾時模型化為錯誤。</span><span class="sxs-lookup"><span data-stu-id="b54cb-130">Model a time out as an error.</span></span> <span data-ttu-id="b54cb-131">如果發生逾時，則引發 <em>MethodName</em>**Completed** 事件，並將 <xref:System.TimeoutException> 指派給 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="b54cb-131">When a time out occurs, raise the <em>MethodName</em>**Completed** event and assign a <xref:System.TimeoutException> to the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> property.</span></span>  
  
-   <span data-ttu-id="b54cb-132">如果您的類別支援多個並行引動過程，請確定 <em>MethodName</em>**Completed** 事件包含適當的 `userSuppliedState` 物件。</span><span class="sxs-lookup"><span data-stu-id="b54cb-132">If your class supports multiple concurrent invocations, ensure that the <em>MethodName</em>**Completed** event contains the appropriate `userSuppliedState` object.</span></span>  
  
-   <span data-ttu-id="b54cb-133">確定 <em>MethodName</em>**Completed** 事件會在適當的執行緒上，以及應用程式生命週期中的適當時間引發。</span><span class="sxs-lookup"><span data-stu-id="b54cb-133">Ensure that the <em>MethodName</em>**Completed** event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="b54cb-134">如需詳細資訊，請參閱＜執行緒和內容＞一節。</span><span class="sxs-lookup"><span data-stu-id="b54cb-134">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="simultaneously-executing-operations"></a><span data-ttu-id="b54cb-135">同時執行作業</span><span class="sxs-lookup"><span data-stu-id="b54cb-135">Simultaneously Executing Operations</span></span>  
  
-   <span data-ttu-id="b54cb-136">如果您的類別支援多個並行引動過程，請讓開發人員定義 <em>MethodName</em>**Async** 多載 (此多載使用物件值狀態參數，或是稱為 `userSuppliedState` 的工作 ID)，以分別追蹤每個引動過程。</span><span class="sxs-lookup"><span data-stu-id="b54cb-136">If your class supports multiple concurrent invocations, enable the developer to track each invocation separately by defining the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, called `userSuppliedState`.</span></span> <span data-ttu-id="b54cb-137">這個參數應該一律是 <em>MethodName</em>**Async** 方法簽章中的最後一個參數。</span><span class="sxs-lookup"><span data-stu-id="b54cb-137">This parameter should always be the last parameter in the <em>MethodName</em>**Async** method's signature.</span></span>  
  
-   <span data-ttu-id="b54cb-138">如果您的類別定義使用物件值狀態參數或工作 ID 的 <em>MethodName</em>**Async** 多載，請務必使用此工作 ID 來追蹤作業的存留期，並務必將此 ID 傳回完成處理常式。</span><span class="sxs-lookup"><span data-stu-id="b54cb-138">If your class defines the <em>MethodName</em>**Async** overload that takes an object-valued state parameter, or task ID, be sure to track the lifetime of the operation with that task ID, and be sure to provide it back into the completion handler.</span></span> <span data-ttu-id="b54cb-139">有一些協助程式類別能提供協助。</span><span class="sxs-lookup"><span data-stu-id="b54cb-139">There are helper classes available to assist.</span></span> <span data-ttu-id="b54cb-140">如需並行管理的詳細資訊，請參閱[操作說明：實作支援事件架構非同步模式的元件](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)\(英文\)。</span><span class="sxs-lookup"><span data-stu-id="b54cb-140">For more information on concurrency management, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
-   <span data-ttu-id="b54cb-141">如果您的類別定義不含狀態參數的 <em>MethodName</em>**Async** 方法，而且不支援多個並行引動過程，請確定之前的 <em>MethodName</em>**Async** 引動過程完成之前，叫用 <em>MethodName</em>**Async** 的任何嘗試動作都會引發 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="b54cb-141">If your class defines the <em>MethodName</em>**Async** method without the state parameter, and it does not support multiple concurrent invocations, ensure that any attempt to invoke <em>MethodName</em>**Async** before the prior <em>MethodName</em>**Async** invocation has completed raises an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="b54cb-142">一般而言，如果叫用 <em>MethodName</em>**Async** 方法多次而不使用 `userSuppliedState` 參數，就會形成多個未完成作業，此時請不要引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b54cb-142">In general, do not raise an exception if the <em>MethodName</em>**Async** method without the `userSuppliedState` parameter is invoked multiple times so that there are multiple outstanding operations.</span></span> <span data-ttu-id="b54cb-143">當您的類別明確地無法處理這種情況，但開發人員應該能夠處理這些無法區分的多個回呼時，便可以引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b54cb-143">You can raise an exception when your class explicitly cannot handle that situation, but assume that developers can handle these multiple indistinguishable callbacks</span></span>  
  
### <a name="accessing-results"></a><span data-ttu-id="b54cb-144">存取結果</span><span class="sxs-lookup"><span data-stu-id="b54cb-144">Accessing Results</span></span>  
  
-   <span data-ttu-id="b54cb-145">如果在執行非同步作業時發生錯誤，應該會無法存取結果。</span><span class="sxs-lookup"><span data-stu-id="b54cb-145">If there was an error during execution of the asynchronous operation, the results should not be accessible.</span></span> <span data-ttu-id="b54cb-146">確定當 <xref:System.ComponentModel.AsyncCompletedEventArgs> 不是 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 時，存取 `null` 中的任何屬性，都會引發 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> 所參考的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b54cb-146">Ensure that accessing any property in the <xref:System.ComponentModel.AsyncCompletedEventArgs> when <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> is not `null` raises the exception referenced by <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A>.</span></span> <span data-ttu-id="b54cb-147">為此，<xref:System.ComponentModel.AsyncCompletedEventArgs> 類別提供了 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="b54cb-147">The <xref:System.ComponentModel.AsyncCompletedEventArgs> class provides the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A> method for this purpose.</span></span>  
  
-   <span data-ttu-id="b54cb-148">確定存取結果的任何嘗試動作都會引發 <xref:System.InvalidOperationException>，指出作業已取消。</span><span class="sxs-lookup"><span data-stu-id="b54cb-148">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="b54cb-149">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 方法來執行此驗證。</span><span class="sxs-lookup"><span data-stu-id="b54cb-149">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
### <a name="progress-reporting"></a><span data-ttu-id="b54cb-150">進度報告</span><span class="sxs-lookup"><span data-stu-id="b54cb-150">Progress Reporting</span></span>  
  
-   <span data-ttu-id="b54cb-151">在可能的情況下，會支援進度報告。</span><span class="sxs-lookup"><span data-stu-id="b54cb-151">Support progress reporting, if possible.</span></span> <span data-ttu-id="b54cb-152">這讓開發人員能在使用您的類別時，對應用程式使用者提供更好的體驗。</span><span class="sxs-lookup"><span data-stu-id="b54cb-152">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
-   <span data-ttu-id="b54cb-153">如果您實作 **ProgressChanged** 或 <em>MethodName</em>**ProgressChanged** 事件，請確定在引發特定非同步作業的 <em>MethodName</em>**Completed** 事件之後，不會對該作業引發這類事件。</span><span class="sxs-lookup"><span data-stu-id="b54cb-153">If you implement a **ProgressChanged** or <em>MethodName</em>**ProgressChanged** event, ensure that there are no such events raised for a particular asynchronous operation after that operation's <em>MethodName</em>**Completed** event has been raised.</span></span>  
  
-   <span data-ttu-id="b54cb-154">如果已填入標準 <xref:System.ComponentModel.ProgressChangedEventArgs>，請確定 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> 一律可以解譯為百分比。</span><span class="sxs-lookup"><span data-stu-id="b54cb-154">If the standard <xref:System.ComponentModel.ProgressChangedEventArgs> is being populated, ensure that the <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> can always be interpreted as a percentage.</span></span> <span data-ttu-id="b54cb-155">百分比不需要很精確，但應該代表某個百分比。</span><span class="sxs-lookup"><span data-stu-id="b54cb-155">The percentage does not need to be accurate, but it should represent a percentage.</span></span> <span data-ttu-id="b54cb-156">如果您的進度報告單位必須是百分比以外的單位，請從 <xref:System.ComponentModel.ProgressChangedEventArgs> 類別衍生一個類別，並將 <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> 保持為 0。</span><span class="sxs-lookup"><span data-stu-id="b54cb-156">If your progress reporting metric must be something other than a percentage, derive a class from the <xref:System.ComponentModel.ProgressChangedEventArgs> class and leave <xref:System.ComponentModel.ProgressChangedEventArgs.ProgressPercentage%2A> at 0.</span></span> <span data-ttu-id="b54cb-157">避免使用百分比以外的報告單位。</span><span class="sxs-lookup"><span data-stu-id="b54cb-157">Avoid using a reporting metric other than a percentage.</span></span>  
  
-   <span data-ttu-id="b54cb-158">確定 `ProgressChanged` 事件會在適當的執行緒上，以及應用程式生命週期中的適當時間引發。</span><span class="sxs-lookup"><span data-stu-id="b54cb-158">Ensure that the `ProgressChanged` event is raised on the appropriate thread and at the appropriate time in the application lifecycle.</span></span> <span data-ttu-id="b54cb-159">如需詳細資訊，請參閱＜執行緒和內容＞一節。</span><span class="sxs-lookup"><span data-stu-id="b54cb-159">For more information, see the Threading and Contexts section.</span></span>  
  
### <a name="isbusy-implementation"></a><span data-ttu-id="b54cb-160">IsBusy 實作</span><span class="sxs-lookup"><span data-stu-id="b54cb-160">IsBusy Implementation</span></span>  
  
-   <span data-ttu-id="b54cb-161">如果您的類別支援多個並行引動過程，請勿公開 `IsBusy` 屬性。</span><span class="sxs-lookup"><span data-stu-id="b54cb-161">Do not expose an `IsBusy` property if your class supports multiple concurrent invocations.</span></span> <span data-ttu-id="b54cb-162">例如，XML Web 服務 Proxy 不會公開 `IsBusy` 屬性，因為這些 Proxy 支援非同步方法的多個並行引動過程。</span><span class="sxs-lookup"><span data-stu-id="b54cb-162">For example, XML Web service proxies do not expose an `IsBusy` property because they support multiple concurrent invocations of asynchronous methods.</span></span>  
  
-   <span data-ttu-id="b54cb-163">`IsBusy` 屬性在呼叫 <em>MethodName</em>**Async** 方法之後，以及引發 <em>MethodName</em>**Completed** 事件之前，應該傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="b54cb-163">The `IsBusy` property should return `true` after the <em>MethodName</em>**Async** method has been called and before the <em>MethodName</em>**Completed** event has been raised.</span></span> <span data-ttu-id="b54cb-164">否則應該傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="b54cb-164">Otherwise it should return `false`.</span></span> <span data-ttu-id="b54cb-165"><xref:System.ComponentModel.BackgroundWorker> 和 <xref:System.Net.WebClient> 元件都是公開 `IsBusy` 屬性之類別的範例。</span><span class="sxs-lookup"><span data-stu-id="b54cb-165">The <xref:System.ComponentModel.BackgroundWorker> and <xref:System.Net.WebClient> components are examples of classes that expose an `IsBusy` property.</span></span>  
  
### <a name="cancellation"></a><span data-ttu-id="b54cb-166">取消</span><span class="sxs-lookup"><span data-stu-id="b54cb-166">Cancellation</span></span>  
  
-   <span data-ttu-id="b54cb-167">在可能的情況下，會支援取消。</span><span class="sxs-lookup"><span data-stu-id="b54cb-167">Support cancellation, if possible.</span></span> <span data-ttu-id="b54cb-168">這讓開發人員能在使用您的類別時，對應用程式使用者提供更好的體驗。</span><span class="sxs-lookup"><span data-stu-id="b54cb-168">This enables developers to provide a better application user experience when they use your class.</span></span>  
  
-   <span data-ttu-id="b54cb-169">在取消的情況下，請設定 <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> 物件中的 <xref:System.ComponentModel.AsyncCompletedEventArgs> 旗標。</span><span class="sxs-lookup"><span data-stu-id="b54cb-169">In the case of cancellation, set the <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> flag in the <xref:System.ComponentModel.AsyncCompletedEventArgs> object.</span></span>  
  
-   <span data-ttu-id="b54cb-170">確定存取結果的任何嘗試動作都會引發 <xref:System.InvalidOperationException>，指出作業已取消。</span><span class="sxs-lookup"><span data-stu-id="b54cb-170">Ensure that any attempt to access the result raises an <xref:System.InvalidOperationException> stating that the operation was canceled.</span></span> <span data-ttu-id="b54cb-171">使用 <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> 方法來執行此驗證。</span><span class="sxs-lookup"><span data-stu-id="b54cb-171">Use the <xref:System.ComponentModel.AsyncCompletedEventArgs.RaiseExceptionIfNecessary%2A?displayProperty=nameWithType> method to perform this verification.</span></span>  
  
-   <span data-ttu-id="b54cb-172">確定對取消方法的呼叫一律會成功傳回，而且絕對不會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b54cb-172">Ensure that calls to a cancellation method always return successfully, and never raise an exception.</span></span> <span data-ttu-id="b54cb-173">一般而言，用戶端不會收到通知，指出作業是否真的可以在任何指定時間取消；用戶端也不會收到通知，指出先前發出的取消是否成功。</span><span class="sxs-lookup"><span data-stu-id="b54cb-173">In general, a client is not notified as to whether an operation is truly cancelable at any given time, and is not notified as to whether a previously issued cancellation has succeeded.</span></span> <span data-ttu-id="b54cb-174">不過，由於應用程式參與完成狀態，因此應用程式一律會在取消成功時收到通知。</span><span class="sxs-lookup"><span data-stu-id="b54cb-174">However, the application will always be given notification when a cancellation succeeded, because the application takes part in the completion status.</span></span>  
  
-   <span data-ttu-id="b54cb-175">在取消作業時，引發 <em>MethodName</em>**Completed** 事件。</span><span class="sxs-lookup"><span data-stu-id="b54cb-175">Raise the <em>MethodName</em>**Completed** event when the operation is canceled.</span></span>  
  
### <a name="errors-and-exceptions"></a><span data-ttu-id="b54cb-176">錯誤和例外狀況</span><span class="sxs-lookup"><span data-stu-id="b54cb-176">Errors and Exceptions</span></span>  
  
-   <span data-ttu-id="b54cb-177">攔截非同步作業中發生的任何例外狀況，並將 <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> 屬性的值設定為該例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b54cb-177">Catch any exceptions that occur in the asynchronous operation and set the value of the <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> property to that exception.</span></span>  
  
### <a name="threading-and-contexts"></a><span data-ttu-id="b54cb-178">執行緒和內容</span><span class="sxs-lookup"><span data-stu-id="b54cb-178">Threading and Contexts</span></span>  
 <span data-ttu-id="b54cb-179">類別若要正常運作，必須在適當的執行緒上或指定應用程式模型 (包括 [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] 和 Windows Form 應用程式) 的內容中，叫用用戶端的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="b54cb-179">For correct operation of your class, it is critical that the client's event handlers are invoked on the proper thread or context for the given application model, including [!INCLUDE[vstecasp](../../../includes/vstecasp-md.md)] and Windows Forms applications.</span></span> <span data-ttu-id="b54cb-180"><xref:System.ComponentModel.AsyncOperation> 和 <xref:System.ComponentModel.AsyncOperationManager> 等兩個重要的協助程式類別，可用於確保您的非同步類別在任何應用程式模型下皆運作正常。</span><span class="sxs-lookup"><span data-stu-id="b54cb-180">Two important helper classes are provided to ensure that your asynchronous class behaves correctly under any application model: <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager>.</span></span>  
  
 <span data-ttu-id="b54cb-181"><xref:System.ComponentModel.AsyncOperationManager> 提供一個方法 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>，此方法會傳回 <xref:System.ComponentModel.AsyncOperation>。</span><span class="sxs-lookup"><span data-stu-id="b54cb-181"><xref:System.ComponentModel.AsyncOperationManager> provides one method, <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>, which returns an <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="b54cb-182">您的 <em>MethodName</em>**Async** 方法會呼叫 <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A>，而您的類別會使用傳回的 <xref:System.ComponentModel.AsyncOperation> 來追蹤非同步工作的存留期。</span><span class="sxs-lookup"><span data-stu-id="b54cb-182">Your <em>MethodName</em>**Async** method calls <xref:System.ComponentModel.AsyncOperationManager.CreateOperation%2A> and your class uses the returned <xref:System.ComponentModel.AsyncOperation> to track the lifetime of the asynchronous task.</span></span>  
  
 <span data-ttu-id="b54cb-183">若要向用戶端報告進度、累加結果和完成，請呼叫 <xref:System.ComponentModel.AsyncOperation.Post%2A> 上的 <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> 和 <xref:System.ComponentModel.AsyncOperation> 方法。</span><span class="sxs-lookup"><span data-stu-id="b54cb-183">To report progress, incremental results, and completion to the client, call the <xref:System.ComponentModel.AsyncOperation.Post%2A> and <xref:System.ComponentModel.AsyncOperation.OperationCompleted%2A> methods on the <xref:System.ComponentModel.AsyncOperation>.</span></span> <span data-ttu-id="b54cb-184"><xref:System.ComponentModel.AsyncOperation> 會負責將用戶端事件處理常式的呼叫，封送處理至適當的執行緒或內容。</span><span class="sxs-lookup"><span data-stu-id="b54cb-184"><xref:System.ComponentModel.AsyncOperation> is responsible for marshaling calls to the client's event handlers to the proper thread or context.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="b54cb-185">如果要明確違背應用程式模型的原則，不過依然要受益於使用事件架構非同步模式的其他優點，您可以規避這些規則。</span><span class="sxs-lookup"><span data-stu-id="b54cb-185">You can circumvent these rules if you explicitly want to go against the policy of the application model, but still benefit from the other advantages of using the Event-based Asynchronous Pattern.</span></span> <span data-ttu-id="b54cb-186">例如，您可能需要將 Windows Forms 中執行的類別設定為無限制執行緒的類別。</span><span class="sxs-lookup"><span data-stu-id="b54cb-186">For example, you may want a class operating in Windows Forms to be free threaded.</span></span> <span data-ttu-id="b54cb-187">只要開發人員了解隱含的限制，您就可以建立無限制執行緒的類別。</span><span class="sxs-lookup"><span data-stu-id="b54cb-187">You can create a free threaded class, as long as developers understand the implied restrictions.</span></span> <span data-ttu-id="b54cb-188">主控台應用程式不會同步執行 <xref:System.ComponentModel.AsyncOperation.Post%2A> 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b54cb-188">Console applications do not synchronize the execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls.</span></span> <span data-ttu-id="b54cb-189">這可能會造成 `ProgressChanged` 事件不按順序引發。</span><span class="sxs-lookup"><span data-stu-id="b54cb-189">This can cause `ProgressChanged` events to be raised out of order.</span></span> <span data-ttu-id="b54cb-190">如果您想要以序列化方式執行 <xref:System.ComponentModel.AsyncOperation.Post%2A> 呼叫，請實作及安裝 <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> 類別。</span><span class="sxs-lookup"><span data-stu-id="b54cb-190">If you wish to have serialized execution of <xref:System.ComponentModel.AsyncOperation.Post%2A> calls, implement and install a <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="b54cb-191">如需使用 <xref:System.ComponentModel.AsyncOperation> 與 <xref:System.ComponentModel.AsyncOperationManager> 以啟用非同步作業的詳細資訊，請參閱[操作說明：實作支援事件架構非同步模式的元件](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md) \(英文\)。</span><span class="sxs-lookup"><span data-stu-id="b54cb-191">For more information about using <xref:System.ComponentModel.AsyncOperation> and <xref:System.ComponentModel.AsyncOperationManager> to enable your asynchronous operations, see [How to: Implement a Component That Supports the Event-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md).</span></span>  
  
## <a name="guidelines"></a><span data-ttu-id="b54cb-192">指導方針</span><span class="sxs-lookup"><span data-stu-id="b54cb-192">Guidelines</span></span>  
  
-   <span data-ttu-id="b54cb-193">理想上，每個方法引動過程都應該獨立於其他引動過程。</span><span class="sxs-lookup"><span data-stu-id="b54cb-193">Ideally, each method invocation should be independent of others.</span></span> <span data-ttu-id="b54cb-194">您應該避免將引動過程與共用資源結合。</span><span class="sxs-lookup"><span data-stu-id="b54cb-194">You should avoid coupling invocations with shared resources.</span></span> <span data-ttu-id="b54cb-195">如果要在引動過程之間共用資源，您需要在實作中提供適當的同步處理機制。</span><span class="sxs-lookup"><span data-stu-id="b54cb-195">If resources are to be shared among invocations, you will need to provide a proper synchronization mechanism in your implementation.</span></span>  
  
-   <span data-ttu-id="b54cb-196">不建議使用需要用戶端實作同步處理的設計。</span><span class="sxs-lookup"><span data-stu-id="b54cb-196">Designs that require the client to implement synchronization are discouraged.</span></span> <span data-ttu-id="b54cb-197">例如，您可以有一個非同步方法，接收全域靜態物件做為參數；這種方法的多個並行引動過程可能會造成資料損毀或死結。</span><span class="sxs-lookup"><span data-stu-id="b54cb-197">For example, you could have an asynchronous method that receives a global static object as a parameter; multiple concurrent invocations of such a method could result in data corruption or deadlocks.</span></span>  
  
-   <span data-ttu-id="b54cb-198">如果您實作具有多個引動過程多載 (簽章中的 `userState`) 的方法，您的類別將需要管理使用者狀態 (或工作 ID) 及其對應暫止作業的集合。</span><span class="sxs-lookup"><span data-stu-id="b54cb-198">If you implement a method with the multiple-invocation overload (`userState` in the signature), your class will need to manage a collection of user states, or task IDs, and their corresponding pending operations.</span></span> <span data-ttu-id="b54cb-199">這個集合應該以 `lock` 區域保護，因為各種引動過程都會加入和移除集合中的 `userState` 物件。</span><span class="sxs-lookup"><span data-stu-id="b54cb-199">This collection should be protected with `lock` regions, because the various invocations add and remove `userState` objects in the collection.</span></span>  
  
-   <span data-ttu-id="b54cb-200">如果可行且適當，請考慮重複使用 `CompletedEventArgs` 類別。</span><span class="sxs-lookup"><span data-stu-id="b54cb-200">Consider reusing `CompletedEventArgs` classes where feasible and appropriate.</span></span> <span data-ttu-id="b54cb-201">在此情況下，由於指定的委派和 <xref:System.EventArgs> 類型不會繫結至單一方法，因此命名將不會與方法名稱一致。</span><span class="sxs-lookup"><span data-stu-id="b54cb-201">In this case, the naming is not consistent with the method name, because a given delegate and <xref:System.EventArgs> type are not tied to a single method.</span></span> <span data-ttu-id="b54cb-202">不過，絕對禁止強制開發人員轉換從 <xref:System.EventArgs> 上屬性擷取的值。</span><span class="sxs-lookup"><span data-stu-id="b54cb-202">However, forcing developers to cast the value retrieved from a property on the <xref:System.EventArgs> is never acceptable.</span></span>  
  
-   <span data-ttu-id="b54cb-203">如果您正在撰寫衍生自 <xref:System.ComponentModel.Component> 的類別，請勿實作及安裝您自己的 <xref:System.Threading.SynchronizationContext> 類別。</span><span class="sxs-lookup"><span data-stu-id="b54cb-203">If you are authoring a class that derives from <xref:System.ComponentModel.Component>, do not implement and install your own <xref:System.Threading.SynchronizationContext> class.</span></span> <span data-ttu-id="b54cb-204">應用程式模型 (而不是元件) 會控制使用的 <xref:System.Threading.SynchronizationContext>。</span><span class="sxs-lookup"><span data-stu-id="b54cb-204">Application models, not components, control the <xref:System.Threading.SynchronizationContext> that is used.</span></span>  
  
-   <span data-ttu-id="b54cb-205">當您使用任何類型的多執行緒時，您很有可能會暴露在非常嚴重且複雜的錯誤下。</span><span class="sxs-lookup"><span data-stu-id="b54cb-205">When you use multithreading of any sort, you potentially expose yourself to very serious and complex bugs.</span></span> <span data-ttu-id="b54cb-206">在實作任何使用多執行緒的解決方案之前，請參閱 [Managed 執行緒最佳做法](../../../docs/standard/threading/managed-threading-best-practices.md)。</span><span class="sxs-lookup"><span data-stu-id="b54cb-206">Before implementing any solution that uses multithreading, see [Managed Threading Best Practices](../../../docs/standard/threading/managed-threading-best-practices.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b54cb-207">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b54cb-207">See Also</span></span>  
 <xref:System.ComponentModel.AsyncOperation>  
 <xref:System.ComponentModel.AsyncOperationManager>  
 <xref:System.ComponentModel.AsyncCompletedEventArgs>  
 <xref:System.ComponentModel.ProgressChangedEventArgs>  
 <xref:System.ComponentModel.BackgroundWorker>  
 [<span data-ttu-id="b54cb-208">實作事件架構非同步模式</span><span class="sxs-lookup"><span data-stu-id="b54cb-208">Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="b54cb-209">事件架構非同步模式 (EAP)</span><span class="sxs-lookup"><span data-stu-id="b54cb-209">Event-based Asynchronous Pattern (EAP)</span></span>](../../../docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-eap.md)  
 [<span data-ttu-id="b54cb-210">決定何時實作事件架構非同步模式</span><span class="sxs-lookup"><span data-stu-id="b54cb-210">Deciding When to Implement the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/deciding-when-to-implement-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="b54cb-211">實作事件架構非同步模式的最佳做法</span><span class="sxs-lookup"><span data-stu-id="b54cb-211">Best Practices for Implementing the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/best-practices-for-implementing-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="b54cb-212">操作說明：使用支援事件架構非同步模式的元件</span><span class="sxs-lookup"><span data-stu-id="b54cb-212">How to: Use Components That Support the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/how-to-use-components-that-support-the-event-based-asynchronous-pattern.md)  
 [<span data-ttu-id="b54cb-213">操作說明：實作支援事件架構非同步模式的元件</span><span class="sxs-lookup"><span data-stu-id="b54cb-213">How to: Implement a Component That Supports the Event-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/component-that-supports-the-event-based-asynchronous-pattern.md)
