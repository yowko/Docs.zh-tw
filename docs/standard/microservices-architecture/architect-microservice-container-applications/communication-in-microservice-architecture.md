---
title: 微服務架構中的通訊
description: 探索微服務之間的不同通訊方式，並了解同步和非同步方式的影響。
ms.date: 09/20/2018
ms.openlocfilehash: 7f7a65ef53d401a8533f82168db5a412d5ac9756
ms.sourcegitcommit: 8699383914c24a0df033393f55db3369db728a7b
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/15/2019
ms.locfileid: "65644360"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="f5cdf-103">微服務架構中的通訊</span><span class="sxs-lookup"><span data-stu-id="f5cdf-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="f5cdf-104">在單一處理序上執行的整合型應用程式中，元件會使用語言層級方法或函式呼叫來彼此叫用。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="f5cdf-105">如果您是使用程式碼 (例如 `new ClassName()`) 來建立物件，這些元件就可以強固結合；或者，如果您是透過參考抽象概念 (而不是具象的物件執行個體) 來使用相依性插入，即可以獨立方式呼叫這些元件。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="f5cdf-106">無論何種情況，物件都會在相同的處理序內執行。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="f5cdf-107">從整合型應用程式變更為微服務應用程式時，最大的挑戰在於變更通訊機制。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="f5cdf-108">從服務的內含式方法呼叫直接轉換成 RPC 呼叫時，會導致過度對話，且在分散式環境中的通訊效率不佳。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="f5cdf-109">除了眾所周知的分散式系統設計挑戰之外，還要考慮 [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) (分散式計算的謬論)，其中列出開發人員從整合型設計進展至分散式設計時通常會有的假設。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="f5cdf-110">對此，您可以採用好幾種解決方案。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-110">There isn't one solution, but several.</span></span> <span data-ttu-id="f5cdf-111">其中一個解決方法包括盡量隔離商務微服務。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="f5cdf-112">接著，您可以使用內部微服務之間的非同步通訊，並以廣泛通訊取代細部通訊 (其為物件之間的常見處理序間通訊)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="f5cdf-113">若要進行這項作業，您可以將呼叫分組，並將多個內部呼叫的彙總結果資料傳回給用戶端。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="f5cdf-114">微服務應用程式是一種分散式系統，其執行於多個處理序或服務上，通常甚至跨多部伺服器或主機。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="f5cdf-115">每個服務執行個體通常就是一個處理序。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-115">Each service instance is typically a process.</span></span> <span data-ttu-id="f5cdf-116">因此，服務必須使用處理序間的通訊協定來互動，例如 HTTP、AMQP 或 TCP 這類二進位通訊協定 (根據每個服務的本質而定)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="f5cdf-117">微服務社群推廣一種 [Smart Endpoints and Dumb Pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes) (智慧端點和傻瓜管道) 的哲學。此標語主要是鼓勵「高內聚、低結合」的設計；亦即盡量分離微服務，並使其在單一的微服務內盡可能地縝密結合。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="f5cdf-118">如前所述，每個微服務擁有它自己的資料和網域邏輯。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="f5cdf-119">但一般來說，由端對端應用程式組成的微服務是單純使用 REST 通訊 (而不是 WS-\* 這類複雜通訊協定) 與彈性的事件驅動通訊 (而不是集中式的商務程序協調器) 來編寫。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="f5cdf-120">兩個最常用的通訊協定是資源 API 的 HTTP 要求/回應 (當查詢是最重要的作業時)，以及跨多個微服務通訊更新時的輕量型非同步傳訊。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="f5cdf-121">下列各節會進行詳細說明。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="f5cdf-122">通訊類型</span><span class="sxs-lookup"><span data-stu-id="f5cdf-122">Communication types</span></span>

<span data-ttu-id="f5cdf-123">用戶端和服務可以透過許多不同通訊類型來進行通訊，每種方式鎖定的案例與目標都不同。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="f5cdf-124">一開始，我們可以將這些通訊類型以兩個軸來分類。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="f5cdf-125">第一個軸定義通訊協定為同步或非同步：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="f5cdf-126">同步通訊協定：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-126">Synchronous protocol.</span></span> <span data-ttu-id="f5cdf-127">HTTP 是同步的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="f5cdf-128">用戶端傳送要求，並等候服務的回應。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="f5cdf-129">其獨立於用戶端程式碼的執行，並可能是同步 (會封鎖執行緒) 或非同步 (不封鎖執行緒，且回應最後會抵達回呼)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="f5cdf-130">此處的重點是通訊協定 (HTTP/HTTPS) 為同步，且用戶端程式碼只能在收到 HTTP 伺服器回應時繼續工作。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="f5cdf-131">非同步通訊協定：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-131">Asynchronous protocol.</span></span> <span data-ttu-id="f5cdf-132">其他通訊協定會使用非同步的訊息，例如 AMQP (許多作業系統和雲端環境支援的通訊協定)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="f5cdf-133">用戶端程式碼或訊息寄件者通常不會等候回應。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="f5cdf-134">而只會在傳送訊息給 RabbitMQ 佇列或任何其他訊息代理程式時傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="f5cdf-135">第二個軸則定義通訊具有單一接收者或多個接收者：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="f5cdf-136">單一接收者：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-136">Single receiver.</span></span> <span data-ttu-id="f5cdf-137">每個要求都必須由一個接收者或服務來處理。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="f5cdf-138">這種通訊的其中一個範例是 [Command pattern](https://en.wikipedia.org/wiki/Command_pattern) (命令模式)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="f5cdf-139">多個接收者：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-139">Multiple receivers.</span></span> <span data-ttu-id="f5cdf-140">每個要求可以由零到多個接收者來處理。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="f5cdf-141">這種類型的通訊必須是非同步的。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="f5cdf-142">其中的範例是用於[事件驅動架構](https://microservices.io/patterns/data/event-driven-architecture.html)這類模式的[發佈/訂閱](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)機制。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="f5cdf-143">這是以透過事件在多個微服務之間散佈資料更新時的事件匯流排介面或訊息代理程式為基礎；通常您可以使用[主題和訂閱](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)，並透過服務匯流排或類似 [Azure 服務匯流排](https://azure.microsoft.com/services/service-bus/)的構件來實作。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="f5cdf-144">微服務應用程式通常會使用這些通訊樣式的組合。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="f5cdf-145">叫用一般 Web API HTTP 服務時，最常見的類型是使用 HTTP/HTTPS 等同步通訊協定的單一接收者通訊。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="f5cdf-146">微服務通常也會使用傳訊通訊協定，來進行微服務之間的非同步通訊。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="f5cdf-147">這些軸可讓您對可能的通訊機制一目了然，但它們不是建置微服務時的重要考量。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="f5cdf-148">在整合微服務時，用戶端執行緒執行的非同步本質或者所選通訊協定的非同步本質兩者都不是重點。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="f5cdf-149">真正的重點在於您要能夠以非同步方式整合微服務，同時保持微服務的獨立性，如下節所述。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="f5cdf-150">非同步的微服務整合可強化微服務的自主性</span><span class="sxs-lookup"><span data-stu-id="f5cdf-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="f5cdf-151">如前所述，建置微服務應用程式的重點是整合微服務的方式。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="f5cdf-152">在理想情況下，您應該盡量將內部微服務之間的通訊降到最低。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="f5cdf-153">微服務之間的通訊越少越好。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="f5cdf-154">但在許多情況下，您仍必須整合微服務。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="f5cdf-155">當您要執行上述作業時，重要的規則是微服務之間的通訊應該為非同步。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="f5cdf-156">這不代表您必須使用特定的通訊協定 (例如，非同步傳訊與同步 HTTP)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="f5cdf-157">而是代表微服務之間的通訊應該僅以非同步資料散佈的方式來進行，但不要試圖仰賴其他屬於初始服務之 HTTP 要求/回應作業的內部微服務。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="f5cdf-158">請盡可能不要仰賴多個微服務之間的同步通訊 (要求/回應)，甚至連查詢也不要仰賴於此。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="f5cdf-159">每個微服務的目標是保持自主並供用戶端取用，即使屬於端對端應用程式一部分的其他服務已關機或狀況不佳時亦同。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="f5cdf-160">如果您設想要從某個微服務呼叫其他微服務 (例如，執行資料查詢的 HTTP 要求)，以便能夠回應用戶端應用程式，這種架構在某些微服務故障時就無法復原。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="f5cdf-161">此外，如圖 4-15 的第一個部分所示，如果微服務之間具有 HTTP 相依性 (例如使用 HTTP 要求鏈結建立長要求/回應循環時)，不只會導致微服務無法自主，一旦該鏈結中的其中一個服務無法順利執行時，也會影響其效能。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="f5cdf-162">如果微服務 (例如查詢要求) 之間的同步相依性越高，用戶端應用程式的整體回應時間就會越糟。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![在同步通訊中，提供處理用戶端要求時會在微服務之間建立要求的「鏈結」。](./media/image15.png)

<span data-ttu-id="f5cdf-166">**圖 4-15**：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-166">**Figure 4-15**.</span></span> <span data-ttu-id="f5cdf-167">微服務之間的通訊模式和反向模式</span><span class="sxs-lookup"><span data-stu-id="f5cdf-167">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="f5cdf-168">如果您的微服務需要引發另一個微服務的其他動作，請盡量不要同步執行該動作，也不要與原始微服務要求及回覆作業一併執行。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-168">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="f5cdf-169">請改為以非同步方式執行 (使用非同步傳訊或整合事件、佇列等)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-169">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="f5cdf-170">但是，請盡量不要與原始的同步要求及回覆作業同步叫用動作。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-170">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="f5cdf-171">最後 (這是建置微服務時大部分問題發生的時候)，如果您初始的微服務需要使用原本由其他微服務擁有的資料時，請避免對該資料提出同步要求。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-171">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="f5cdf-172">反之，請使用最終一致性 (通常使用整合事件來進行，如接下來的章節中所述)，將該資料 (僅所需的屬性) 複製或散佈到初始服務的資料庫中。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-172">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="f5cdf-173">如[識別每個微服務的領域模型界限](identify-microservice-domain-model-boundaries.md)一節中所述，在數個微服務之間複製某些資料的設計是可行的；這麼做可讓您將資料轉譯到特定語言、其他領域或繫結內容。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-173">As noted earlier in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md), duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="f5cdf-174">例如，在 [eShopOnContainers 應用程式](https://github.com/dotnet-architecture/eShopOnContainers)中，您有一個名為 identity.api 的微服務，其負責處理大多數的使用者資料 (含有「使用者」名稱的實體)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-174">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named identity.api that's in charge of most of the user's data with an entity named User.</span></span> <span data-ttu-id="f5cdf-175">不過，當您要儲存訂購微服務中的使用者相關資料時，請將它儲存為不同的實體，並命名為「買方」。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-175">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="f5cdf-176">「買方」實體與原始「使用者」實體會共用相同的識別，但訂購網域可能只需要幾個屬性，而不是整個使用者設定檔。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-176">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="f5cdf-177">您可以使用任何通訊協定來進行通訊，並以非同步方式跨微服務散佈資料，來保持最終一致性。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-177">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="f5cdf-178">如前所述，您可以使用事件匯流排或訊息代理程式來運用整合事件；甚至還可以改輪詢其他服務來使用 HTTP。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-178">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="f5cdf-179">它並不重要。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-179">It doesn't matter.</span></span> <span data-ttu-id="f5cdf-180">重要的規則是不要讓微服務之間建立同步相依性。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-180">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="f5cdf-181">下列各節說明您可以考慮在微服務應用程式中使用的多種通訊樣式。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-181">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="f5cdf-182">通訊樣式</span><span class="sxs-lookup"><span data-stu-id="f5cdf-182">Communication styles</span></span>

<span data-ttu-id="f5cdf-183">依據所要使用的通訊類型而定，您可以搭配許多通訊協定和選擇來進行通訊。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-183">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="f5cdf-184">如果您是使用以同步要求/回應為基礎的通訊機制，則 HTTP 和 REST 這類通訊協定是最常見的方法，尤其是當您要在 Docker 主機或微服務叢集之外發佈服務時。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-184">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="f5cdf-185">如果您要在內部服務 (Docker 主機或微服務叢集內) 之間進行通訊，也可以使用二進位格式的通訊機制 (例如使用 TCP 和二進位格式的 Service Fabric 遠端處理或 WCF)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-185">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="f5cdf-186">或者，您可以使用非同步訊息通訊機制，例如 AMQP。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-186">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="f5cdf-187">還有很多種訊息格式可能更有效率，如 JSON 或 XML，甚至二進位格式。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-187">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="f5cdf-188">如果您選擇的二進位格式不是標準格式，則不建議您使用該格式來公開發佈服務。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-188">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="f5cdf-189">您可以在微服務之間的內部通訊使用非標準格式。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-189">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="f5cdf-190">好比說，在 Docker 主機或微服務叢集 (Docker 協調器或 Azure Service Fabric) 內的微服務之間進行通訊時，或針對可與微服務通訊的專屬用戶端應用程式，您可以這樣做。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-190">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="f5cdf-191">使用 HTTP 和 REST 的要求/回應通訊</span><span class="sxs-lookup"><span data-stu-id="f5cdf-191">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="f5cdf-192">當用戶端使用要求/回應通訊時，它會將要求傳送給服務，然後由服務處理要求，並傳回回應。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-192">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="f5cdf-193">要求/回應通訊非常適合用來查詢用戶端應用程式的即時 UI (即時的使用者介面) 資料。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-193">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="f5cdf-194">因此，在微服務架構中，您可能會針對大部分查詢使用這種通訊機制，如圖 4-16 所示。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-194">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![當用戶端傳送要求給 API 閘道時，假設微服務的回應會在極短時間抵達，您可以使用要求/回應通訊進行即時查詢。](./media/image16.png)

<span data-ttu-id="f5cdf-196">**圖 4-16**：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-196">**Figure 4-16**.</span></span> <span data-ttu-id="f5cdf-197">使用 HTTP 要求/回應通訊 (同步或非同步)</span><span class="sxs-lookup"><span data-stu-id="f5cdf-197">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="f5cdf-198">當用戶端使用要求/回應通訊時，它會假設回應很快抵達，通常少於一秒或最多幾秒鐘的時間。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-198">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="f5cdf-199">針對回應延遲，您需要依據[訊息模式](https://docs.microsoft.com/azure/architecture/patterns/category/messaging)和[技術](https://en.wikipedia.org/wiki/Message-oriented_middleware)來實作非同步通訊；我們將在下節說明此種不同的方法。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-199">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="f5cdf-200">要求/回應通訊的熱門架構樣式是 [REST](https://en.wikipedia.org/wiki/Representational_state_transfer)。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-200">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="f5cdf-201">這種方法是以 [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) 通訊協定為基礎並與其緊密結合，同時採用 HTTP 動詞命令，例如 GET、POST 和 PUT。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-201">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="f5cdf-202">建立服務時，REST 是最常用的架構通訊方法。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-202">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="f5cdf-203">開發 ASP.NET Core Web API 服務時，您可以實作 REST 服務。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-203">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="f5cdf-204">將 HTTP REST 服務作為您的介面定義語言時，還有其他附加價值。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-204">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="f5cdf-205">比方說，如果您使用 [Swagger 中繼資料](https://swagger.io/)來描述服務 API，即可使用工具來產生用戶端 Stub，以直接探索及取用您的服務。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-205">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="f5cdf-206">其他資源</span><span class="sxs-lookup"><span data-stu-id="f5cdf-206">Additional resources</span></span>

- <span data-ttu-id="f5cdf-207">**Martin Fowler：Richardson 成熟度模型** REST 模型的描述。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-207">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="f5cdf-208">**Swagger** 官方網站。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-208">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="f5cdf-209">以 HTTP 為基礎的推送和即時通訊</span><span class="sxs-lookup"><span data-stu-id="f5cdf-209">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="f5cdf-210">另一個可能性 (通常用途與 REST 不同) 是使用 [ASP.NET SignalR](https://www.asp.net/signalr) 這類更高階 Framework 和 [WebSockets](https://en.wikipedia.org/wiki/WebSocket) 等通訊協定的即時和一對多通訊。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-210">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="f5cdf-211">如圖 4-17 所示，即時 HTTP 通訊表示您可以讓伺服器程式碼在資料可用時將內容推送至連線的用戶端，而不需要讓伺服器等候用戶端要求新的資料。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-211">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![SignalR 很適合用來完成將內容從後端伺服器推送到用戶端的即時通訊。](./media/image17.png)

<span data-ttu-id="f5cdf-213">**圖 4-17**：</span><span class="sxs-lookup"><span data-stu-id="f5cdf-213">**Figure 4-17**.</span></span> <span data-ttu-id="f5cdf-214">一對一的即時非同步訊息通訊</span><span class="sxs-lookup"><span data-stu-id="f5cdf-214">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="f5cdf-215">由於是即時通訊，因此用戶端應用程式幾乎會立即顯示變更。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-215">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="f5cdf-216">一般來說，其會由 WebSockets 這類通訊協定使用許多 Websocket 連線 (每個用戶端一個) 來進行處理。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-216">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="f5cdf-217">典型的範例是：某個服務同時向許多用戶端 Web 應用程式傳達運動遊戲之分數變更的情況。</span><span class="sxs-lookup"><span data-stu-id="f5cdf-217">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="f5cdf-218">[上一頁](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[下一頁](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="f5cdf-218">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
