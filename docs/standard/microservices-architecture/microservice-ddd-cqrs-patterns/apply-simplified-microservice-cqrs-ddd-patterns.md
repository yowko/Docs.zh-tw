---
title: 在微服務中套用簡化的 CQRS 和 DDD 模式
description: .NET 微服務：容器化 .NET 應用程式的架構 | 了解 CQRS 和 DDD 模式之間的整體關聯。
ms.date: 10/08/2018
ms.openlocfilehash: 36bffce37176aed6c7d9daea7f2995952b58e895
ms.sourcegitcommit: ffd7dd79468a81bbb0d6449f6d65513e050c04c4
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/21/2019
ms.locfileid: "65959381"
---
# <a name="apply-simplified-cqrs-and-ddd-patterns-in-a-microservice"></a><span data-ttu-id="302f3-103">在微服務中套用簡化 CQRS 和 DDD 模式</span><span class="sxs-lookup"><span data-stu-id="302f3-103">Apply simplified CQRS and DDD patterns in a microservice</span></span>

<span data-ttu-id="302f3-104">CQRS 是將模型分隔為讀取資料和寫入資料的架構模式。</span><span class="sxs-lookup"><span data-stu-id="302f3-104">CQRS is an architectural pattern that separates the models for reading and writing data.</span></span> <span data-ttu-id="302f3-105">相關術語[命令查詢分離 (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) 最初是在 Bertrand Meyer 的 *Object Oriented Software Construction* 一書中定義。</span><span class="sxs-lookup"><span data-stu-id="302f3-105">The related term [Command Query Separation (CQS)](https://martinfowler.com/bliki/CommandQuerySeparation.html) was originally defined by Bertrand Meyer in his book *Object Oriented Software Construction*.</span></span> <span data-ttu-id="302f3-106">其基本概念是，您可以將系統的作業分成兩個明顯不同的分類：</span><span class="sxs-lookup"><span data-stu-id="302f3-106">The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></span>

- <span data-ttu-id="302f3-107">查詢：</span><span class="sxs-lookup"><span data-stu-id="302f3-107">Queries.</span></span> <span data-ttu-id="302f3-108">這些作業會傳回結果，但不會變更系統的狀態，而且沒有副作用。</span><span class="sxs-lookup"><span data-stu-id="302f3-108">These return a result and do not change the state of the system, and they are free of side effects.</span></span>

- <span data-ttu-id="302f3-109">命令：</span><span class="sxs-lookup"><span data-stu-id="302f3-109">Commands.</span></span> <span data-ttu-id="302f3-110">這些作業會變更系統的狀態。</span><span class="sxs-lookup"><span data-stu-id="302f3-110">These change the state of a system.</span></span>

<span data-ttu-id="302f3-111">CQS 是一個簡單的概念，它與相同物件內的方法 (查詢或命令) 相關。</span><span class="sxs-lookup"><span data-stu-id="302f3-111">CQS is a simple concept—it is about methods within the same object being either queries or commands.</span></span> <span data-ttu-id="302f3-112">每個方法可傳回狀態或變動狀態，但不會同時執行。</span><span class="sxs-lookup"><span data-stu-id="302f3-112">Each method either returns state or mutates state, but not both.</span></span> <span data-ttu-id="302f3-113">即使是單一存放庫模式物件也會遵守 CQS。</span><span class="sxs-lookup"><span data-stu-id="302f3-113">Even a single repository pattern object can comply with CQS.</span></span> <span data-ttu-id="302f3-114">CQS 可視為 CQRS 的基本原則。</span><span class="sxs-lookup"><span data-stu-id="302f3-114">CQS can be considered a foundational principle for CQRS.</span></span>

<span data-ttu-id="302f3-115">[命令和查詢職責分離 (CQRS)](https://martinfowler.com/bliki/CQRS.html)是由 Greg Young 所引進，並由 Udi Dahan 等人強烈提倡。</span><span class="sxs-lookup"><span data-stu-id="302f3-115">[Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) was introduced by Greg Young and strongly promoted by Udi Dahan and others.</span></span> <span data-ttu-id="302f3-116">它是以 CQS 原則為依據，但內容更詳細。</span><span class="sxs-lookup"><span data-stu-id="302f3-116">It is based on the CQS principle, although it is more detailed.</span></span> <span data-ttu-id="302f3-117">它可以視為根據命令和事件 (或選擇性地根據非同步訊息) 的模式。</span><span class="sxs-lookup"><span data-stu-id="302f3-117">It can be considered a pattern based on commands and events plus optionally on asynchronous messages.</span></span> <span data-ttu-id="302f3-118">在許多情況下，CQRS 與更進階的案例相關，像是針對讀取 (查詢) 和寫入 (更新) 使用不同的實體資料庫。</span><span class="sxs-lookup"><span data-stu-id="302f3-118">In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates).</span></span> <span data-ttu-id="302f3-119">此外，更進階的 CQRS 系統可能會針對您的更新資料庫實作[事件溯源 (Event Sourcing，ES)](https://martinfowler.com/eaaDev/EventSourcing.html)，因此您只會在領域模型中儲存事件，而不會儲存目前的狀態資料。</span><span class="sxs-lookup"><span data-stu-id="302f3-119">Moreover, a more evolved CQRS system might implement [Event-Sourcing (ES)](https://martinfowler.com/eaaDev/EventSourcing.html) for your updates database, so you would only store events in the domain model instead of storing the current-state data.</span></span> <span data-ttu-id="302f3-120">不過，這不是本指南中所使用的方法；我們將使用最簡單的 CQRS 方法，該方法只會將查詢與命令分隔。</span><span class="sxs-lookup"><span data-stu-id="302f3-120">However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></span>

<span data-ttu-id="302f3-121">您可以將查詢作業分組為一個層級，並將命令分組為另一個層級，來達到 CQRS 的分離狀況。</span><span class="sxs-lookup"><span data-stu-id="302f3-121">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer.</span></span> <span data-ttu-id="302f3-122">每個層級都有自己的資料模型 (請注意我們是說模型，但不一定是不同的資料庫)，並使用自己的模式和技術組合來建立。</span><span class="sxs-lookup"><span data-stu-id="302f3-122">Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies.</span></span> <span data-ttu-id="302f3-123">更重要的是，這兩個層級可以在相同的階層或微服務中，如本指南中所使用的範例 (訂購微服務) 所示。</span><span class="sxs-lookup"><span data-stu-id="302f3-123">More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide.</span></span> <span data-ttu-id="302f3-124">或者，它們可能會在不同的微服務或處理序上實作，以便可分別最佳化和擴充而不會彼此影響。</span><span class="sxs-lookup"><span data-stu-id="302f3-124">Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</span></span>

<span data-ttu-id="302f3-125">CQRS 表示會有兩個物件用於讀取/寫入作業，在其他內容中則有一個。</span><span class="sxs-lookup"><span data-stu-id="302f3-125">CQRS means having two objects for a read/write operation where in other contexts there is one.</span></span> <span data-ttu-id="302f3-126">使用反正規化的讀取資料庫有其原因，您可以在更進階的 CQRS 文獻中了解。</span><span class="sxs-lookup"><span data-stu-id="302f3-126">There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature.</span></span> <span data-ttu-id="302f3-127">但我們不會在此使用該方法，因為此處的目標在於提高查詢的彈性，而不在於使用 DDD 模式中的條件約束 (例如彙總) 來限制查詢。</span><span class="sxs-lookup"><span data-stu-id="302f3-127">But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</span></span>

<span data-ttu-id="302f3-128">eShopOnContainers 參考應用程式中的訂購微服務即為這種服務的範例。</span><span class="sxs-lookup"><span data-stu-id="302f3-128">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application.</span></span> <span data-ttu-id="302f3-129">此服務會實作以簡化的 CQRS 方法為基礎的微服務。</span><span class="sxs-lookup"><span data-stu-id="302f3-129">This service implements a microservice based on a simplified CQRS approach.</span></span> <span data-ttu-id="302f3-130">它會使用單一資料來源或資料庫，但有兩個邏輯模型加上異動領域的 DDD 模式，如圖 7-2 所示。</span><span class="sxs-lookup"><span data-stu-id="302f3-130">It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</span></span>

![邏輯 Ordering 微服務包含其 Ordering 資料庫，該資料庫可以位於相同或不同的 Docker 主機。](./media/image2.png)

<span data-ttu-id="302f3-133">**圖 7-2**.</span><span class="sxs-lookup"><span data-stu-id="302f3-133">**Figure 7-2**.</span></span> <span data-ttu-id="302f3-134">簡化的 CQRS 和 DDD 型微服務</span><span class="sxs-lookup"><span data-stu-id="302f3-134">Simplified CQRS- and DDD-based microservice</span></span>

<span data-ttu-id="302f3-135">應用程式層可以是 Web API 本身。</span><span class="sxs-lookup"><span data-stu-id="302f3-135">The application layer can be the Web API itself.</span></span> <span data-ttu-id="302f3-136">此處的重要設計觀點是微服務已遵循 CQRS 模式，將查詢、ViewModel (專為用戶端應用程式所建立的資料模型) 與命令、領域模型、異動分開。</span><span class="sxs-lookup"><span data-stu-id="302f3-136">The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern.</span></span> <span data-ttu-id="302f3-137">此方法可確保查詢不會受限於來自 DDD 模式的限制和條件約束，這些限制和條件約束只對異動和更新才有意義，如稍後章節所述。</span><span class="sxs-lookup"><span data-stu-id="302f3-137">This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="302f3-138">其他資源</span><span class="sxs-lookup"><span data-stu-id="302f3-138">Additional resources</span></span>

- <span data-ttu-id="302f3-139">**Greg Young。Versioning in an Event Sourced System** (事件來源系統中的版本控制) (免費閱讀的線上電子書) \\</span><span class="sxs-lookup"><span data-stu-id="302f3-139">**Greg Young. Versioning in an Event Sourced System** (Free to read online e-book) \\</span></span>
   <https://leanpub.com/esversioning/read>

>[!div class="step-by-step"]
><span data-ttu-id="302f3-140">[上一頁](index.md)
>[下一頁](eshoponcontainers-cqrs-ddd-microservice.md)</span><span class="sxs-lookup"><span data-stu-id="302f3-140">[Previous](index.md)
[Next](eshoponcontainers-cqrs-ddd-microservice.md)</span></span>
