---
title: 規則運算式選項
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, options
- constructs, options
- .NET Framework regular expressions, options
- inline option constructs
- options parameter
ms.assetid: c82dc689-7e82-4767-a18d-cd24ce5f05e9
ms.openlocfilehash: a53d7517485d2a0b02b6f11928f478a7da3f9503
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/12/2019
ms.locfileid: "73972106"
---
# <a name="regular-expression-options"></a><span data-ttu-id="cc58d-102">規則運算式選項</span><span class="sxs-lookup"><span data-stu-id="cc58d-102">Regular Expression Options</span></span>

<span data-ttu-id="cc58d-103">依預設，輸入字串與規則運算式模式中任何常值字元的比較會區分大小寫，規則運算式模式中的空白字元會解譯成常值空白字元，而規則運算式中的擷取群組會隱含也會明確命名。</span><span class="sxs-lookup"><span data-stu-id="cc58d-103">By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</span></span> <span data-ttu-id="cc58d-104">您可以藉由指定規則運算式選項來修改這些預設規則運算式行為和幾個其他方面。</span><span class="sxs-lookup"><span data-stu-id="cc58d-104">You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</span></span> <span data-ttu-id="cc58d-105">這些選項 (列示於下表) 可以內嵌為規則運算式模式的部分，或是提供給 <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> 類別建構函式或靜態模式比對方法，以做為 <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 列舉值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-105">These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static pattern matching method as a <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumeration value.</span></span>

|<span data-ttu-id="cc58d-106">RegexOptions 成員</span><span class="sxs-lookup"><span data-stu-id="cc58d-106">RegexOptions member</span></span>|<span data-ttu-id="cc58d-107">內嵌字元</span><span class="sxs-lookup"><span data-stu-id="cc58d-107">Inline character</span></span>|<span data-ttu-id="cc58d-108">作用</span><span class="sxs-lookup"><span data-stu-id="cc58d-108">Effect</span></span>|
|-------------------------|----------------------|------------|
|<xref:System.Text.RegularExpressions.RegexOptions.None>|<span data-ttu-id="cc58d-109">無法使用</span><span class="sxs-lookup"><span data-stu-id="cc58d-109">Not available</span></span>|<span data-ttu-id="cc58d-110">使用預設行為。</span><span class="sxs-lookup"><span data-stu-id="cc58d-110">Use default behavior.</span></span> <span data-ttu-id="cc58d-111">如需詳細資訊，請參閱[預設選項](#default-options)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-111">For more information, see [Default Options](#default-options).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>|`i`|<span data-ttu-id="cc58d-112">使用不區分大小寫的比對方式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-112">Use case-insensitive matching.</span></span> <span data-ttu-id="cc58d-113">如需詳細資訊，請參閱[不區分大小寫比對](#case-insensitive-matching)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-113">For more information, see [Case-Insensitive Matching](#case-insensitive-matching).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Multiline>|`m`|<span data-ttu-id="cc58d-114">使用多行模式，其中 `^` 和 `$` 會比對每一行的開頭與結尾 (而不是輸入字串的開頭和結尾)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-114">Use multiline mode, where `^` and `$` match the beginning and end of each line (instead of the beginning and end of the input string).</span></span> <span data-ttu-id="cc58d-115">如需詳細資訊，請參閱[多行模式](#multiline-mode)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-115">For more information, see [Multiline Mode](#multiline-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Singleline>|`s`|<span data-ttu-id="cc58d-116">使用單行模式，其中句點 (.) 會比對每個字元 (而不是 `\n` 以外的每個字元)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-116">Use single-line mode, where the period (.) matches every character (instead of every character except `\n`).</span></span> <span data-ttu-id="cc58d-117">如需詳細資訊，請參閱[單行模式](#single-line-mode)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-117">For more information, see [Single-line Mode](#single-line-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>|`n`|<span data-ttu-id="cc58d-118">不擷取未命名的群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-118">Do not capture unnamed groups.</span></span> <span data-ttu-id="cc58d-119">唯一有效的擷取是明確命名或編號的群組，格式如下：`(?<`name`>` subexpression`)`。</span><span class="sxs-lookup"><span data-stu-id="cc58d-119">The only valid captures are explicitly named or numbered groups of the form `(?<`*name*`>` *subexpression*`)`.</span></span> <span data-ttu-id="cc58d-120">如需詳細資訊，請參閱[僅明確擷取](#explicit-captures-only)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-120">For more information, see [Explicit Captures Only](#explicit-captures-only).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Compiled>|<span data-ttu-id="cc58d-121">無法使用</span><span class="sxs-lookup"><span data-stu-id="cc58d-121">Not available</span></span>|<span data-ttu-id="cc58d-122">將規則運算式編譯為組件。</span><span class="sxs-lookup"><span data-stu-id="cc58d-122">Compile the regular expression to an assembly.</span></span> <span data-ttu-id="cc58d-123">如需詳細資訊，請參閱[編譯的規則運算式](#compiled-regular-expressions)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-123">For more information, see [Compiled Regular Expressions](#compiled-regular-expressions).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace>|`x`|<span data-ttu-id="cc58d-124">在模式中排除未逸出的空白字元，並且在數字符號 (`#`) 後面啟用註解。</span><span class="sxs-lookup"><span data-stu-id="cc58d-124">Exclude unescaped white space from the pattern, and enable comments after a number sign (`#`).</span></span> <span data-ttu-id="cc58d-125">如需詳細資訊，請參閱[忽略空白字元](#ignore-white-space)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-125">For more information, see [Ignore White Space](#ignore-white-space).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>|<span data-ttu-id="cc58d-126">無法使用</span><span class="sxs-lookup"><span data-stu-id="cc58d-126">Not available</span></span>|<span data-ttu-id="cc58d-127">變更搜尋方向。</span><span class="sxs-lookup"><span data-stu-id="cc58d-127">Change the search direction.</span></span> <span data-ttu-id="cc58d-128">搜尋方向為由右至左，而不是由左至右。</span><span class="sxs-lookup"><span data-stu-id="cc58d-128">Search moves from right to left instead of from left to right.</span></span> <span data-ttu-id="cc58d-129">如需詳細資訊，請參閱[由右至左模式](#right-to-left-mode)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-129">For more information, see [Right-to-Left Mode](#right-to-left-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ECMAScript>|<span data-ttu-id="cc58d-130">無法使用</span><span class="sxs-lookup"><span data-stu-id="cc58d-130">Not available</span></span>|<span data-ttu-id="cc58d-131">為運算式啟用符合 ECMAScript 規範的行為。</span><span class="sxs-lookup"><span data-stu-id="cc58d-131">Enable ECMAScript-compliant behavior for the expression.</span></span> <span data-ttu-id="cc58d-132">如需詳細資訊，請參閱 [ECMAScript 相符行為](#ecmascript-matching-behavior)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-132">For more information, see [ECMAScript Matching Behavior](#ecmascript-matching-behavior).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant>|<span data-ttu-id="cc58d-133">無法使用</span><span class="sxs-lookup"><span data-stu-id="cc58d-133">Not available</span></span>|<span data-ttu-id="cc58d-134">忽略語言中的文化特性差異。</span><span class="sxs-lookup"><span data-stu-id="cc58d-134">Ignore cultural differences in language.</span></span> <span data-ttu-id="cc58d-135">如需詳細資訊，請參閱[使用不因國別而異的文化特性比較](#comparison-using-the-invariant-culture)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-135">For more information, see [Comparison Using the Invariant Culture](#comparison-using-the-invariant-culture).</span></span>|

## <a name="specifying-the-options"></a><span data-ttu-id="cc58d-136">指定選項</span><span class="sxs-lookup"><span data-stu-id="cc58d-136">Specifying the Options</span></span>

<span data-ttu-id="cc58d-137">指定規則運算式選項的方式有三種：</span><span class="sxs-lookup"><span data-stu-id="cc58d-137">You can specify options for regular expressions in one of three ways:</span></span>

- <span data-ttu-id="cc58d-138">在 `options` 類別建構函式或靜態 (在 Visual Basic 中為 <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType>) 模式比對方法 (例如 `Shared` 或 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>) 的 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 參數中。</span><span class="sxs-lookup"><span data-stu-id="cc58d-138">In the `options` parameter of a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static (`Shared` in Visual Basic) pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc58d-139">`options` 參數是 <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 列舉值的位元「或」組合。</span><span class="sxs-lookup"><span data-stu-id="cc58d-139">The `options` parameter is a bitwise OR combination of <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumerated values.</span></span>

  <span data-ttu-id="cc58d-140">當使用類別建構函式的 `options` 參數提供選項給 <xref:System.Text.RegularExpressions.Regex> 執行個體時，選項會指派給 <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 屬性。</span><span class="sxs-lookup"><span data-stu-id="cc58d-140">When options are supplied to a <xref:System.Text.RegularExpressions.Regex> instance by using the `options` parameter of a class constructor, the options are assigned to the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="cc58d-141">不過，<xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 屬性不會在規則運算式模式中反映內嵌選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-141">However, the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property does not reflect inline options in the regular expression pattern itself.</span></span>

  <span data-ttu-id="cc58d-142">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="cc58d-142">The following example provides an illustration.</span></span> <span data-ttu-id="cc58d-143">其使用 `options` 方法的 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 參數來啟用不區分大小寫比對，並且在識別以字母 "d" 開頭的文字時，忽略模式空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-143">It uses the `options` parameter of the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#6)]
  [!code-vb[Conceptual.Regex.Language.Options#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#6)]

- <span data-ttu-id="cc58d-144">使用語法 `(?imnsx-imnsx)`，在規則運算式模式中套用內嵌選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-144">By applying inline options in a regular expression pattern with the syntax `(?imnsx-imnsx)`.</span></span> <span data-ttu-id="cc58d-145">此選項會從定義選項的位置開始套用至模式，直到模式結尾，或是有其他內嵌選項取消定義選項為止。</span><span class="sxs-lookup"><span data-stu-id="cc58d-145">The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</span></span> <span data-ttu-id="cc58d-146">請注意，<xref:System.Text.RegularExpressions.Regex> 執行個體的 <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> 屬性不會反映這些內嵌選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-146">Note that the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property of a <xref:System.Text.RegularExpressions.Regex> instance does not reflect these inline options.</span></span> <span data-ttu-id="cc58d-147">如需詳細資訊，請參閱[其他建構](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md)主題。</span><span class="sxs-lookup"><span data-stu-id="cc58d-147">For more information, see the [Miscellaneous Constructs](../../../docs/standard/base-types/miscellaneous-constructs-in-regular-expressions.md) topic.</span></span>

  <span data-ttu-id="cc58d-148">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="cc58d-148">The following example provides an illustration.</span></span> <span data-ttu-id="cc58d-149">其使用內嵌選項來啟用不區分大小寫比對，並且在識別以字母 "d" 開頭的文字時，忽略模式空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-149">It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#7)]
  [!code-vb[Conceptual.Regex.Language.Options#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#7)]

- <span data-ttu-id="cc58d-150">使用語法 `(?imnsx-imnsx:`subexpression`)`，在規則運算式模式的特定群組建構中套用內嵌選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-150">By applying inline options in a particular grouping construct in a regular expression pattern with the syntax `(?imnsx-imnsx:`*subexpression*`)`.</span></span> <span data-ttu-id="cc58d-151">如果選項集前面沒有符號，會開啟選項集；如果選項集前面有減號，則會關閉選項集。</span><span class="sxs-lookup"><span data-stu-id="cc58d-151">No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</span></span> <span data-ttu-id="cc58d-152">（`?` 是語言結構的固定部分，無論啟用或停用選項，都需要此語法。）此選項只適用于該群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-152">(`?` is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</span></span> <span data-ttu-id="cc58d-153">如需詳細資訊，請參閱[分組建構](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-153">For more information, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

  <span data-ttu-id="cc58d-154">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="cc58d-154">The following example provides an illustration.</span></span> <span data-ttu-id="cc58d-155">其使用群組建構中的內嵌選項來啟用不區分大小寫比對，並且在識別以字母 "d" 開頭的文字時，忽略模式空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-155">It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
  [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]

<span data-ttu-id="cc58d-156">如果將選項指定為內嵌，選項或選項集前面的減號 (`-`) 會關閉那些選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-156">If options are specified inline, a minus sign (`-`) before an option or set of options turns off those options.</span></span> <span data-ttu-id="cc58d-157">例如，內嵌建構 `(?ix-ms)` 會開啟 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 選項，並關閉 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> 選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-157">For example, the inline construct `(?ix-ms)` turns on the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> options and turns off the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="cc58d-158">依預設，會關閉所有規則運算式選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-158">All regular expression options are turned off by default.</span></span>

> [!NOTE]
> <span data-ttu-id="cc58d-159">如果建構函式或方法呼叫的 `options` 參數指定的規則運算式選項，與規則運算式模式中指定內嵌的選項相衝突，則會使用內嵌選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-159">If the regular expression options specified in the `options` parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</span></span>

<span data-ttu-id="cc58d-160">選項參數和內嵌都可以用來設定下列五個規則運算式選項：</span><span class="sxs-lookup"><span data-stu-id="cc58d-160">The following five regular expression options can be set both with the options parameter and inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>

<span data-ttu-id="cc58d-161">下列五個規則運算式選項可以用 `options` 參數來設定，但不能設定內嵌：</span><span class="sxs-lookup"><span data-stu-id="cc58d-161">The following five regular expression options can be set using the `options` parameter but cannot be set inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>

## <a name="determining-the-options"></a><span data-ttu-id="cc58d-162">決定選項</span><span class="sxs-lookup"><span data-stu-id="cc58d-162">Determining the Options</span></span>

<span data-ttu-id="cc58d-163">您可以判定，在擷取唯讀 <xref:System.Text.RegularExpressions.Regex> 屬性的值來將物件具現化時，提供了哪些選項給 <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="cc58d-163">You can determine which options were provided to a <xref:System.Text.RegularExpressions.Regex> object when it was instantiated by retrieving the value of the read-only <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="cc58d-164">在判定為 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> 方法建立之編譯規則運算式定義的選項時，此屬性特別好用。</span><span class="sxs-lookup"><span data-stu-id="cc58d-164">This property is particularly useful for determining the options that are defined for a compiled regular expression created by the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="cc58d-165">若要測試任何選項 (<xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 除外) 是否存在，請使用 <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> 屬性的值和您感興趣的 <xref:System.Text.RegularExpressions.RegexOptions> 值來執行 AND 作業。</span><span class="sxs-lookup"><span data-stu-id="cc58d-165">To test for the presence of any option except <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, perform an AND operation with the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property and the <xref:System.Text.RegularExpressions.RegexOptions> value in which you are interested.</span></span> <span data-ttu-id="cc58d-166">然後測試結果是否等於 <xref:System.Text.RegularExpressions.RegexOptions> 值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-166">Then test whether the result equals that <xref:System.Text.RegularExpressions.RegexOptions> value.</span></span> <span data-ttu-id="cc58d-167">下列範例會測試是否已設定 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-167">The following example tests whether the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option has been set.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#19)]
[!code-vb[Conceptual.Regex.Language.Options#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#19)]

<span data-ttu-id="cc58d-168">若要測試 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>，請判定 <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> 屬性的值是否等於 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="cc58d-168">To test for <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, determine whether the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property is equal to <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, as the following example illustrates.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#20)]
[!code-vb[Conceptual.Regex.Language.Options#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#20)]

<span data-ttu-id="cc58d-169">以下各節會列出 .NET 中規則運算式所支援的選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-169">The following sections list the options supported by regular expression in .NET.</span></span>

## <a name="default-options"></a><span data-ttu-id="cc58d-170">預設選項</span><span class="sxs-lookup"><span data-stu-id="cc58d-170">Default Options</span></span>

<span data-ttu-id="cc58d-171"><xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 選項指出未指定任何選項，而規則運算式引擎使用其預設行為。</span><span class="sxs-lookup"><span data-stu-id="cc58d-171">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</span></span> <span data-ttu-id="cc58d-172">其中包括下列項目：</span><span class="sxs-lookup"><span data-stu-id="cc58d-172">This includes the following:</span></span>

- <span data-ttu-id="cc58d-173">模式被解譯為標準規則運算式，而不是 ECMAScript 規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-173">The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</span></span>

- <span data-ttu-id="cc58d-174">在輸入字串中，由左至右比對規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-174">The regular expression pattern is matched in the input string from left to right.</span></span>

- <span data-ttu-id="cc58d-175">比較會區分大小寫。</span><span class="sxs-lookup"><span data-stu-id="cc58d-175">Comparisons are case-sensitive.</span></span>

- <span data-ttu-id="cc58d-176">`^` 和 `$` 語言項目會比對輸入字串的開頭和結尾。</span><span class="sxs-lookup"><span data-stu-id="cc58d-176">The `^` and `$` language elements match the beginning and end of the input string.</span></span>

- <span data-ttu-id="cc58d-177">`.` 語言項目會比對 `\n` 以外的每個字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-177">The `.` language element matches every character except `\n`.</span></span>

- <span data-ttu-id="cc58d-178">規則運算式模式中的任何空白字元會被解譯成常值空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-178">Any white space in a regular expression pattern is interpreted as a literal space character.</span></span>

- <span data-ttu-id="cc58d-179">將模式與輸入字串比較時，會使用目前文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="cc58d-179">The conventions of the current culture are used when comparing the pattern to the input string.</span></span>

- <span data-ttu-id="cc58d-180">規則運算式模式中的擷取群組是隱含的，也是明確的。</span><span class="sxs-lookup"><span data-stu-id="cc58d-180">Capturing groups in the regular expression pattern are implicit as well as explicit.</span></span>

> [!NOTE]
> <span data-ttu-id="cc58d-181"><xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 選項沒有內嵌對等項目。</span><span class="sxs-lookup"><span data-stu-id="cc58d-181">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option has no inline equivalent.</span></span> <span data-ttu-id="cc58d-182">將規則運算式選項套用為內嵌時，會關閉特定選項，依據各選項逐一還原預設行為。</span><span class="sxs-lookup"><span data-stu-id="cc58d-182">When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</span></span> <span data-ttu-id="cc58d-183">例如，`(?i)` 會開啟不區分大小寫比較，而 `(?-i)` 會還原預設區分大小寫比較。</span><span class="sxs-lookup"><span data-stu-id="cc58d-183">For example, `(?i)` turns on case-insensitive comparison, and `(?-i)` restores the default case-sensitive comparison.</span></span>

<span data-ttu-id="cc58d-184">因為 <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> 選項代表規則運算式引擎的預設行為，所以很少明確地指定在方法呼叫中，</span><span class="sxs-lookup"><span data-stu-id="cc58d-184">Because the <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</span></span> <span data-ttu-id="cc58d-185">而是會呼叫不含 `options` 參數的建構函式或靜態模式比對方法。</span><span class="sxs-lookup"><span data-stu-id="cc58d-185">A constructor or static pattern-matching method without an `options` parameter is called instead.</span></span>

## <a name="case-insensitive-matching"></a><span data-ttu-id="cc58d-186">不區分大小寫比對</span><span class="sxs-lookup"><span data-stu-id="cc58d-186">Case-Insensitive Matching</span></span>

<span data-ttu-id="cc58d-187"><xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> 選項 (或 `i` 內嵌選項) 提供不區分大小寫比對。</span><span class="sxs-lookup"><span data-stu-id="cc58d-187">The <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> option, or the `i` inline option, provides case-insensitive matching.</span></span> <span data-ttu-id="cc58d-188">依預設，會使用目前文化特性的大小寫慣例。</span><span class="sxs-lookup"><span data-stu-id="cc58d-188">By default, the casing conventions of the current culture are used.</span></span>

<span data-ttu-id="cc58d-189">下列範例定義規則運算式模式 `\bthe\w*\b`，它會比對以 "the" 開頭的所有文字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-189">The following example defines a regular expression pattern, `\bthe\w*\b`, that matches all words starting with "the".</span></span> <span data-ttu-id="cc58d-190">因為第一次呼叫 <xref:System.Text.RegularExpressions.Regex.Match%2A> 方法是使用預設的區分大小寫比較，所以輸出指出未比對句子開頭的 "The" 字串。</span><span class="sxs-lookup"><span data-stu-id="cc58d-190">Because the first call to the <xref:System.Text.RegularExpressions.Regex.Match%2A> method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</span></span> <span data-ttu-id="cc58d-191">選項設為 <xref:System.Text.RegularExpressions.Regex.Match%2A> 來呼叫 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> 方法時，才會加以比對。</span><span class="sxs-lookup"><span data-stu-id="cc58d-191">It is matched when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with options set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case1.cs#1)]
[!code-vb[Conceptual.Regex.Language.Options#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case1.vb#1)]

<span data-ttu-id="cc58d-192">下列範例會修改上一個範例中的規則運算式模式，改為使用內嵌選項，而不是使用 `options` 參數，以提供不區分大小寫比較。</span><span class="sxs-lookup"><span data-stu-id="cc58d-192">The following example modifies the regular expression pattern from the previous example to use inline options instead of the `options` parameter to provide case-insensitive comparison.</span></span> <span data-ttu-id="cc58d-193">第一個模式在群組建構中定義不區分大小寫選項，只套用於字串 "the" 中的字母 "t"。</span><span class="sxs-lookup"><span data-stu-id="cc58d-193">The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</span></span> <span data-ttu-id="cc58d-194">因為選項建構出現在模式開頭，所以第二個模式會將不區分大小寫選項套用於整個規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-194">Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case2.cs#2)]
[!code-vb[Conceptual.Regex.Language.Options#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case2.vb#2)]

## <a name="multiline-mode"></a><span data-ttu-id="cc58d-195">多行模式</span><span class="sxs-lookup"><span data-stu-id="cc58d-195">Multiline Mode</span></span>

<span data-ttu-id="cc58d-196"><xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項 (或 `m` 內嵌選項) 可讓規則運算式引擎處理構成多行的輸入字串。</span><span class="sxs-lookup"><span data-stu-id="cc58d-196">The <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, or the `m` inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</span></span> <span data-ttu-id="cc58d-197">它會變更 `^` 和 `$` 語言項目的解譯，以便比對字行的開頭和結尾，而不是輸入字串的開頭和結尾。</span><span class="sxs-lookup"><span data-stu-id="cc58d-197">It changes the interpretation of the `^` and `$` language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</span></span>

<span data-ttu-id="cc58d-198">依預設，`$` 只會比對輸入字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="cc58d-198">By default, `$` matches only the end of the input string.</span></span> <span data-ttu-id="cc58d-199">如果您指定 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項，則會比對新行字元 (`\n`) 或輸入字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="cc58d-199">If you specify the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, it matches either the newline character (`\n`) or the end of the input string.</span></span> <span data-ttu-id="cc58d-200">不過，並不會比對歸位字元/換行字元組合。</span><span class="sxs-lookup"><span data-stu-id="cc58d-200">It does not, however, match the carriage return/line feed character combination.</span></span> <span data-ttu-id="cc58d-201">若要順利比對，請使用子運算式 `\r?$`，而不只是使用 `$`。</span><span class="sxs-lookup"><span data-stu-id="cc58d-201">To successfully match them, use the subexpression `\r?$` instead of just `$`.</span></span>

<span data-ttu-id="cc58d-202">下列範例會擷取保齡球員的名字和分數，並將其加入 <xref:System.Collections.Generic.SortedList%602> 集合，以遞減順序排序。</span><span class="sxs-lookup"><span data-stu-id="cc58d-202">The following example extracts bowlers' names and scores and adds them to a <xref:System.Collections.Generic.SortedList%602> collection that sorts them in descending order.</span></span> <span data-ttu-id="cc58d-203">呼叫 <xref:System.Text.RegularExpressions.Regex.Matches%2A> 方法兩次。</span><span class="sxs-lookup"><span data-stu-id="cc58d-203">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method is called twice.</span></span> <span data-ttu-id="cc58d-204">在第一次呼叫方法時，規則運算式為 `^(\w+)\s(\d+)$`，且沒有設定選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-204">In the first method call, the regular expression is `^(\w+)\s(\d+)$` and no options are set.</span></span> <span data-ttu-id="cc58d-205">如輸出所示，因為規則運算式引擎無法隨著輸入字串的開頭和結尾來比對輸入模式，所以沒有找到相符項目。</span><span class="sxs-lookup"><span data-stu-id="cc58d-205">As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</span></span> <span data-ttu-id="cc58d-206">在第二次呼叫方法時，規則運算式變更為 `^(\w+)\s(\d+)\r?$`，且選項設為 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="cc58d-206">In the second method call, the regular expression is changed to `^(\w+)\s(\d+)\r?$` and the options are set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc58d-207">如輸出所示，已成功比對名字和分數，且分數以遞減順序顯示。</span><span class="sxs-lookup"><span data-stu-id="cc58d-207">As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline1.cs#3)]
[!code-vb[Conceptual.Regex.Language.Options#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline1.vb#3)]

<span data-ttu-id="cc58d-208">規則運算式模式 `^(\w+)\s(\d+)\r*$` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="cc58d-208">The regular expression pattern `^(\w+)\s(\d+)\r*$` is defined as shown in the following table.</span></span>

|<span data-ttu-id="cc58d-209">模式</span><span class="sxs-lookup"><span data-stu-id="cc58d-209">Pattern</span></span>|<span data-ttu-id="cc58d-210">描述</span><span class="sxs-lookup"><span data-stu-id="cc58d-210">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="cc58d-211">從字行開頭開始。</span><span class="sxs-lookup"><span data-stu-id="cc58d-211">Begin at the start of the line.</span></span>|
|`(\w+)`|<span data-ttu-id="cc58d-212">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-212">Match one or more word characters.</span></span> <span data-ttu-id="cc58d-213">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-213">This is the first capturing group.</span></span>|
|`\s`|<span data-ttu-id="cc58d-214">比對空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-214">Match a white-space character.</span></span>|
|`(\d+)`|<span data-ttu-id="cc58d-215">比對一個或多個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-215">Match one or more decimal digits.</span></span> <span data-ttu-id="cc58d-216">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-216">This is the second capturing group.</span></span>|
|`\r?`|<span data-ttu-id="cc58d-217">比對零或一個歸位字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-217">Match zero or one carriage return character.</span></span>|
|`$`|<span data-ttu-id="cc58d-218">在字行結尾結束。</span><span class="sxs-lookup"><span data-stu-id="cc58d-218">End at the end of the line.</span></span>|

<span data-ttu-id="cc58d-219">下列範例與上一個範例相同，只是下列範例是使用內嵌選項 `(?m)` 來設定多行選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-219">The following example is equivalent to the previous one, except that it uses the inline option `(?m)` to set the multiline option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline2.cs#4)]
[!code-vb[Conceptual.Regex.Language.Options#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline2.vb#4)]

## <a name="single-line-mode"></a><span data-ttu-id="cc58d-220">單行模式</span><span class="sxs-lookup"><span data-stu-id="cc58d-220">Single-line Mode</span></span>

<span data-ttu-id="cc58d-221"><xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> 選項 (或 `s` 內嵌選項) 會使規則運算式引擎將輸入字串當作其包含單行。</span><span class="sxs-lookup"><span data-stu-id="cc58d-221">The <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option, or the `s` inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</span></span> <span data-ttu-id="cc58d-222">其作法是變更句點 (`.`) 語言項目的行為，使其比對每個字元，而不是比對新行字元 `\n` 或 \u000A 以外的每個字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-222">It does this by changing the behavior of the period (`.`) language element so that it matches every character, instead of matching every character except for the newline character `\n` or \u000A.</span></span>

<span data-ttu-id="cc58d-223">下列範例說明，當您使用 `.` 選項時，<xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> 語言項目的行為有何變更。</span><span class="sxs-lookup"><span data-stu-id="cc58d-223">The following example illustrates how the behavior of the `.` language element changes when you use the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="cc58d-224">規則運算式 `^.+` 會從字串開頭開始，比對每一個字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-224">The regular expression `^.+` starts at the beginning of the string and matches every character.</span></span> <span data-ttu-id="cc58d-225">根據預設，比對會在第一行結尾結束。規則運算式模式會比對歸位字元 `\r` 或 \u000D，但不會比對 `\n`。</span><span class="sxs-lookup"><span data-stu-id="cc58d-225">By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, `\r` or \u000D, but it does not match `\n`.</span></span> <span data-ttu-id="cc58d-226">由於 <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> 選項會將整個輸入字串解譯為單行，因此它會比對輸入字串中的每個字元，包括 `\n`。</span><span class="sxs-lookup"><span data-stu-id="cc58d-226">Because the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option interprets the entire input string as a single line, it matches every character in the input string, including `\n`.</span></span>

[!code-csharp[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)]
[!code-vb[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)]

<span data-ttu-id="cc58d-227">下列範例與上一個範例相同，只是下列範例是使用內嵌選項 `(?s)` 來啟用單行模式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-227">The following example is equivalent to the previous one, except that it uses the inline option `(?s)` to enable single-line mode.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/singleline1.cs#5)]
[!code-vb[Conceptual.Regex.Language.Options#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/singleline1.vb#5)]

## <a name="explicit-captures-only"></a><span data-ttu-id="cc58d-228">僅明確擷取</span><span class="sxs-lookup"><span data-stu-id="cc58d-228">Explicit Captures Only</span></span>

<span data-ttu-id="cc58d-229">依預設，擷取群組的定義方式是在規則運算式模式中使用括號。</span><span class="sxs-lookup"><span data-stu-id="cc58d-229">By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</span></span> <span data-ttu-id="cc58d-230">具名群組是以 `(?<`name`>`subexpression`)` 語言選項來指派名稱或號碼，而未具名群組可透過索引來存取。</span><span class="sxs-lookup"><span data-stu-id="cc58d-230">Named groups are assigned a name or number by the `(?<`*name*`>`*subexpression*`)` language option, whereas unnamed groups are accessible by index.</span></span> <span data-ttu-id="cc58d-231">在 <xref:System.Text.RegularExpressions.GroupCollection> 物件中，未具名群組的前面是具名群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-231">In the <xref:System.Text.RegularExpressions.GroupCollection> object, unnamed groups precede named groups.</span></span>

<span data-ttu-id="cc58d-232">群組建構通常只用來將數量詞套用至多個語言項目，我們對所擷取的子字串並不感興趣。</span><span class="sxs-lookup"><span data-stu-id="cc58d-232">Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</span></span> <span data-ttu-id="cc58d-233">例如，如果下列運算式：</span><span class="sxs-lookup"><span data-stu-id="cc58d-233">For example, if the following regular expression:</span></span>

`\b\(?((\w+),?\s?)+[\.!?]\)?`

<span data-ttu-id="cc58d-234">目的只是要從文件中擷取以句點、驚嘆號或問號結尾的句子，則我們只對所產生的句子 (由 <xref:System.Text.RegularExpressions.Match> 物件代表) 感興趣。</span><span class="sxs-lookup"><span data-stu-id="cc58d-234">is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <xref:System.Text.RegularExpressions.Match> object) is of interest.</span></span> <span data-ttu-id="cc58d-235">我們對集合中的個別文字並不感興趣。</span><span class="sxs-lookup"><span data-stu-id="cc58d-235">The individual words in the collection are not.</span></span>

<span data-ttu-id="cc58d-236">非後續使用的擷取群組可能會耗用很多資源，因為規則運算式引擎必須同時填入 <xref:System.Text.RegularExpressions.GroupCollection> 和 <xref:System.Text.RegularExpressions.CaptureCollection> 集合物件。</span><span class="sxs-lookup"><span data-stu-id="cc58d-236">Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects.</span></span> <span data-ttu-id="cc58d-237">或者，您也可以使用 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 選項或 `n` 內嵌選項，指定唯一有效的擷取是 `(?<`*name*`>` *subexpression*`)` 建構所指定的明確命名或編號群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-237">As an alternative, you can use either the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option or the `n` inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the `(?<`*name*`>` *subexpression*`)` construct.</span></span>

<span data-ttu-id="cc58d-238">下列範例顯示，當呼叫 `\b\(?((\w+),?\s?)+[\.!?]\)?` 方法時，如果沒有使用 <xref:System.Text.RegularExpressions.Regex.Match%2A> 選項，<xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 規則運算式模式所傳回的比對相關資訊。</span><span class="sxs-lookup"><span data-stu-id="cc58d-238">The following example displays information about the matches returned by the `\b\(?((\w+),?\s?)+[\.!?]\)?` regular expression pattern when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with and without the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="cc58d-239">當第一個方法呼叫的輸出顯示時，規則運算式引擎會以擷取子字串的相關資訊完整填入 <xref:System.Text.RegularExpressions.GroupCollection> 和 <xref:System.Text.RegularExpressions.CaptureCollection> 集合物件。</span><span class="sxs-lookup"><span data-stu-id="cc58d-239">As the output from the first method call shows, the regular expression engine fully populates the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects with information about captured substrings.</span></span> <span data-ttu-id="cc58d-240">因為呼叫第二個方法時，`options` 設為 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>，所以沒有擷取群組的資訊。</span><span class="sxs-lookup"><span data-stu-id="cc58d-240">Because the second method is called with `options` set to <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, it does not capture information on groups.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit1.cs#9)]
[!code-vb[Conceptual.Regex.Language.Options#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit1.vb#9)]

<span data-ttu-id="cc58d-241">規則運算式模式 `\b\(?((?>\w+),?\s?)+[\.!?]\)?` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="cc58d-241">The regular expression pattern`\b\(?((?>\w+),?\s?)+[\.!?]\)?` is defined as shown in the following table.</span></span>

|<span data-ttu-id="cc58d-242">模式</span><span class="sxs-lookup"><span data-stu-id="cc58d-242">Pattern</span></span>|<span data-ttu-id="cc58d-243">描述</span><span class="sxs-lookup"><span data-stu-id="cc58d-243">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="cc58d-244">從字邊界開始。</span><span class="sxs-lookup"><span data-stu-id="cc58d-244">Begin at a word boundary.</span></span>|
|`\(?`|<span data-ttu-id="cc58d-245">比對出現零或一次的左括號 ("(")。</span><span class="sxs-lookup"><span data-stu-id="cc58d-245">Match zero or one occurrences of the opening parenthesis ("(").</span></span>|
|`(?>\w+),?`|<span data-ttu-id="cc58d-246">比對後面接著零或一個逗號的一或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-246">Match one or more word characters, followed by zero or one commas.</span></span> <span data-ttu-id="cc58d-247">比對文字字元時，請勿回溯。</span><span class="sxs-lookup"><span data-stu-id="cc58d-247">Do not backtrack when matching word characters.</span></span>|
|`\s?`|<span data-ttu-id="cc58d-248">比對零個或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-248">Match zero or one white-space characters.</span></span>|
|`((\w+),?\s?)+`|<span data-ttu-id="cc58d-249">一或多次比對一或多個文字字元、零或一個逗號及零或一個空白字元的組合。</span><span class="sxs-lookup"><span data-stu-id="cc58d-249">Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</span></span>|
|`[\.!?]\)?`|<span data-ttu-id="cc58d-250">比對這三種標點符號中的任一種，後面接零或一個右括號 (")")。</span><span class="sxs-lookup"><span data-stu-id="cc58d-250">Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</span></span>|

<span data-ttu-id="cc58d-251">您也可以使用 `(?n)` 內嵌元素來隱藏自動擷取。</span><span class="sxs-lookup"><span data-stu-id="cc58d-251">You can also use the `(?n)` inline element to suppress automatic captures.</span></span> <span data-ttu-id="cc58d-252">下列範例會修改上一個規則運算式模式，以使用 `(?n)` 內嵌項目，而不是使用 <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> 選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-252">The following example modifies the previous regular expression pattern to use the `(?n)` inline element instead of the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit2.cs#10)]
[!code-vb[Conceptual.Regex.Language.Options#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit2.vb#10)]

<span data-ttu-id="cc58d-253">最後，您可以使用內嵌群組項目 `(?n:)`，針對每個群組逐一隱藏自動擷取。</span><span class="sxs-lookup"><span data-stu-id="cc58d-253">Finally, you can use the inline group element `(?n:)` to suppress automatic captures on a group-by-group basis.</span></span> <span data-ttu-id="cc58d-254">下列範例會修改上一個模式，以隱藏外部群組 `((?>\w+),?\s?)` 中的未具名擷取。</span><span class="sxs-lookup"><span data-stu-id="cc58d-254">The following example modifies the previous pattern to suppress unnamed captures in the outer group, `((?>\w+),?\s?)`.</span></span> <span data-ttu-id="cc58d-255">請注意，這也會隱藏內部群組中的未具名擷取。</span><span class="sxs-lookup"><span data-stu-id="cc58d-255">Note that this suppresses unnamed captures in the inner group as well.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit3.cs#11)]
[!code-vb[Conceptual.Regex.Language.Options#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit3.vb#11)]

## <a name="compiled-regular-expressions"></a><span data-ttu-id="cc58d-256">編譯的規則運算式</span><span class="sxs-lookup"><span data-stu-id="cc58d-256">Compiled Regular Expressions</span></span>

<span data-ttu-id="cc58d-257">預設會解譯 .NET 中的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-257">By default, regular expressions in .NET are interpreted.</span></span> <span data-ttu-id="cc58d-258">將 <xref:System.Text.RegularExpressions.Regex> 物件具現化，或是呼叫靜態 <xref:System.Text.RegularExpressions.Regex> 方法時，會將規則運算式模式剖析成一組自訂 opcode，而解譯器會使用這些 opcode 來執行規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-258">When a <xref:System.Text.RegularExpressions.Regex> object is instantiated or a static <xref:System.Text.RegularExpressions.Regex> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</span></span> <span data-ttu-id="cc58d-259">這需要有所取捨：要將初始化規則運算式引擎的成本降到最低，就會犧牲執行時期效能。</span><span class="sxs-lookup"><span data-stu-id="cc58d-259">This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</span></span>

<span data-ttu-id="cc58d-260">您可以使用 <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> 選項，以編譯的規則運算式來取代解譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-260">You can use compiled instead of interpreted regular expressions by using the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="cc58d-261">在這個情況下，將模式傳遞至規則運算式時，會將該模式剖析成一組自訂作業碼，然後再轉換成 Microsoft 中繼語言 (MSIL)，可直接傳遞至通用語言執行平台。</span><span class="sxs-lookup"><span data-stu-id="cc58d-261">In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</span></span> <span data-ttu-id="cc58d-262">編譯的規則運算式可充分提升執行時期效能，但會犧牲初始化時間。</span><span class="sxs-lookup"><span data-stu-id="cc58d-262">Compiled regular expressions maximize run-time performance at the expense of initialization time.</span></span>

> [!NOTE]
> <span data-ttu-id="cc58d-263">若要編譯規則運算式，唯一的方法就是提供 <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> 值給 `options` 類別建構函式或靜態模式比對方法的 <xref:System.Text.RegularExpressions.Regex> 參數。</span><span class="sxs-lookup"><span data-stu-id="cc58d-263">A regular expression can be compiled only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or a static pattern-matching method.</span></span> <span data-ttu-id="cc58d-264">無法以內嵌選項來提供此值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-264">It is not available as an inline option.</span></span>

<span data-ttu-id="cc58d-265">在呼叫靜態和執行個體規則運算式時，都可以使用編譯的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-265">You can use compiled regular expressions in calls to both static and instance regular expressions.</span></span> <span data-ttu-id="cc58d-266">在靜態規則運算式中，會將 <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> 選項傳遞至規則運算式模式比對方法的 `options` 參數。</span><span class="sxs-lookup"><span data-stu-id="cc58d-266">In static regular expressions, the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is passed to the `options` parameter of the regular expression pattern-matching method.</span></span> <span data-ttu-id="cc58d-267">在執行個體規則運算式中，則會傳遞至 `options` 類別建構函式的 <xref:System.Text.RegularExpressions.Regex> 參數。</span><span class="sxs-lookup"><span data-stu-id="cc58d-267">In instance regular expressions, it is passed to the `options` parameter of the <xref:System.Text.RegularExpressions.Regex> class constructor.</span></span> <span data-ttu-id="cc58d-268">在這兩個情況中，都會增強效能。</span><span class="sxs-lookup"><span data-stu-id="cc58d-268">In both cases, it results in enhanced performance.</span></span>

<span data-ttu-id="cc58d-269">不過，只有在下列條件下，效能才會提升：</span><span class="sxs-lookup"><span data-stu-id="cc58d-269">However, this improvement in performance occurs only under the following conditions:</span></span>

- <span data-ttu-id="cc58d-270">在對規則運算式模式比對方法的多個呼叫中，都會使用代表特定規則運算式的 <xref:System.Text.RegularExpressions.Regex> 物件。</span><span class="sxs-lookup"><span data-stu-id="cc58d-270">A <xref:System.Text.RegularExpressions.Regex> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span>

- <span data-ttu-id="cc58d-271"><xref:System.Text.RegularExpressions.Regex> 物件不能超出範圍，因此可以重複使用。</span><span class="sxs-lookup"><span data-stu-id="cc58d-271">The <xref:System.Text.RegularExpressions.Regex> object is not allowed to go out of scope, so it can be reused.</span></span>

- <span data-ttu-id="cc58d-272">在對規則運算式模式比對方法的多個呼叫中，會使用靜態規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-272">A static regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span> <span data-ttu-id="cc58d-273">(效能提升是有可能的，因為規則運算式引擎會快取靜態方法呼叫中所使用的規則運算式。)</span><span class="sxs-lookup"><span data-stu-id="cc58d-273">(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</span></span>

> [!NOTE]
> <span data-ttu-id="cc58d-274"><xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> 選項與 <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> 方法無關，此方法會建立特殊用途的組件，其中包含預先定義的編譯規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-274">The <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is unrelated to the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, which creates a special-purpose assembly that contains predefined compiled regular expressions.</span></span>

## <a name="ignore-white-space"></a><span data-ttu-id="cc58d-275">忽略空白字元</span><span class="sxs-lookup"><span data-stu-id="cc58d-275">Ignore White Space</span></span>

<span data-ttu-id="cc58d-276">依預設，規則運算式模式中的空白字元很重要；它會強制規則運算式引擎比對輸入字串中的空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-276">By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</span></span> <span data-ttu-id="cc58d-277">因此，規則運算式 "`\b\w+\s`" 和 "`\b\w+`" 是大致相等的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-277">Because of this, the regular expression "`\b\w+\s`" and "`\b\w+` " are roughly equivalent regular expressions.</span></span> <span data-ttu-id="cc58d-278">此外，在規則運算式模式中遇到數字符號 (#) 時，會將其解譯成常值字元，以供比對。</span><span class="sxs-lookup"><span data-stu-id="cc58d-278">In addition, when the number sign (#) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</span></span>

<span data-ttu-id="cc58d-279"><xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 選項 (或 `x` 內嵌選項) 會變更此預設行為，如下所示：</span><span class="sxs-lookup"><span data-stu-id="cc58d-279">The <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option, or the `x` inline option, changes this default behavior as follows:</span></span>

- <span data-ttu-id="cc58d-280">規則運算式模式中未逸出的空白字元會被忽略。</span><span class="sxs-lookup"><span data-stu-id="cc58d-280">Unescaped white space in the regular expression pattern is ignored.</span></span> <span data-ttu-id="cc58d-281">若要在規則運算式模式中使用空白字元，就必須將它逸出 (例如，`\s` 或 "`\`")。</span><span class="sxs-lookup"><span data-stu-id="cc58d-281">To be part of a regular expression pattern, white-space characters must be escaped (for example, as `\s` or "`\` ").</span></span>

- <span data-ttu-id="cc58d-282">數字符號 (#) 會解譯成註解的開頭，而不是常值字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-282">The number sign (#) is interpreted as the beginning of a comment, rather than as a literal character.</span></span> <span data-ttu-id="cc58d-283">規則運算式模式中，從 # 字元到字串結尾的所有文字會被解譯成註解。</span><span class="sxs-lookup"><span data-stu-id="cc58d-283">All text in the regular expression pattern from the # character to the end of the string is interpreted as a comment.</span></span>

<span data-ttu-id="cc58d-284">但在下列案例中，即使您使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 選項，也不會忽略規則運算式中的空白字元：</span><span class="sxs-lookup"><span data-stu-id="cc58d-284">However, in the following cases, white-space characters in a regular expression aren't ignored, even if you use the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option:</span></span>

- <span data-ttu-id="cc58d-285">字元類別中的空白字元一律解譯為常值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-285">White space within a character class is always interpreted literally.</span></span> <span data-ttu-id="cc58d-286">例如，規則運算式模式 `[ .,;:]` 會比對任何單一空白字元、句點、逗號、分號或冒號。</span><span class="sxs-lookup"><span data-stu-id="cc58d-286">For example, the regular expression pattern `[ .,;:]` matches any single white-space character, period, comma, semicolon, or colon.</span></span>

- <span data-ttu-id="cc58d-287">方括號數量詞中不允許空白字元，例如 `{`n`}`、`{`n`,}` 和 `{`n`,`m`}`。</span><span class="sxs-lookup"><span data-stu-id="cc58d-287">White space isn't allowed within a bracketed quantifier, such as `{`*n*`}`, `{`*n*`,}`, and `{`*n*`,`*m*`}`.</span></span> <span data-ttu-id="cc58d-288">例如，規則運算式模式 `\d{1, 3}` 無法比對從一到三位數的任何數字序列，因為其中包含空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-288">For example, the regular expression pattern `\d{1, 3}` fails to match any sequences of digits from one to three digits because it contains a white-space character.</span></span>

- <span data-ttu-id="cc58d-289">引進語言項目的字元序列中，不允許空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-289">White space isn't allowed within a character sequence that introduces a language element.</span></span> <span data-ttu-id="cc58d-290">例如:</span><span class="sxs-lookup"><span data-stu-id="cc58d-290">For example:</span></span>

  - <span data-ttu-id="cc58d-291">語言元素 `(?:`subexpression`)` 代表非擷取群組，而該項目的 `(?:` 部分不能有內嵌空格。</span><span class="sxs-lookup"><span data-stu-id="cc58d-291">The language element `(?:`*subexpression*`)` represents a noncapturing group, and the `(?:` portion of the element can't have embedded spaces.</span></span> <span data-ttu-id="cc58d-292">模式 `(? :`*subexpression*`)` 會在執行時期擲回 <xref:System.ArgumentException>，因為規則運算式引擎無法剖析該模式，而且模式 `( ?:`*subexpression*`)` 無法比對 *subexpression*。</span><span class="sxs-lookup"><span data-stu-id="cc58d-292">The pattern `(? :`*subexpression*`)` throws an <xref:System.ArgumentException> at run time because the regular expression engine can't parse the pattern, and the pattern `( ?:`*subexpression*`)` fails to match *subexpression*.</span></span>

  - <span data-ttu-id="cc58d-293">語言元素 `\p{`name`}` 代表 Unicode 類別或具名資料區塊，不能在此元素的 `\p{` 部分中包含內嵌空格。</span><span class="sxs-lookup"><span data-stu-id="cc58d-293">The language element `\p{`*name*`}`, which represents a Unicode category or named block, can't include embedded spaces in the `\p{` portion of the element.</span></span> <span data-ttu-id="cc58d-294">如果包含空白字元，則此項目會在執行時期擲回 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="cc58d-294">If you do include a white space, the element throws an <xref:System.ArgumentException> at run time.</span></span>

<span data-ttu-id="cc58d-295">啟用此選項有助於簡化通常很難剖析及了解的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-295">Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</span></span> <span data-ttu-id="cc58d-296">其增進了可讀性，並且讓規則運算式可以被記載下來。</span><span class="sxs-lookup"><span data-stu-id="cc58d-296">It improves readability, and makes it possible to document a regular expression.</span></span>

<span data-ttu-id="cc58d-297">下列範例定義下列規則運算式模式：</span><span class="sxs-lookup"><span data-stu-id="cc58d-297">The following example defines the following regular expression pattern:</span></span>

`\b \(? ( (?>\w+) ,?\s? )+  [\.!?] \)? # Matches an entire sentence.`

<span data-ttu-id="cc58d-298">此模式類似[僅明確擷取](#explicit-captures-only)一節中定義的模式，只是其會使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> 選項來忽略模式空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-298">This pattern is similar to the pattern defined in the [Explicit Captures Only](#explicit-captures-only) section, except that it uses the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace1.cs#12)]
[!code-vb[Conceptual.Regex.Language.Options#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace1.vb#12)]

<span data-ttu-id="cc58d-299">下列範例使用內嵌選項 `(?x)` 來忽略模式空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-299">The following example uses the inline option `(?x)` to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace2.cs#13)]
[!code-vb[Conceptual.Regex.Language.Options#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace2.vb#13)]

## <a name="right-to-left-mode"></a><span data-ttu-id="cc58d-300">由右至左模式</span><span class="sxs-lookup"><span data-stu-id="cc58d-300">Right-to-Left Mode</span></span>

<span data-ttu-id="cc58d-301">依預設，規則運算式引擎會由左至右搜尋。</span><span class="sxs-lookup"><span data-stu-id="cc58d-301">By default, the regular expression engine searches from left to right.</span></span> <span data-ttu-id="cc58d-302">您可以使用 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 選項來反轉搜尋方向。</span><span class="sxs-lookup"><span data-stu-id="cc58d-302">You can reverse the search direction by using the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="cc58d-303">此搜尋會自動從字串最後一個字元的位置開始。</span><span class="sxs-lookup"><span data-stu-id="cc58d-303">The search automatically begins at the last character position of the string.</span></span> <span data-ttu-id="cc58d-304">針對包含開始位置參數的模式比對方法，例如 <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>，開始位置是要開始搜尋之最右邊字元位置的索引。</span><span class="sxs-lookup"><span data-stu-id="cc58d-304">For pattern-matching methods that include a starting position parameter, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, the starting position is the index of the rightmost character position at which the search is to begin.</span></span>

> [!NOTE]
> <span data-ttu-id="cc58d-305">若要使用由右至左模式，唯一的方法就是提供 <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 值給 `options` 類別建構函式或靜態模式比對方法的 <xref:System.Text.RegularExpressions.Regex> 參數。</span><span class="sxs-lookup"><span data-stu-id="cc58d-305">Right-to-left pattern mode is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="cc58d-306">無法以內嵌選項來提供此值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-306">It is not available as an inline option.</span></span>

<span data-ttu-id="cc58d-307"><xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> 選項只會變更搜尋方向，並不會由右至左解譯規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-307">The <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</span></span> <span data-ttu-id="cc58d-308">例如，規則運算式 `\bb\w+\s` 會比對字母 "b" 開頭、後接空白字元的文字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-308">For example, the regular expression `\bb\w+\s` matches words that begin with the letter "b" and are followed by a white-space character.</span></span> <span data-ttu-id="cc58d-309">在下列範例中，輸入字串是由包含一或數個 "b" 字元的三個單字所組成。</span><span class="sxs-lookup"><span data-stu-id="cc58d-309">In the following example, the input string consists of three words that include one or more "b" characters.</span></span> <span data-ttu-id="cc58d-310">第一個單字以 "b" 開頭，第二個單字以 "b" 結尾，而第三個單字中間包含兩個 "b" 字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-310">The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</span></span> <span data-ttu-id="cc58d-311">如範例輸出所示，只有第一個單字符合規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="cc58d-311">As the output from the example shows, only the first word matches the regular expression pattern.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft1.cs#17)]
[!code-vb[Conceptual.Regex.Language.Options#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft1.vb#17)]

<span data-ttu-id="cc58d-312">另請注意，右合樣判斷提示 (`(?=`subexpression`)` 語言元素) 和左合樣判斷提示 (`(?<=`subexpression`)` 語言元素) 沒有變更方向。</span><span class="sxs-lookup"><span data-stu-id="cc58d-312">Also note that the lookahead assertion (the `(?=`*subexpression*`)` language element) and the lookbehind assertion (the `(?<=`*subexpression*`)` language element) do not change direction.</span></span> <span data-ttu-id="cc58d-313">右合樣判斷提示朝右看，而左合樣判斷提示朝左看。</span><span class="sxs-lookup"><span data-stu-id="cc58d-313">The lookahead assertions look to the right; the lookbehind assertions look to the left.</span></span> <span data-ttu-id="cc58d-314">例如，規則運算式 `(?<=\d{1,2}\s)\w+,?\s\d{4}` 使用左合樣判斷提示來測試月份名稱前面的日期。</span><span class="sxs-lookup"><span data-stu-id="cc58d-314">For example, the regular expression `(?<=\d{1,2}\s)\w+,?\s\d{4}` uses the lookbehind assertion to test for a date that precedes a month name.</span></span> <span data-ttu-id="cc58d-315">然後規則運算式會比對月和年。</span><span class="sxs-lookup"><span data-stu-id="cc58d-315">The regular expression then matches the month and the year.</span></span> <span data-ttu-id="cc58d-316">如需右合樣判斷提示和左合樣判斷提示的詳細資訊，請參閱[群組建構](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-316">For information on lookahead and lookbehind assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft2.cs#18)]
[!code-vb[Conceptual.Regex.Language.Options#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft2.vb#18)]

<span data-ttu-id="cc58d-317">規則運算式模式的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="cc58d-317">The regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="cc58d-318">模式</span><span class="sxs-lookup"><span data-stu-id="cc58d-318">Pattern</span></span>|<span data-ttu-id="cc58d-319">描述</span><span class="sxs-lookup"><span data-stu-id="cc58d-319">Description</span></span>|
|-------------|-----------------|
|`(?<=\d{1,2}\s)`|<span data-ttu-id="cc58d-320">相符項目的開頭前面必須要有一個或兩個十進位數字後接空格。</span><span class="sxs-lookup"><span data-stu-id="cc58d-320">The beginning of the match must be preceded by one or two decimal digits followed by a space.</span></span>|
|`\w+`|<span data-ttu-id="cc58d-321">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-321">Match one or more word characters.</span></span>|
|`,?`|<span data-ttu-id="cc58d-322">比對零或一個逗號字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-322">Match zero or one comma characters.</span></span>|
|`\s`|<span data-ttu-id="cc58d-323">比對空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-323">Match a white-space character.</span></span>|
|`\d{4}`|<span data-ttu-id="cc58d-324">比對四個十進位數字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-324">Match four decimal digits.</span></span>|

## <a name="ecmascript-matching-behavior"></a><span data-ttu-id="cc58d-325">ECMAScript 相符行為</span><span class="sxs-lookup"><span data-stu-id="cc58d-325">ECMAScript Matching Behavior</span></span>

<span data-ttu-id="cc58d-326">依預設，在比對規則運算式模式與輸入文字時，規則運算式引擎會使用標準行為。</span><span class="sxs-lookup"><span data-stu-id="cc58d-326">By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</span></span> <span data-ttu-id="cc58d-327">不過，您可以指定 <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> 選項，以指示規則運算式引擎使用 ECMAScript 相符行為。</span><span class="sxs-lookup"><span data-stu-id="cc58d-327">However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option.</span></span>

> [!NOTE]
> <span data-ttu-id="cc58d-328">若要使用符合 ECMAScript 的行為，唯一的方法就是提供 <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> 值給 `options` 類別建構函式或靜態模式比對方法的 <xref:System.Text.RegularExpressions.Regex> 參數。</span><span class="sxs-lookup"><span data-stu-id="cc58d-328">ECMAScript-compliant behavior is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="cc58d-329">無法以內嵌選項來提供此值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-329">It is not available as an inline option.</span></span>

<span data-ttu-id="cc58d-330"><xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> 選項只能與 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 和 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項合併使用。</span><span class="sxs-lookup"><span data-stu-id="cc58d-330">The <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option can be combined only with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="cc58d-331">在規則運算式中使用任何其他選項將會導致 <xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="cc58d-331">The use of any other option in a regular expression results in an <xref:System.ArgumentOutOfRangeException>.</span></span>

<span data-ttu-id="cc58d-332">ECMAScript 的行為與標準規則運算式有三個不同層面：字元類別語法、自我參考擷取群組，以及八進位與反向參考解譯。</span><span class="sxs-lookup"><span data-stu-id="cc58d-332">The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</span></span>

- <span data-ttu-id="cc58d-333">字元類別語法。</span><span class="sxs-lookup"><span data-stu-id="cc58d-333">Character class syntax.</span></span> <span data-ttu-id="cc58d-334">因為標準規則運算式支援 Unicode，而 ECMAScript 不支援，所以 ECMAScript 中的字元類別有較多的語法限制，而且有些字元類別語言項目有不同的意義。</span><span class="sxs-lookup"><span data-stu-id="cc58d-334">Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</span></span> <span data-ttu-id="cc58d-335">例如，ECMAScript 不支援語言項目 (例如 Unicode 類別) 或資料區塊項目 `\p` 和 `\P`。</span><span class="sxs-lookup"><span data-stu-id="cc58d-335">For example, ECMAScript does not support language elements such as the Unicode category or block elements `\p` and `\P`.</span></span> <span data-ttu-id="cc58d-336">同樣地，使用 ECMAScript 時，`\w` 項目 (用來比對文字字元) 同等於 `[a-zA-Z_0-9]` 字元類別，使用標準行為時，同等於 `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]`。</span><span class="sxs-lookup"><span data-stu-id="cc58d-336">Similarly, the `\w` element, which matches a word character, is equivalent to the `[a-zA-Z_0-9]` character class when using ECMAScript and `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` when using canonical behavior.</span></span> <span data-ttu-id="cc58d-337">如需詳細資訊，請參閱[字元類別](../../../docs/standard/base-types/character-classes-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-337">For more information, see [Character Classes](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span>

  <span data-ttu-id="cc58d-338">下列範例說明標準與 ECMAScript 模式比對之間的差異。</span><span class="sxs-lookup"><span data-stu-id="cc58d-338">The following example illustrates the difference between canonical and ECMAScript pattern matching.</span></span> <span data-ttu-id="cc58d-339">其定義規則運算式 `\b(\w+\s*)+`，可比對後接空白字元的文字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-339">It defines a regular expression, `\b(\w+\s*)+`, that matches words followed by white-space characters.</span></span> <span data-ttu-id="cc58d-340">該輸入包含兩個字串，一個使用 Latin 字元集，另一個使用 Cyrillic 字元集。</span><span class="sxs-lookup"><span data-stu-id="cc58d-340">The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</span></span> <span data-ttu-id="cc58d-341">如輸出所示，呼叫使用 ECMAScript 比對的 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 方法時，無法比對 Cyrillic 文字，而使用標準比對的方法呼叫則可比對這些文字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-341">As the output shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript1.cs#16)]
  [!code-vb[Conceptual.Regex.Language.Options#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript1.vb#16)]

- <span data-ttu-id="cc58d-342">自我參考擷取群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-342">Self-referencing capturing groups.</span></span> <span data-ttu-id="cc58d-343">具有自我反向參考的規則運算式擷取類別必須以每個擷取反覆項目來更新。</span><span class="sxs-lookup"><span data-stu-id="cc58d-343">A regular expression capture class with a backreference to itself must be updated with each capture iteration.</span></span> <span data-ttu-id="cc58d-344">如下列範例所示，使用 ECMAScript 時，此功能可讓規則運算式 `((a+)(\1) ?)+` 比對輸入字串 " aa aaaa aaaaaa "，使用標準比對時則不能。</span><span class="sxs-lookup"><span data-stu-id="cc58d-344">As the following example shows, this feature enables the regular expression `((a+)(\1) ?)+` to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#21](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript2.cs#21)]
  [!code-vb[Conceptual.Regex.Language.Options#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript2.vb#21)]

  <span data-ttu-id="cc58d-345">規則運算式的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="cc58d-345">The regular expression is defined as shown in the following table.</span></span>

  |<span data-ttu-id="cc58d-346">模式</span><span class="sxs-lookup"><span data-stu-id="cc58d-346">Pattern</span></span>|<span data-ttu-id="cc58d-347">描述</span><span class="sxs-lookup"><span data-stu-id="cc58d-347">Description</span></span>|
  |-------------|-----------------|
  |<span data-ttu-id="cc58d-348">(a+)</span><span class="sxs-lookup"><span data-stu-id="cc58d-348">(a+)</span></span>|<span data-ttu-id="cc58d-349">比對字母 "a" 一次或多次。</span><span class="sxs-lookup"><span data-stu-id="cc58d-349">Match the letter "a" one or more times.</span></span> <span data-ttu-id="cc58d-350">這是第二個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-350">This is the second capturing group.</span></span>|
  |<span data-ttu-id="cc58d-351">(\1)</span><span class="sxs-lookup"><span data-stu-id="cc58d-351">(\1)</span></span>|<span data-ttu-id="cc58d-352">比對第一個擷取群組所擷取的子字串。</span><span class="sxs-lookup"><span data-stu-id="cc58d-352">Match the substring captured by the first capturing group.</span></span> <span data-ttu-id="cc58d-353">這是第三個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-353">This is the third capturing group.</span></span>|
  |<span data-ttu-id="cc58d-354">?</span><span class="sxs-lookup"><span data-stu-id="cc58d-354">?</span></span>|<span data-ttu-id="cc58d-355">比對零或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-355">Match zero or one space characters.</span></span>|
  |<span data-ttu-id="cc58d-356">((a+)(\1) ?)+</span><span class="sxs-lookup"><span data-stu-id="cc58d-356">((a+)(\1) ?)+</span></span>|<span data-ttu-id="cc58d-357">一次或多次比對一個或多個 "a" 字元，後面接符合第一個擷取群組的字串，後面再接零或一個空白字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-357">Match the pattern of one or more "a" characters followed by a string that matches the first capturing group followed by zero or one space characters one or more times.</span></span> <span data-ttu-id="cc58d-358">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="cc58d-358">This is the first capturing group.</span></span>|

- <span data-ttu-id="cc58d-359">八進位逸出與反向參考之間模棱兩可的解決方案。</span><span class="sxs-lookup"><span data-stu-id="cc58d-359">Resolution of ambiguities between octal escapes and backreferences.</span></span> <span data-ttu-id="cc58d-360">下表總結以標準和 ECMAScript 規則運算式來進行八進位與反向參考解譯的差異。</span><span class="sxs-lookup"><span data-stu-id="cc58d-360">The following table summarizes the differences in octal versus backreference interpretation by canonical and ECMAScript regular expressions.</span></span>

  |<span data-ttu-id="cc58d-361">規則運算式</span><span class="sxs-lookup"><span data-stu-id="cc58d-361">Regular expression</span></span>|<span data-ttu-id="cc58d-362">標準行為</span><span class="sxs-lookup"><span data-stu-id="cc58d-362">Canonical behavior</span></span>|<span data-ttu-id="cc58d-363">ECMAScript 行為</span><span class="sxs-lookup"><span data-stu-id="cc58d-363">ECMAScript behavior</span></span>|
  |------------------------|------------------------|-------------------------|
  |<span data-ttu-id="cc58d-364">`\0` 後接 0 到 2 個八進位數字</span><span class="sxs-lookup"><span data-stu-id="cc58d-364">`\0` followed by 0 to 2 octal digits</span></span>|<span data-ttu-id="cc58d-365">解譯成八進位。</span><span class="sxs-lookup"><span data-stu-id="cc58d-365">Interpret as an octal.</span></span> <span data-ttu-id="cc58d-366">例如，`\044` 一律解譯成八進位值，且意思是 "$"。</span><span class="sxs-lookup"><span data-stu-id="cc58d-366">For example, `\044` is always interpreted as an octal value and means "$".</span></span>|<span data-ttu-id="cc58d-367">相同行為。</span><span class="sxs-lookup"><span data-stu-id="cc58d-367">Same behavior.</span></span>|
  |<span data-ttu-id="cc58d-368">`\` 後接 1 到 9 的數字，後面不再接其他十進位數字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-368">`\` followed by a digit from 1 to 9, followed by no additional decimal digits,</span></span>|<span data-ttu-id="cc58d-369">解譯成反向參考。</span><span class="sxs-lookup"><span data-stu-id="cc58d-369">Interpret as a backreference.</span></span> <span data-ttu-id="cc58d-370">例如，`\9` 一律表示反向參考 9，即使第 9 個擷取群組不存在也一樣。</span><span class="sxs-lookup"><span data-stu-id="cc58d-370">For example, `\9` always means backreference 9, even if a ninth capturing group does not exist.</span></span> <span data-ttu-id="cc58d-371">如果擷取群組不存在，規則運算式剖析器會擲回 <xref:System.ArgumentException>。</span><span class="sxs-lookup"><span data-stu-id="cc58d-371">If the capturing group does not exist, the regular expression parser throws an <xref:System.ArgumentException>.</span></span>|<span data-ttu-id="cc58d-372">如果單一十進位數字擷取群組存在，則反向參考至該數字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-372">If a single decimal digit capturing group exists, backreference to that digit.</span></span> <span data-ttu-id="cc58d-373">否則，會將該值解譯成常值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-373">Otherwise, interpret the value as a literal.</span></span>|
  |<span data-ttu-id="cc58d-374">`\` 後接 1 到 9 的數字，後面再接其他十進位數字。</span><span class="sxs-lookup"><span data-stu-id="cc58d-374">`\` followed by a digit from 1 to 9, followed by additional decimal digits</span></span>|<span data-ttu-id="cc58d-375">將這些數字解譯成十進位值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-375">Interpret the digits as a decimal value.</span></span> <span data-ttu-id="cc58d-376">如果該擷取群組存在，則將運算式解譯成反向參考。</span><span class="sxs-lookup"><span data-stu-id="cc58d-376">If that capturing group exists, interpret the expression as a backreference.</span></span><br /><br /> <span data-ttu-id="cc58d-377">否則，解譯前置八進位數字至八進位 377；也就是說，僅考慮該值的低 8 位元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-377">Otherwise, interpret the leading octal digits up to octal 377; that is, consider only the low 8 bits of the value.</span></span> <span data-ttu-id="cc58d-378">將其餘數字解譯成常值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-378">Interpret the remaining digits as literals.</span></span> <span data-ttu-id="cc58d-379">例如，在運算式 `\3000` 中，如果擷取群組 300 存在，則解譯成反向參考 300；如果擷取群組 300 不存在，則解譯成八進位 300 後接 0。</span><span class="sxs-lookup"><span data-stu-id="cc58d-379">For example, in the expression `\3000`, if capturing group 300 exists, interpret as backreference 300; if capturing group 300 does not exist, interpret as octal 300 followed by 0.</span></span>|<span data-ttu-id="cc58d-380">盡可能將多位數字轉換成可以參考擷取的十進位值，以解譯成反向參考。</span><span class="sxs-lookup"><span data-stu-id="cc58d-380">Interpret as a backreference by converting as many digits as possible to a decimal value that can refer to a capture.</span></span> <span data-ttu-id="cc58d-381">如果沒有數字可供轉換，則使用前置八進位數字至八進位 377，以解譯成八進位；將其餘數字解譯成常值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-381">If no digits can be converted, interpret as an octal by using the leading octal digits up to octal 377; interpret the remaining digits as literals.</span></span>|

## <a name="comparison-using-the-invariant-culture"></a><span data-ttu-id="cc58d-382">使用不因國別而異的文化特性比較</span><span class="sxs-lookup"><span data-stu-id="cc58d-382">Comparison Using the Invariant Culture</span></span>

<span data-ttu-id="cc58d-383">依預設，當規則運算式引擎執行不區分大小寫比較時，會使用目前文化特性的大小寫慣例來判定相等的大小寫字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-383">By default, when the regular expression engine performs case-insensitive comparisons, it uses the casing conventions of the current culture to determine equivalent uppercase and lowercase characters.</span></span>

<span data-ttu-id="cc58d-384">不過，某些類型的比較並不希望有此行為，尤其是將使用者輸入與系統資源名稱 (例如密碼、檔案或 URL) 做比較時。</span><span class="sxs-lookup"><span data-stu-id="cc58d-384">However, this behavior is undesirable for some types of comparisons, particularly when comparing user input to the names of system resources, such as passwords, files, or URLs.</span></span> <span data-ttu-id="cc58d-385">下列範例說明這種案例。</span><span class="sxs-lookup"><span data-stu-id="cc58d-385">The following example illustrates such as scenario.</span></span> <span data-ttu-id="cc58d-386">程式碼的目的是要封鎖存取前面加上 **FILE://** 之 URL 的任何資源。</span><span class="sxs-lookup"><span data-stu-id="cc58d-386">The code is intended to block access to any resource whose URL is prefaced with **FILE://**.</span></span> <span data-ttu-id="cc58d-387">規則運算式使用規則運算式 `$FILE://`，嘗試不區分大小寫來比對字串。</span><span class="sxs-lookup"><span data-stu-id="cc58d-387">The regular expression attempts a case-insensitive match with the string by using the regular expression `$FILE://`.</span></span> <span data-ttu-id="cc58d-388">不過，當目前系統文化特性為 tr-TR (Turkish-Turkey) 時，"I" 並不是 "i" 的相等大寫字元。</span><span class="sxs-lookup"><span data-stu-id="cc58d-388">However, when the current system culture is tr-TR (Turkish-Turkey), "I" is not the uppercase equivalent of "i".</span></span> <span data-ttu-id="cc58d-389">因此，呼叫 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法時，會傳回 `false`，並允許存取該檔案。</span><span class="sxs-lookup"><span data-stu-id="cc58d-389">As a result, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method returns `false`, and access to the file is allowed.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#14)]
[!code-vb[Conceptual.Regex.Language.Options#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#14)]

> [!NOTE]
> <span data-ttu-id="cc58d-390">如需區分大小寫和使用不因國別而異的文化特性之字串比較的詳細資訊，請參閱[在 .NET Framework 中使用字串的最佳作法](../../../docs/standard/base-types/best-practices-strings.md)。</span><span class="sxs-lookup"><span data-stu-id="cc58d-390">For more information about string comparisons that are case-sensitive and that use the invariant culture, see [Best Practices for Using Strings](../../../docs/standard/base-types/best-practices-strings.md).</span></span>

<span data-ttu-id="cc58d-391">您可以不要使用不因國別而異的文化特性的不區分大小寫比較，而是指定 <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> 選項來忽略語言中的文化特性差異，並使用不因國別而異的文化特性的慣例。</span><span class="sxs-lookup"><span data-stu-id="cc58d-391">Instead of using the case-insensitive comparisons of the current culture, you can specify the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> option to ignore cultural differences in language and to use the conventions of the invariant culture.</span></span>

> [!NOTE]
> <span data-ttu-id="cc58d-392">若要使用不因國別而異的文化特性的比較，唯一的方法就是提供 <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> 值給 `options` 類別建構函式或靜態模式比對方法的 <xref:System.Text.RegularExpressions.Regex> 參數。</span><span class="sxs-lookup"><span data-stu-id="cc58d-392">Comparison using the invariant culture is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="cc58d-393">無法以內嵌選項來提供此值。</span><span class="sxs-lookup"><span data-stu-id="cc58d-393">It is not available as an inline option.</span></span>

<span data-ttu-id="cc58d-394">下列範例與上一個範例相同，差別在於呼叫靜態 <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 方法時，是使用包含 <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> 的選項。</span><span class="sxs-lookup"><span data-stu-id="cc58d-394">The following example is identical to the previous example, except that the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with options that include <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span></span> <span data-ttu-id="cc58d-395">即使目前的文化特性設為 Turkish (Turkey)，規則運算式引擎還是可以成功比對 "FILE" 和 "file"，並封鎖存取檔案資源。</span><span class="sxs-lookup"><span data-stu-id="cc58d-395">Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#15)]
[!code-vb[Conceptual.Regex.Language.Options#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#15)]

## <a name="see-also"></a><span data-ttu-id="cc58d-396">請參閱</span><span class="sxs-lookup"><span data-stu-id="cc58d-396">See also</span></span>

- [<span data-ttu-id="cc58d-397">規則運算式語言 - 快速參考</span><span class="sxs-lookup"><span data-stu-id="cc58d-397">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
