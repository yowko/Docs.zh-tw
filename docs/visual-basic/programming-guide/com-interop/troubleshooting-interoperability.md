---
title: 疑難排解互通性 (Visual Basic)
ms.date: 07/20/2015
helpviewer_keywords:
- interop, deploying assemblies
- assemblies [Visual Basic]
- interop, installing assemblies that share components
- COM objects, troubleshooting
- interop, sharing components
- troubleshooting interoperability [Visual Basic]
- interoperability, troubleshooting
- COM interop [Visual Basic], troubleshooting
- assemblies [Visual Basic], deploying
- troubleshooting Visual Basic, interoperability
- interop assemblies
- interoperability, sharing components
- shared components, using with assemblies
ms.assetid: b324cc1e-b03c-4f39-aea6-6a6d5bfd0e37
ms.openlocfilehash: c04cd0928eb83aabcd1f0f4b1b43f8ae6d356d20
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/22/2019
ms.locfileid: "69969329"
---
# <a name="troubleshooting-interoperability-visual-basic"></a><span data-ttu-id="a79a1-102">疑難排解互通性 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a79a1-102">Troubleshooting Interoperability (Visual Basic)</span></span>
<span data-ttu-id="a79a1-103">當您在 COM 與 .NET Framework 的 managed 程式碼之間交互操作時, 您可能會遇到下列一個或多個常見的問題。</span><span class="sxs-lookup"><span data-stu-id="a79a1-103">When you interoperate between COM and the managed code of the .NET Framework, you may encounter one or more of the following common issues.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor1"></a><span data-ttu-id="a79a1-104">Interop 封送處理</span><span class="sxs-lookup"><span data-stu-id="a79a1-104">Interop Marshaling</span></span>  
 <span data-ttu-id="a79a1-105">有時候, 您可能必須使用不屬於 .NET Framework 的資料類型。</span><span class="sxs-lookup"><span data-stu-id="a79a1-105">At times, you may have to use data types that are not part of the .NET Framework.</span></span> <span data-ttu-id="a79a1-106">Interop 元件會處理 COM 物件的大部分工作, 但您可能必須控制將 managed 物件公開給 COM 時所使用的資料類型。</span><span class="sxs-lookup"><span data-stu-id="a79a1-106">Interop assemblies handle most of the work for COM objects, but you may have to control the data types that are used when managed objects are exposed to COM.</span></span> <span data-ttu-id="a79a1-107">例如, 類別庫中的結構必須在傳送`BStr`至 Visual Basic 6.0 和更早版本所建立之 COM 物件的字串上, 指定非受控型別。</span><span class="sxs-lookup"><span data-stu-id="a79a1-107">For example, structures in class libraries must specify the `BStr` unmanaged type on strings sent to COM objects created by Visual Basic 6.0 and earlier versions.</span></span> <span data-ttu-id="a79a1-108">在這種情況下, 您可以<xref:System.Runtime.InteropServices.MarshalAsAttribute>使用屬性, 使 managed 類型公開為非受控類型。</span><span class="sxs-lookup"><span data-stu-id="a79a1-108">In such cases, you can use the <xref:System.Runtime.InteropServices.MarshalAsAttribute> attribute to cause managed types to be exposed as unmanaged types.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor2"></a><span data-ttu-id="a79a1-109">將固定長度的字串匯出至未受管理的程式碼</span><span class="sxs-lookup"><span data-stu-id="a79a1-109">Exporting Fixed-Length Strings to Unmanaged Code</span></span>  
 <span data-ttu-id="a79a1-110">在 Visual Basic 6.0 和更早版本中, 字串會以不含 null 終止字元的位元組序列形式匯出至 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="a79a1-110">In Visual Basic 6.0 and earlier versions, strings are exported to COM objects as sequences of bytes without a null termination character.</span></span> <span data-ttu-id="a79a1-111">為了與其他語言相容, 在匯出字串時, Visual Basic .NET 會包含一個終止字元。</span><span class="sxs-lookup"><span data-stu-id="a79a1-111">For compatibility with other languages, Visual Basic .NET includes a termination character when exporting strings.</span></span> <span data-ttu-id="a79a1-112">解決此不相容性的最佳方式, 是將缺少終止字元的字串匯出為或`Byte` `Char`的陣列。</span><span class="sxs-lookup"><span data-stu-id="a79a1-112">The best way to address this incompatibility is to export strings that lack the termination character as arrays of `Byte` or `Char`.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor3"></a><span data-ttu-id="a79a1-113">匯出繼承階層</span><span class="sxs-lookup"><span data-stu-id="a79a1-113">Exporting Inheritance Hierarchies</span></span>  
 <span data-ttu-id="a79a1-114">當公開為 COM 物件時, Managed 類別階層會壓平合併。</span><span class="sxs-lookup"><span data-stu-id="a79a1-114">Managed class hierarchies flatten out when exposed as COM objects.</span></span> <span data-ttu-id="a79a1-115">例如, 如果您使用成員定義基類, 然後繼承衍生類別中公開為 COM 物件的基類, 則在 COM 物件中使用衍生類別的用戶端將無法使用繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="a79a1-115">For example, if you define a base class with a member, and then inherit the base class in a derived class that is exposed as a COM object, clients that use the derived class in the COM object will not be able to use the inherited members.</span></span> <span data-ttu-id="a79a1-116">基類成員只能從 COM 物件存取為基類的實例, 而且只有在基類也建立為 COM 物件時才可以。</span><span class="sxs-lookup"><span data-stu-id="a79a1-116">Base class members can be accessed from COM objects only as instances of a base class, and then only if the base class is also created as a COM object.</span></span>  
  
## <a name="overloaded-methods"></a><span data-ttu-id="a79a1-117">多載的方法</span><span class="sxs-lookup"><span data-stu-id="a79a1-117">Overloaded Methods</span></span>  
 <span data-ttu-id="a79a1-118">雖然您可以使用 Visual Basic 建立多載的方法, 但 COM 並不支援它們。</span><span class="sxs-lookup"><span data-stu-id="a79a1-118">Although you can create overloaded methods with Visual Basic, they are not supported by COM.</span></span> <span data-ttu-id="a79a1-119">當包含多載方法的類別公開為 COM 物件時, 會為多載的方法產生新的方法名稱。</span><span class="sxs-lookup"><span data-stu-id="a79a1-119">When a class that contains overloaded methods is exposed as a COM object, new method names are generated for the overloaded methods.</span></span>  
  
 <span data-ttu-id="a79a1-120">例如, 假設有一個類別具有`Synch`方法的兩個多載。</span><span class="sxs-lookup"><span data-stu-id="a79a1-120">For example, consider a class that has two overloads of the `Synch` method.</span></span> <span data-ttu-id="a79a1-121">當類別公開為 COM 物件時, 新產生的方法名稱可能是`Synch`和。 `Synch_2`</span><span class="sxs-lookup"><span data-stu-id="a79a1-121">When the class is exposed as a COM object, the new generated method names could be `Synch` and `Synch_2`.</span></span>  
  
 <span data-ttu-id="a79a1-122">重新命名可能會對 COM 物件的取用者造成兩個問題。</span><span class="sxs-lookup"><span data-stu-id="a79a1-122">The renaming can cause two problems for consumers of the COM object.</span></span>  
  
1. <span data-ttu-id="a79a1-123">用戶端可能不會預期產生的方法名稱。</span><span class="sxs-lookup"><span data-stu-id="a79a1-123">Clients might not expect the generated method names.</span></span>  
  
2. <span data-ttu-id="a79a1-124">將新的多載新增至類別或其基類時, 在公開為 COM 物件的類別中產生的方法名稱可能會變更。</span><span class="sxs-lookup"><span data-stu-id="a79a1-124">The generated method names in the class exposed as a COM object can change when new overloads are added to the class or its base class.</span></span> <span data-ttu-id="a79a1-125">這可能會造成版本控制問題。</span><span class="sxs-lookup"><span data-stu-id="a79a1-125">This can cause versioning problems.</span></span>  
  
 <span data-ttu-id="a79a1-126">若要解決這兩個問題, 當您開發將公開為 COM 物件的物件時, 請為每個方法提供唯一的名稱, 而不是使用多載。</span><span class="sxs-lookup"><span data-stu-id="a79a1-126">To solve both problems, give each method a unique name, instead of using overloading, when you develop objects that will be exposed as COM objects.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor4"></a><span data-ttu-id="a79a1-127">透過 Interop 元件使用 COM 物件</span><span class="sxs-lookup"><span data-stu-id="a79a1-127">Use of COM Objects Through Interop Assemblies</span></span>  
 <span data-ttu-id="a79a1-128">Interop 元件的使用方式幾乎就像是它們所代表 COM 物件的 managed 程式碼取代。</span><span class="sxs-lookup"><span data-stu-id="a79a1-128">You use interop assemblies almost as if they are managed code replacements for the COM objects they represent.</span></span> <span data-ttu-id="a79a1-129">不過, 因為它們是包裝函式, 而不是實際的 COM 物件, 所以使用 interop 元件和標準元件之間有一些差異。</span><span class="sxs-lookup"><span data-stu-id="a79a1-129">However, because they are wrappers and not actual COM objects, there are some differences between using interop assemblies and standard assemblies.</span></span> <span data-ttu-id="a79a1-130">這些差異區域包括類別的公開, 以及參數和傳回值的資料類型。</span><span class="sxs-lookup"><span data-stu-id="a79a1-130">These areas of difference include the exposure of classes, and data types for parameters and return values.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor5"></a><span data-ttu-id="a79a1-131">公開為介面和類別的類別</span><span class="sxs-lookup"><span data-stu-id="a79a1-131">Classes Exposed as Both Interfaces and Classes</span></span>  
 <span data-ttu-id="a79a1-132">不同于標準元件中的類別, COM 類別會在 interop 元件中公開為介面和代表 COM 類別的類別。</span><span class="sxs-lookup"><span data-stu-id="a79a1-132">Unlike classes in standard assemblies, COM classes are exposed in interop assemblies as both an interface and a class that represents the COM class.</span></span> <span data-ttu-id="a79a1-133">介面的名稱與 COM 類別的名稱相同。</span><span class="sxs-lookup"><span data-stu-id="a79a1-133">The interface's name is identical to that of the COM class.</span></span> <span data-ttu-id="a79a1-134">Interop 類別的名稱與原始 COM 類別的名稱相同, 但附加了 "Class" 這個字。</span><span class="sxs-lookup"><span data-stu-id="a79a1-134">The name of the interop class is the same as that of the original COM class, but with the word "Class" appended.</span></span> <span data-ttu-id="a79a1-135">例如, 假設您有一個專案, 其中包含 COM 物件的 interop 元件參考。</span><span class="sxs-lookup"><span data-stu-id="a79a1-135">For example, suppose you have a project with a reference to an interop assembly for a COM object.</span></span> <span data-ttu-id="a79a1-136">如果 COM 類別名`MyComClass`為, IntelliSense 和物件瀏覽器會顯示名為`MyComClass`的介面和名為`MyComClassClass`的類別。</span><span class="sxs-lookup"><span data-stu-id="a79a1-136">If the COM class is named `MyComClass`, IntelliSense and the Object Browser show an interface named `MyComClass` and a class named `MyComClassClass`.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor6"></a><span data-ttu-id="a79a1-137">建立 .NET Framework 類別的實例</span><span class="sxs-lookup"><span data-stu-id="a79a1-137">Creating Instances of a .NET Framework Class</span></span>  
 <span data-ttu-id="a79a1-138">一般來說, 您會使用具有類別名稱的`New`語句來建立 .NET Framework 類別的實例。</span><span class="sxs-lookup"><span data-stu-id="a79a1-138">Generally, you create an instance of a .NET Framework class using the `New` statement with a class name.</span></span> <span data-ttu-id="a79a1-139">以 interop 元件表示的 COM 類別, 是您可以在介面中使用`New`語句的一種情況。</span><span class="sxs-lookup"><span data-stu-id="a79a1-139">Having a COM class represented by an interop assembly is the one case in which you can use the `New` statement with an interface.</span></span> <span data-ttu-id="a79a1-140">除非您使用 COM 類別`Inherits`搭配語句, 否則您可以使用介面, 就像類別一樣。</span><span class="sxs-lookup"><span data-stu-id="a79a1-140">Unless you are using the COM class with an `Inherits` statement, you can use the interface just as you would a class.</span></span> <span data-ttu-id="a79a1-141">下列程式碼示範如何在具有 Microsoft `Command` ActiveX Data Objects 2.8 程式庫 COM 物件參考的專案中建立物件:</span><span class="sxs-lookup"><span data-stu-id="a79a1-141">The following code demonstrates how to create a `Command` object in a project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object:</span></span>  
  
 [!code-vb[VbVbalrInterop#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#20)]  
  
 <span data-ttu-id="a79a1-142">不過, 如果您使用 COM 類別做為衍生類別的基底, 則必須使用代表 COM 類別的 interop 類別, 如下列程式碼所示:</span><span class="sxs-lookup"><span data-stu-id="a79a1-142">However, if you are using the COM class as the base for a derived class, you must use the interop class that represents the COM class, as in the following code:</span></span>  
  
 [!code-vb[VbVbalrInterop#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#21)]  
  
> [!NOTE]
> <span data-ttu-id="a79a1-143">Interop 元件會隱含地執行代表 COM 類別的介面。</span><span class="sxs-lookup"><span data-stu-id="a79a1-143">Interop assemblies implicitly implement interfaces that represent COM classes.</span></span> <span data-ttu-id="a79a1-144">您不應該嘗試使用`Implements`語句來執行這些介面, 否則會產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="a79a1-144">You should not try to use the `Implements` statement to implement these interfaces or an error will result.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor7"></a><span data-ttu-id="a79a1-145">參數和傳回值的資料類型</span><span class="sxs-lookup"><span data-stu-id="a79a1-145">Data Types for Parameters and Return Values</span></span>  
 <span data-ttu-id="a79a1-146">不同于標準元件的成員, interop 元件成員可能會有與原始物件宣告中使用的不同的資料類型。</span><span class="sxs-lookup"><span data-stu-id="a79a1-146">Unlike members of standard assemblies, interop assembly members may have data types that differ from those used in the  original object declaration.</span></span> <span data-ttu-id="a79a1-147">雖然 interop 元件會隱含地將 COM 類型轉換成相容的 common language runtime 類型, 但您應該注意雙方所使用的資料類型, 以避免執行階段錯誤。</span><span class="sxs-lookup"><span data-stu-id="a79a1-147">Although interop assemblies implicitly convert COM types to compatible common language runtime types, you should pay attention to the data types that are used by both sides to prevent runtime errors.</span></span> <span data-ttu-id="a79a1-148">例如, 在 Visual Basic 6.0 和更早版本中建立的 COM 物件中, 類型`Integer`的值會假設 .NET Framework 對`Short`等類型。</span><span class="sxs-lookup"><span data-stu-id="a79a1-148">For example, in COM objects created in Visual Basic 6.0 and earlier versions, values of type `Integer` assume the .NET Framework equivalent type, `Short`.</span></span> <span data-ttu-id="a79a1-149">建議您在使用匯入的成員之前, 先使用物件瀏覽器來檢查其特性。</span><span class="sxs-lookup"><span data-stu-id="a79a1-149">It is recommended that you use the Object Browser to examine the characteristics of imported members before you use them.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor8"></a><span data-ttu-id="a79a1-150">模組層級 COM 方法</span><span class="sxs-lookup"><span data-stu-id="a79a1-150">Module level COM methods</span></span>  
 <span data-ttu-id="a79a1-151">大部分 com 物件的使用方式, 是使用`New`關鍵字來建立 COM 類別的實例, 然後呼叫物件的方法。</span><span class="sxs-lookup"><span data-stu-id="a79a1-151">Most COM objects are used by creating an instance of a COM class using the `New` keyword and then calling methods of the object.</span></span> <span data-ttu-id="a79a1-152">此規則有一個例外, 包括包含`AppObj`或`GlobalMultiUse` com 類別的 com 物件。</span><span class="sxs-lookup"><span data-stu-id="a79a1-152">One exception to this rule involves COM objects that contain `AppObj` or `GlobalMultiUse` COM classes.</span></span> <span data-ttu-id="a79a1-153">這類類別與 Visual Basic .NET 類別中的模組層級方法類似。</span><span class="sxs-lookup"><span data-stu-id="a79a1-153">Such classes resemble module level methods in Visual Basic .NET classes.</span></span> <span data-ttu-id="a79a1-154">Visual Basic 6.0 和舊版版本會在您第一次呼叫其中一個方法時, 隱含地為您建立這類物件的實例。</span><span class="sxs-lookup"><span data-stu-id="a79a1-154">Visual Basic 6.0 and earlier versions implicitly create instances of such objects for you the first time that you call one of their methods.</span></span> <span data-ttu-id="a79a1-155">例如, 在 Visual Basic 6.0 中, 您可以將參考新增至 Microsoft DAO 3.6 物件程式庫, 並呼叫`DBEngine`方法, 而不需要先建立實例:</span><span class="sxs-lookup"><span data-stu-id="a79a1-155">For example, in Visual Basic 6.0 you can add a reference to the Microsoft DAO 3.6 Object Library and call the `DBEngine` method without first creating an instance:</span></span>  
  
```vb  
Dim db As DAO.Database  
' Open the database.  
Set db = DBEngine.OpenDatabase("C:\nwind.mdb")  
' Use the database object.  
```  
  
 <span data-ttu-id="a79a1-156">Visual Basic .NET 要求您一定要先建立 COM 物件的實例, 才能使用其方法。</span><span class="sxs-lookup"><span data-stu-id="a79a1-156">Visual Basic .NET requires that you always create instances of COM objects before you can use their methods.</span></span> <span data-ttu-id="a79a1-157">若要在 Visual Basic 中使用這些方法, 請宣告所需類別的變數, 並使用 new 關鍵字將物件指派給物件變數。</span><span class="sxs-lookup"><span data-stu-id="a79a1-157">To use these methods in Visual Basic, declare a variable of the desired class and use the new keyword to assign the object to the object variable.</span></span> <span data-ttu-id="a79a1-158">當`Shared`您想要確保只會建立類別的一個實例時, 可以使用關鍵字。</span><span class="sxs-lookup"><span data-stu-id="a79a1-158">The `Shared` keyword can be used when you want to make sure that only one instance of the class is created.</span></span>  
  
 [!code-vb[VbVbalrInterop#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#23)]  
  
## <a name="vbconinteroperabilitymarshalinganchor9"></a><span data-ttu-id="a79a1-159">事件處理常式中的未處理錯誤</span><span class="sxs-lookup"><span data-stu-id="a79a1-159">Unhandled Errors in Event Handlers</span></span>  
 <span data-ttu-id="a79a1-160">其中一個常見的 interop 問題牽涉到處理 COM 物件所引發之事件的事件處理常式中的錯誤。</span><span class="sxs-lookup"><span data-stu-id="a79a1-160">One common interop problem involves errors in event handlers that handle events raised by COM objects.</span></span> <span data-ttu-id="a79a1-161">除非您使用`On Error`或`Try...Catch...Finally`語句來特別檢查錯誤, 否則會忽略這類錯誤。</span><span class="sxs-lookup"><span data-stu-id="a79a1-161">Such errors are ignored unless you specifically check for errors using `On Error` or `Try...Catch...Finally` statements.</span></span> <span data-ttu-id="a79a1-162">例如, 下列範例來自具有 Microsoft ActiveX Data Objects 2.8 程式庫 COM 物件參考的 Visual Basic .NET 專案。</span><span class="sxs-lookup"><span data-stu-id="a79a1-162">For example, the following example is from a Visual Basic .NET project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object.</span></span>  
  
 [!code-vb[VbVbalrInterop#24](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#24)]  
  
 <span data-ttu-id="a79a1-163">這個範例會如預期般引發錯誤。</span><span class="sxs-lookup"><span data-stu-id="a79a1-163">This example raises an error as expected.</span></span> <span data-ttu-id="a79a1-164">不過, 如果您嘗試相同的範例, 但`Try...Catch...Finally`沒有區塊, 則會忽略此錯誤, 就如同`OnError Resume Next`您使用語句一樣。</span><span class="sxs-lookup"><span data-stu-id="a79a1-164">However, if you try the same example without the `Try...Catch...Finally` block, the error is ignored as if you used the `OnError Resume Next` statement.</span></span> <span data-ttu-id="a79a1-165">如果沒有錯誤處理, 則零除的無訊息失敗。</span><span class="sxs-lookup"><span data-stu-id="a79a1-165">Without error handling, the division by zero silently fails.</span></span> <span data-ttu-id="a79a1-166">由於這類錯誤永遠不會引發未處理的例外狀況錯誤, 因此在處理 COM 物件事件的事件處理常式中, 請務必使用某種形式的例外狀況處理。</span><span class="sxs-lookup"><span data-stu-id="a79a1-166">Because such errors never raise unhandled exception errors, it is important that you use some form of exception handling in event handlers that handle events from COM objects.</span></span>  
  
### <a name="understanding-com-interop-errors"></a><span data-ttu-id="a79a1-167">瞭解 COM Interop 錯誤</span><span class="sxs-lookup"><span data-stu-id="a79a1-167">Understanding COM interop errors</span></span>  
 <span data-ttu-id="a79a1-168">如果沒有錯誤處理, interop 呼叫通常會產生錯誤, 而不會提供一些資訊。</span><span class="sxs-lookup"><span data-stu-id="a79a1-168">Without error handling, interop calls often generate errors that provide little information.</span></span> <span data-ttu-id="a79a1-169">可能的話, 請使用結構化錯誤處理來提供發生問題時的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="a79a1-169">Whenever possible, use structured error handling to provide more information about problems when they occur.</span></span> <span data-ttu-id="a79a1-170">當您在偵錯工具時, 這會特別有用。</span><span class="sxs-lookup"><span data-stu-id="a79a1-170">This can be especially helpful when you debug applications.</span></span> <span data-ttu-id="a79a1-171">例如：</span><span class="sxs-lookup"><span data-stu-id="a79a1-171">For example:</span></span>  
  
 [!code-vb[VbVbalrInterop#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#25)]  
  
 <span data-ttu-id="a79a1-172">您可以藉由檢查 exception 物件的內容, 來尋找如錯誤描述、HRESULT 和 COM 錯誤來源的資訊。</span><span class="sxs-lookup"><span data-stu-id="a79a1-172">You can find information such as the error description, HRESULT, and the source of COM errors by examining the contents of the exception object.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor10"></a><span data-ttu-id="a79a1-173">ActiveX 控制項問題</span><span class="sxs-lookup"><span data-stu-id="a79a1-173">ActiveX Control Issues</span></span>  
 <span data-ttu-id="a79a1-174">大部分與 Visual Basic 6.0 搭配使用的 ActiveX 控制項都能與 Visual Basic .NET 搭配使用, 而不會發生問題。</span><span class="sxs-lookup"><span data-stu-id="a79a1-174">Most ActiveX controls that work with Visual Basic 6.0 work with Visual Basic .NET without trouble.</span></span> <span data-ttu-id="a79a1-175">主要的例外狀況包括容器控制項, 或以視覺化方式包含其他控制項的控制項。</span><span class="sxs-lookup"><span data-stu-id="a79a1-175">The main exceptions are container controls, or controls that visually contain other controls.</span></span> <span data-ttu-id="a79a1-176">某些較舊的控制項範例無法與 Visual Studio 正確搭配運作, 如下所示:</span><span class="sxs-lookup"><span data-stu-id="a79a1-176">Some examples of older controls that do not work correctly with Visual Studio are as follows:</span></span>  
  
- <span data-ttu-id="a79a1-177">Microsoft Forms 2.0 框架控制項</span><span class="sxs-lookup"><span data-stu-id="a79a1-177">Microsoft Forms 2.0 Frame control</span></span>  
  
- <span data-ttu-id="a79a1-178">上下按鈕控制項, 也稱為微調控制項</span><span class="sxs-lookup"><span data-stu-id="a79a1-178">Up-Down control, also known as the spin control</span></span>  
  
- <span data-ttu-id="a79a1-179">Sheridan 索引標籤控制項</span><span class="sxs-lookup"><span data-stu-id="a79a1-179">Sheridan Tab Control</span></span>  
  
 <span data-ttu-id="a79a1-180">針對不支援的 ActiveX 控制項問題, 只有一些因應措施。</span><span class="sxs-lookup"><span data-stu-id="a79a1-180">There are only a few workarounds for unsupported ActiveX control problems.</span></span> <span data-ttu-id="a79a1-181">如果您擁有原始的原始程式碼, 您可以將現有的控制項遷移至 Visual Studio。</span><span class="sxs-lookup"><span data-stu-id="a79a1-181">You can migrate existing controls to Visual Studio if you own the original source code.</span></span> <span data-ttu-id="a79a1-182">否則, 您可以向軟體廠商確認是否已更新。控制項的 NET 相容版本, 用來取代不支援的 ActiveX 控制項。</span><span class="sxs-lookup"><span data-stu-id="a79a1-182">Otherwise, you can check with software vendors for updated .NET-compatible versions of controls to replace unsupported ActiveX controls.</span></span>  
  
## <a name="vbconinteroperabilitymarshalinganchor11"></a><span data-ttu-id="a79a1-183">傳遞控制項的 ReadOnly 屬性 ByRef</span><span class="sxs-lookup"><span data-stu-id="a79a1-183">Passing ReadOnly Properties of Controls ByRef</span></span>  
 <span data-ttu-id="a79a1-184">當您將一些較舊的 ActiveX `ReadOnly` `ByRef`控制項的屬性當做參數傳遞至其他程式時, Visual Basic .net 有時會引發 COM 錯誤, 例如「錯誤 0x800A017F CTL_E_SETNOTSUPPORTED」。</span><span class="sxs-lookup"><span data-stu-id="a79a1-184">Visual Basic .NET sometimes raises COM errors such as, "Error 0x800A017F CTL_E_SETNOTSUPPORTED", when you pass `ReadOnly` properties of some older ActiveX controls as `ByRef` parameters to other procedures.</span></span> <span data-ttu-id="a79a1-185">來自 Visual Basic 6.0 的類似程式呼叫不會引發錯誤, 而且會將參數視為以傳值方式傳遞。</span><span class="sxs-lookup"><span data-stu-id="a79a1-185">Similar procedure calls from Visual Basic 6.0 do not raise an error, and the parameters are treated as if you passed them by value.</span></span> <span data-ttu-id="a79a1-186">Visual Basic 的 .net 錯誤訊息指出您嘗試變更沒有屬性`Set`程式的屬性。</span><span class="sxs-lookup"><span data-stu-id="a79a1-186">The Visual Basic .NET error message indicates that you are trying to change a property that does not have a property `Set` procedure.</span></span>  
  
 <span data-ttu-id="a79a1-187">如果您有權存取所呼叫的程式, 您可以使用`ByVal`關鍵字宣告接受`ReadOnly`屬性的參數, 以避免這個錯誤。</span><span class="sxs-lookup"><span data-stu-id="a79a1-187">If you have access to the procedure being called, you can prevent this error by using the `ByVal` keyword to declare parameters that accept `ReadOnly` properties.</span></span> <span data-ttu-id="a79a1-188">例如：</span><span class="sxs-lookup"><span data-stu-id="a79a1-188">For example:</span></span>  
  
 [!code-vb[VbVbalrInterop#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#26)]  
  
 <span data-ttu-id="a79a1-189">如果您無法存取所呼叫程式的原始程式碼, 您可以在呼叫程式前後新增一組額外的括弧, 以強制以傳值方式傳遞屬性。</span><span class="sxs-lookup"><span data-stu-id="a79a1-189">If you do not have access to the source code for the procedure being called, you can force the property to be passed by value by adding an extra set of brackets around the calling procedure.</span></span> <span data-ttu-id="a79a1-190">例如, 在具有 Microsoft ActiveX Data Objects 2.8 程式庫 COM 物件參考的專案中, 您可以使用:</span><span class="sxs-lookup"><span data-stu-id="a79a1-190">For example, in a project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object, you can use:</span></span>  
  
 [!code-vb[VbVbalrInterop#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrInterop/VB/Class1.vb#27)]  
  
## <a name="vbconinteroperabilitymarshalinganchor12"></a><span data-ttu-id="a79a1-191">部署公開 Interop 的元件</span><span class="sxs-lookup"><span data-stu-id="a79a1-191">Deploying Assemblies That Expose Interop</span></span>  
 <span data-ttu-id="a79a1-192">部署公開 COM 介面的元件會帶來一些獨特的挑戰。</span><span class="sxs-lookup"><span data-stu-id="a79a1-192">Deploying assemblies that expose COM interfaces presents some unique challenges.</span></span> <span data-ttu-id="a79a1-193">例如, 當不同的應用程式參考相同的 COM 元件時, 可能會發生問題。</span><span class="sxs-lookup"><span data-stu-id="a79a1-193">For example, a potential problem occurs when separate applications reference the same COM assembly.</span></span> <span data-ttu-id="a79a1-194">當安裝新版本的元件, 而且另一個應用程式仍在使用舊版的元件時, 就會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="a79a1-194">This situation is common when a new version of an assembly is installed and another application is still using the old version of the assembly.</span></span> <span data-ttu-id="a79a1-195">如果您卸載共用 DLL 的元件, 就可以不小心讓其他元件無法使用它。</span><span class="sxs-lookup"><span data-stu-id="a79a1-195">If you uninstall an assembly that shares a DLL, you can unintentionally make it unavailable to the other assemblies.</span></span>  
  
 <span data-ttu-id="a79a1-196">若要避免這個問題, 您應該將共用元件安裝到全域組件快取 (GAC), 並使用元件的合併模組。</span><span class="sxs-lookup"><span data-stu-id="a79a1-196">To avoid this problem, you should install shared assemblies to the Global Assembly Cache (GAC) and use a MergeModule for the component.</span></span> <span data-ttu-id="a79a1-197">如果您無法將應用程式安裝在 GAC 中, 則應該將它安裝在特定版本子目錄中的 CommonFilesFolder。</span><span class="sxs-lookup"><span data-stu-id="a79a1-197">If you cannot install the application in the GAC, it should be installed to CommonFilesFolder in a version-specific subdirectory.</span></span>  
  
 <span data-ttu-id="a79a1-198">未共用的元件應該與呼叫應用程式位於目錄中的並存位置。</span><span class="sxs-lookup"><span data-stu-id="a79a1-198">Assemblies that are not shared should be located side by side in the directory with the calling application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a79a1-199">另請參閱</span><span class="sxs-lookup"><span data-stu-id="a79a1-199">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="a79a1-200">COM Interop</span><span class="sxs-lookup"><span data-stu-id="a79a1-200">COM Interop</span></span>](../../../visual-basic/programming-guide/com-interop/index.md)
- [<span data-ttu-id="a79a1-201">Tlbimp.exe (類型程式庫匯入工具)</span><span class="sxs-lookup"><span data-stu-id="a79a1-201">Tlbimp.exe (Type Library Importer)</span></span>](../../../framework/tools/tlbimp-exe-type-library-importer.md)
- [<span data-ttu-id="a79a1-202">Tlbexp.exe (類型程式庫匯出工具)</span><span class="sxs-lookup"><span data-stu-id="a79a1-202">Tlbexp.exe (Type Library Exporter)</span></span>](../../../framework/tools/tlbexp-exe-type-library-exporter.md)
- [<span data-ttu-id="a79a1-203">逐步解說：實作 COM 物件的繼承</span><span class="sxs-lookup"><span data-stu-id="a79a1-203">Walkthrough: Implementing Inheritance with COM Objects</span></span>](../../../visual-basic/programming-guide/com-interop/walkthrough-implementing-inheritance-with-com-objects.md)
- [<span data-ttu-id="a79a1-204">Inherits 陳述式</span><span class="sxs-lookup"><span data-stu-id="a79a1-204">Inherits Statement</span></span>](../../../visual-basic/language-reference/statements/inherits-statement.md)
- [<span data-ttu-id="a79a1-205">全域組件快取</span><span class="sxs-lookup"><span data-stu-id="a79a1-205">Global Assembly Cache</span></span>](../../../framework/app-domains/gac.md)
