---
title: Windows Workflow Foundation 4 效能
ms.date: 03/30/2017
ms.assetid: 67d2b3e8-3777-49f8-9084-abbb33b5a766
ms.openlocfilehash: 032c143e1b27c6e37872ac070b3a1430b3c948b4
ms.sourcegitcommit: 160a88c8087b0e63606e6e35f9bd57fa5f69c168
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/09/2019
ms.locfileid: "57724579"
---
# <a name="windows-workflow-foundation-4-performance"></a><span data-ttu-id="e1dcb-102">Windows Workflow Foundation 4 效能</span><span class="sxs-lookup"><span data-stu-id="e1dcb-102">Windows Workflow Foundation 4 Performance</span></span>
<span data-ttu-id="e1dcb-103">Dustin Metzgar</span><span class="sxs-lookup"><span data-stu-id="e1dcb-103">Dustin Metzgar</span></span>

 <span data-ttu-id="e1dcb-104">Wenlong Dong</span><span class="sxs-lookup"><span data-stu-id="e1dcb-104">Wenlong Dong</span></span>

 <span data-ttu-id="e1dcb-105">Microsoft Corporation，2010 年 9 月</span><span class="sxs-lookup"><span data-stu-id="e1dcb-105">Microsoft Corporation, September 2010</span></span>

 <span data-ttu-id="e1dcb-106">Microsoft[!INCLUDE[netfx40_long](../../../includes/netfx40-long-md.md)]效能中包含的主要版本的 Windows Workflow Foundation (WF) 進行了大量投資。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-106">Microsoft [!INCLUDE[netfx40_long](../../../includes/netfx40-long-md.md)] includes a major revision of the Windows Workflow Foundation (WF) with heavy investments in performance.</span></span>  <span data-ttu-id="e1dcb-107">這個新修訂在設計方面做了改變，與 .NET Framework 3.0 和 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 隨附的舊版 [!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)] 有明顯的不同。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-107">This new revision introduces significant design changes from the previous versions of [!INCLUDE[wf1](../../../includes/wf1-md.md)] that shipped as part of .NET Framework 3.0 and [!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)].</span></span> <span data-ttu-id="e1dcb-108">在此版本中，程式設計模型、執行階段及工具的核心已重新架構，以大幅改善效能和可用性。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-108">It has been re-architected from the core of the programming model, runtime, and tooling to greatly improve performance and usability.</span></span> <span data-ttu-id="e1dcb-109">本主題說明這些修訂的重要效能特性，並且與其舊版進行比較。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-109">This topic shows the important performance characteristics of these revisions and compares them against those of the previous version.</span></span>

 <span data-ttu-id="e1dcb-110">WF3 與 WF4 之間個別工作流程元件效能提升的速度很快。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-110">Individual workflow component performance has increased by orders of magnitude between WF3 and WF4.</span></span>  <span data-ttu-id="e1dcb-111">這可讓此間隔之間手動編碼 Windows Communication Foundation (WCF) 服務和 WCF workflow service 是變得很小。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-111">This leaves the gap between hand-coded Windows Communication Foundation (WCF) services and WCF workflow services to be quite small.</span></span>  <span data-ttu-id="e1dcb-112">在 WF4 中，工作流程延遲已大幅降低。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-112">Workflow latency has been significantly reduced in WF4.</span></span>  <span data-ttu-id="e1dcb-113">持續性效能已提升 2.5 至 3.0 倍。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-113">Persistence performance has increased by a factor of 2.5 - 3.0.</span></span>  <span data-ttu-id="e1dcb-114">透過工作流程追蹤進行健康監視的負荷已明顯減少。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-114">Health monitoring by means of workflow tracking has significantly less overhead.</span></span>  <span data-ttu-id="e1dcb-115">這些都是移轉至 WF4 或在應用程式中採用 WF4 的絕佳理由。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-115">These are compelling reasons to migrate to or adopt WF4 in your applications.</span></span>

## <a name="terminology"></a><span data-ttu-id="e1dcb-116">用語</span><span class="sxs-lookup"><span data-stu-id="e1dcb-116">Terminology</span></span>
 <span data-ttu-id="e1dcb-117">本主題後續內容皆以 WF4 代表 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 中引進的 [!INCLUDE[netfx40_short](../../../includes/netfx40-short-md.md)] 版本。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-117">The version of [!INCLUDE[wf1](../../../includes/wf1-md.md)] introduced in [!INCLUDE[netfx40_short](../../../includes/netfx40-short-md.md)] will be referred to as WF4 for the rest of this topic.</span></span>  [!INCLUDE[wf1](../../../includes/wf1-md.md)] <span data-ttu-id="e1dcb-118">是在 .Net 3.0 中引進的，並且透過 [!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)] SP1 進行了幾項小幅修訂。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-118">was introduced in .Net 3.0 and had a few minor revisions through [!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)] SP1.</span></span> <span data-ttu-id="e1dcb-119">本主題中一律將 [!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)] 版的 Workflow Foundation 稱為 WF3。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-119">The [!INCLUDE[netfx35_short](../../../includes/netfx35-short-md.md)] version of Workflow Foundation will be referred to as WF3 for the rest of this topic.</span></span> <span data-ttu-id="e1dcb-120">WF3 與 WF4 一同隨附於 [!INCLUDE[netfx40_short](../../../includes/netfx40-short-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-120">WF3 is shipped in [!INCLUDE[netfx40_short](../../../includes/netfx40-short-md.md)] side-by-side with WF4.</span></span> <span data-ttu-id="e1dcb-121">如需將 WF3 成品移轉至 WF4 的詳細資訊，請參閱：[Windows Workflow Foundation 4 移轉指南](https://go.microsoft.com/fwlink/?LinkID=153313)</span><span class="sxs-lookup"><span data-stu-id="e1dcb-121">For more information about migrating WF3 artifacts to WF4 see: [Windows Workflow Foundation 4 Migration Guide](https://go.microsoft.com/fwlink/?LinkID=153313)</span></span>

 <span data-ttu-id="e1dcb-122">Windows Communication Foundation (WCF) 是 Microsoft 的統一程式設計模型來建置服務導向應用程式。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-122">Windows Communication Foundation (WCF) is Microsoft’s unified programming model for building service-oriented applications.</span></span> <span data-ttu-id="e1dcb-123">它一開始是做為 .NET 3.0 的一部分與 WF3 一併導入，而現在已成為 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 的其中一個重要元件。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-123">It was first introduced as part of .Net 3.0 together with WF3 and now is one of the key components of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].</span></span>

 <span data-ttu-id="e1dcb-124">Windows Server AppFabric 是一組整合式技術，可讓您更輕鬆地建置、調整及管理 IIS 上執行的 Web 與複合應用程式。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-124">Windows Server AppFabric is a set of integrated technologies that make it easier to build, scale and manage Web and composite applications that run on IIS.</span></span> <span data-ttu-id="e1dcb-125">它提供了監視及管理服務和工作流程的工具。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-125">It provides tools for monitoring and managing services and workflows.</span></span> <span data-ttu-id="e1dcb-126">如需詳細資訊，請參閱 < [Windows Server AppFabric 1.0](https://docs.microsoft.com/previous-versions/appfabric/ff384253(v=azure.10))。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-126">For more information, see [Windows Server AppFabric 1.0](https://docs.microsoft.com/previous-versions/appfabric/ff384253(v=azure.10)).</span></span>

## <a name="goals"></a><span data-ttu-id="e1dcb-127">目標</span><span class="sxs-lookup"><span data-stu-id="e1dcb-127">Goals</span></span>
 <span data-ttu-id="e1dcb-128">本主題的目標在於說明 WF4 的效能特性，其中包含的資料會針對不同的案例加以計算。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-128">The goal of this topic is to show the performance characteristics of WF4 with data measured for different scenarios.</span></span> <span data-ttu-id="e1dcb-129">此外也會提供 WF4 與 WF3 之間的詳細比較，藉此說明這個新修訂中所做的優越改良。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-129">It also provides detailed comparisons between WF4 and WF3, and thus shows the great improvements that have been made in this new revision.</span></span> <span data-ttu-id="e1dcb-130">本文的案例和資料會將 WF4 和 WF3 各層面的基礎成本加以量化。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-130">The scenarios and data presented in this article quantify the underlying cost of different aspects of WF4 and WF3.</span></span> <span data-ttu-id="e1dcb-131">這項資料除了能讓您充分了解 WF4 的效能特性之外，同時有助於規劃從 WF3 移轉至 WF4 的作業，或是在應用程式開發的過程中使用 WF4。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-131">This data is useful in understanding the performance characteristics of WF4 and can be helpful in planning migrations from WF3 to WF4 or using WF4 in application development.</span></span> <span data-ttu-id="e1dcb-132">不過，應用本文資料得出的結論時，務必謹慎考慮。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-132">However, care should be taken in the conclusions drawn from the data presented in this article.</span></span> <span data-ttu-id="e1dcb-133">複合工作流程應用程式的效能主要取決於工作流程的實作方式以及不同元件的整合方式。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-133">The performance of a composite workflow application is highly dependent on how the workflow is implemented and how different components are integrated.</span></span> <span data-ttu-id="e1dcb-134">因此必須謹慎評估每一個應用程式，才能判斷出該應用程式的效能特性。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-134">One must measure each application to determine the performance characteristics of that application.</span></span>

## <a name="overview-of-wf4-performance-enhancements"></a><span data-ttu-id="e1dcb-135">WF4 效能加強功能的概觀</span><span class="sxs-lookup"><span data-stu-id="e1dcb-135">Overview of WF4 Performance Enhancements</span></span>
 <span data-ttu-id="e1dcb-136">WF4 經過仔細的設計與實作，其高效能與延展性將在以下各節中加以描述。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-136">WF4 was carefully designed and implemented with high performance and scalability which are described in the following sections.</span></span>

### <a name="wf-runtime"></a><span data-ttu-id="e1dcb-137">WF 執行階段</span><span class="sxs-lookup"><span data-stu-id="e1dcb-137">WF Runtime</span></span>
 <span data-ttu-id="e1dcb-138">[!INCLUDE[wf1](../../../includes/wf1-md.md)] 執行階段的核心擁有非同步的排程器，可讓工作流程中的活動執行。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-138">At the core of the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime is an asynchronous scheduler that drives the execution of the activities in a workflow.</span></span> <span data-ttu-id="e1dcb-139">它提供了高效能且可預測的活動執行環境。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-139">It provides a performant, predictable execution environment for activities.</span></span> <span data-ttu-id="e1dcb-140">這個環境具備妥善定義的執行、接續、完成、取消、例外狀況合約，以及可預測的執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-140">The environment has a well-defined contract for execution, continuation, completion, cancellation, exceptions, and a predictable threading model.</span></span>

 <span data-ttu-id="e1dcb-141">與 WF3 相較之下，WF4 執行階段的排程器更有效率。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-141">In comparison to WF3, the WF4 runtime has a more efficient scheduler.</span></span> <span data-ttu-id="e1dcb-142">它會利用相同的 I/O 執行緒集區用於 WCF 的人，這是非常有效率，在執行批次的工作項目。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-142">It leverages the same I/O thread pool that is used for WCF, which is very efficient at executing batched work items.</span></span> <span data-ttu-id="e1dcb-143">內部工作項目排程器佇列已針對最常見的使用模式完成最佳化。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-143">The internal work item scheduler queue is optimized for most common usage patterns.</span></span> <span data-ttu-id="e1dcb-144">WF4 執行階段還會透過最低限度的同步處理和事件處理邏輯，以相當輕量的方式管理執行狀態，而 WF3 則須倚賴大量的事件註冊和叫用作業，針對狀態轉換進行複雜的同步處理。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-144">The WF4 runtime also manages the execution states in a very light-weight way with minimal synchronization and event handling logic, while WF3 depends on heavy-weight event registration and invocation to perform complex synchronization for state transitions.</span></span>

### <a name="data-storage-and-flow"></a><span data-ttu-id="e1dcb-145">資料儲存和流程</span><span class="sxs-lookup"><span data-stu-id="e1dcb-145">Data Storage and Flow</span></span>
 <span data-ttu-id="e1dcb-146">在 WF3 中，與活動相關聯的資料會透過 <xref:System.Windows.DependencyProperty> 型別所實作的相依性屬性模型化。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-146">In WF3, data associated with an activity is modeled through dependency properties implemented by the type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="e1dcb-147">相依性屬性模式引進了 Windows Presentation Foundation (WPF) 中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-147">The dependency property pattern was introduced in Windows Presentation Foundation (WPF).</span></span> <span data-ttu-id="e1dcb-148">一般而言，此模式相當富彈性，可支援簡單的資料繫結和其他 UI 功能。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-148">In general, this pattern is very flexible to support easy data binding and other UI features.</span></span> <span data-ttu-id="e1dcb-149">不過，此模式需要將屬性定義為工作流程定義中的靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-149">However, the pattern requires the properties to be defined as static fields in the workflow definition.</span></span> <span data-ttu-id="e1dcb-150">每當 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 執行階段設定或取得屬性值，就會涉及相當大量的查詢邏輯。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-150">Whenever the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime sets or gets the property values, it involves heavily-weighted look-up logic.</span></span>

 <span data-ttu-id="e1dcb-151">WF4 使用清楚的資料範圍邏輯，大幅改善了在工作流程中處理資料的方式。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-151">WF4 uses clear data scoping logic to greatly improve how data is handled in a workflow.</span></span> <span data-ttu-id="e1dcb-152">它會使用兩種不同的概念：變數和引數，將儲存於活動中的資料與在活動界限之間流動的資料加以區分。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-152">It separates the data stored in an activity from the data that is flowing across the activity boundaries by using two different concepts: variables and arguments.</span></span> <span data-ttu-id="e1dcb-153">藉由使用變數和 「 在/Out/InOut"引數的清楚的階層式範圍，大幅降低活動的資料使用複雜度，資料的存留期也會自動範圍。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-153">By using a clear hierarchical scope for variables and "In/Out/InOut" arguments, the data usage complexity for activities is dramatically reduced and the lifetime of the data is also automatically scoped.</span></span> <span data-ttu-id="e1dcb-154">活動都具有妥善定義的特徵標記，而此特徵標記由其引數所描述。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-154">Activities have a well-defined signature described by its arguments.</span></span> <span data-ttu-id="e1dcb-155">只要檢查活動，您就可以判斷活動應接收的資料為何，以及活動執行後會產生哪些資料。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-155">By simply inspecting an activity you can determine what data it expects to receive and what data will be produced by it as the result of its execution.</span></span>

 <span data-ttu-id="e1dcb-156">在 WF3 中，活動會在建立工作流程時初始化。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-156">In WF3 activities were initialized when a workflow was created.</span></span> <span data-ttu-id="e1dcb-157">在 WF 4 中，活動只會在對應的活動執行時初始化。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-157">In WF 4 activities are initialized only when the corresponding activities are executing.</span></span> <span data-ttu-id="e1dcb-158">這樣會讓活動的生命週期更為簡單，不必在新的工作流程執行個體建立時執行初始化/取消初始化作業，也因而更有效率。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-158">This allows a simpler activity lifecycle without performing Initialize/Uninitialize operations when a new workflow instance is created, and thus has achieved more efficiency</span></span>

### <a name="control-flow"></a><span data-ttu-id="e1dcb-159">控制流程</span><span class="sxs-lookup"><span data-stu-id="e1dcb-159">Control Flow</span></span>
 <span data-ttu-id="e1dcb-160">就像任何程式語言一樣，[!INCLUDE[wf1](../../../includes/wf1-md.md)] 透過導入一組用於順序、迴圈、分支和其他模式的控制流程活動，支援工作流程定義的控制流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-160">Just as in any programming language, [!INCLUDE[wf1](../../../includes/wf1-md.md)] provides support for control flows for workflow definitions by introducing a set of control flow activities for sequencing, looping, branching and other patterns.</span></span> <span data-ttu-id="e1dcb-161">在 WF3 中，當需要重新執行相同的活動時，就會建立新的 <xref:System.Workflow.ComponentModel.ActivityExecutionContext>，而該活動會透過以 <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 為基礎的大量序列化和還原序列化邏輯進行複製。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-161">In WF3, when the same activity needs to be re-executed, a new <xref:System.Workflow.ComponentModel.ActivityExecutionContext> is created and the activity is cloned through a heavy-weight serialization and deserialization logic based on <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>.</span></span> <span data-ttu-id="e1dcb-162">通常反覆執行之控制流程的效能會比執行一系列活動的效能慢很多。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-162">Usually the performance for iterative control flows is much slower than executing a sequence of activities.</span></span>

 <span data-ttu-id="e1dcb-163">WF4 處理的方式則大為不同。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-163">WF4 handles this quite differently.</span></span> <span data-ttu-id="e1dcb-164">它會採用活動範本、建立新的 ActivityInstance 物件，並且將該物件加入至排程器佇列。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-164">It takes the activity template, creates a new ActivityInstance object, and adds it to the scheduler queue.</span></span> <span data-ttu-id="e1dcb-165">這整個程序只需要明確地建立物件，作業相當輕量。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-165">This whole process only involves explicit object creation and is very light-weight.</span></span>

### <a name="asynchronous-programming"></a><span data-ttu-id="e1dcb-166">非同步程式設計</span><span class="sxs-lookup"><span data-stu-id="e1dcb-166">Asynchronous Programming</span></span>
 <span data-ttu-id="e1dcb-167">應用程式針對長時間執行的封鎖作業 (例如 I/O) 或分散式運算作業採用非同步程式設計時，通常可展現較佳的效能和延展性。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-167">Applications usually have better performance and scalability with asynchronous programming for long running blocking operations such as I/O or distributed computing operations.</span></span> <span data-ttu-id="e1dcb-168">WF4 會透過基礎活動型別 <xref:System.Activities.AsyncCodeActivity> 和 <xref:System.Activities.AsyncCodeActivity%601> 提供非同步支援。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-168">WF4 provides asynchronous support through base activity types <xref:System.Activities.AsyncCodeActivity>, <xref:System.Activities.AsyncCodeActivity%601>.</span></span> <span data-ttu-id="e1dcb-169">執行階段原本即了解非同步活動，因此可以在非同步工作未處理完畢時，自動將執行個體放入不保存區域中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-169">The runtime natively understands asynchronous activities and therefore can automatically put the instance in a no-persist zone while the asynchronous work is outstanding.</span></span> <span data-ttu-id="e1dcb-170">您可以從這些類型衍生自訂活動，以執行非同步工作；如此就不會佔用工作流程排程器執行緒，也不會阻擋任何可平行執行的活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-170">Custom activities can derive from these types to perform asynchronous work without holding the workflow scheduler thread and blocking any activities that may be able to run in parallel.</span></span>

### <a name="messaging"></a><span data-ttu-id="e1dcb-171">傳訊</span><span class="sxs-lookup"><span data-stu-id="e1dcb-171">Messaging</span></span>
 <span data-ttu-id="e1dcb-172">WF3 一開始僅透過外部事件或叫用 Web 服務提供相當有限的傳訊支援。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-172">Initially WF3 had very limited messaging support through external events or web services invocations.</span></span> <span data-ttu-id="e1dcb-173">在.Net 3.5 中，工作流程可以實作為 WCF 用戶端或公開為 WCF 服務，透過<xref:System.Workflow.Activities.SendActivity>和<xref:System.Workflow.Activities.ReceiveActivity>。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-173">In .Net 3.5, workflows could be implemented as WCF clients or exposed as WCF services through <xref:System.Workflow.Activities.SendActivity> and <xref:System.Workflow.Activities.ReceiveActivity>.</span></span> <span data-ttu-id="e1dcb-174">在 WF4 中，工作流程為基礎的傳訊程式設計概念有已進一步加強透過 WCF 至 WF 傳訊邏輯緊密整合。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-174">In WF4, the concept of workflow-based messaging programming has been further strengthened through the tight integration of WCF messaging logic into WF.</span></span>

 <span data-ttu-id="e1dcb-175">.Net 4 中的 WCF 中提供的統一的訊息處理管線可協助將大幅提升效能和延展性，比 WF3 的 WF4 服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-175">The unified message processing pipeline provided in WCF in .Net 4 helps WF4 services to have significantly better performance and scalability than WF3.</span></span> <span data-ttu-id="e1dcb-176">WF4 還提供更豐富的傳訊程式設計支援，可建立複雜的訊息交換模式 (MEP) 模型。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-176">WF4 also provides richer messaging programming support that can model complex Message Exchange Patterns (MEPs).</span></span> <span data-ttu-id="e1dcb-177">開發人員可以使用具型別的服務合約輕鬆進行程式設計，或使用不具型別的服務合約獲得更佳的效能，而不必付出序列化成本。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-177">Developers can use either typed service contracts to achieve easy programming or un-typed service contracts to achieve better performance without paying serialization costs.</span></span> <span data-ttu-id="e1dcb-178">WF4 中透過 <xref:System.ServiceModel.Activities.SendMessageChannelCache> 類別提供的用戶端通道快取支援，可幫助開發人員執行最少的工作來建置快速的應用程式。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-178">The client-side channel caching support through the <xref:System.ServiceModel.Activities.SendMessageChannelCache> class in WF4 helps developers build fast applications with minimal effort.</span></span> <span data-ttu-id="e1dcb-179">如需詳細資訊，請參閱 <<c0> [ 變更傳送活動的快取共用層級](../wcf/feature-details/changing-the-cache-sharing-levels-for-send-activities.md)。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-179">For more information, see [Changing the Cache Sharing Levels for Send Activities](../wcf/feature-details/changing-the-cache-sharing-levels-for-send-activities.md).</span></span>

### <a name="declarative-programming"></a><span data-ttu-id="e1dcb-180">宣告式程式設計</span><span class="sxs-lookup"><span data-stu-id="e1dcb-180">Declarative Programming</span></span>
 <span data-ttu-id="e1dcb-181">WF4 提供清楚且簡單的宣告式程式設計架構來建立商務程序和服務的模型。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-181">WF4 provides a clean and simple declarative programming framework to model business processes and services.</span></span> <span data-ttu-id="e1dcb-182">程式設計模型支援完全以宣告的方式撰寫活動，沒有任何 Code-Beside，因而大幅簡化了工作流程的撰寫。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-182">The programming model supports fully declarative composition of activities, with no code-beside, greatly simplifying workflow authoring.</span></span> <span data-ttu-id="e1dcb-183">在 [!INCLUDE[netfx40_short](../../../includes/netfx40-short-md.md)] 中，XAML 宣告式程式設計架構已整合至單一組件 System.Xaml.dll，以同時支援 WPF 和 WF。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-183">In [!INCLUDE[netfx40_short](../../../includes/netfx40-short-md.md)], the XAML-based declarative programming framework has been unified into the single assembly System.Xaml.dll to support both WPF and WF.</span></span>

 <span data-ttu-id="e1dcb-184">在 WF4 中，XAML 提供了真正的宣告式體驗，而且允許使用 XML 標記定義工作流程的整個定義，並參考使用 .NET 建置的活動和型別。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-184">In WF4, XAML provides a truly declarative experience and allows for the entire definition of the workflow to be defined in XML markup, referencing activities and types built using .NET.</span></span> <span data-ttu-id="e1dcb-185">這種方式在採用 XOML 格式的 WF3 中不容易達成，因為沒有自訂的程式碼後置邏輯。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-185">This was difficult to do in WF3 with XOML format without involving custom code-behind logic.</span></span> <span data-ttu-id="e1dcb-186">.Net 4 中新的 XAML 堆疊能在序列化/還原序列化工作流程成品方面提供更佳的效能，並且讓宣告式程式設計更吸引人也更穩固。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-186">The new XAML-stack in .Net 4 has much better performance in serializing/deserializing workflow artifacts and makes declarative programming more attractive and solid.</span></span>

### <a name="workflow-designer"></a><span data-ttu-id="e1dcb-187">Workflow Designer</span><span class="sxs-lookup"><span data-stu-id="e1dcb-187">Workflow Designer</span></span>
 <span data-ttu-id="e1dcb-188">WF4 的完全宣告式程式設計支援對於大型工作流程在設計階段的效能要求明顯更高。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-188">Fully declarative programming support for WF4 explicitly imposes higher requirements for design time performance for large workflows.</span></span> <span data-ttu-id="e1dcb-189">與 WF3 相較之下，WF4 中的工作流程設計工具對於大型工作流程擁有較佳的延展性。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-189">The Workflow designer in WF4 has much better scalability for large workflows than that for WF3.</span></span> <span data-ttu-id="e1dcb-190">有了 UI 虛擬化支援，設計工具只要幾秒鐘就能輕鬆載入包含 1000 個活動的大型工作流程，而 WF3 設計工具則幾乎不可能載入擁有幾百個活動的工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-190">With UI virtualization support, the designer can easily load a large workflow of 1000 activities in a few seconds, while it is almost impossible to load a workflow of a few hundred activities with the WF3 designer.</span></span>

## <a name="component-level-performance-comparisons"></a><span data-ttu-id="e1dcb-191">元件層級的效能比較</span><span class="sxs-lookup"><span data-stu-id="e1dcb-191">Component-level Performance Comparisons</span></span>
 <span data-ttu-id="e1dcb-192">本節包含在 WF3 和 WF4 工作流程中個別活動之間進行直接比較的相關資料。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-192">This section contains data on direct comparisons between individual activities in WF3 and WF4 workflows.</span></span>  <span data-ttu-id="e1dcb-193">像是持續性等重要方面，對於效能的影響就比個別活動元件的影響更為深遠。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-193">Key areas like persistence have a more profound impact on performance than the individual activity components.</span></span>  <span data-ttu-id="e1dcb-194">不過，WF4 中個別元件的效能改進也相當重要，因為現在元件的速度已經迎頭趕上手動編碼的協調流程邏輯。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-194">The performance improvements in individual components in WF4 are important though because the components are now fast enough to be compared against hand-coded orchestration logic.</span></span>  <span data-ttu-id="e1dcb-195">下一節涵蓋其中的一個範例：< 服務撰寫案例 >。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-195">An example of which is covered in the next section: "Service Composition Scenario."</span></span>

### <a name="environment-setup"></a><span data-ttu-id="e1dcb-196">環境設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-196">Environment Setup</span></span>
 <span data-ttu-id="e1dcb-197">![工作流程效能測試環境](./media/wfperfenvironment.gif "WFPerfEnvironment")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-197">![Workflow Performance Test Environment](./media/wfperfenvironment.gif "WFPerfEnvironment")</span></span>

 <span data-ttu-id="e1dcb-198">上圖顯示用於測量元件層級效能的電腦組態。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-198">The above figure shows the machine configuration used for component-level performance measurement.</span></span> <span data-ttu-id="e1dcb-199">一部伺服器和五個用戶端透過單一 1 Gbps 乙太網路的網路介面連接。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-199">A single server and five clients connected over one 1-Gbps Ethernet network interface.</span></span> <span data-ttu-id="e1dcb-200">為了輕鬆進行測量，伺服器會設定為使用執行 Windows Server 2008 x86 雙處理器/四核心伺服器的單一核心。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-200">For easy measurements, the server is configured to use a single core of a dual-proc/quad-core server  running Windows Server 2008 x86.</span></span> <span data-ttu-id="e1dcb-201">系統 CPU 使用率幾乎維持在 100%。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-201">The system CPU utilization is maintained at nearly 100%.</span></span>

### <a name="test-details"></a><span data-ttu-id="e1dcb-202">測試詳細資料</span><span class="sxs-lookup"><span data-stu-id="e1dcb-202">Test Details</span></span>
 <span data-ttu-id="e1dcb-203">WF3 <xref:System.Workflow.Activities.CodeActivity> 可能是可在 WF3 工作流程中使用的最簡單活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-203">The WF3 <xref:System.Workflow.Activities.CodeActivity> is likely the simplest activity that can be used in a WF3 workflow.</span></span>  <span data-ttu-id="e1dcb-204">此活動會呼叫程式碼後置中的方法，工作流程程式設計人員可以在其中放入自訂程式碼。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-204">The activity calls a method in the code-behind that the workflow programmer can put custom code into.</span></span>  <span data-ttu-id="e1dcb-205">在 WF4 中，沒有任何項目與 WF3 的 <xref:System.Workflow.Activities.CodeActivity>  類似且可提供相同功能。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-205">In WF4, there is no direct analog to the WF3 <xref:System.Workflow.Activities.CodeActivity> that provides the same functionality.</span></span>  <span data-ttu-id="e1dcb-206">請注意，WF4 中的 <xref:System.Activities.CodeActivity> 基底類別與 WF3 <xref:System.Workflow.Activities.CodeActivity> 不相關。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-206">Note that there is a <xref:System.Activities.CodeActivity> base class in WF4 that is not related to the WF3 <xref:System.Workflow.Activities.CodeActivity>.</span></span>  <span data-ttu-id="e1dcb-207">建議工作流程作者建立自訂活動並建置僅限 XAML 的工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-207">Workflow authors are encouraged to create custom activities and build XAML-only workflows.</span></span>  <span data-ttu-id="e1dcb-208">在下列測試中， WF4 工作流程中空的 `Comment` 會由稱為 <xref:System.Workflow.Activities.CodeActivity> 的活動取代。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-208">In the tests below, an activity called `Comment` is used in place of an empty <xref:System.Workflow.Activities.CodeActivity> in WF4 workflows.</span></span>  <span data-ttu-id="e1dcb-209">`Comment` 活動中的程式碼如下所示：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-209">The code in the `Comment` activity is as follows:</span></span>

```
[ContentProperty("Body")]
    public sealed class Comment : CodeActivity
    {
        public Comment()
            : base()
        {
        }

        [DefaultValue(null)]
        public Activity Body
        {
            get;
            set;
        }

        protected override void Execute(CodeActivityContext context)
        {
        }
    }
```

### <a name="empty-workflow"></a><span data-ttu-id="e1dcb-210">空白工作流程</span><span class="sxs-lookup"><span data-stu-id="e1dcb-210">Empty Workflow</span></span>
 <span data-ttu-id="e1dcb-211">這項測試會使用沒有子活動的序列工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-211">This test uses a sequence workflow with no child activities.</span></span>

### <a name="single-activity"></a><span data-ttu-id="e1dcb-212">單一活動</span><span class="sxs-lookup"><span data-stu-id="e1dcb-212">Single Activity</span></span>
 <span data-ttu-id="e1dcb-213">工作流程是包含一個子活動的序列工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-213">The workflow is a sequence workflow containing one child activity.</span></span>  <span data-ttu-id="e1dcb-214">活動是 <xref:System.Workflow.Activities.CodeActivity>，該活動在 WF3 案例中沒有程式碼，而在 WF4 案例中則為 `Comment` 活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-214">The activity is a <xref:System.Workflow.Activities.CodeActivity> with no code in the WF3 case and a `Comment` activity in the WF4 case.</span></span>

### <a name="while-with-1000-iterations"></a><span data-ttu-id="e1dcb-215">While 搭配 1000 個反覆項目</span><span class="sxs-lookup"><span data-stu-id="e1dcb-215">While with 1000 Iterations</span></span>
 <span data-ttu-id="e1dcb-216">序列工作流程包含一個擁有一個子活動的 <xref:System.Activities.Statements.While> 活動，它位於不執行任何工作的迴圈中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-216">The sequence workflow contains one <xref:System.Activities.Statements.While> activity with one child activity in the loop that does not perform any work.</span></span>

### <a name="replicator-compared-to-parallelforeach"></a><span data-ttu-id="e1dcb-217">與 ParallelForEach 比較的 Replicator</span><span class="sxs-lookup"><span data-stu-id="e1dcb-217">Replicator compared to ParallelForEach</span></span>
 <span data-ttu-id="e1dcb-218">WF3 中的 <xref:System.Workflow.Activities.ReplicatorActivity> 具有循序和平行執行模式。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-218"><xref:System.Workflow.Activities.ReplicatorActivity> in WF3 has sequential and parallel execution modes.</span></span>  <span data-ttu-id="e1dcb-219">在循序模式中，活動的效能與 <xref:System.Workflow.Activities.WhileActivity> 相似。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-219">In sequential mode, the activity’s performance is similar to the <xref:System.Workflow.Activities.WhileActivity>.</span></span>  <span data-ttu-id="e1dcb-220"><xref:System.Workflow.Activities.ReplicatorActivity> 最適合用於平行執行。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-220">The <xref:System.Workflow.Activities.ReplicatorActivity> is most useful for parallel execution.</span></span>  <span data-ttu-id="e1dcb-221">WF4 中與此相似的項目為 <xref:System.Activities.Statements.ParallelForEach%601> 活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-221">The WF4 analog for this is the <xref:System.Activities.Statements.ParallelForEach%601> activity.</span></span>

 <span data-ttu-id="e1dcb-222">下圖顯示這項測試所使用的工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-222">The following diagram shows the workflows used for this test.</span></span> <span data-ttu-id="e1dcb-223">左邊為 WF3 工作流程，右邊為 WF4 工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-223">The WF3 workflow is on the left and the WF4 workflow is on the right.</span></span>

 <span data-ttu-id="e1dcb-224">![WF3 ReplicatorActivity 及 WF4 ParallelForEach](./media/replicatorandparallelforeach.gif "ReplicatorAndParallelForEach")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-224">![WF3 ReplicatorActivity and WF4 ParallelForEach](./media/replicatorandparallelforeach.gif "ReplicatorAndParallelForEach")</span></span>

### <a name="sequential-workflow-with-five-activities"></a><span data-ttu-id="e1dcb-225">包含五個活動的循序工作流程</span><span class="sxs-lookup"><span data-stu-id="e1dcb-225">Sequential Workflow with Five Activities</span></span>
 <span data-ttu-id="e1dcb-226">這項測試的目的在於顯示依序執行數個活動的效果。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-226">This test is meant to show the effect of having several activities execute in sequence.</span></span>  <span data-ttu-id="e1dcb-227">序列中有五個活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-227">There are five activities in the sequence.</span></span>

### <a name="transaction-scope"></a><span data-ttu-id="e1dcb-228">交易範圍</span><span class="sxs-lookup"><span data-stu-id="e1dcb-228">Transaction Scope</span></span>
 <span data-ttu-id="e1dcb-229">與其他測試稍為不同的是，交易範圍測試不會針對每個反覆項目建立新的工作流程執行個體。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-229">The transaction scope test differs from the other tests slightly in that a new workflow instance is not created for every iteration.</span></span>  <span data-ttu-id="e1dcb-230">工作流程會以 while 迴圈建構，該迴圈包含的 <xref:System.Activities.Statements.TransactionScope> 活動中會有一個不執行任何工作的活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-230">Instead, the workflow is structured with a while loop containing a <xref:System.Activities.Statements.TransactionScope> activity containing a single activity that does no work.</span></span>  <span data-ttu-id="e1dcb-231">每次透過 while 迴圈執行一批包含 50 個反覆項目的作業，都會計算為單一作業。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-231">Each run of a batch of 50 iterations through the while loop is counted as a single operation.</span></span>

### <a name="compensation"></a><span data-ttu-id="e1dcb-232">補償</span><span class="sxs-lookup"><span data-stu-id="e1dcb-232">Compensation</span></span>
 <span data-ttu-id="e1dcb-233">WF3 工作流程具有名為 `WorkScope` 的單一可補償活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-233">The WF3 workflow has a single compensatable activity named `WorkScope`.</span></span>  <span data-ttu-id="e1dcb-234">此活動只會實作 <xref:System.Workflow.ComponentModel.ICompensatableActivity> 介面：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-234">The activity simply implements the <xref:System.Workflow.ComponentModel.ICompensatableActivity> interface:</span></span>

```
class WorkScope :
        CompositeActivity, ICompensatableActivity
    {
        public WorkScope() : base() { }

        public WorkScope(string name)
        {
            this.Name = name;
        }

        public ActivityExecutionStatus Compensate(
            ActivityExecutionContext executionContext)
        {
            return ActivityExecutionStatus.Closed;
        }
    }
```

 <span data-ttu-id="e1dcb-235">錯誤處理常式會以 `WorkScope` 活動為目標。WF4 工作流程同樣非常簡單。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-235">The fault handler targets the `WorkScope` activity.The WF4 workflow is equally simplistic.</span></span>  <span data-ttu-id="e1dcb-236"><xref:System.Activities.Statements.CompensableActivity> 包含主體和補償處理常式。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-236">A <xref:System.Activities.Statements.CompensableActivity> has a body and a compensation handler.</span></span>  <span data-ttu-id="e1dcb-237">序列中的下一個會是明確補償。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-237">An explicit compensate is next in the sequence.</span></span>  <span data-ttu-id="e1dcb-238">主體活動和補償處理常式活動都是空白實作：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-238">The body activity and compensation handler activity are both empty implementations:</span></span>

```
public sealed class CompensableActivityEmptyCompensation : CodeActivity
    {
        public CompensableActivityEmptyCompensation()
            : base() { }

        public Activity Body { get; set; }

        protected override void Execute(CodeActivityContext context) { }
    }
    public sealed class CompensableActivityEmptyBody : CodeActivity
    {
        public CompensableActivityEmptyBody()
            : base() { }

        public Activity Body { get; set; }

        protected override void Execute(CodeActivityContext context) { }
    }
```

 <span data-ttu-id="e1dcb-239">![WF3 及 WF 基本補償工作流程](./media/basiccompensationworkflows.gif "BasicCompensationWorkflows")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-239">![WF3 and WF basic compensation workflows](./media/basiccompensationworkflows.gif "BasicCompensationWorkflows")</span></span>

 <span data-ttu-id="e1dcb-240">圖 2 - WF3 (左) 和 WF4 (右) 的基本補償工作流程</span><span class="sxs-lookup"><span data-stu-id="e1dcb-240">Figure 2 – WF3 (left) and WF4 (right) basic compensation workflows</span></span>

### <a name="performance-test-results"></a><span data-ttu-id="e1dcb-241">效能測試結果</span><span class="sxs-lookup"><span data-stu-id="e1dcb-241">Performance Test Results</span></span>
 <span data-ttu-id="e1dcb-242">![效能測試結果](./media/performancedata.gif "PerformanceData")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-242">![Performance Test Results](./media/performancedata.gif "PerformanceData")</span></span>

 <span data-ttu-id="e1dcb-243">![效能測試資料圖形](./media/performancetestchart.gif "PerformanceTestChart")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-243">![Performance Test Data Graph](./media/performancetestchart.gif "PerformanceTestChart")</span></span>

 <span data-ttu-id="e1dcb-244">工作流程的所有測試都是以秒為測量單位，但是異動範圍測試除外。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-244">All tests are measured in workflows per second with the exception of the transaction scope test.</span></span>  <span data-ttu-id="e1dcb-245">如上面所示，[!INCLUDE[wf1](../../../includes/wf1-md.md)] 執行階段效能已全面提升，尤其是在需要多次執行相同活動 (如 while 迴圈) 的區域中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-245">As can be seen above, the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime performance has improved across the board, especially in areas that require multiple executions of the same activity like the while loop.</span></span>

## <a name="service-composition-scenario"></a><span data-ttu-id="e1dcb-246">服務撰寫案例</span><span class="sxs-lookup"><span data-stu-id="e1dcb-246">Service Composition Scenario</span></span>
 <span data-ttu-id="e1dcb-247">上一節 < 元件層級的效能比較 > 中所示已經過大幅降低在 WF3 和 WF4 之間的額外負荷。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-247">As is shown in the previous section, "Component-level Performance Comparisons," there has been a significant reduction in overhead between WF3 and WF4.</span></span>  <span data-ttu-id="e1dcb-248">WCF workflow service 可現在幾乎符合手動編碼的 WCF 服務的效能，但仍擁有的所有優點[!INCLUDE[wf1](../../../includes/wf1-md.md)]執行階段。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-248">WCF workflow services can now almost match the performance of hand-coded WCF services but still have all the benefits of the [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime.</span></span>  <span data-ttu-id="e1dcb-249">此測試案例會比較針對 WCF workflow service，WF4 中的 WCF 服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-249">This test scenario compares a WCF service against a WCF workflow service in WF4.</span></span>

### <a name="online-store-service"></a><span data-ttu-id="e1dcb-250">線上存放服務</span><span class="sxs-lookup"><span data-stu-id="e1dcb-250">Online Store Service</span></span>
 <span data-ttu-id="e1dcb-251">Windows Workflow Foundation 的優點之一是能夠撰寫使用數個服務的處理序。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-251">One of the strengths of Windows Workflow Foundation is the ability to compose processes using several services.</span></span>  <span data-ttu-id="e1dcb-252">這個優點的範例為線上存放服務，該服務會協調兩個服務呼叫以採購訂單。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-252">For this example, there is an online store service that orchestrates two service calls to purchase an order.</span></span>  <span data-ttu-id="e1dcb-253">第一個步驟是使用訂單驗證服務驗證訂單。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-253">The first step is to validate the order using an Order Validating Service.</span></span>  <span data-ttu-id="e1dcb-254">第二個步驟是使用倉儲服務填寫訂單。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-254">The second step is to fill the order using a Warehouse Service.</span></span>

 <span data-ttu-id="e1dcb-255">在兩項測驗中，訂單驗證服務和倉儲服務這兩項後端服務保持不變。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-255">The two backend services, Order Validating Service and Warehouse Service, remain the same for both tests.</span></span>  <span data-ttu-id="e1dcb-256">變更的部分是執行協調流程的線上存放服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-256">The part that changes is the Online Store Service that performs the orchestration.</span></span>  <span data-ttu-id="e1dcb-257">在其中一個案例，服務會是手動編碼為 WCF 服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-257">In one case, the service is hand-coded as a WCF service.</span></span>  <span data-ttu-id="e1dcb-258">其他案例中，服務會撰寫為 WF4 中的 WCF 工作流程服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-258">For the other case, the service is written as a WCF workflow service in WF4.</span></span> <span data-ttu-id="e1dcb-259">在這項測試中，[!INCLUDE[wf1](../../../includes/wf1-md.md)] 的專屬功能像是追蹤和持續性都會關閉。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-259">[!INCLUDE[wf1](../../../includes/wf1-md.md)]-specific features like tracking and persistence are turned off for this test.</span></span>

### <a name="environment"></a><span data-ttu-id="e1dcb-260">環境</span><span class="sxs-lookup"><span data-stu-id="e1dcb-260">Environment</span></span>
 <span data-ttu-id="e1dcb-261">![工作流程效能測試環境](./media/wfperfenvironment.gif "WFPerfEnvironment")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-261">![Workflow Performance Test Environment](./media/wfperfenvironment.gif "WFPerfEnvironment")</span></span>

 <span data-ttu-id="e1dcb-262">從多部電腦透過 HTTP 對線上存放服務發出用戶端要求。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-262">Client requests are made to the Online Store Service via HTTP from multiple computers.</span></span>  <span data-ttu-id="e1dcb-263">這三項服務全裝載於單一電腦。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-263">A single computer hosts all three services.</span></span>  <span data-ttu-id="e1dcb-264">線上存放服務和後端服務之間的傳輸層是 TCP 或 HTTP。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-264">The transport layer between the Online Store Service and the backend services is TCP or HTTP.</span></span>  <span data-ttu-id="e1dcb-265">對作業/秒的測量是以完成的 `PurchaseOrder` 呼叫數目為基礎，這些呼叫的目標是線上存放服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-265">The measurement of operations/second is based on the number of completed `PurchaseOrder` calls made to the Online Store Service.</span></span>  <span data-ttu-id="e1dcb-266">通道共用是 WF4 提供的新功能。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-266">Channel pooling is a new feature available in WF4.</span></span>  <span data-ttu-id="e1dcb-267">在 WCF 中的此測試通道共用的部分不是提供現成的因此線上存放服務中使用簡單共用技術的手動編碼實作。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-267">In the WCF portion of this test channel pooling is not provided out of the box so a hand-coded implementation of a simple pooling technique was used in the Online Store Service.</span></span>

### <a name="performance"></a><span data-ttu-id="e1dcb-268">效能</span><span class="sxs-lookup"><span data-stu-id="e1dcb-268">Performance</span></span>
 <span data-ttu-id="e1dcb-269">![線上存放服務效能圖表](./media/onlinestoreperfgraph.gif "OnlineStorePerfGraph")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-269">![Online Store Service Performance Graph](./media/onlinestoreperfgraph.gif "OnlineStorePerfGraph")</span></span>

 <span data-ttu-id="e1dcb-270">不透過通道共用連線到後端 TCP 服務時，[!INCLUDE[wf1](../../../includes/wf1-md.md)] 服務的輸送量會有 17.2% 的影響。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-270">Connecting to backend TCP services without channel pooling, the [!INCLUDE[wf1](../../../includes/wf1-md.md)] service has a 17.2% impact on throughput.</span></span>  <span data-ttu-id="e1dcb-271">若透過通道共用，則影響約 23.8%。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-271">With channel pooling, the penalty is about 23.8%.</span></span>  <span data-ttu-id="e1dcb-272">若為 HTTP，影響會少很多：4.3%，而不需要共用和共用則為 8.1%。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-272">For HTTP, the impact is much less: 4.3% without pooling and 8.1% with pooling.</span></span>  <span data-ttu-id="e1dcb-273">另外要特別注意的是，使用 HTTP 時通道共用的效用不大。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-273">It is also important to note that the channel pooling provides very little benefit when using HTTP.</span></span>

 <span data-ttu-id="e1dcb-274">雖然沒有額外負荷項目從相較於手動編碼中的 WCF 服務這項測試的 WF4 執行階段中，但是可以視為最糟的狀況。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-274">While there is overhead from the WF4 runtime compared with a hand-coded WCF service in this test, it could be considered a worst-case scenario.</span></span>  <span data-ttu-id="e1dcb-275">在這項測試中，兩個後端服務執行的工作相當少。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-275">The two backend services in this test do very little work.</span></span>  <span data-ttu-id="e1dcb-276">在實際的端對端案例中，這些服務會執行更耗費資源的作業，像是資料庫呼叫，傳輸層效能的影響即變得較不重要。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-276">In a real end-to-end scenario, these services would perform more expensive operations like database calls, making the performance impact of the transport layer less important.</span></span>  <span data-ttu-id="e1dcb-277">再加上 WF4 所提供的功能優勢，使得 Workflow Foundation 成為一項建立協調流程服務的可行選擇。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-277">This plus the benefits of the features available in WF4 makes Workflow Foundation a viable choice for creating orchestration services.</span></span>

## <a name="key-performance-considerations"></a><span data-ttu-id="e1dcb-278">重要的效能考量</span><span class="sxs-lookup"><span data-stu-id="e1dcb-278">Key Performance Considerations</span></span>
 <span data-ttu-id="e1dcb-279">本節中提到的功能 (Interop 除外) 在 WF3 和 WF4 之間已有大幅變更。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-279">The feature areas in this section, with the exception of interop, have dramatically changed between WF3 and WF4.</span></span>  <span data-ttu-id="e1dcb-280">這會影響工作流程應用程式的設計以及效能。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-280">This affects the design of workflow applications as well as the performance.</span></span>

#### <a name="workflow-activation-latency"></a><span data-ttu-id="e1dcb-281">工作流程啟動延遲</span><span class="sxs-lookup"><span data-stu-id="e1dcb-281">Workflow Activation Latency</span></span>
 <span data-ttu-id="e1dcb-282">WCF 工作流程服務應用程式中啟動新的工作流程或載入現有的工作流程的延遲都是重要，因為它可能會造成封鎖的。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-282">In a WCF workflow service application, the latency for starting a new workflow or loading an existing workflow is important as it can be blocking.</span></span>  <span data-ttu-id="e1dcb-283">這項測試案例會評估一般案例中的 WF3 XOML 主機與 WF4 XAMLX 主機。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-283">This test case measures a WF3 XOML host against a WF4 XAMLX host in a typical scenario.</span></span>

##### <a name="environment-setup"></a><span data-ttu-id="e1dcb-284">環境設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-284">Environment Setup</span></span>
 <span data-ttu-id="e1dcb-285">![延遲和輸送量測試的環境設定](./media/latencyandthroughputenvironment.gif "LatencyAndThroughputEnvironment")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-285">![Environment setup for latency and throughput tests](./media/latencyandthroughputenvironment.gif "LatencyAndThroughputEnvironment")</span></span>

##### <a name="test-setup"></a><span data-ttu-id="e1dcb-286">測試設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-286">Test Setup</span></span>
 <span data-ttu-id="e1dcb-287">在案例中，用戶端電腦會連絡 WCF workflow service 使用以內容為主的相互關聯。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-287">In the scenario, a client computer contacts a WCF workflow service using context-based correlation.</span></span>  <span data-ttu-id="e1dcb-288">內容相互關聯需要特殊的內容繫結，並使用內容標頭或 Cookie 將訊息與正確的工作流程產生關聯。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-288">Context correlation requires a special context binding and uses a context header or cookie to relate messages to the correct workflow instance.</span></span>  <span data-ttu-id="e1dcb-289">這樣做有益於效能，因為相互關聯 ID 位於訊息標頭中，因此訊息本文不需要進行剖析。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-289">It has a performance benefit in that the correlation Id is located in the message header so the message body does not need to be parsed.</span></span>

 <span data-ttu-id="e1dcb-290">服務將根據要求建立新的工作流程，並且傳送立即回應，如此對延遲的測量就不會包括執行工作流程所花的時間。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-290">The service will create a new workflow with the request and send an immediate response so that the measurement of latency does not include the time spent running the workflow.</span></span>  <span data-ttu-id="e1dcb-291">WF3 工作流程是包含程式碼後置的 XOML，而 WF4 工作流程完全是 XAML。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-291">The WF3 workflow is XOML with a code-behind and the WF4 workflow is entirely XAML.</span></span>  <span data-ttu-id="e1dcb-292">WF4 工作流程看起來像這樣：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-292">The WF4 workflow looks like this:</span></span>

 <span data-ttu-id="e1dcb-293">![WF 4 相互關聯範圍](./media/correlationscopeworkflow.gif "CorrelationScopeWorkflow")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-293">![WF 4 Correlation Scope](./media/correlationscopeworkflow.gif "CorrelationScopeWorkflow")</span></span>

 <span data-ttu-id="e1dcb-294">
  <xref:System.ServiceModel.Activities.Receive> 活動會建立工作流程執行個體。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-294">The <xref:System.ServiceModel.Activities.Receive> activity creates the workflow instance.</span></span>  <span data-ttu-id="e1dcb-295">接收的訊息中傳遞的值會重複在回覆訊息中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-295">A value passed in the received message is echoed in the reply message.</span></span>  <span data-ttu-id="e1dcb-296">回覆之後的序列包含工作流程的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-296">A sequence following the reply contains the rest of the workflow.</span></span>  <span data-ttu-id="e1dcb-297">上述案例中只會顯示一個註解活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-297">In the above case, only one comment activity is shown.</span></span>  <span data-ttu-id="e1dcb-298">註解活動的數量會變更，以模擬工作流程的複雜度。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-298">The number of comment activities is changed to simulate workflow complexity.</span></span>  <span data-ttu-id="e1dcb-299">註解活動相當於不執行任何工作的 WF3 <xref:System.Workflow.Activities.CodeActivity>。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-299">A comment activity is equivalent to a WF3 <xref:System.Workflow.Activities.CodeActivity> that performs no work.</span></span> <span data-ttu-id="e1dcb-300">如需有關註解活動的詳細資訊，請參閱本文稍早 < 元件層級效能比較 > 一節。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-300">For more information about the comment activity, see the "Component-level Performance Comparison" section earlier in this article.</span></span>

##### <a name="test-results"></a><span data-ttu-id="e1dcb-301">測試結果</span><span class="sxs-lookup"><span data-stu-id="e1dcb-301">Test Results</span></span>
 <span data-ttu-id="e1dcb-302">![延遲結果](./media/latencyresultsgraph.gif "LatencyResultsGraph")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-302">![Latency Results](./media/latencyresultsgraph.gif "LatencyResultsGraph")</span></span>

 <span data-ttu-id="e1dcb-303">圖 3 - WCF 工作流程服務的冷延遲和暖延遲</span><span class="sxs-lookup"><span data-stu-id="e1dcb-303">Figure 3 – Cold and warm latency for WCF workflow services</span></span>

 <span data-ttu-id="e1dcb-304">在上圖中，「冷」是表示指定的工作流程沒有現有的 <xref:System.ServiceModel.WorkflowServiceHost>。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-304">In the graph above, cold refers to the case where there is not an existing <xref:System.ServiceModel.WorkflowServiceHost> for the given workflow.</span></span>  <span data-ttu-id="e1dcb-305">換句話說，冷延遲意謂第一次使用此工作流程，XOML 或 XAML 需要進行編譯。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-305">In other words, cold latency is when the workflow is being used for the first time and the XOML or XAML needs to be compiled.</span></span>  <span data-ttu-id="e1dcb-306">暖延遲則意謂所建立的新工作流程執行個體，其工作流程類型已完成編譯。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-306">Warm latency is the time to create a new workflow instance when the workflow type has already been compiled.</span></span>  <span data-ttu-id="e1dcb-307">工作流程的複雜度在 WF4 案例中只有相當些微的差異，但是在 WF3 案例中則呈現直線進展。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-307">The complexity of the workflow makes very little difference in the WF4 case but has a linear progression in the WF3 case.</span></span>

#### <a name="correlation-throughput"></a><span data-ttu-id="e1dcb-308">相互關聯輸送量</span><span class="sxs-lookup"><span data-stu-id="e1dcb-308">Correlation Throughput</span></span>
 <span data-ttu-id="e1dcb-309">WF4 採用新的內容架構相互關聯 (Content-Based Correlation) 功能。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-309">WF4 introduces a new content-based correlation feature.</span></span>  <span data-ttu-id="e1dcb-310">WF3 僅提供以內容為主的相互關聯 (Context-Based Correlation)。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-310">WF3 provided only context-based correlation.</span></span>  <span data-ttu-id="e1dcb-311">只能透過特定的 WCF 通道繫結內容為基礎的相互關聯。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-311">Context-based correlation could only be done over specific WCF channel bindings.</span></span>  <span data-ttu-id="e1dcb-312">使用這些繫結時，工作流程 ID 會插入至訊息標頭。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-312">The workflow Id is inserted into the message header when using these bindings.</span></span>  <span data-ttu-id="e1dcb-313">WF3 執行階段只能根據工作流程 ID 來識別工作流程。透過內容架構的相互關聯，工作流程作者可以從相關的資料片段 (像是帳戶號碼或客戶 ID) 建立相互關聯索引鍵。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-313">The WF3 runtime could only identify a workflow by its Id.  With content-based correlation, the workflow author can create a correlation key out of a relevant piece of data like an account number or customer Id.</span></span>

 <span data-ttu-id="e1dcb-314">以內容為主的相互關聯擁有的效能優勢在於，相互關聯索引鍵位於訊息標頭內。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-314">Context-based correlation has a performance advantage in that the correlation key is located in the message header.</span></span>  <span data-ttu-id="e1dcb-315">索引鍵可以從訊息讀取，而不需進行還原序列化/訊息複製。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-315">The key can be read from the message without de-serialization/message-copying.</span></span>  <span data-ttu-id="e1dcb-316">在內容架構的相互關聯中，相互關聯索引鍵是儲存在訊息主體中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-316">In content-based correlation, the correlation key is stored in the message body.</span></span>  <span data-ttu-id="e1dcb-317">XPath 運算式會用來尋找該索引鍵。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-317">An XPath expression is used to locate the key.</span></span>  <span data-ttu-id="e1dcb-318">這項額外處理的成本取決於訊息的大小、索引鍵在主體中的深度，以及索引鍵的數量。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-318">The cost of this extra processing depends on the size of the message, depth of the key in the body, and the number of keys.</span></span>  <span data-ttu-id="e1dcb-319">這項測試會比較以內容為主的相互關聯與內容架構的相互關聯，另外還會顯示使用多個索引鍵時效能降低的情況。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-319">This test compares context- and content-based correlation and also shows the performance degradation when using multiple keys.</span></span>

#### <a name="environment-setup"></a><span data-ttu-id="e1dcb-320">環境設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-320">Environment Setup</span></span>
 <span data-ttu-id="e1dcb-321">![工作流程效能測試環境](./media/wfperfenvironment.gif "WFPerfEnvironment")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-321">![Workflow Performance Test Environment](./media/wfperfenvironment.gif "WFPerfEnvironment")</span></span>

#### <a name="test-setup"></a><span data-ttu-id="e1dcb-322">測試設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-322">Test Setup</span></span>
 <span data-ttu-id="e1dcb-323">![相互關聯輸送量工作流程測試](./media/correlationthroughputworkflow.gif "CorrelationThroughputWorkflow")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-323">![Correlation Throughput Workflow Test](./media/correlationthroughputworkflow.gif "CorrelationThroughputWorkflow")</span></span>

 <span data-ttu-id="e1dcb-324">如上所示的工作流程是使用下面 < 持續性 > 一節的一樣。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-324">The workflow shown above is the same one used in the "Persistence" section below.</span></span>  <span data-ttu-id="e1dcb-325">執行階段中並未針對未包含持續性的相互關聯測試安裝持續性提供者。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-325">For the correlation tests without persistence there is no persistence provider installed in the runtime.</span></span>  <span data-ttu-id="e1dcb-326">相互關聯，就會發生在兩個地方：CreateOrder 和 CompleteOrder。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-326">Correlation occurs in two places: CreateOrder and CompleteOrder.</span></span>

#### <a name="test-results"></a><span data-ttu-id="e1dcb-327">測試結果</span><span class="sxs-lookup"><span data-stu-id="e1dcb-327">Test Results</span></span>
 <span data-ttu-id="e1dcb-328">![相互關聯輸送量](./media/correlationthroughputgraph.gif "CorrelationThroughputGraph")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-328">![Correlation Throughput](./media/correlationthroughputgraph.gif "CorrelationThroughputGraph")</span></span>

 <span data-ttu-id="e1dcb-329">此圖顯示效能會隨著內容架構相互關聯中使用的索引鍵數目增加而降低。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-329">This graph shows a decrease in performance as the number of keys used in content-based correlation increases.</span></span>  <span data-ttu-id="e1dcb-330">TCP 和 HTTP 之間曲線的相似度，表示與這兩種通訊協定相關聯的負荷。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-330">The similarity in the curves between TCP and HTTP indicates the overhead associated with these protocols.</span></span>

#### <a name="correlation-with-persistence"></a><span data-ttu-id="e1dcb-331">具備持續性的相互關聯</span><span class="sxs-lookup"><span data-stu-id="e1dcb-331">Correlation with Persistence</span></span>
 <span data-ttu-id="e1dcb-332">使用已保存的工作流程時，來自內容架構相互關聯的 CPU 壓力會從工作流程執行階段轉移至 SQL 資料庫。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-332">With a persisted workflow, the CPU pressure from content-based correlation shifts from the workflow runtime to the SQL database.</span></span>  <span data-ttu-id="e1dcb-333">SQL 持續性提供者中的預存程序會進行比對索引鍵的工作，以找出適當的工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-333">The stored procedures in the SQL persistence provider do the work of matching the keys to locate the appropriate workflow.</span></span>

 <span data-ttu-id="e1dcb-334">![相互關聯及持續性結果](./media/correlationandpersistencegraph.gif "CorrelationAndPersistenceGraph")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-334">![Correlation and persistence results](./media/correlationandpersistencegraph.gif "CorrelationAndPersistenceGraph")</span></span>

 <span data-ttu-id="e1dcb-335">以內容為主的相互關聯速度仍然比內容架構的相互關聯快。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-335">Context-based correlation is still faster than content-based correlation.</span></span>  <span data-ttu-id="e1dcb-336">然而差異較不明顯，因為持續性對於效能的影響比相互關聯還要大。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-336">However, the difference is less pronounced as persistence has more impact on performance than correlation.</span></span>

### <a name="complex-workflow-throughput"></a><span data-ttu-id="e1dcb-337">複雜的工作流程輸送量</span><span class="sxs-lookup"><span data-stu-id="e1dcb-337">Complex Workflow Throughput</span></span>
 <span data-ttu-id="e1dcb-338">在測量工作流程複雜度時，並不只是看活動的數目。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-338">The complexity of a workflow is not measured only by the number of activities.</span></span>  <span data-ttu-id="e1dcb-339">複合活動可能包含許多子系，而這些子系本身也可能是複合活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-339">Composite activities can contain many children and those children can also be composite activities.</span></span>  <span data-ttu-id="e1dcb-340">隨著巢狀層級的數目增加，目前可能處於執行中狀態的活動數目，以及處於狀態中的變數數目也會增加。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-340">As the number of levels of nesting increases, so does the number of activities that can be currently in the executing state and the number of variables that can be in state.</span></span>  <span data-ttu-id="e1dcb-341">這項測試會比較執行複雜工作流程時 WF3 和 WF4 的輸送量。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-341">This test compares throughput between WF3 and WF4 when executing complex workflows.</span></span>

### <a name="test-setup"></a><span data-ttu-id="e1dcb-342">測試設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-342">Test Setup</span></span>
 <span data-ttu-id="e1dcb-343">這些測試會在執行 Windows Server 2008 x64、擁有 4GB RAM 且採用 Xeon X5355 (速度 2.66GHz) 的 4 向電腦上執行。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-343">These tests were executed on an Intel Xeon X5355 @ 2.66GHz 4-way computer with 4GB RAM running Windows Server 2008 x64.</span></span>  <span data-ttu-id="e1dcb-344">測試程式碼會在單一處理序中以每個核心一個執行緒的方式執行，以達到 100% CPU 使用率。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-344">The test code runs in a single process with one thread per core to reach 100% CPU utilization.</span></span>

 <span data-ttu-id="e1dcb-345">針對這項測試所產生的工作流程有兩個主要變數：深度和每個序列的活動數目。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-345">The workflows generated for this test have two main variables: depth and number of activities in each sequence.</span></span>  <span data-ttu-id="e1dcb-346">每一個深度層級都包含一個平行活動、while 迴圈、決策、指派及序列。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-346">Each depth level includes a parallel activity, while loop, decisions, assignments, and sequences.</span></span>  <span data-ttu-id="e1dcb-347">下圖顯示的 WF4 設計工具中，會顯示最上層流程圖。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-347">In the WF4 designer pictured below, the top-level flow chart is pictured.</span></span>  <span data-ttu-id="e1dcb-348">每個流程圖活動都與主要流程圖相似。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-348">Each flowchart activity resembles the main flowchart.</span></span>  <span data-ttu-id="e1dcb-349">您可以將這個工作流程想像成一個不規則碎片，其中深度受限於測試的參數。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-349">It may be helpful to think of a fractal when picturing this workflow, where the depth is limited to the parameters of the test.</span></span>

 <span data-ttu-id="e1dcb-350">指定之測試中活動的數目取決於深度和每個序列的活動數目。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-350">The number of activities in a given test is determined by the depth and number of activities per sequence.</span></span>  <span data-ttu-id="e1dcb-351">下列方程式會計算 WF4 測試中的活動數目：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-351">The following equation computes the number of activities in the WF4 test:</span></span>

 <span data-ttu-id="e1dcb-352">![若要計算活動數目的方程式](./media/numberofactivitiesequation.gif "NumberOfActivitiesEquation")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-352">![Equation to compute number of activities](./media/numberofactivitiesequation.gif "NumberOfActivitiesEquation")</span></span>

 <span data-ttu-id="e1dcb-353">由於有額外的序列，WF3 測試的活動計數可以藉由稍為不同的方程式計算：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-353">The WF3 test’s activity count can be computed with a slightly different equation due to an extra sequence:</span></span>

 <span data-ttu-id="e1dcb-354">![若要計算活動數目的方程式](./media/w3numberofactivitiesequation.gif "W3NumberOfActivitiesEquation")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-354">![Equation to compute number of activities](./media/w3numberofactivitiesequation.gif "W3NumberOfActivitiesEquation")</span></span>

 <span data-ttu-id="e1dcb-355">其中 d 代表深度，a 代表每個序列的活動數目。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-355">Where d is the depth and a is the number of activities per sequence.</span></span>  <span data-ttu-id="e1dcb-356">這些方程式背後的邏輯在於，第一個常數乘以 a 得出序列的數目，而第二個常數是目前層級中的靜態活動數目。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-356">The logic behind these equations is that the first constant, multiplied by a, is the number of sequences and the second constant is the static number of activities in the current level.</span></span>  <span data-ttu-id="e1dcb-357">每一個流程圖中會有三個流程圖子活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-357">There are three flowchart child activities in each flowchart.</span></span>  <span data-ttu-id="e1dcb-358">這些流程圖在最下層會是空的，但是在其他層級中則會是主要流程圖的複本。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-358">At the bottom depth level, these flowcharts are empty but at the other levels they are copies of the main flowchart.</span></span>  <span data-ttu-id="e1dcb-359">下表針對每個經變化的測試，顯示其工作流程定義中的活動數目：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-359">The number of activities in each test variation’s workflow definition is indicated in the following table:</span></span>

 <span data-ttu-id="e1dcb-360">![比較每個測試中使用的活動數目](./media/comparechart.gif "CompareChart")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-360">![Compares number of activities used in each test](./media/comparechart.gif "CompareChart")</span></span>

 <span data-ttu-id="e1dcb-361">工作流程定義中的活動數目會隨著深度加深而大幅增加。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-361">The number of activities in the workflow definition increases sharply with each depth level.</span></span>  <span data-ttu-id="e1dcb-362">但是，在指定的工作流程執行個體中，每個決策點只會執行一個路徑，因此只會執行實際活動的一小部分。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-362">But only one path per decision point is executed in a given workflow instance, so only a small subset of the actual activities are executed.</span></span>

 <span data-ttu-id="e1dcb-363">![複雜的工作流程](./media/complexworkflowthroughputworkflow.gif "ComplexWorkflowThroughputWorkflow")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-363">![Complex Workflow](./media/complexworkflowthroughputworkflow.gif "ComplexWorkflowThroughputWorkflow")</span></span>

 <span data-ttu-id="e1dcb-364">WF3 中會建立對等的工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-364">An equivalent workflow was created for WF3.</span></span> <span data-ttu-id="e1dcb-365">WF3 設計工具會在設計區域中顯示整個工作流程，而非巢狀結構，因此超出本主題所能顯示的範圍。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-365">The WF3 designer shows the entire workflow in the design area instead of nesting, therefore it is too big to display in this topic.</span></span> <span data-ttu-id="e1dcb-366">下面顯示工作流程的片段。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-366">A snippet of the workflow is shown below.</span></span>

 <span data-ttu-id="e1dcb-367">![WF3 工作流程](./media/wf3workflow.gif "WF3Workflow")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-367">![WF3 Workflow](./media/wf3workflow.gif "WF3Workflow")</span></span>

 <span data-ttu-id="e1dcb-368">為了練習極端案例中的巢狀結構，這項測試包含的另一個工作流程會使用 100 個巢狀序列。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-368">To exercise nesting in an extreme case, another workflow that is part of this test uses 100 nested sequences.</span></span>  <span data-ttu-id="e1dcb-369">最內層的序列是單一 `Comment` 或 <xref:System.Workflow.Activities.CodeActivity>。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-369">In the innermost sequence is a single `Comment` or <xref:System.Workflow.Activities.CodeActivity>.</span></span>

 <span data-ttu-id="e1dcb-370">![巢狀序列](./media/nestedsequencewf.gif "NestedSequenceWF")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-370">![Nested sequences](./media/nestedsequencewf.gif "NestedSequenceWF")</span></span>

 <span data-ttu-id="e1dcb-371">這項測試中不會使用追蹤和持續性。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-371">Tracking and persistence are not used as part of this test.</span></span>

### <a name="test-results"></a><span data-ttu-id="e1dcb-372">測試結果</span><span class="sxs-lookup"><span data-stu-id="e1dcb-372">Test Results</span></span>
 <span data-ttu-id="e1dcb-373">![輸送量圖形](./media/testresults1.gif "TestResults1")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-373">![Throughput Graph](./media/testresults1.gif "TestResults1")</span></span>

 <span data-ttu-id="e1dcb-374">即使是擁有多層深度和大量活動的複雜工作流程，其效能與本文前段所示的其他輸送量數字一致。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-374">Even with complex workflows with lots of depth and a high number of activities, the performance results are consistent with other throughput numbers shown earlier in this article.</span></span>  <span data-ttu-id="e1dcb-375">WF4 的輸送量增加的速度較快，而且必須在對數刻度上進行比較。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-375">WF4’s throughput is orders of magnitude faster and has to be compared on a logarithmic scale.</span></span>

### <a name="memory"></a><span data-ttu-id="e1dcb-376">記憶體</span><span class="sxs-lookup"><span data-stu-id="e1dcb-376">Memory</span></span>
 <span data-ttu-id="e1dcb-377">Windows Workflow Foundation 的記憶體負荷是從兩個重要的方面加以測量：工作流程複雜度和工作流程定義的數目。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-377">The memory overhead of Windows Workflow Foundation is measured in two key areas: workflow complexity and number of workflow definitions.</span></span>  <span data-ttu-id="e1dcb-378">記憶體測量作業是在 Windows 7 64 位元工作站上進行。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-378">Memory measurements were taken on a Windows 7 64-bit workstation.</span></span>  <span data-ttu-id="e1dcb-379">有許多方法來取得工作集大小，包括監視效能計數器、 輪詢 Environment.WorkingSet，或使用像是 vmmap 這類可從工具[VMMap](/sysinternals/downloads/vmmap)。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-379">There are many ways to obtain the measurement of working set size such as monitoring performance counters, polling Environment.WorkingSet, or using a tool like VMMap available from [VMMap](/sysinternals/downloads/vmmap).</span></span> <span data-ttu-id="e1dcb-380">您可以結合各種方式來取得和驗證每項測試的結果。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-380">A combination of methods was used to obtain and verify the results of each test.</span></span>

### <a name="workflow-complexity-test"></a><span data-ttu-id="e1dcb-381">工作流程複雜度測試</span><span class="sxs-lookup"><span data-stu-id="e1dcb-381">Workflow Complexity Test</span></span>
 <span data-ttu-id="e1dcb-382">工作流程複雜度測試會依據工作流程的複雜度測量工作集的差異。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-382">The workflow complexity test measures the working set difference based on the complexity of the workflow.</span></span>  <span data-ttu-id="e1dcb-383">除了上節中使用的複雜工作流程之外，還加入了新的變化以涵蓋兩個基本案例：單一活動工作流程，以及包含 1000 個活動的序列。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-383">In addition to the complex workflows used in the previous section, new variations are added to cover two basic cases: a single activity workflow and a sequence with 1000 activities.</span></span>  <span data-ttu-id="e1dcb-384">在這些測試中，工作流程會在單一序列迴圈中初始化並且完整執行 (為時一分鐘)。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-384">For these tests the workflows are initialized and executed to completion in a single serial loop for a period of one minute.</span></span>  <span data-ttu-id="e1dcb-385">每一個經變化的測試都會執行三次，而記錄的資料會是這三個回合的平均值。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-385">Each test variation is run three times and the data recorded is the average of those three runs.</span></span>

 <span data-ttu-id="e1dcb-386">兩項新基本測試中的工作流程如下所示：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-386">The two new basic tests have workflows that look like those shown below:</span></span>

 <span data-ttu-id="e1dcb-387">![複雜的工作流程](./media/complexworkflowboth.gif "ComplexWorkflowBoth")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-387">![Complex Workflows](./media/complexworkflowboth.gif "ComplexWorkflowBoth")</span></span>

 <span data-ttu-id="e1dcb-388">在上面所示的 WF3 工作流程中，會使用空的 <xref:System.Workflow.Activities.CodeActivity> 活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-388">In the WF3 workflow shown above, empty <xref:System.Workflow.Activities.CodeActivity> activities are used.</span></span>  <span data-ttu-id="e1dcb-389">上面的 WF4 工作流程則會使用 `Comment` 活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-389">The WF4 workflow above uses `Comment` activities.</span></span>  <span data-ttu-id="e1dcb-390">
  `Comment\` 活動已在本文前段的＜元件層級的效能比較＞一節中說明。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-390">The `Comment` activity was described in the Component-level Performance Comparisons section earlier in this article.</span></span>

 <span data-ttu-id="e1dcb-391">![記憶體使用量圖表](./media/complexmemoryusage.gif "ComplexMemoryUsage")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-391">![Memory Usage Graph](./media/complexmemoryusage.gif "ComplexMemoryUsage")</span></span>

 <span data-ttu-id="e1dcb-392">此圖中其中一個值得注意的明顯趨勢為：巢狀結構對於 WF3 和 WF4 的記憶體使用量相對來說影響較小。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-392">One of the clear trends to notice in this graph is that nesting has relatively minimal impact on memory usage in both WF3 and WF4.</span></span>  <span data-ttu-id="e1dcb-393">指定之工作流程中的活動數目對記憶體的影響程度最大。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-393">The most significant memory impact comes from the number of activities in a given workflow.</span></span>  <span data-ttu-id="e1dcb-394">若查看序列 1000、複雜深度 5 序列 5 及複雜深度 7 序列 1 這些變化的資料，就能清楚得知，活動數目增加到千位數時，記憶體使用量也會更明顯地增加。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-394">Given the data from the sequence 1000, complex depth 5 sequence 5, and complex depth 7 sequence 1 variations, it is clear that as the number of activities enters the thousands, the memory usage increase becomes more noticeable.</span></span>  <span data-ttu-id="e1dcb-395">在有將近 29000 個活動的極端案例中 (深度 7 序列 1)，WF4 使用的記憶體幾乎比 WF3 少 79%。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-395">In the extreme case (depth 7 sequence 1) where there are ~29K activities, WF4 is using almost 79% less memory than WF3.</span></span>

### <a name="multiple-workflow-definitions-test"></a><span data-ttu-id="e1dcb-396">多個工作流程定義測試</span><span class="sxs-lookup"><span data-stu-id="e1dcb-396">Multiple Workflow Definitions Test</span></span>
 <span data-ttu-id="e1dcb-397">由於 WF3 和 WF4 中可用於裝載工作流程的選項有所不同，因此會分成兩項不同的測試來測量每個工作流程定義的記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-397">Measuring memory per workflow definition is divided into two different tests because of the available options for hosting workflows in WF3 and WF4.</span></span>  <span data-ttu-id="e1dcb-398">這兩項測試執行的方式與工作流程複雜度測試不同，因為根據定義初始化和執行指定之工作流程的次數只有一次。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-398">The tests are run in a different manner than the workflow complexity test in that a given workflow is instanced and executed only once per definition.</span></span>  <span data-ttu-id="e1dcb-399">這是因為工作流程定義及其主機在 AppDomain 的存留期會保留在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-399">This is because the workflow definition and its host remain in memory for the lifetime of the AppDomain.</span></span>  <span data-ttu-id="e1dcb-400">為執行指定之工作流程執行個體而使用的記憶體應該在記憶體回收期間清除。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-400">The memory used by running a given workflow instance should be cleaned up during garbage collection.</span></span>  <span data-ttu-id="e1dcb-401">WF4 的移轉指引包含有關裝載選項的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-401">The migration guidance for WF4 contains more detailed information on the hosting options.</span></span> <span data-ttu-id="e1dcb-402">如需詳細資訊，請參閱[WF 移轉做法指南：工作流程裝載](https://go.microsoft.com/fwlink/?LinkID=153313)。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-402">For more information, see [WF Migration Cookbook: Workflow Hosting](https://go.microsoft.com/fwlink/?LinkID=153313).</span></span>

 <span data-ttu-id="e1dcb-403">您可以透過使用幾種方式建立許多工作流程定義，以進工作流程定義測試。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-403">Creating many workflow definitions for a workflow definition test can be done in several ways.</span></span>  <span data-ttu-id="e1dcb-404">例如，您可以使用程式碼產生建立一組除了名稱之外完全相同的 1000 個工作流程，然後將每一個工作流程儲存到不同的檔案中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-404">For instance, one could use code generation to create a set of 1000 workflows that are identical except in name and save each of those workflows into separate files.</span></span>  <span data-ttu-id="e1dcb-405">這種方式原本是用於主控台裝載的測試。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-405">This approach was taken for the console-hosted test.</span></span>  <span data-ttu-id="e1dcb-406">在 WF3 中，<xref:System.Workflow.Runtime.WorkflowRuntime> 類別是用來執行工作流程定義。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-406">In WF3, the <xref:System.Workflow.Runtime.WorkflowRuntime> class was used to run the workflow definitions.</span></span>  <span data-ttu-id="e1dcb-407">WF4 可使用 <xref:System.Activities.WorkflowApplication> 來建立單一工作流程執行個體，也可以直接使用 <xref:System.Activities.WorkflowInvoker> 來執行活動，就像使用方法呼叫一樣。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-407">WF4 can either use <xref:System.Activities.WorkflowApplication> to create a single workflow instance or directly use <xref:System.Activities.WorkflowInvoker> to run the activity as if it were a method call.</span></span>  <span data-ttu-id="e1dcb-408"><xref:System.Activities.WorkflowApplication> 是單一工作流程執行個體的主機，其功能與 <xref:System.Workflow.Runtime.WorkflowRuntime> 相近，因此在這項測試中使用。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-408"><xref:System.Activities.WorkflowApplication> is a host of a single workflow instance and has closer feature parity to <xref:System.Workflow.Runtime.WorkflowRuntime> so that was used in this test.</span></span>

 <span data-ttu-id="e1dcb-409">在 IIS 中裝載工作流程時，可以使用 <xref:System.Web.Hosting.VirtualPathProvider> 建立新的 <xref:System.ServiceModel.WorkflowServiceHost>，而不產生所有 XAMLX 或 XOML 檔案。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-409">When hosting workflows in IIS it is possible to use a <xref:System.Web.Hosting.VirtualPathProvider> to create a new <xref:System.ServiceModel.WorkflowServiceHost> instead of generating all of the XAMLX or XOML files.</span></span>  <span data-ttu-id="e1dcb-410"><xref:System.Web.Hosting.VirtualPathProvider>處理連入要求，並以 「 虛擬檔案 」，可以從資料庫載入或，在此情況下，產生即時回應。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-410">The <xref:System.Web.Hosting.VirtualPathProvider> handles the incoming request and responds with a "virtual file" that can be loaded from a database or, in this case, generated on the fly.</span></span>  <span data-ttu-id="e1dcb-411">因此不需要建立 1000 個實體檔案。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-411">It is therefore unnecessary to create 1000 physical files.</span></span>

 <span data-ttu-id="e1dcb-412">主控台測試中所使用的工作流程定義是包含單一活動的簡單循序工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-412">The workflow definitions used in the console test were simple sequential workflows with a single activity.</span></span>  <span data-ttu-id="e1dcb-413">單一活動在 WF3 案例中是空的 <xref:System.Workflow.Activities.CodeActivity>，在 WF4 案例中則是 `Comment` 活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-413">The single activity was an empty <xref:System.Workflow.Activities.CodeActivity> for the WF3 case and a `Comment` activity for the WF4 case.</span></span>  <span data-ttu-id="e1dcb-414">IIS 裝載的案例使用的工作流程是從接收訊息開始，於傳送回覆時結束：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-414">The IIS-hosted case used workflows that start on receiving a message and end on sending a reply:</span></span>

 <span data-ttu-id="e1dcb-415">![工作流程服務，WF3 和 WF4](./media/receiveworkflowboth.gif "ReceiveWorkflowBoth")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-415">![Workflow Services in WF3 and WF4](./media/receiveworkflowboth.gif "ReceiveWorkflowBoth")</span></span>

 <span data-ttu-id="e1dcb-416">圖 4 - 使用 ReceiveActivity 的 WF3 工作流程，以及使用要求/回應模式的 WF4 工作流程</span><span class="sxs-lookup"><span data-stu-id="e1dcb-416">Figure 4 – WF3 workflow with ReceiveActivity and WF4 workflow with request/response pattern</span></span>

 <span data-ttu-id="e1dcb-417">下表顯示單一工作流程定義與 1001 個定義在工作集上的差異：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-417">The table below shows the delta in working set between a single workflow definition and 1001 definitions:</span></span>

|<span data-ttu-id="e1dcb-418">裝載選項</span><span class="sxs-lookup"><span data-stu-id="e1dcb-418">Hosting Options</span></span>|<span data-ttu-id="e1dcb-419">WF3 工作集差異</span><span class="sxs-lookup"><span data-stu-id="e1dcb-419">WF3 Working Set Delta</span></span>|<span data-ttu-id="e1dcb-420">WF4 工作集差異</span><span class="sxs-lookup"><span data-stu-id="e1dcb-420">WF4 Working Set Delta</span></span>|
|---------------------|---------------------------|---------------------------|
|<span data-ttu-id="e1dcb-421">主控台應用程式裝載的工作流程</span><span class="sxs-lookup"><span data-stu-id="e1dcb-421">Console Application Hosted Workflows</span></span>|<span data-ttu-id="e1dcb-422">18 MB</span><span class="sxs-lookup"><span data-stu-id="e1dcb-422">18 MB</span></span>|<span data-ttu-id="e1dcb-423">9 MB</span><span class="sxs-lookup"><span data-stu-id="e1dcb-423">9 MB</span></span>|
|<span data-ttu-id="e1dcb-424">IIS 裝載的工作流程服務</span><span class="sxs-lookup"><span data-stu-id="e1dcb-424">IIS Hosted Workflow Services</span></span>|<span data-ttu-id="e1dcb-425">446 MB</span><span class="sxs-lookup"><span data-stu-id="e1dcb-425">446 MB</span></span>|<span data-ttu-id="e1dcb-426">364 MB</span><span class="sxs-lookup"><span data-stu-id="e1dcb-426">364 MB</span></span>|

 <span data-ttu-id="e1dcb-427">裝載在 IIS 中的工作流程定義會消耗更多的記憶體，因為<xref:System.ServiceModel.WorkflowServiceHost>，詳細的 WCF 服務成品和處理邏輯與主機關聯的訊息。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-427">Hosting workflow definitions in IIS consumes much more memory due to the <xref:System.ServiceModel.WorkflowServiceHost>, detailed WCF service artifacts, and the message processing logic associated with the host.</span></span>

 <span data-ttu-id="e1dcb-428">針對 WF3 中的主控台裝載作業，工作流程會以程式碼實作，而不是 XOML。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-428">For console hosting in WF3 the workflows were implemented in code instead of XOML.</span></span>  <span data-ttu-id="e1dcb-429">在 WF4 中，預設為使用 XAML。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-429">In WF4 the default is to use XAML.</span></span>  <span data-ttu-id="e1dcb-430">XAML 會在組件中儲存為內嵌資源，並且在執行階段期間編譯，以提供工作流程的實作。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-430">The XAML is stored as an embedded resource in the assembly and compiled during runtime to provide the implementation of the workflow.</span></span>  <span data-ttu-id="e1dcb-431">此程序會產生一些負荷。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-431">There is some overhead associated with this process.</span></span>  <span data-ttu-id="e1dcb-432">為了在 WF3 和 WF4 之間進行公平的比較，會使用以程式碼 (而非 XAML) 撰寫的工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-432">In order to make a fair comparison between WF3 and WF4, coded workflows were used instead of XAML.</span></span>  <span data-ttu-id="e1dcb-433">以下顯示其中一個 WF4 工作流程的範例：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-433">An example of one of the WF4 workflows is shown below:</span></span>

```
public class Workflow1 : Activity
{
    protected override Func<Activity> Implementation
    {
        get
        {
            return new Func<Activity>(() =>
            {
                return new Sequence
                {
                    Activities = {
                        new Comment()
                    }
                };
            });
        }
        set
        {
            base.Implementation = value;
        }
    }
}
```

 <span data-ttu-id="e1dcb-434">還有許多其他的因素可能會影響記憶體消耗。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-434">There are many other factors that can affect memory consumption.</span></span> <span data-ttu-id="e1dcb-435">針對所有 Managed 程式的相同建議仍適用。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-435">The same advice for all managed programs still applies.</span></span>  <span data-ttu-id="e1dcb-436">在 IIS 裝載環境中，針對工作流程定義建立的 <xref:System.ServiceModel.WorkflowServiceHost> 物件會保留在記憶體中，直到回收應用程式集區為止。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-436">In IIS-hosted environments, the <xref:System.ServiceModel.WorkflowServiceHost> object created for a workflow definition stays in memory until the application pool is recycled.</span></span>  <span data-ttu-id="e1dcb-437">撰寫延伸模組時，務必記住這點。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-437">This should be kept in mind when writing extensions.</span></span>  <span data-ttu-id="e1dcb-438">此外，最好是避免 「 全域 」 變數 （範圍為整個工作流程變數），並盡可能限制變數的範圍。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-438">Also, it is best to avoid "global" variables (variables scoped to the whole workflow) and limit the scope of variables wherever possible.</span></span>

## <a name="workflow-runtime-services"></a><span data-ttu-id="e1dcb-439">工作流程執行階段服務</span><span class="sxs-lookup"><span data-stu-id="e1dcb-439">Workflow Runtime Services</span></span>

### <a name="persistence"></a><span data-ttu-id="e1dcb-440">持續性</span><span class="sxs-lookup"><span data-stu-id="e1dcb-440">Persistence</span></span>
 <span data-ttu-id="e1dcb-441">WF3 和 WF4 都隨附 SQL 持續性提供者。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-441">WF3 and WF4 both ship with a SQL persistence provider.</span></span>  <span data-ttu-id="e1dcb-442">WF3 SQL 持續性提供者是一個簡單的實作，可以將工作流程執行個體序列化並將它儲存到 BLOB 中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-442">The WF3 SQL persistence provider is a simple implementation that serializes the workflow instance and stores it in a blob.</span></span>  <span data-ttu-id="e1dcb-443">基於這個理由，工作流程執行個體的大小對於此提供者的效能會有相當大的影響。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-443">For this reason, the performance of this provider depends heavily on the size of the workflow instance.</span></span>  <span data-ttu-id="e1dcb-444">在 WF3 中，可能導致執行個體大小增加的原因有許多種，如本文件前段所討論。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-444">In WF3, the instance size could increase for many reasons, as is discussed previously in this paper.</span></span>  <span data-ttu-id="e1dcb-445">許多客戶選擇不使用預設的 SQL 持續性提供者，因為將序列化執行個體儲存在資料庫中會導致無法看見工作流程的狀態。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-445">Many customers choose not to use the default SQL persistence provider because storing a serialized instance in a database gives no visibility into the state of the workflow.</span></span>  <span data-ttu-id="e1dcb-446">若要在不知道工作流程 ID 的情況下尋找特定工作流程，則必須還原序列化每個保存的執行個體，並且檢查內容。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-446">In order to find a particular workflow without knowing the workflow id, one would have to deserialize each persisted instance and examine the contents.</span></span>  <span data-ttu-id="e1dcb-447">許多開發人員偏好撰寫自己的持續性提供者來克服這個障礙。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-447">Many developers prefer to write their own persistence providers to overcome this obstacle.</span></span>

 <span data-ttu-id="e1dcb-448">WF4 SQL 持續性提供者已嘗試解決部分問題。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-448">The WF4 SQL persistence provider has tried to address some of these concerns.</span></span>  <span data-ttu-id="e1dcb-449">持續性資料表會公開特定資訊，例如使用中書籤和可提升的屬性。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-449">The persistence tables expose certain information such as the active bookmarks and promotable properties.</span></span>  <span data-ttu-id="e1dcb-450">WF4 中新的內容架構相互關聯功能使用 WF3 SQL 持續性方法的話，可能無法正常執行，該功能已對保存的工作流程執行個體進行一些組織上的變更。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-450">The new content-based correlation feature in WF4 would not perform well using the WF3 SQL persistence approach, which has driven some change in the organization of the persisted workflow instance.</span></span>  <span data-ttu-id="e1dcb-451">這樣會使持續性提供者的工作更為複雜，並帶給資料庫額外的壓力。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-451">This makes the job of the persistence provider more complex and puts extra stress on the database.</span></span>

### <a name="environment-setup"></a><span data-ttu-id="e1dcb-452">環境設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-452">Environment Setup</span></span>
 <span data-ttu-id="e1dcb-453">![工作流程效能測試環境](./media/wfperfenvironment.gif "WFPerfEnvironment")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-453">![Workflow Performance Test Environment](./media/wfperfenvironment.gif "WFPerfEnvironment")</span></span>

### <a name="test-setup"></a><span data-ttu-id="e1dcb-454">測試設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-454">Test Setup</span></span>
 <span data-ttu-id="e1dcb-455">即使有了改良的功能集和更優越的並行處理，WF4 中 SQL 持續性提供者的速度還是比 WF3 中的提供者快。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-455">Even with an improved feature set and better concurrency handling, the SQL persistence provider in WF4 is faster than the provider in WF3.</span></span>  <span data-ttu-id="e1dcb-456">為了展示這個情況，以下將比較 WF3 和 WF4 中執行本質相同之作業的兩個工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-456">To showcase this, two workflows that perform essentially the same operations in WF3 and WF4 are compared below.</span></span>

 <span data-ttu-id="e1dcb-457">![持續性工作流程](./media/persistworkflow.gif "PersistWorkflow")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-457">![Persistence Workflows](./media/persistworkflow.gif "PersistWorkflow")</span></span>

 <span data-ttu-id="e1dcb-458">圖 5 - 左邊為 WF3 中的持續性工作流程，右邊則為 WF4</span><span class="sxs-lookup"><span data-stu-id="e1dcb-458">Figure 5 – Persistence workflow in WF3 on left and WF4 on right</span></span>

 <span data-ttu-id="e1dcb-459">兩個工作流程都是透過收到的訊息所建立。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-459">The two workflows are both created by a received message.</span></span>  <span data-ttu-id="e1dcb-460">傳送初始回覆之後，會保存工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-460">After sending an initial reply, the workflow is persisted.</span></span>  <span data-ttu-id="e1dcb-461">WF3 案例中會使用空的 <xref:System.Workflow.ComponentModel.TransactionScopeActivity> 啟始持續性。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-461">In the WF3 case, an empty <xref:System.Workflow.ComponentModel.TransactionScopeActivity> is used to initiate the persistence.</span></span>  <span data-ttu-id="e1dcb-462">相同無法在 WF3 中達成標示活動做為 「 關閉時保存。 」</span><span class="sxs-lookup"><span data-stu-id="e1dcb-462">The same could be achieved in WF3 by marking an activity as "persist on close."</span></span>  <span data-ttu-id="e1dcb-463">另一個相互關聯的訊息會完成工作流程。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-463">A second, correlated message completes the workflow.</span></span>  <span data-ttu-id="e1dcb-464">工作流程會保存，但是不會卸載。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-464">The workflows are persisted but not unloaded.</span></span>

### <a name="test-results"></a><span data-ttu-id="e1dcb-465">測試結果</span><span class="sxs-lookup"><span data-stu-id="e1dcb-465">Test Results</span></span>
 <span data-ttu-id="e1dcb-466">![輸送量持續性](./media/throughputpersistence.gif "ThroughputPersistence")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-466">![Throughput Persistence](./media/throughputpersistence.gif "ThroughputPersistence")</span></span>

 <span data-ttu-id="e1dcb-467">當用戶端和中介層之間的傳輸為 HTTP 時，WF4 中的持續性就會提升 2.6 倍。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-467">When the transport between client and middle tier is HTTP, persistence in WF4 shows an improvement of 2.6 times.</span></span>  <span data-ttu-id="e1dcb-468">TCP 傳輸會將該係數增加為 3.0 倍。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-468">The TCP transport increases that factor to 3.0 times.</span></span>  <span data-ttu-id="e1dcb-469">在所有案例中，中介層的 CPU 使用率都會是 98% 或更高。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-469">In all cases, CPU utilization on the middle tier is 98% or higher.</span></span>  <span data-ttu-id="e1dcb-470">WF4 輸送量較大的原因在於，工作流程執行階段的速度較快。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-470">The reason that WF4 throughput is greater is due to the faster workflow runtime.</span></span>  <span data-ttu-id="e1dcb-471">這兩個案例的序列化執行個體都不大，所以在此情況下並不是主要影響因素。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-471">The size of the serialized instance is low for both cases and is not a major contributing element in this situation.</span></span>

 <span data-ttu-id="e1dcb-472">這項測試中的 WF3 和 WF4 工作流程都使用活動明確指出持續性應該發生的時機。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-472">Both the WF3 and WF4 workflows in this test use an activity to explicitly indicate when persistence should occur.</span></span>  <span data-ttu-id="e1dcb-473">這樣做的優點在於保存工作流程，而不將它卸載。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-473">This has the benefit of persisting the workflow without unloading it.</span></span>  <span data-ttu-id="e1dcb-474">在 WF3 中也可以使用 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 功能保存，但是這樣會從記憶體卸載工作流程執行個體。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-474">In WF3, it is also possible to persist using the <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> feature, but this unloads the workflow instance from memory.</span></span>  <span data-ttu-id="e1dcb-475">如果使用 WF3 的開發人員想要確保在特定時間點保存工作流程，則必須修改工作流程定義，或是付出卸載及重新載入工作流程執行個體的成本。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-475">If a developer using WF3 wants to make sure a workflow persists at certain points, they either have to alter the workflow definition or pay the cost for unloading and re-loading the workflow instance.</span></span>  <span data-ttu-id="e1dcb-476">WF4 的新功能則可在不需要卸載的情況下保存工作流程執行個體：<xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-476">A new feature in WF4 makes it possible to persist without unloading: <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToPersist%2A>.</span></span>  <span data-ttu-id="e1dcb-477">這項功能允許工作流程執行個體在閒置時被保存，並且保留在記憶體中，直到達到 <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> 臨界值或繼續執行時。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-477">This feature allows the workflow instance to be persisted on idle but stay in memory until the <xref:System.ServiceModel.Activities.Description.WorkflowIdleBehavior.TimeToUnload%2A> threshold is met or execution is resumed.</span></span>

 <span data-ttu-id="e1dcb-478">請注意，WF4 SQL 持續性提供者在資料庫層中會執行較多工作。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-478">Note that the WF4 SQL persistence provider performs more work in the database tier.</span></span>  <span data-ttu-id="e1dcb-479">由於 SQL 資料庫可能變成瓶頸，因此務必監視該處的 CPU 和磁碟使用量。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-479">The SQL database can become a bottleneck so it is important to monitor the CPU and disk usage there.</span></span>  <span data-ttu-id="e1dcb-480">效能測試工作流程應用程式時，務必包括以下 SQL 資料庫中的效能計數器：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-480">Be sure to include the following performance counters from the SQL database when performance testing workflow applications:</span></span>

-   <span data-ttu-id="e1dcb-481">PhysicalDisk\\%磁碟讀取時間</span><span class="sxs-lookup"><span data-stu-id="e1dcb-481">PhysicalDisk\\%Disk Read Time</span></span>

-   <span data-ttu-id="e1dcb-482">PhysicalDisk\\%Disk Time</span><span class="sxs-lookup"><span data-stu-id="e1dcb-482">PhysicalDisk\\% Disk Time</span></span>

-   <span data-ttu-id="e1dcb-483">PhysicalDisk\\%的磁碟寫入時間</span><span class="sxs-lookup"><span data-stu-id="e1dcb-483">PhysicalDisk\\% Disk Write Time</span></span>

-   <span data-ttu-id="e1dcb-484">PhysicalDisk\\%平均Disk Queue Length</span><span class="sxs-lookup"><span data-stu-id="e1dcb-484">PhysicalDisk\\% Avg. Disk Queue Length</span></span>

-   <span data-ttu-id="e1dcb-485">PhysicalDisk\Avg.Disk Read Queue Length</span><span class="sxs-lookup"><span data-stu-id="e1dcb-485">PhysicalDisk\Avg. Disk Read Queue Length</span></span>

-   <span data-ttu-id="e1dcb-486">PhysicalDisk\Avg.Disk Write Queue Length</span><span class="sxs-lookup"><span data-stu-id="e1dcb-486">PhysicalDisk\Avg. Disk Write Queue Length</span></span>

-   <span data-ttu-id="e1dcb-487">PhysicalDisk\Current Disk Queue Length</span><span class="sxs-lookup"><span data-stu-id="e1dcb-487">PhysicalDisk\Current Disk Queue Length</span></span>

-   <span data-ttu-id="e1dcb-488">處理器資訊\\%處理器時間</span><span class="sxs-lookup"><span data-stu-id="e1dcb-488">Processor Information\\% Processor Time</span></span>

-   <span data-ttu-id="e1dcb-489">SQLServer:Latches\Average Latch Wait Time (ms)</span><span class="sxs-lookup"><span data-stu-id="e1dcb-489">SQLServer:Latches\Average Latch Wait Time (ms)</span></span>

-   <span data-ttu-id="e1dcb-490">SQLServer:Latches\Latch Waits/sec</span><span class="sxs-lookup"><span data-stu-id="e1dcb-490">SQLServer:Latches\Latch Waits/sec</span></span>

### <a name="tracking"></a><span data-ttu-id="e1dcb-491">追蹤</span><span class="sxs-lookup"><span data-stu-id="e1dcb-491">Tracking</span></span>
 <span data-ttu-id="e1dcb-492">工作流程追蹤可以用來追蹤工作流程的進度。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-492">Workflow tracking can be used to track the progress of a workflow.</span></span>  <span data-ttu-id="e1dcb-493">追蹤事件中包含的資訊是由追蹤設定檔所決定。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-493">The information that is included in the tracking events is determined by a tracking profile.</span></span>  <span data-ttu-id="e1dcb-494">追蹤設定檔越複雜，追蹤所耗用的資源就愈多。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-494">The more complex the tracking profile, the more expensive tracking becomes.</span></span>

 <span data-ttu-id="e1dcb-495">WF3 隨附 SQL 架構追蹤服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-495">WF3 shipped with a SQL-based tracking service.</span></span>  <span data-ttu-id="e1dcb-496">這項服務可以在批次和非批次模式下運作。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-496">This service could work in batched and non-batched modes.</span></span>  <span data-ttu-id="e1dcb-497">在非批次模式中，追蹤事件會直接寫入資料庫。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-497">In non-batched mode, tracking events are written directly to the database.</span></span>  <span data-ttu-id="e1dcb-498">在批次模式中，追蹤事件會收集到與工作流程執行個體狀態相同的批次中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-498">In batched mode, tracking events are collected into the same batch as the workflow instance state.</span></span>  <span data-ttu-id="e1dcb-499">針對最廣泛的工作流程設計，批次模式可提供最佳效能。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-499">The batched mode has the best performance for the widest range of workflow designs.</span></span>  <span data-ttu-id="e1dcb-500">不過，如果工作流程執行許多活動而未保存，而且這些活動都會加以追蹤，則批次處理可能對效能產生負面影響。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-500">However, batching can have a negative performance impact if the workflow runs many activities without persisting and those activities are tracked.</span></span>  <span data-ttu-id="e1dcb-501">這種情況常發生在迴圈中，而避免這種情況發生的最佳方式，就是設計大型迴圈來包含保存點。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-501">This would commonly happen in loops and the best way to avoid this scenario is to design large loops to contain a persistence point.</span></span>  <span data-ttu-id="e1dcb-502">在迴圈中導入保存點同樣可能對效能造成負面影響，因此務必計算各項的成本並找出平衡。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-502">Introducing a persistence point into a loop can negatively affect performance as well so it is important to measure the costs of each and come up with a balance.</span></span>

 <span data-ttu-id="e1dcb-503">WF4 沒有隨附 SQL 追蹤服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-503">WF4 is not shipped with a SQL tracking service.</span></span>  <span data-ttu-id="e1dcb-504">將追蹤資訊記錄到 SQL 資料庫的工作，交由應用程式伺服器處理會比內建於 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 更有效。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-504">Recording tracking information to a SQL database can be handled better from an application server rather than built into the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="e1dcb-505">因此，SQL 追蹤現在是由 AppFabric 處理。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-505">Therefore SQL tracking is now handled by AppFabric.</span></span>  <span data-ttu-id="e1dcb-506">WF4 中現成的追蹤提供者是以 Windows 事件追蹤 (ETW) 為基礎。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-506">The out-of-the-box tracking provider in WF4 is based on Event Tracing for Windows (ETW).</span></span>

 <span data-ttu-id="e1dcb-507">ETW 是核心層級的低延遲事件系統，內建於 Windows。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-507">ETW is a kernel-level, low-latency event system built into Windows.</span></span>  <span data-ttu-id="e1dcb-508">它使用提供者/消費者模型，如此在實際上有消費者時，就只有事件追蹤會產生負面影響。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-508">It uses a provider/consumer model that makes it possible to only incur the penalty for event tracing when there is actually a consumer.</span></span>  <span data-ttu-id="e1dcb-509">除了核心事件 (像是處理器、磁碟、記憶體和網路使用量) 之外，許多應用程式也都會運用 ETW。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-509">In addition to kernel events such as processor, disk, memory, and network usage, many applications leverage ETW as well.</span></span>  <span data-ttu-id="e1dcb-510">ETW 事件的功能比效能計數器強大，因為可以針對應用程式自訂事件。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-510">ETW events are more powerful than performance counters in that events can be customized to the application.</span></span>  <span data-ttu-id="e1dcb-511">事件可以包含像是工作流程 ID 或資訊訊息這類文字。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-511">An event can contain text such as a workflow ID or an informational message.</span></span>  <span data-ttu-id="e1dcb-512">此外，事件還會依位元遮罩分類，如此一來，使用特定事件子集對效能的影響就會比擷取所有事件低。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-512">Also, events are categorized with bitmasks so that consuming a certain subset of events will have less performance impact than capturing all events.</span></span>

 <span data-ttu-id="e1dcb-513">使用 ETW 而不使用 SQL 進行追蹤的優點如下：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-513">Benefits to the approach of using ETW for tracking instead of SQL include:</span></span>

-   <span data-ttu-id="e1dcb-514">追蹤事件的收集工作可以分割到另一個處理序。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-514">Collection of tracking events can be separated to another process.</span></span>  <span data-ttu-id="e1dcb-515">如此就能在事件記錄方式上獲得更大的彈性。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-515">This gives greater flexibility in how the events are recorded.</span></span>

-   <span data-ttu-id="e1dcb-516">ETW 追蹤事件可輕鬆結合 WCF ETW 事件或是其他 ETW 提供者，例如 SQL Server 或核心提供者。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-516">ETW tracking events are easily combined with the WCF ETW events or other ETW providers such as a SQL Server or kernel provider.</span></span>

-   <span data-ttu-id="e1dcb-517">工作流程作者不需要修改工作流程，就能更充分地運用特定追蹤實作，例如 WF3 SQL 追蹤服務的批次模式。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-517">Workflow authors do not need to alter a workflow to work better with a particular tracking implementation, such as the WF3 SQL tracking service’s batch mode.</span></span>

-   <span data-ttu-id="e1dcb-518">系統管理員可以開啟或關閉追蹤功能，而不需回收主機處理序。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-518">An administrator can turn tracking on or off without recycling the host process.</span></span>

 <span data-ttu-id="e1dcb-519">但是 ETW 追蹤的效能優點伴隨了一個缺點。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-519">The performance benefits to ETW tracking come with a drawback.</span></span>  <span data-ttu-id="e1dcb-520">如果系統的資源壓力很大，則 ETW 事件可能會遺失。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-520">ETW events can be lost if the system is under intense resource pressure.</span></span>  <span data-ttu-id="e1dcb-521">事件處理的目的不是封鎖正常的程式執行，因此無法保證所有 ETW 事件都會廣播至其訂閱者。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-521">The processing of events is not meant to block normal program execution and therefore it is not guaranteed that all ETW events will be broadcast to their subscribers.</span></span>  <span data-ttu-id="e1dcb-522">因此 ETW 追蹤相當適合用於健康監視，但不適合用於稽核。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-522">This makes ETW tracking great for health monitoring but not suitable for auditing.</span></span>

 <span data-ttu-id="e1dcb-523">雖然 WF4 沒有 SQL 追蹤提供者，但是 AppFabric 有。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-523">While WF4 does not have a SQL tracking provider, AppFabric does.</span></span>  <span data-ttu-id="e1dcb-524">AppFabric 的 SQL 追蹤方法是使用 Windows 服務訂閱 ETW 事件，此服務會批次處理事件並將事件寫入可快速插入的 SQL 資料表中。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-524">AppFabric’s SQL tracking approach is to subscribe to ETW events with a Windows Service that batches the events and writes them to a SQL table designed for quick inserts.</span></span>  <span data-ttu-id="e1dcb-525">另一項工作會從這個資料表取出資料，然後重新製成可在 AppFabric 儀表板上檢視的報告資料表。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-525">A separate job drains the data from this table and reforms it into reporting tables that can be viewed on the AppFabric dashboard.</span></span>  <span data-ttu-id="e1dcb-526">這表示一批追蹤事件會與其來源的工作流程分開處理，因此不必等待保存點即可加以記錄。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-526">This means that a batch of tracking events is handled independent of the workflow it came from and therefore does not have to wait for a persistence point before being recorded.</span></span>

 <span data-ttu-id="e1dcb-527">ETW 事件可以使用 logman 或 xperf 這類工具記錄。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-527">ETW events can be recorded with tools such as logman or xperf.</span></span>  <span data-ttu-id="e1dcb-528">壓縮的 ETL 檔案可以使用 xperfview 這類工具檢視，或是使用 tracerpt 轉換成更容易閱讀的格式，例如 XML。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-528">The compact ETL file can be viewed with a tool like xperfview or converted to a more readable format, such as XML, with tracerpt.</span></span>  <span data-ttu-id="e1dcb-529">在 WF3 中，若要不使用 SQL 資料庫來取得追蹤事件，唯一的方法就是建立自訂追蹤服務。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-529">In WF3, the only option for getting tracking events without a SQL database is to create a custom tracking service.</span></span> <span data-ttu-id="e1dcb-530">如需 ETW 的詳細資訊，請參閱[WCF 服務與為 Windows 事件追蹤](../wcf/samples/wcf-services-and-event-tracing-for-windows.md)並[事件追蹤-Windows 應用程式](/windows/desktop/etw/event-tracing-portal)。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-530">For more information about ETW, see [WCF Services and Event Tracing for Windows](../wcf/samples/wcf-services-and-event-tracing-for-windows.md) and [Event Tracing - Windows applications](/windows/desktop/etw/event-tracing-portal).</span></span>

 <span data-ttu-id="e1dcb-531">啟用工作流程追蹤對效能會有不同程度的影響。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-531">Enabling workflow tracking will impact performance in varying degrees.</span></span>  <span data-ttu-id="e1dcb-532">下列基準會使用 logman 工具取用 ETW 追蹤事件，並且將事件記錄到 ETL 檔案。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-532">The benchmark below uses the logman tool to consume the ETW tracking events and record them to an ETL file.</span></span>  <span data-ttu-id="e1dcb-533">AppFabric 中 SQL 追蹤的成本不在本文的討論範圍內。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-533">The cost of the SQL tracking in AppFabric is not in the scope of this article.</span></span>  <span data-ttu-id="e1dcb-534">此基準中會顯示基本追蹤設定檔 (也會在 AppFabric 中使用)。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-534">The basic tracking profile, also used in AppFabric, is shown in this benchmark.</span></span>  <span data-ttu-id="e1dcb-535">另外還包括僅追蹤健康監視事件的成本。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-535">Also included is the cost of tracking only health monitoring events.</span></span>  <span data-ttu-id="e1dcb-536">這些事件有助於問題的疑難排解，以及判斷系統的平均輸送量。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-536">These events are useful for troubleshooting problems and determining the average throughput of the system.</span></span>

### <a name="environment-setup"></a><span data-ttu-id="e1dcb-537">環境設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-537">Environment Setup</span></span>
 <span data-ttu-id="e1dcb-538">![工作流程效能測試環境](./media/wfperfenvironment.gif "WFPerfEnvironment")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-538">![Workflow Performance Test Environment](./media/wfperfenvironment.gif "WFPerfEnvironment")</span></span>

### <a name="test-results"></a><span data-ttu-id="e1dcb-539">測試結果</span><span class="sxs-lookup"><span data-stu-id="e1dcb-539">Test Results</span></span>
 <span data-ttu-id="e1dcb-540">![工作流程追蹤成本](./media/workflowtracingcost.gif "WorkflowTracingCost")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-540">![Workflow Tracing Cost](./media/workflowtracingcost.gif "WorkflowTracingCost")</span></span>

 <span data-ttu-id="e1dcb-541">健康監視對於輸送量的影響約為 3%。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-541">Health monitoring has roughly a 3% impact on throughput.</span></span>  <span data-ttu-id="e1dcb-542">基本設定檔的成本約為 8%。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-542">The basic profile’s cost is around 8%.</span></span>

## <a name="interop"></a><span data-ttu-id="e1dcb-543">Interop</span><span class="sxs-lookup"><span data-stu-id="e1dcb-543">Interop</span></span>
 <span data-ttu-id="e1dcb-544">WF4 幾乎是完全重新撰寫 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 的結果，因此 WF3 工作流程和活動無法與 WF4 直接相容。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-544">WF4 is almost a complete rewrite of [!INCLUDE[wf1](../../../includes/wf1-md.md)] and therefore WF3 workflows and activities are not directly compatible with WF4.</span></span>  <span data-ttu-id="e1dcb-545">早期採用 Windows Workflow Foundation 的許多客戶將會有 WF3 內部或協力廠商的工作流程定義和自訂活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-545">Many customers that adopted Windows Workflow Foundation early will have in-house or third-party workflow definitions and custom activities for WF3.</span></span>  <span data-ttu-id="e1dcb-546">其中一種輕鬆轉換至 WF4 的方式就是使用 Interop 活動，該活動可以從 WF4 工作流程內執行 WF3 活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-546">One way to ease the transition to WF4 is to use the Interop activity, which can execute WF3 activities from within a WF4 workflow.</span></span>  <span data-ttu-id="e1dcb-547">建議必要時才使用 <xref:System.Activities.Statements.Interop> 活動。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-547">It is recommended that the <xref:System.Activities.Statements.Interop> activity only be used when necessary.</span></span> <span data-ttu-id="e1dcb-548">如需移轉至 WF4 的詳細資訊請參閱[WF4 移轉指引](https://go.microsoft.com/fwlink/?LinkID=153313)。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-548">For more information about migrating to WF4 check out the [WF4 Migration Guidance](https://go.microsoft.com/fwlink/?LinkID=153313).</span></span>

### <a name="environment-setup"></a><span data-ttu-id="e1dcb-549">環境設定</span><span class="sxs-lookup"><span data-stu-id="e1dcb-549">Environment Setup</span></span>
 <span data-ttu-id="e1dcb-550">![工作流程效能測試環境](./media/wfperfenvironment.gif "WFPerfEnvironment")</span><span class="sxs-lookup"><span data-stu-id="e1dcb-550">![Workflow Performance Test Environment](./media/wfperfenvironment.gif "WFPerfEnvironment")</span></span>

### <a name="test-results"></a><span data-ttu-id="e1dcb-551">測試結果</span><span class="sxs-lookup"><span data-stu-id="e1dcb-551">Test Results</span></span>
 <span data-ttu-id="e1dcb-552">下表顯示在各種不同組態中，執行序列中包含五個活動之工作流程的結果。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-552">The table below shows the results of running a workflow containing five activities in a sequence in various configurations.</span></span>

|<span data-ttu-id="e1dcb-553">測試</span><span class="sxs-lookup"><span data-stu-id="e1dcb-553">Test</span></span>|<span data-ttu-id="e1dcb-554">輸送量 (工作流程/秒)</span><span class="sxs-lookup"><span data-stu-id="e1dcb-554">Throughput (workflows/sec)</span></span>|
|----------|-----------------------------------|
|<span data-ttu-id="e1dcb-555">WF3 執行階段中的 WF3 序列</span><span class="sxs-lookup"><span data-stu-id="e1dcb-555">WF3 Sequence in WF3 runtime</span></span>|<span data-ttu-id="e1dcb-556">1,576</span><span class="sxs-lookup"><span data-stu-id="e1dcb-556">1,576</span></span>|
|<span data-ttu-id="e1dcb-557">使用 Interop 之 WF4 執行階段中的 WF3 序列</span><span class="sxs-lookup"><span data-stu-id="e1dcb-557">WF3 Sequence in WF4 runtime using Interop</span></span>|<span data-ttu-id="e1dcb-558">2,745</span><span class="sxs-lookup"><span data-stu-id="e1dcb-558">2,745</span></span>|
|<span data-ttu-id="e1dcb-559">WF4 序列</span><span class="sxs-lookup"><span data-stu-id="e1dcb-559">WF4 Sequence</span></span>|<span data-ttu-id="e1dcb-560">153,582</span><span class="sxs-lookup"><span data-stu-id="e1dcb-560">153,582</span></span>|

 <span data-ttu-id="e1dcb-561">直接透過 WF3 使用 Interop 在效能上有顯著提升。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-561">There is a notable performance increase to using Interop over straight WF3.</span></span>  <span data-ttu-id="e1dcb-562">不過，與 WF4 活動相較之下，這項提升就顯得微不足道。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-562">However, when compared against WF4 activities, the increase is negligible.</span></span>

## <a name="summary"></a><span data-ttu-id="e1dcb-563">摘要</span><span class="sxs-lookup"><span data-stu-id="e1dcb-563">Summary</span></span>
 <span data-ttu-id="e1dcb-564">WF4 中對效能的大量投資已在許多重要的方面獲得成效。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-564">Heavy investments in performance for WF4 have paid off in many crucial areas.</span></span>  <span data-ttu-id="e1dcb-565">在某些情況下，WF4 中個別工作流程元件的效能比 WF3 快上數百倍，因為 WF4 擁有較精簡的 [!INCLUDE[wf1](../../../includes/wf1-md.md)] 執行階段。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-565">Individual workflow component performance is in some cases hundreds of times faster in WF4 compared to WF3 due to a leaner [!INCLUDE[wf1](../../../includes/wf1-md.md)] runtime.</span></span>  <span data-ttu-id="e1dcb-566">延遲數據同樣大為改善。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-566">Latency numbers are significantly better as well.</span></span>  <span data-ttu-id="e1dcb-567">這表示使用的效能損失[!INCLUDE[wf1](../../../includes/wf1-md.md)]而不是手動編碼的 WCF 協調流程服務是非常小考慮使用的新增的功能[!INCLUDE[wf1](../../../includes/wf1-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-567">This means the performance penalty for using [!INCLUDE[wf1](../../../includes/wf1-md.md)] as opposed to hand-coding WCF orchestration services is very small considering the added benefits of using [!INCLUDE[wf1](../../../includes/wf1-md.md)].</span></span>  <span data-ttu-id="e1dcb-568">持續性效能已提升 2.5 至 3.0 倍。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-568">Persistence performance has increased by a factor of 2.5 - 3.0.</span></span>  <span data-ttu-id="e1dcb-569">現在透過工作流程追蹤進行健康監視的負荷已相當低。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-569">Health monitoring by means of workflow tracking now has very little overhead.</span></span>  <span data-ttu-id="e1dcb-570">若您考慮從 WF3 移至 WF4，我們提供了一套完整的移轉指南。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-570">A comprehensive set of migration guides are available for those that are considering moving from WF3 to WF4.</span></span>  <span data-ttu-id="e1dcb-571">這些都將使 WF4 成為撰寫複雜應用程式的理想選擇。</span><span class="sxs-lookup"><span data-stu-id="e1dcb-571">All of this should make WF4 an attractive option for writing complex applications.</span></span>

## <a name="acknowledgements"></a><span data-ttu-id="e1dcb-572">謝誌</span><span class="sxs-lookup"><span data-stu-id="e1dcb-572">Acknowledgements</span></span>
 <span data-ttu-id="e1dcb-573">非常感謝下列參與人員與校閱人員的大力協助：</span><span class="sxs-lookup"><span data-stu-id="e1dcb-573">Many thanks to the following contributors and reviewers for their efforts:</span></span>

-   <span data-ttu-id="e1dcb-574">Leon Welicki，Microsoft Corporation</span><span class="sxs-lookup"><span data-stu-id="e1dcb-574">Leon Welicki, Microsoft Corporation</span></span>

-   <span data-ttu-id="e1dcb-575">Ryszard Kwiecinski，Microsoft Corporation</span><span class="sxs-lookup"><span data-stu-id="e1dcb-575">Ryszard Kwiecinski, Microsoft Corporation</span></span>

-   <span data-ttu-id="e1dcb-576">Emil Velinov，Microsoft Corporation</span><span class="sxs-lookup"><span data-stu-id="e1dcb-576">Emil Velinov, Microsoft Corporation</span></span>

-   <span data-ttu-id="e1dcb-577">Nate Talbert，Microsoft Corporation</span><span class="sxs-lookup"><span data-stu-id="e1dcb-577">Nate Talbert, Microsoft Corporation</span></span>

-   <span data-ttu-id="e1dcb-578">Bob Schmidt，Microsoft Corporation</span><span class="sxs-lookup"><span data-stu-id="e1dcb-578">Bob Schmidt, Microsoft Corporation</span></span>

-   <span data-ttu-id="e1dcb-579">Stefan Batres，Microsoft Corporation</span><span class="sxs-lookup"><span data-stu-id="e1dcb-579">Stefan Batres, Microsoft Corporation</span></span>
