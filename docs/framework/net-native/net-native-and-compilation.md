---
title: .NET 原生和編譯
ms.date: 03/30/2017
ms.assetid: e38ae4f3-3e3d-42c3-a4b8-db1aa9d84f85
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 1a15d30ea4d6e0f4456460248e96428419117d85
ms.sourcegitcommit: 289e06e904b72f34ac717dbcc5074239b977e707
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/17/2019
ms.locfileid: "71049431"
---
# <a name="net-native-and-compilation"></a><span data-ttu-id="f0e13-102">.NET 原生和編譯</span><span class="sxs-lookup"><span data-stu-id="f0e13-102">.NET Native and Compilation</span></span>

<span data-ttu-id="f0e13-103">以 .NET Framework 為目標的 Windows 8.1 應用程式及 Windows 桌面應用程式，會以特定的程式設計語言撰寫，並會編譯成中繼語言 (IL)。</span><span class="sxs-lookup"><span data-stu-id="f0e13-103">Windows 8.1 applications and Windows Desktop applications that target the.NET Framework are written in a particular programming language and compiled into intermediate language (IL).</span></span> <span data-ttu-id="f0e13-104">在執行階段，Just-In-Time (JIT) 編譯器在第一次執行方法之前，才會負責編譯 IL 為本機電腦的原生程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-104">At runtime, a just-in-time (JIT) compiler is responsible for compiling the IL into native code for the local machine just before a method is executed for the first time.</span></span> <span data-ttu-id="f0e13-105">相較之下，.NET 原生工具鏈會在編譯時期轉換原始碼為原生程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-105">In contrast, the .NET Native tool chain converts source code to native code at compile time.</span></span> <span data-ttu-id="f0e13-106">本主題比較 .NET 原生與其他適用於 .NET Framework 應用程式的編譯技術，並提供 .NET 原生如何產生原生程式碼的實用概觀，可協助您了解為什麼在以 .NET 原生編譯的程式碼中發生的例外狀況不會發生在 JIT 編譯程式碼中。</span><span class="sxs-lookup"><span data-stu-id="f0e13-106">This topic compares .NET Native with other compilation technologies available for .NET Framework apps, and also provides a practical overview of how .NET Native produces native code that can help you understand why exceptions that occur in code compiled with .NET Native do not occur in JIT-compiled code.</span></span>

## <a name="net-native-generating-native-binaries"></a><span data-ttu-id="f0e13-107">.NET Native：產生原生二進位檔</span><span class="sxs-lookup"><span data-stu-id="f0e13-107">.NET Native: Generating native binaries</span></span>

<span data-ttu-id="f0e13-108">目標為 .NET Framework 且不使用 .NET 原生工具鏈編譯的應用程式，可由您的應用程式組件組成，其中包含下列項目：</span><span class="sxs-lookup"><span data-stu-id="f0e13-108">An application that targets the .NET Framework and that is not compiled by using the .NET Native tool chain consists of your application assembly, which includes the following:</span></span>

- <span data-ttu-id="f0e13-109">描述組件、其相依性、包含的類型和其成員的[中繼資料](../../standard/metadata-and-self-describing-components.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e13-109">[Metadata](../../standard/metadata-and-self-describing-components.md) that describes the assembly, its dependencies, the types it contains, and their members.</span></span> <span data-ttu-id="f0e13-110">中繼資料用於反映和晚期繫結存取，以及在某些情況下也由編譯器及建置工具所使用。</span><span class="sxs-lookup"><span data-stu-id="f0e13-110">The metadata is used for reflection and late-bound access, and in some cases by compiler and build tools as well.</span></span>

- <span data-ttu-id="f0e13-111">實作程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-111">Implementation code.</span></span> <span data-ttu-id="f0e13-112">這包含中繼語言 (IL) Opcode。</span><span class="sxs-lookup"><span data-stu-id="f0e13-112">This consists of intermediate language (IL) opcodes.</span></span> <span data-ttu-id="f0e13-113">在執行階段，Just-In-Time (JIT) 編譯器將其轉譯成目標平台的原生程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-113">At runtime, the just-in-time (JIT) compiler translates it into native code for the target platform.</span></span>

 <span data-ttu-id="f0e13-114">除了主要應用程式組件，應用程式會要求下列項目必須存在：</span><span class="sxs-lookup"><span data-stu-id="f0e13-114">In addition to your main application assembly, an app requires that the following be present:</span></span>

- <span data-ttu-id="f0e13-115">任何您應用程式所需的其他類別庫或協力廠商組件。</span><span class="sxs-lookup"><span data-stu-id="f0e13-115">Any additional class libraries or third-party assemblies that are required by your app.</span></span> <span data-ttu-id="f0e13-116">這些組件同樣包含描述組件、類型及成員的中繼資料，以及實作所有類型成員的 IL。</span><span class="sxs-lookup"><span data-stu-id="f0e13-116">These assemblies similarly include metadata that describes the assembly, its types, and their members, as well as the IL that implements all type members.</span></span>

- <span data-ttu-id="f0e13-117">.NET Framework 類別庫</span><span class="sxs-lookup"><span data-stu-id="f0e13-117">The .NET Framework Class Library.</span></span> <span data-ttu-id="f0e13-118">這是在安裝 .NET Framework 時安裝在本機系統的組件集合。</span><span class="sxs-lookup"><span data-stu-id="f0e13-118">This is a collection of assemblies that is installed on the local system with the .NET Framework installation.</span></span> <span data-ttu-id="f0e13-119">包含在 .NET Framework 類別庫中的組件含有一組完整的中繼資料和實作的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-119">The assemblies included in the .NET Framework Class Library include a complete set of metadata and implementation code.</span></span>

- <span data-ttu-id="f0e13-120">Common Language Runtime。</span><span class="sxs-lookup"><span data-stu-id="f0e13-120">The common language runtime.</span></span> <span data-ttu-id="f0e13-121">這是做為組件載入的動態連結程式庫集合，會執行這類服務如：記憶體管理和記憶體回收、例外狀況處理、Just-In-Time 編譯、遠端處理和 Interop。</span><span class="sxs-lookup"><span data-stu-id="f0e13-121">This is a collection of dynamic link libraries that perform such services as assembly loading, memory management and garbage collection, exception handling, just-in-time compilation, remoting, and interop.</span></span> <span data-ttu-id="f0e13-122">就像類別庫，執行階段會安裝在本機系統上，做為安裝 .NET Framework 的一部分。</span><span class="sxs-lookup"><span data-stu-id="f0e13-122">Like the class library, the runtime is installed on the local system as part of the .NET Framework installation.</span></span>

<span data-ttu-id="f0e13-123">請注意必須有整個 Common Language Runtime 以及應用程式特有的組件、協力廠商組件和系統組件中所有類型的中繼資料和 IL，才能讓應用程式順利執行。</span><span class="sxs-lookup"><span data-stu-id="f0e13-123">Note that the entire common language runtime, as well as metadata and IL for all types in application-specific assemblies, third-party assemblies, and system assemblies must be present for the app to execute successfully.</span></span>

## <a name="net-native-and-just-in-time-compilation"></a><span data-ttu-id="f0e13-124">.NET 原生和 Just-In-Time 編譯</span><span class="sxs-lookup"><span data-stu-id="f0e13-124">.NET Native and just-in-time compilation</span></span>

<span data-ttu-id="f0e13-125">.NET 原生工具鏈的輸入，是 C# 或 Visual Basic 編譯器所建置的 Windows 市集應用程式。</span><span class="sxs-lookup"><span data-stu-id="f0e13-125">The input for the .NET Native tool chain is the Windows store app built by the C# or Visual Basic compiler.</span></span> <span data-ttu-id="f0e13-126">換句話說，當語言編譯器完成 Windows 市集應用程式的編譯時，.NET Native 工具鏈就會開始執行。</span><span class="sxs-lookup"><span data-stu-id="f0e13-126">In other words, the .NET Native tool chain begins execution when the language compiler has finished compilation of a Windows Store app.</span></span>

> [!TIP]
> <span data-ttu-id="f0e13-127">因為 .NET Native 的輸入是寫入至 Managed 組件中的 IL 和中繼資料，您仍然可以使用建置前或建置後事件，或修改 MSBuild 專案檔，來執行自訂程式碼產生或其他自訂作業。</span><span class="sxs-lookup"><span data-stu-id="f0e13-127">Because the input to .NET Native is the IL and metadata written to managed assemblies, you can still perform custom code generation or other custom operations by using pre-build or post-build events or by modifying the MSBuild project file.</span></span>
>
> <span data-ttu-id="f0e13-128">不過，不支援會修改 IL，並藉此防止 .NET 工具鏈分析應用程式 IL 的類別。</span><span class="sxs-lookup"><span data-stu-id="f0e13-128">However, categories of tools that modify IL and thereby prevent the .NET tool chain from analyzing an app's IL are not supported.</span></span> <span data-ttu-id="f0e13-129">模糊化是這種類型最值得注意的工具。</span><span class="sxs-lookup"><span data-stu-id="f0e13-129">Obfuscators are the most notable tools of this type.</span></span>

<span data-ttu-id="f0e13-130">在應用程式從 IL 轉換成原生程式碼的過程中，.NET Native 工具鏈會執行如下所示的作業：</span><span class="sxs-lookup"><span data-stu-id="f0e13-130">In the course of converting an app from IL to native code, the .NET Native tool chain performs operations like the following:</span></span>

- <span data-ttu-id="f0e13-131">對於某些程式碼路徑，它會取代依賴反映和中繼資料的程式碼為靜態機器碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-131">For certain code paths, it replaces code that relies on reflection and metadata with static native code.</span></span> <span data-ttu-id="f0e13-132">例如，如果實值類型不覆寫 <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> 方法，則測試是否相等的預設測試會使用反映來擷取 <xref:System.Reflection.FieldInfo> 物件，此物件表示值類型的欄位，然後會比較兩個執行個體的欄位值。</span><span class="sxs-lookup"><span data-stu-id="f0e13-132">For example, if a value type does not override the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method, the default test for equality uses reflection to retrieve <xref:System.Reflection.FieldInfo> objects that represent the value type's fields, then compares the field values of two instances.</span></span> <span data-ttu-id="f0e13-133">當編譯為機器碼時，.NET Native 工具鏈會取代反映程式碼和中繼資料為欄位值的靜態比較。</span><span class="sxs-lookup"><span data-stu-id="f0e13-133">When compiling to native code, the .NET Native tool chain replaces the reflection code and metadata with a static comparison of the field values.</span></span>

- <span data-ttu-id="f0e13-134">如果可行的話，它會嘗試排除所有中繼資料。</span><span class="sxs-lookup"><span data-stu-id="f0e13-134">Where possible, it attempts to eliminate all metadata.</span></span>

- <span data-ttu-id="f0e13-135">在最終的應用程式組件中只包含應用程式所實際叫用的實作程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-135">It includes in the final app assemblies only the implementation code that is actually invoked by the app.</span></span> <span data-ttu-id="f0e13-136">這尤其會影響協力廠商程式庫和 .NET Framework 類別庫中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-136">This particularly affects code in third-party libraries and in the .NET Framework Class Library.</span></span> <span data-ttu-id="f0e13-137">如此一來，應用程式不再依賴協力廠商程式庫或完整 .NET Framework 類別庫；相反地，現在協力廠商和 .NET Framework 類別庫中的程式碼對於應用程式而言是本機的。</span><span class="sxs-lookup"><span data-stu-id="f0e13-137">As a result, an application no longer depends on either third-party libraries or the full .NET Framework Class Library; instead, code in third-party and .NET Framework class libraries is now local to the app.</span></span>

- <span data-ttu-id="f0e13-138">它會取代完整的 CLR 為重構的執行階段，主要包含記憶體回收行程。</span><span class="sxs-lookup"><span data-stu-id="f0e13-138">It replaces the full CLR with a refactored runtime that primarily contains the garbage collector.</span></span> <span data-ttu-id="f0e13-139">重構的執行階段會在名為 mrt100_app.dll 的程式庫中找到，對於應用程式而言是本機的，而且也只有數百 KB 大小。</span><span class="sxs-lookup"><span data-stu-id="f0e13-139">The refactored runtime is found in a library named mrt100_app.dll that is local to the app and is only a few hundred kilobytes in size.</span></span> <span data-ttu-id="f0e13-140">這可能是因為靜態連結不需要許多由 Common Language Runtime 所執行的服務。</span><span class="sxs-lookup"><span data-stu-id="f0e13-140">This is possible because static linking eliminates the need for many of the services performed by the common language runtime.</span></span>

  > [!NOTE]
  > <span data-ttu-id="f0e13-141">.NET 原生使用相同的記憶體回收行程，如同標準的 Common Language Runtime 。</span><span class="sxs-lookup"><span data-stu-id="f0e13-141">.NET Native uses the same garbage collector as the standard common language runtime.</span></span> <span data-ttu-id="f0e13-142">在 .NET 原生記憶體回收行程中，預設會啟用背景記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="f0e13-142">In the .NET Native garbage collector, background garbage collection is enabled by default.</span></span> <span data-ttu-id="f0e13-143">如需記憶體回收的詳細資訊，請參閱[記憶體回收的基本概念](../../standard/garbage-collection/fundamentals.md)。</span><span class="sxs-lookup"><span data-stu-id="f0e13-143">For more information about garbage collection, see [Fundamentals of Garbage Collection](../../standard/garbage-collection/fundamentals.md).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f0e13-144">.NET 原生會編譯整個應用程式為原生應用程式。</span><span class="sxs-lookup"><span data-stu-id="f0e13-144">.NET Native compiles an entire application to a native application.</span></span> <span data-ttu-id="f0e13-145">它不允許您編譯包含類別程式庫的單一組件為原生程式碼，如此一來才可單獨從 Managed 程式碼中呼叫它。</span><span class="sxs-lookup"><span data-stu-id="f0e13-145">It does not allow you to compile a single assembly that contains a class library to native code so that it can be called independently from managed code.</span></span>

<span data-ttu-id="f0e13-146">由 .NET 原生工具鏈所產生的應用程式會寫入名為 ilc.out 的目錄，位於您專案目錄的偵錯或發行目錄中。</span><span class="sxs-lookup"><span data-stu-id="f0e13-146">The resulting app that is produced by the .NET Native tool chain is written to a directory named ilc.out in the Debug or Release directory of your project directory.</span></span> <span data-ttu-id="f0e13-147">它包含下列檔案：</span><span class="sxs-lookup"><span data-stu-id="f0e13-147">It consists of the following files:</span></span>

- <span data-ttu-id="f0e13-148">*\<appName>* .exe 是虛設常式可執行檔，只會將控制項傳輸至 *\<appName>* .dll 中的特殊 `Main` 匯出。</span><span class="sxs-lookup"><span data-stu-id="f0e13-148">*\<appName>*.exe, a stub executable that simply transfers control to a special `Main` export in *\<appName>*.dll.</span></span>

- <span data-ttu-id="f0e13-149">*\<appName>* .dll 為 Windows 動態連結程式庫，其中包含您應用程式的程式碼，以及來自 .NET Framework Class Library 的程式碼，和任何有相依性的協力廠商程式庫的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-149">*\<appName>*.dll, a Windows dynamic link library that contains all your application code, as well as code from the .NET Framework Class Library and any third-party libraries that you have a dependency on.</span></span>  <span data-ttu-id="f0e13-150">它也包含支援程式碼，例如應用程式中與 Windows 交互操作及序列化物件所必需的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-150">It also contains support code, such as the code necessary to interoperate with Windows and to serialize objects in your app.</span></span>

- <span data-ttu-id="f0e13-151">mrt100_app.dll 為重構的執行階段，會提供執行階段服務，例如記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="f0e13-151">mrt100_app.dll, a refactored runtime that provides runtime services such as garbage collection.</span></span>

 <span data-ttu-id="f0e13-152">應用程式的 APPX 資訊清單會擷取所有相依性。</span><span class="sxs-lookup"><span data-stu-id="f0e13-152">All dependencies are captured by the app's APPX manifest.</span></span>  <span data-ttu-id="f0e13-153">除了直接組合在 appx 封裝中的應用程式 exe、dll 和 mrt100_app.dll 之外，這還包含另外兩個檔案：</span><span class="sxs-lookup"><span data-stu-id="f0e13-153">In addition to the application exe, dll, and mrt100_app.dll, which are bundled directly in the appx package, this includes two more files:</span></span>

- <span data-ttu-id="f0e13-154">msvcr140_app.dll，其為 mrt100_app.dll 所使用的 C 執行階段 (CRT) 程式庫。</span><span class="sxs-lookup"><span data-stu-id="f0e13-154">msvcr140_app.dll, the C run-time (CRT) library used by mrt100_app.dll.</span></span> <span data-ttu-id="f0e13-155">它會包含在封裝中的 Framework 參考。</span><span class="sxs-lookup"><span data-stu-id="f0e13-155">It is included by a framework reference in the package.</span></span>

- <span data-ttu-id="f0e13-156">mrt100.dll。</span><span class="sxs-lookup"><span data-stu-id="f0e13-156">mrt100.dll.</span></span> <span data-ttu-id="f0e13-157">此程式庫包含可改善 mrt100_app.dll 效能的函式，儘管沒有它也不會造成 mrt100_app.dll 無法正常運作。</span><span class="sxs-lookup"><span data-stu-id="f0e13-157">This library includes functions that can improve the performance of mrt100_app.dll, although its absence does not prevent mrt100_app.dll from functioning.</span></span> <span data-ttu-id="f0e13-158">如果有的話，會從本機電腦的 System32 目錄載入它。</span><span class="sxs-lookup"><span data-stu-id="f0e13-158">It is loaded from the system32 directory on the local machine, if it is present.</span></span>

<span data-ttu-id="f0e13-159">因為 .NET Native 工具鏈只會在當它知道您的應用程式會實際叫用該程式碼時才會連結實作程式碼到應用程式中，所以下列案例所需的中繼資料或實作程式碼可能未必包含於您的應用程式中：</span><span class="sxs-lookup"><span data-stu-id="f0e13-159">Because the .NET Native tool chain links implementation code into your app only if it knows that your app actually invokes that code, either the metadata or the implementation code required in the following scenarios may not be included with your app:</span></span>

- <span data-ttu-id="f0e13-160">反映。</span><span class="sxs-lookup"><span data-stu-id="f0e13-160">Reflection.</span></span>

- <span data-ttu-id="f0e13-161">動態或晚期繫結引動過程。</span><span class="sxs-lookup"><span data-stu-id="f0e13-161">Dynamic or late-bound invocation.</span></span>

- <span data-ttu-id="f0e13-162">序列化與還原序列化。</span><span class="sxs-lookup"><span data-stu-id="f0e13-162">Serialization and deserialization.</span></span>

- <span data-ttu-id="f0e13-163">COM Interop。</span><span class="sxs-lookup"><span data-stu-id="f0e13-163">COM interop.</span></span>

<span data-ttu-id="f0e13-164">如果在執行階段沒有必要的中繼資料或實作程式碼，則 .NET Native 執行階段會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f0e13-164">If the necessary metadata or implementation code is absent at runtime, the .NET Native runtime throws an exception.</span></span> <span data-ttu-id="f0e13-165">您可以防止這些例外狀況發生，並確認 .NET Native 工具鏈中包含必要的中繼資料和實作程式碼，這可藉由使用[執行階段指示詞檔案](runtime-directives-rd-xml-configuration-file-reference.md)達成，此為指定程式項目的 XML 檔案，其中繼資料或實作程式碼必須是在執行階段可用的，且指派執行階段原則給程式項目。</span><span class="sxs-lookup"><span data-stu-id="f0e13-165">You can prevent these exceptions, and ensure that the .NET Native tool chain includes the required metadata and implementation code, by using a [runtime directives file](runtime-directives-rd-xml-configuration-file-reference.md), an XML file that designates the program elements whose metadata or implementation code must be available at runtime and assigns a runtime policy to them.</span></span> <span data-ttu-id="f0e13-166">以下是加入由 .NET 原生工具鏈所編譯的 Windows 市集專案之預設執行階段指示詞檔案：</span><span class="sxs-lookup"><span data-stu-id="f0e13-166">The following is the default runtime directives file that is added to a Windows Store project that is compiled by the .NET Native tool chain:</span></span>

```xml
<Directives xmlns="http://schemas.microsoft.com/netfx/2013/01/metadata">
  <Application>
    <Assembly Name="*Application*" Dynamic="Required All" />
  </Application>
</Directives>
```

<span data-ttu-id="f0e13-167">這會在應用程式封裝中的所有組件裡啟用所有類型及其所有成員，供反映和動態引動過程之用。</span><span class="sxs-lookup"><span data-stu-id="f0e13-167">This enables all the types, as well as all their members, in all the assemblies in your app package for reflection and dynamic invocation.</span></span> <span data-ttu-id="f0e13-168">不過，它不會啟用 .NET Framework 類別庫組件中類型的反映或動態啟動。</span><span class="sxs-lookup"><span data-stu-id="f0e13-168">However, it does not enable reflection or dynamic activation of types in .NET Framework Class Library assemblies.</span></span> <span data-ttu-id="f0e13-169">在許多情況下，這樣已足夠。</span><span class="sxs-lookup"><span data-stu-id="f0e13-169">In many cases, this is adequate.</span></span>

## <a name="net-native-and-ngen"></a><span data-ttu-id="f0e13-170">.NET 原生和 NGEN</span><span class="sxs-lookup"><span data-stu-id="f0e13-170">.NET Native and NGEN</span></span>

<span data-ttu-id="f0e13-171">[原生映像產生器](../tools/ngen-exe-native-image-generator.md) (NGEN) 會將組件編譯成機器碼，並在本機電腦的原生映像快取中安裝它們。</span><span class="sxs-lookup"><span data-stu-id="f0e13-171">The [(Native Image Generator](../tools/ngen-exe-native-image-generator.md) (NGEN) compiles assemblies to native code and installs them in the native image cache on the local computer.</span></span> <span data-ttu-id="f0e13-172">不過，儘管 NGEN 如同 .NET 原生會產生機器碼，仍有幾個不同於 .NET 原生的顯著區別：</span><span class="sxs-lookup"><span data-stu-id="f0e13-172">However, although NGEN, like .NET Native, produces native code, it differs from .NET Native in some significant ways:</span></span>

- <span data-ttu-id="f0e13-173">如果沒有原生映像能用於特定的方法，NGEN 會轉而使用 JIT 編譯的程式碼。</span><span class="sxs-lookup"><span data-stu-id="f0e13-173">If no native image is available for a particular method, NGEN falls back to JITing code.</span></span> <span data-ttu-id="f0e13-174">這表示在 NGEN 需要轉而使用 JIT 編譯的情況下，原生映像必須繼續包含中繼資料和 IL。</span><span class="sxs-lookup"><span data-stu-id="f0e13-174">This means that native images must continue to include metadata and IL in the event that NGEN needs to fall back to JIT compilation.</span></span> <span data-ttu-id="f0e13-175">相反地，.NET 原生只會產生原生映像，並不會轉而產生 JIT 編譯。</span><span class="sxs-lookup"><span data-stu-id="f0e13-175">In contrast, .NET Native produces only native images and does not fall back to JIT compilation.</span></span> <span data-ttu-id="f0e13-176">如此一來，您只需保留一些反映、序列化和 Interop 案例所需的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="f0e13-176">As a result, only metadata required for some reflection, serialization, and interop scenarios must be preserved.</span></span>

- <span data-ttu-id="f0e13-177">NGEN 繼續依賴完整 Common Language Runtime 的服務，例如組件載入、遠端處理、Interop、記憶體管理、記憶體回收，若有需要的話，也依賴 JIT 編譯。</span><span class="sxs-lookup"><span data-stu-id="f0e13-177">NGEN continues to rely on the full common language runtime for services such as assembly loading, remoting, interop, memory management, garbage collection, and, if necessary, JIT compilation.</span></span> <span data-ttu-id="f0e13-178">在 .NET 原生中，這些服務有許多都不必要 (JIT 編譯) 或會在建置階段解決，並且併入應用程式組件中。</span><span class="sxs-lookup"><span data-stu-id="f0e13-178">In .NET Native, many of these services are either unnecessary (JIT compilation) or are resolved at build-time and incorporated in the app assembly.</span></span> <span data-ttu-id="f0e13-179">其中最重要的剩餘服務是記憶體回收，會包含在較小、重構的執行階段，名為 mrt100_app.dll。</span><span class="sxs-lookup"><span data-stu-id="f0e13-179">The remaining services, the most important of which is garbage collection, are included in a much smaller, refactored runtime named mrt100_app.dll.</span></span>

- <span data-ttu-id="f0e13-180">NGEN 映像通常易於損壞。</span><span class="sxs-lookup"><span data-stu-id="f0e13-180">NGEN images tend to be fragile.</span></span> <span data-ttu-id="f0e13-181">例如，修補檔案或相依性的變更通常要求使用它的組件也是由原生映像所產生的。</span><span class="sxs-lookup"><span data-stu-id="f0e13-181">For example, a patch or change to a dependency typically requires that the assemblies that use it also be re-NGENed.</span></span> <span data-ttu-id="f0e13-182">特別在 .NET Framework 類別庫中的系統組件更是如此。</span><span class="sxs-lookup"><span data-stu-id="f0e13-182">This is particularly true of system assemblies in the .NET Framework Class Library.</span></span> <span data-ttu-id="f0e13-183">相反地，.NET 原生允許獨立地服務彼此的應用程式。</span><span class="sxs-lookup"><span data-stu-id="f0e13-183">In contrast, .NET Native allows applications to be served independently of one another.</span></span>

## <a name="see-also"></a><span data-ttu-id="f0e13-184">另請參閱</span><span class="sxs-lookup"><span data-stu-id="f0e13-184">See also</span></span>

- [<span data-ttu-id="f0e13-185">中繼資料和自我描述元件</span><span class="sxs-lookup"><span data-stu-id="f0e13-185">Metadata and Self-Describing Components</span></span>](../../standard/metadata-and-self-describing-components.md)
- [<span data-ttu-id="f0e13-186">內部 .NET Native （Channel 9 影片）</span><span class="sxs-lookup"><span data-stu-id="f0e13-186">Inside .NET Native (Channel 9 Video)</span></span>](https://channel9.msdn.com/Shows/Going+Deep/Inside-NET-Native)
- [<span data-ttu-id="f0e13-187">反映和 .NET Native</span><span class="sxs-lookup"><span data-stu-id="f0e13-187">Reflection and .NET Native</span></span>](reflection-and-net-native.md)
- [<span data-ttu-id="f0e13-188">.NET Native 一般疑難排解</span><span class="sxs-lookup"><span data-stu-id="f0e13-188">.NET Native General Troubleshooting</span></span>](net-native-general-troubleshooting.md)
