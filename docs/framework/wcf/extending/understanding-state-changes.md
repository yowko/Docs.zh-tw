---
title: "了解狀態變更"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: a79ed2aa-e49a-47a8-845a-c9f436ec9987
caps.latest.revision: "13"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: ce0d3be43b8e50367d1cdd9b4e486a4154001624
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/22/2017
---
# <a name="understanding-state-changes"></a><span data-ttu-id="e102e-102">了解狀態變更</span><span class="sxs-lookup"><span data-stu-id="e102e-102">Understanding State Changes</span></span>
<span data-ttu-id="e102e-103">本主題說明通道具有的狀態和轉換、用來建構通道狀態的型別，以及如何實作。</span><span class="sxs-lookup"><span data-stu-id="e102e-103">This topic discusses the states and transitions that channels have, the types used to structure channel states, and how to implement them.</span></span>  
  
## <a name="state-machines-and-channels"></a><span data-ttu-id="e102e-104">狀態機器和通道</span><span class="sxs-lookup"><span data-stu-id="e102e-104">State Machines and Channels</span></span>  
 <span data-ttu-id="e102e-105">處理通訊的物件 (例如通訊端) 通常會呈現狀態轉換與配置網路資源、建立或接受連線、關閉連線和終止通訊等相關的狀態機器。</span><span class="sxs-lookup"><span data-stu-id="e102e-105">Objects that deal with communication, for example sockets, usually present a state machine whose state transitions relate to allocating network resources, making or accepting connections, closing connections and terminating communication.</span></span> <span data-ttu-id="e102e-106">通道狀態機器提供了通訊物件狀態的統一模型，摘要該物件的基礎實作。</span><span class="sxs-lookup"><span data-stu-id="e102e-106">The channel state machine provides a uniform model of the states of a communication object that abstracts the underlying implementation of that object.</span></span> <span data-ttu-id="e102e-107"><xref:System.ServiceModel.ICommunicationObject> 介面提供一組狀態、狀態轉換方法和狀態轉換事件。</span><span class="sxs-lookup"><span data-stu-id="e102e-107">The <xref:System.ServiceModel.ICommunicationObject> interface provides a set of states, state transition methods and state transition events.</span></span> <span data-ttu-id="e102e-108">所有通道、通道處理站和通道接聽項都會實作通道狀態機器。</span><span class="sxs-lookup"><span data-stu-id="e102e-108">All channels, channel factories and channel listeners implement the channel state machine.</span></span>  
  
 <span data-ttu-id="e102e-109">事件 Closed、Closing、Faulted、Opened 和 Opening 會在狀態轉換發生後對外部觀察器發出信號。</span><span class="sxs-lookup"><span data-stu-id="e102e-109">The events Closed, Closing, Faulted, Opened and Opening signal an external observer after a state transition occurs.</span></span>  
  
 <span data-ttu-id="e102e-110">方法 Abort、Close 和 Open (以及它們的非同步對等用法) 會造成狀態轉換。</span><span class="sxs-lookup"><span data-stu-id="e102e-110">The methods Abort, Close, and Open (and their asynchronous equivalents) cause state transitions.</span></span>  
  
 <span data-ttu-id="e102e-111">狀態屬性會傳回 <xref:System.ServiceModel.CommunicationState> 所定義的目前狀態：</span><span class="sxs-lookup"><span data-stu-id="e102e-111">The state property returns the current state as defined by <xref:System.ServiceModel.CommunicationState>:</span></span>  
  
## <a name="icommunicationobject-communicationobject-and-states-and-state-transition"></a><span data-ttu-id="e102e-112">ICommunicationObject、CommunicationObject、狀態和狀態轉換</span><span class="sxs-lookup"><span data-stu-id="e102e-112">ICommunicationObject, CommunicationObject, and States and State Transition</span></span>  
 <span data-ttu-id="e102e-113"><xref:System.ServiceModel.ICommunicationObject> 一開始處於 Created 狀態，在這個狀態下可設定各種屬性。</span><span class="sxs-lookup"><span data-stu-id="e102e-113">An <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state where its various properties can be configured.</span></span> <span data-ttu-id="e102e-114">一旦在 Opened 狀態下，物件就不能用於傳送和接收訊息，它的屬性也會被視為不變的。</span><span class="sxs-lookup"><span data-stu-id="e102e-114">Once in the Opened state, the object is usable for sending and receiving messages but its properties are considered immutable.</span></span> <span data-ttu-id="e102e-115">一旦在 Closing 狀態下，物件就無法再處理新的傳送或接收要求，但是直到 Close 逾時之前現有的要求仍有機會完成。</span><span class="sxs-lookup"><span data-stu-id="e102e-115">Once in the Closing state, the object can no longer process new send or receive requests, but existing requests have a chance to complete until the Close timeout is reached.</span></span>  <span data-ttu-id="e102e-116">如果發生無法修復的錯誤，物件會轉換為 Faulted 狀態，在這個狀態下，可檢查物件取得錯誤相關資訊，最後關閉物件。</span><span class="sxs-lookup"><span data-stu-id="e102e-116">If an unrecoverable error occurs, the object transitions to the Faulted state where it can be inspected for information about the error and ultimately closed.</span></span> <span data-ttu-id="e102e-117">在 Closed 狀態下，物件本質上已經達到狀態機器結尾。</span><span class="sxs-lookup"><span data-stu-id="e102e-117">When in the Closed state the object has essentially reached the end of the state machine.</span></span> <span data-ttu-id="e102e-118">一旦物件從某個狀態轉換為下一個狀態，就不會回到上一個狀態。</span><span class="sxs-lookup"><span data-stu-id="e102e-118">Once an object transitions from one state to the next, it does not go back to a previous state.</span></span>  
  
 <span data-ttu-id="e102e-119">下圖說明 <xref:System.ServiceModel.ICommunicationObject> 狀態和狀態轉換。</span><span class="sxs-lookup"><span data-stu-id="e102e-119">The following diagram shows the <xref:System.ServiceModel.ICommunicationObject> states and state transitions.</span></span> <span data-ttu-id="e102e-120">藉由呼叫下列三個方法其中一個，可以造成狀態轉換：Abort、Open 或 Close。</span><span class="sxs-lookup"><span data-stu-id="e102e-120">State transitions can be caused by calling one of the three methods: Abort, Open, or Close.</span></span> <span data-ttu-id="e102e-121">此外，藉由呼叫其他實作特定的方法，也可以造成狀態轉換。</span><span class="sxs-lookup"><span data-stu-id="e102e-121">They could also be caused by calling other implementation-specific methods.</span></span> <span data-ttu-id="e102e-122">當開啟通訊物件的時候或之後發生錯誤，則會轉換為 Faulted 狀態。</span><span class="sxs-lookup"><span data-stu-id="e102e-122">Transitioning to the Faulted state could happen as a result of errors while opening or after having opened the communication object.</span></span>  
  
 <span data-ttu-id="e102e-123">每個 <xref:System.ServiceModel.ICommunicationObject> 一開始都處於 Created 狀態。</span><span class="sxs-lookup"><span data-stu-id="e102e-123">Every <xref:System.ServiceModel.ICommunicationObject> starts out in the Created state.</span></span> <span data-ttu-id="e102e-124">在這個狀態下，應用程式可以設定物件屬性。</span><span class="sxs-lookup"><span data-stu-id="e102e-124">In this state, an application can configure the object by setting its properties.</span></span> <span data-ttu-id="e102e-125">一旦物件處於 Created 以外的狀態，就會被視為不變的。</span><span class="sxs-lookup"><span data-stu-id="e102e-125">Once an object is in a state other than Created, it is considered immutable.</span></span>  
  
 <span data-ttu-id="e102e-126">![通道狀態轉換](../../../../docs/framework/wcf/extending/media/channelstatetranitionshighleveldiagram.gif "ChannelStateTranitionsHighLevelDiagram")</span><span class="sxs-lookup"><span data-stu-id="e102e-126">![Channel state transitition](../../../../docs/framework/wcf/extending/media/channelstatetranitionshighleveldiagram.gif "ChannelStateTranitionsHighLevelDiagram")</span></span>  
<span data-ttu-id="e102e-127">圖 1。</span><span class="sxs-lookup"><span data-stu-id="e102e-127">Figure 1.</span></span> <span data-ttu-id="e102e-128">ICommunicationObject 狀態機器。</span><span class="sxs-lookup"><span data-stu-id="e102e-128">The ICommunicationObject State Machine.</span></span>  
  
 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]<span data-ttu-id="e102e-129"> 提供了一個名為 <xref:System.ServiceModel.Channels.CommunicationObject>，會實作 <xref:System.ServiceModel.ICommunicationObject> 和通道狀態機器的抽象基底類別。</span><span class="sxs-lookup"><span data-stu-id="e102e-129"> provides an abstract base class named <xref:System.ServiceModel.Channels.CommunicationObject> that implements <xref:System.ServiceModel.ICommunicationObject> and the channel state machine.</span></span> <span data-ttu-id="e102e-130">下圖是 <xref:System.ServiceModel.Channels.CommunicationObject> 特定的狀態修訂圖。</span><span class="sxs-lookup"><span data-stu-id="e102e-130">The following graphic is a modified state diagram that is specific to <xref:System.ServiceModel.Channels.CommunicationObject>.</span></span> <span data-ttu-id="e102e-131">除了 <xref:System.ServiceModel.ICommunicationObject> 狀態機器之外，它還說明了叫用其他 <xref:System.ServiceModel.Channels.CommunicationObject> 方法的時機。</span><span class="sxs-lookup"><span data-stu-id="e102e-131">In addition to the <xref:System.ServiceModel.ICommunicationObject> state machine, it shows the timing when additional <xref:System.ServiceModel.Channels.CommunicationObject> methods are invoked.</span></span>  
  
 <span data-ttu-id="e102e-132">![狀態變更](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure5statetransitionsdetailsc.gif "wcfc_WCFChannelsigure5StateTransitionsDetailsc")</span><span class="sxs-lookup"><span data-stu-id="e102e-132">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure5statetransitionsdetailsc.gif "wcfc_WCFChannelsigure5StateTransitionsDetailsc")</span></span>  
<span data-ttu-id="e102e-133">圖 2。</span><span class="sxs-lookup"><span data-stu-id="e102e-133">Figure 2.</span></span> <span data-ttu-id="e102e-134">CommunicationObject 狀態機器的 CommunicationObject 實作，包括呼叫事件和受保護的方法。</span><span class="sxs-lookup"><span data-stu-id="e102e-134">The CommunicationObject implementation of the ICommunicationObject state machine including calls to events and protected methods.</span></span>  
  
### <a name="icommunicationobject-events"></a><span data-ttu-id="e102e-135">ICommunicationObject 事件</span><span class="sxs-lookup"><span data-stu-id="e102e-135">ICommunicationObject Events</span></span>  
 <span data-ttu-id="e102e-136"><xref:System.ServiceModel.Channels.CommunicationObject> 會公開 <xref:System.ServiceModel.ICommunicationObject> 所定義的五個事件。</span><span class="sxs-lookup"><span data-stu-id="e102e-136"><xref:System.ServiceModel.Channels.CommunicationObject> exposes the five events defined by <xref:System.ServiceModel.ICommunicationObject>.</span></span> <span data-ttu-id="e102e-137">這些事件是為使用通訊物件以得知狀態轉換的程式碼而設計。</span><span class="sxs-lookup"><span data-stu-id="e102e-137">These events are designed for code using the communication object to be notified of state transitions.</span></span> <span data-ttu-id="e102e-138">如上面圖 2 所示，在物件狀態轉換為依事件所指名的狀態之後，每個事件都會引發一次。</span><span class="sxs-lookup"><span data-stu-id="e102e-138">As shown in Figure 2 above, each event is fired once after the object’s state transitions to the state named by the event.</span></span> <span data-ttu-id="e102e-139">所有五個事件都屬於 `EventHandler` 型別，定義為：</span><span class="sxs-lookup"><span data-stu-id="e102e-139">All five events are of the `EventHandler` type which is defined as:</span></span>  
  
 `public delegate void EventHandler(object sender, EventArgs e);`  
  
 <span data-ttu-id="e102e-140">在 <xref:System.ServiceModel.Channels.CommunicationObject> 實作中，<xref:System.ServiceModel.Channels.CommunicationObject> 本身是傳送者，或者傳入 <xref:System.ServiceModel.Channels.CommunicationObject> 建構函式當做傳送者 (如果使用該建構函式多載的話)。</span><span class="sxs-lookup"><span data-stu-id="e102e-140">In the <xref:System.ServiceModel.Channels.CommunicationObject> implementation, the sender is either the <xref:System.ServiceModel.Channels.CommunicationObject> itself or whatever was passed in as the sender to the <xref:System.ServiceModel.Channels.CommunicationObject> constructor (if that constructor overload was used).</span></span> <span data-ttu-id="e102e-141">EventArgs 參數 `e` 一定是 `EventArgs.Empty`。</span><span class="sxs-lookup"><span data-stu-id="e102e-141">The EventArgs parameter, `e`, is always `EventArgs.Empty`.</span></span>  
  
### <a name="derived-object-callbacks"></a><span data-ttu-id="e102e-142">衍生的物件回呼</span><span class="sxs-lookup"><span data-stu-id="e102e-142">Derived Object Callbacks</span></span>  
 <span data-ttu-id="e102e-143">除了五個事件之外，<xref:System.ServiceModel.Channels.CommunicationObject> 還會宣告八個受保護的虛擬方法，設計用於狀態轉換前後回呼衍生的物件。</span><span class="sxs-lookup"><span data-stu-id="e102e-143">In addition to the five events, <xref:System.ServiceModel.Channels.CommunicationObject> declares eight protected virtual methods designed to allow a derived object to be called back before and after state transitions occur.</span></span>  
  
 <span data-ttu-id="e102e-144"><xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> 方法各有三個這類的回呼。</span><span class="sxs-lookup"><span data-stu-id="e102e-144">The <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> methods have three such callbacks associated with each of them.</span></span> <span data-ttu-id="e102e-145">例如，<xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> 有對應的 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e102e-145">For example, corresponding to <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A?displayProperty=nameWithType> there is <xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e102e-146"><xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> 有相關聯的 <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="e102e-146">Associated with <xref:System.ServiceModel.Channels.CommunicationObject.Close%2A?displayProperty=nameWithType> are the <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="e102e-147">同樣的，<xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> 方法也有對應的 <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e102e-147">Similarly, the <xref:System.ServiceModel.Channels.CommunicationObject.Abort%2A?displayProperty=nameWithType> method has a corresponding <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e102e-148">雖然 <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> 沒有預設實作，但其他回呼仍有狀態機器正確性需要的預設實作。</span><span class="sxs-lookup"><span data-stu-id="e102e-148">While <xref:System.ServiceModel.Channels.CommunicationObject.OnOpen%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClose%2A?displayProperty=nameWithType>, and <xref:System.ServiceModel.Channels.CommunicationObject.OnAbort%2A?displayProperty=nameWithType> have no default implementation, the other callbacks do have a default implementation which is necessary for state machine correctness.</span></span> <span data-ttu-id="e102e-149">如果您要覆寫這些方法，請務必呼叫基底實作或正確地將它取代。</span><span class="sxs-lookup"><span data-stu-id="e102e-149">If you override those methods be sure to call the base implementation or correctly replace it.</span></span>  
  
 <span data-ttu-id="e102e-150"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> 會引發對應的 <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>、<xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="e102e-150"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpening%2A?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.OnClosing%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnFaulted%2A?displayProperty=nameWithType> fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opening?displayProperty=nameWithType>, <xref:System.ServiceModel.Channels.CommunicationObject.Closing?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Faulted?displayProperty=nameWithType> events.</span></span> <span data-ttu-id="e102e-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> 會將物件狀態分別設定為 Opened 和 Closed，然後引發對應的 <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> 和 <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> 事件。</span><span class="sxs-lookup"><span data-stu-id="e102e-151"><xref:System.ServiceModel.Channels.CommunicationObject.OnOpened%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.OnClosed%2A?displayProperty=nameWithType> set the object state to Opened and Closed respectively then fire the corresponding <xref:System.ServiceModel.Channels.CommunicationObject.Opened?displayProperty=nameWithType> and <xref:System.ServiceModel.Channels.CommunicationObject.Closed?displayProperty=nameWithType> events.</span></span>  
  
### <a name="state-transition-methods"></a><span data-ttu-id="e102e-152">狀態轉換方法</span><span class="sxs-lookup"><span data-stu-id="e102e-152">State Transition Methods</span></span>  
 <span data-ttu-id="e102e-153"><xref:System.ServiceModel.Channels.CommunicationObject> 提供了 Abort、Close 和 Open 實作。</span><span class="sxs-lookup"><span data-stu-id="e102e-153"><xref:System.ServiceModel.Channels.CommunicationObject> provides implementations of Abort, Close and Open.</span></span> <span data-ttu-id="e102e-154">此外，還提供 Fault 方法，會將狀態轉換為 Faulted 狀態。</span><span class="sxs-lookup"><span data-stu-id="e102e-154">It also provides a Fault method which causes a state transition to the Faulted state.</span></span> <span data-ttu-id="e102e-155">圖 2 說明 <xref:System.ServiceModel.ICommunicationObject> 狀態機器，其中每個轉換都由造成轉換的方法所標記 (在造成上一個已標記轉換的方法實作內部，會發生未標記的轉換)。</span><span class="sxs-lookup"><span data-stu-id="e102e-155">Figure 2 shows the <xref:System.ServiceModel.ICommunicationObject> state machine with each transition labeled by the method that causes it (unlabeled transitions happen inside the implementation of the method that caused the last labeled transition).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e102e-156"><xref:System.ServiceModel.Channels.CommunicationObject> 所有的通訊狀態取得/設定實作，都是執行緒同步。</span><span class="sxs-lookup"><span data-stu-id="e102e-156">All <xref:System.ServiceModel.Channels.CommunicationObject> implementations of communication state gets/sets are thread-synchronized.</span></span>  
  
 <span data-ttu-id="e102e-157">建構函式</span><span class="sxs-lookup"><span data-stu-id="e102e-157">Constructor</span></span>  
  
 <span data-ttu-id="e102e-158"><xref:System.ServiceModel.Channels.CommunicationObject> 提供了三個都會將物件置於 Created 狀態的建構函式。</span><span class="sxs-lookup"><span data-stu-id="e102e-158"><xref:System.ServiceModel.Channels.CommunicationObject> provides three constructors, all of which leave the object in the Created state.</span></span> <span data-ttu-id="e102e-159">這些建構函式定義為：</span><span class="sxs-lookup"><span data-stu-id="e102e-159">The constructors are defined as:</span></span>  
  
 <span data-ttu-id="e102e-160">第一個是預設建構函式，會委派至接受物件的建構函式多載：</span><span class="sxs-lookup"><span data-stu-id="e102e-160">The first constructor is a default constructor that delegates to the constructor overload that takes an object:</span></span>  
  
 `protected CommunicationObject() : this(new object()) { … }`  
  
 <span data-ttu-id="e102e-161">在同步存取通訊物件狀態時，接受物件的建構函式會將該參數做為要鎖定的物件：</span><span class="sxs-lookup"><span data-stu-id="e102e-161">The constructor that takes an object uses that parameter as the object to be locked when synchronizing access to communication object state:</span></span>  
  
 `protected CommunicationObject(object mutex) { … }`  
  
 <span data-ttu-id="e102e-162">最後，當引發 <xref:System.ServiceModel.ICommunicationObject> 事件時，第三個建構函式會接受其他參數做為傳送者引數。</span><span class="sxs-lookup"><span data-stu-id="e102e-162">Finally, a third constructor takes an additional parameter that is used as the sender argument when <xref:System.ServiceModel.ICommunicationObject> events are fired.</span></span>  
  
 `protected CommunicationObject(object mutex, object eventSender) { … }`  
  
 <span data-ttu-id="e102e-163">前兩個建構函式會設定此傳送者。</span><span class="sxs-lookup"><span data-stu-id="e102e-163">The previous two constructors set the sender to this.</span></span>  
  
 <span data-ttu-id="e102e-164">Open 方法</span><span class="sxs-lookup"><span data-stu-id="e102e-164">Open Method</span></span>  
  
 <span data-ttu-id="e102e-165">前置條件：狀態為 Created。</span><span class="sxs-lookup"><span data-stu-id="e102e-165">Precondition: State is Created.</span></span>  
  
 <span data-ttu-id="e102e-166">後置條件：狀態為 Opened 或 Faulted。</span><span class="sxs-lookup"><span data-stu-id="e102e-166">Post-condition: State is Opened or Faulted.</span></span> <span data-ttu-id="e102e-167">可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-167">May throw an exception.</span></span>  
  
 <span data-ttu-id="e102e-168">Open() 方法會嘗試開啟通訊物件，並將狀態設定為 Opened。</span><span class="sxs-lookup"><span data-stu-id="e102e-168">The Open() method will try to open the communication object and set the state to Opened.</span></span> <span data-ttu-id="e102e-169">如果發生錯誤，則會將狀態設定為 Faulted。</span><span class="sxs-lookup"><span data-stu-id="e102e-169">If it encounters an error, it will set the state to Faulted.</span></span>  
  
 <span data-ttu-id="e102e-170">此方法會先檢查目前狀態是否為 Created。</span><span class="sxs-lookup"><span data-stu-id="e102e-170">The method first checks that the current state is Created.</span></span> <span data-ttu-id="e102e-171">如果目前狀態為 Opening 或 Opened，則會擲回 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="e102e-171">If the current state is Opening or Opened it throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="e102e-172">如果目前狀態為 Closing 或 Closed，且物件已終止，則會擲回 <xref:System.ServiceModel.CommunicationObjectAbortedException>，否則會擲回 <xref:System.ObjectDisposedException>。</span><span class="sxs-lookup"><span data-stu-id="e102e-172">If the current state is Closing or Closed, it throws a <xref:System.ServiceModel.CommunicationObjectAbortedException> if the object has been terminated and <xref:System.ObjectDisposedException> otherwise.</span></span> <span data-ttu-id="e102e-173">如果目前狀態為 Faulted，則會擲回 <xref:System.ServiceModel.CommunicationObjectFaultedException>。</span><span class="sxs-lookup"><span data-stu-id="e102e-173">If the current state is Faulted, it throws a <xref:System.ServiceModel.CommunicationObjectFaultedException>.</span></span>  
  
 <span data-ttu-id="e102e-174">然後，將狀態設定為 Opening，並依序呼叫 OnOpening() (這會引發 Opening 事件)、OnOpen() 和 OnOpened()。</span><span class="sxs-lookup"><span data-stu-id="e102e-174">It then sets the state to Opening and calls OnOpening() (which raises the Opening event), OnOpen() and OnOpened() in that order.</span></span> <span data-ttu-id="e102e-175">OnOpened() 會將狀態設定為 Opened，並且引發 Opened 事件。</span><span class="sxs-lookup"><span data-stu-id="e102e-175">OnOpened() sets the state to Opened and raises the Opened event.</span></span> <span data-ttu-id="e102e-176">如果任何這些呼叫擲回例外狀況，則 Open() 會呼叫 Fault()，並且將例外狀況反昇。</span><span class="sxs-lookup"><span data-stu-id="e102e-176">If any of these throws an exception, Open()calls Fault() and lets the exception bubble up.</span></span> <span data-ttu-id="e102e-177">下圖詳細說明 Open 處理序。</span><span class="sxs-lookup"><span data-stu-id="e102e-177">The following diagram shows the Open process in more detail.</span></span>  
  
 <span data-ttu-id="e102e-178">![狀態變更](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigurecoopenflowchartf.gif "wcfc_WCFChannelsigureCOOpenFlowChartf")</span><span class="sxs-lookup"><span data-stu-id="e102e-178">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigurecoopenflowchartf.gif "wcfc_WCFChannelsigureCOOpenFlowChartf")</span></span>  
<span data-ttu-id="e102e-179">覆寫 OnOpen 方法以實作自訂開啟邏輯，例如開啟內部通訊物件。</span><span class="sxs-lookup"><span data-stu-id="e102e-179">Override the OnOpen method to implement custom open logic such as opening an inner communication object.</span></span>  
  
 <span data-ttu-id="e102e-180">Close 方法</span><span class="sxs-lookup"><span data-stu-id="e102e-180">Close Method</span></span>  
  
 <span data-ttu-id="e102e-181">前置條件：無。</span><span class="sxs-lookup"><span data-stu-id="e102e-181">Precondition: None.</span></span>  
  
 <span data-ttu-id="e102e-182">後置條件：狀態為 Closed。</span><span class="sxs-lookup"><span data-stu-id="e102e-182">Post-condition: State is Closed.</span></span> <span data-ttu-id="e102e-183">可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-183">May throw an exception.</span></span>  
  
 <span data-ttu-id="e102e-184">在任何狀態下，都可以呼叫 Close() 方法。</span><span class="sxs-lookup"><span data-stu-id="e102e-184">The Close() method can be called at any state.</span></span> <span data-ttu-id="e102e-185">這個方法會嘗試依正常程序關閉物件。</span><span class="sxs-lookup"><span data-stu-id="e102e-185">It tries to close the object normally.</span></span> <span data-ttu-id="e102e-186">如果發生錯誤，則會終止物件。</span><span class="sxs-lookup"><span data-stu-id="e102e-186">If an error is encountered, it terminates the object.</span></span> <span data-ttu-id="e102e-187">如果目前狀態為 Closing 或 Closed，這個方法不會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="e102e-187">The method does nothing if the current state is Closing or Closed.</span></span> <span data-ttu-id="e102e-188">否則，會將狀態設定為 Closing。</span><span class="sxs-lookup"><span data-stu-id="e102e-188">Otherwise it sets the state to Closing.</span></span> <span data-ttu-id="e102e-189">如果原始狀態為 Created、Opening 或 Faulted，則會呼叫 Abort() (請參閱下圖)。</span><span class="sxs-lookup"><span data-stu-id="e102e-189">If the original state was Created, Opening or Faulted, it calls Abort() (see the following diagram).</span></span> <span data-ttu-id="e102e-190">如果原始狀態為 Opened，則會依序呼叫 OnClosing() (這會引發 Closing 事件)、OnClose() 和 OnClosed()。</span><span class="sxs-lookup"><span data-stu-id="e102e-190">If the original state was Opened, it calls OnClosing() (which raises the Closing event), OnClose() and OnClosed() in that order.</span></span> <span data-ttu-id="e102e-191">如果任何這些呼叫擲回例外狀況，則 Close() 會呼叫 Abort()，並且將例外狀況反昇。</span><span class="sxs-lookup"><span data-stu-id="e102e-191">If any of these throws an exception, Close()calls Abort() and lets the exception bubble up.</span></span> <span data-ttu-id="e102e-192">OnClosed() 會將狀態設定為 Closed，並且引發 Closed 事件。</span><span class="sxs-lookup"><span data-stu-id="e102e-192">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="e102e-193">下圖詳細說明 Close 處理序。</span><span class="sxs-lookup"><span data-stu-id="e102e-193">The following diagram shows the Close process in more detail.</span></span>  
  
 <span data-ttu-id="e102e-194">![狀態變更](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsguire7ico-closeflowchartc.gif "wcfc_WCFChannelsguire7ICO CloseFlowChartc")</span><span class="sxs-lookup"><span data-stu-id="e102e-194">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsguire7ico-closeflowchartc.gif "wcfc_WCFChannelsguire7ICO-CloseFlowChartc")</span></span>  
<span data-ttu-id="e102e-195">覆寫 OnClose 方法以實作自訂關閉邏輯，例如關閉內部通訊物件。</span><span class="sxs-lookup"><span data-stu-id="e102e-195">Override the OnClose method to implement custom close logic, such as closing an inner communication object.</span></span> <span data-ttu-id="e102e-196">因為 OnClose() 接受逾時參數，而且不是做為 Abort() 的一部分呼叫，所有長時間封鎖 (例如等待另一端回應) 的依正常程序關閉邏輯都應該在 OnClose() 之中實作。</span><span class="sxs-lookup"><span data-stu-id="e102e-196">All graceful closing logic that may block for a long time (for example, waiting for the other side to respond) should be implemented in OnClose() because it takes a timeout parameter and because it is not called as part of Abort().</span></span>  
  
 <span data-ttu-id="e102e-197">Abort</span><span class="sxs-lookup"><span data-stu-id="e102e-197">Abort</span></span>  
  
 <span data-ttu-id="e102e-198">前置條件：無。</span><span class="sxs-lookup"><span data-stu-id="e102e-198">Precondition: None.</span></span>  
<span data-ttu-id="e102e-199">後置條件：狀態為 Closed。</span><span class="sxs-lookup"><span data-stu-id="e102e-199">Post-condition: State is Closed.</span></span> <span data-ttu-id="e102e-200">可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-200">May throw an exception.</span></span>  
  
 <span data-ttu-id="e102e-201">如果目前狀態為 Closed，或者物件已經終止 (例如，可能藉由在另一個執行緒上執行 Abort())，則 Abort() 方法不會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="e102e-201">The Abort() method does nothing if the current state is Closed or if the object has been terminated before (for example, possibly by having Abort() executing on another thread).</span></span> <span data-ttu-id="e102e-202">否則，方法會將狀態設定為 Closing，並且依序呼叫 OnClosing() (這會引發 Closing 事件)、OnAbort() 和 OnClosed() (不會呼叫 OnClose，因為物件正在終止，而未關閉)。</span><span class="sxs-lookup"><span data-stu-id="e102e-202">Otherwise it sets the state to Closing and calls OnClosing() (which raises the Closing event), OnAbort(), and OnClosed() in that order (does not call OnClose because the object is being terminated, not closed).</span></span> <span data-ttu-id="e102e-203">OnClosed() 會將狀態設定為 Closed，並且引發 Closed 事件。</span><span class="sxs-lookup"><span data-stu-id="e102e-203">OnClosed() sets the state to Closed and raises the Closed event.</span></span> <span data-ttu-id="e102e-204">如果任何這些呼叫擲回例外狀況，則會將例外狀況重新擲回至 Abort 的呼叫者。</span><span class="sxs-lookup"><span data-stu-id="e102e-204">If any of these throw an exception, it is re-thrown to the caller of Abort.</span></span> <span data-ttu-id="e102e-205">OnClosing()、OnClosed() 和 OnAbort() 實作不應封鎖 (例如，於輸入/輸出時)。</span><span class="sxs-lookup"><span data-stu-id="e102e-205">Implementations of OnClosing(), OnClosed() and OnAbort() should not block (for example, on input/output).</span></span> <span data-ttu-id="e102e-206">下圖詳細說明 Abort 處理序。</span><span class="sxs-lookup"><span data-stu-id="e102e-206">The following diagram shows the Abort process in more detail.</span></span>  
  
 <span data-ttu-id="e102e-207">![狀態變更](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure8ico-abortflowchartc.gif "wcfc_WCFChannelsigure8ICO AbortFlowChartc")</span><span class="sxs-lookup"><span data-stu-id="e102e-207">![State changes](../../../../docs/framework/wcf/extending/media/wcfc-wcfchannelsigure8ico-abortflowchartc.gif "wcfc_WCFChannelsigure8ICO-AbortFlowChartc")</span></span>  
<span data-ttu-id="e102e-208">覆寫 OnAbort 方法以實作自訂終止邏輯，例如終止內部通訊物件。</span><span class="sxs-lookup"><span data-stu-id="e102e-208">Override the OnAbort method to implement custom terminate logic such as terminating an inner communication object.</span></span>  
  
 <span data-ttu-id="e102e-209">Fault</span><span class="sxs-lookup"><span data-stu-id="e102e-209">Fault</span></span>  
  
 <span data-ttu-id="e102e-210">Fault 方法是 <xref:System.ServiceModel.Channels.CommunicationObject> 特有的，不是 <xref:System.ServiceModel.ICommunicationObject> 介面的一部分。</span><span class="sxs-lookup"><span data-stu-id="e102e-210">The Fault method is specific to <xref:System.ServiceModel.Channels.CommunicationObject> and is not part of the <xref:System.ServiceModel.ICommunicationObject> interface.</span></span> <span data-ttu-id="e102e-211">為求完整性，將它一併併入。</span><span class="sxs-lookup"><span data-stu-id="e102e-211">It is included here for completeness.</span></span>  
  
 <span data-ttu-id="e102e-212">前置條件：無。</span><span class="sxs-lookup"><span data-stu-id="e102e-212">Precondition: None.</span></span>  
  
 <span data-ttu-id="e102e-213">後置條件：狀態為 Faulted。</span><span class="sxs-lookup"><span data-stu-id="e102e-213">Post-condition: State is Faulted.</span></span> <span data-ttu-id="e102e-214">可能會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-214">May throw an exception.</span></span>  
  
 <span data-ttu-id="e102e-215">如果目前狀態為 Faulted 或 Closed，Fault() 方法不會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="e102e-215">The Fault() method does nothing if the current state is Faulted or Closed.</span></span> <span data-ttu-id="e102e-216">否則，會將狀態設定為 Faulted 並呼叫 OnFaulted()，而引發 Faulted 事件。</span><span class="sxs-lookup"><span data-stu-id="e102e-216">Otherwise it sets the state to Faulted and call OnFaulted(), which raises the Faulted event.</span></span> <span data-ttu-id="e102e-217">如果 OnFaulted 擲回例外狀況，則會重新擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-217">If OnFaulted throws an exception it is re-thrown.</span></span>  
  
### <a name="throwifxxx-methods"></a><span data-ttu-id="e102e-218">ThrowIfXxx 方法</span><span class="sxs-lookup"><span data-stu-id="e102e-218">ThrowIfXxx Methods</span></span>  
 <span data-ttu-id="e102e-219">CommunicationObject 有三個受保護的方法，當物件處於特定狀態時，可用來擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-219">CommunicationObject has three protected methods that can be used to throw exceptions if the object is in a specific state.</span></span>  
  
 <span data-ttu-id="e102e-220">如果狀態為 Closing、Closed 或 Faulted，<xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-220"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposed%2A> throws an exception if the state is Closing, Closed or Faulted.</span></span>  
  
 <span data-ttu-id="e102e-221">如果狀態不是 Created，<xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-221"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrImmutable%2A> throws an exception if the state is not Created.</span></span>  
  
 <span data-ttu-id="e102e-222">如果狀態不是 Opened，<xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="e102e-222"><xref:System.ServiceModel.Channels.CommunicationObject.ThrowIfDisposedOrNotOpen%2A> throws an exception if the state is not Opened.</span></span>  
  
 <span data-ttu-id="e102e-223">擲回的例外狀況取決於狀態。</span><span class="sxs-lookup"><span data-stu-id="e102e-223">The exceptions thrown depend on the state.</span></span> <span data-ttu-id="e102e-224">下表說明不同狀態，以及在狀態下藉由呼叫 ThrowIfXxx 擲回的對應例外狀況型別。</span><span class="sxs-lookup"><span data-stu-id="e102e-224">The following table shows the different states and the corresponding exception type thrown by calling a ThrowIfXxx that throws on that state.</span></span>  
  
|<span data-ttu-id="e102e-225">狀況</span><span class="sxs-lookup"><span data-stu-id="e102e-225">State</span></span>|<span data-ttu-id="e102e-226">是否已呼叫 Abort？</span><span class="sxs-lookup"><span data-stu-id="e102e-226">Has Abort been called?</span></span>|<span data-ttu-id="e102e-227">例外</span><span class="sxs-lookup"><span data-stu-id="e102e-227">Exception</span></span>|  
|-----------|----------------------------|---------------|  
|<span data-ttu-id="e102e-228">建立時間</span><span class="sxs-lookup"><span data-stu-id="e102e-228">Created</span></span>|<span data-ttu-id="e102e-229">N/A</span><span class="sxs-lookup"><span data-stu-id="e102e-229">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="e102e-230">正在開啟</span><span class="sxs-lookup"><span data-stu-id="e102e-230">Opening</span></span>|<span data-ttu-id="e102e-231">N/A</span><span class="sxs-lookup"><span data-stu-id="e102e-231">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="e102e-232">Opened</span><span class="sxs-lookup"><span data-stu-id="e102e-232">Opened</span></span>|<span data-ttu-id="e102e-233">N/A</span><span class="sxs-lookup"><span data-stu-id="e102e-233">N/A</span></span>|<xref:System.InvalidOperationException?displayProperty=nameWithType>|  
|<span data-ttu-id="e102e-234">Closing</span><span class="sxs-lookup"><span data-stu-id="e102e-234">Closing</span></span>|<span data-ttu-id="e102e-235">[是]</span><span class="sxs-lookup"><span data-stu-id="e102e-235">Yes</span></span>|<xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>|  
|<span data-ttu-id="e102e-236">Closing</span><span class="sxs-lookup"><span data-stu-id="e102e-236">Closing</span></span>|<span data-ttu-id="e102e-237">否</span><span class="sxs-lookup"><span data-stu-id="e102e-237">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="e102e-238">Closed</span><span class="sxs-lookup"><span data-stu-id="e102e-238">Closed</span></span>|<span data-ttu-id="e102e-239">[是]</span><span class="sxs-lookup"><span data-stu-id="e102e-239">Yes</span></span>|<span data-ttu-id="e102e-240">在先前明確呼叫 Abort 而關閉物件的情況下，為 <xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e102e-240"><xref:System.ServiceModel.CommunicationObjectAbortedException?displayProperty=nameWithType> in the case that an object was closed by a previous and explicit call of Abort.</span></span> <span data-ttu-id="e102e-241">如果在此物件上呼叫 Close，則會擲回 <xref:System.ObjectDisposedException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="e102e-241">If you call Close on the object then an <xref:System.ObjectDisposedException?displayProperty=nameWithType> is thrown.</span></span>|  
|<span data-ttu-id="e102e-242">Closed</span><span class="sxs-lookup"><span data-stu-id="e102e-242">Closed</span></span>|<span data-ttu-id="e102e-243">否</span><span class="sxs-lookup"><span data-stu-id="e102e-243">No</span></span>|<xref:System.ObjectDisposedException?displayProperty=nameWithType>|  
|<span data-ttu-id="e102e-244">Faulted</span><span class="sxs-lookup"><span data-stu-id="e102e-244">Faulted</span></span>|<span data-ttu-id="e102e-245">N/A</span><span class="sxs-lookup"><span data-stu-id="e102e-245">N/A</span></span>|<xref:System.ServiceModel.CommunicationObjectFaultedException?displayProperty=nameWithType>|  
  
### <a name="timeouts"></a><span data-ttu-id="e102e-246">逾時</span><span class="sxs-lookup"><span data-stu-id="e102e-246">Timeouts</span></span>  
 <span data-ttu-id="e102e-247">我們所討論的數個方法會接受逾時參數，</span><span class="sxs-lookup"><span data-stu-id="e102e-247">Several of the methods we discussed take timeout parameters.</span></span> <span data-ttu-id="e102e-248">包括 Close、Open (某些多載和非同步版本)、OnClose 和 OnOpen。</span><span class="sxs-lookup"><span data-stu-id="e102e-248">These are Close, Open (certain overloads and asynchronous versions), OnClose and OnOpen.</span></span> <span data-ttu-id="e102e-249">這些方法的設計考慮到漫長作業 (例如，於輸入/輸出時封鎖，同時依正常程序關閉連線)，因此逾時參數會表示中斷前這類作業所需的時間。</span><span class="sxs-lookup"><span data-stu-id="e102e-249">These methods are designed to allow for lengthy operations (for example, blocking on input/output while gracefully closing down a connection) so the timeout parameter indicates how long such operations can take before being interrupted.</span></span> <span data-ttu-id="e102e-250">任何這些方法的實作都應該使用提供的逾時值，以確保在逾時前傳回至呼叫者。</span><span class="sxs-lookup"><span data-stu-id="e102e-250">Implementations of any of these methods should use the supplied timeout value to ensure it returns to the caller within that timeout.</span></span> <span data-ttu-id="e102e-251">不接受逾時的其他方法實作，不是為漫長作業而設計，且不應於輸入/輸出時封鎖。</span><span class="sxs-lookup"><span data-stu-id="e102e-251">Implementations of other methods that do not take a timeout are not designed for lengthy operations and should not block on input/output.</span></span>  
  
 <span data-ttu-id="e102e-252">但是 Open() 和 Close() 多載例外，這些方法多載不會接受逾時，</span><span class="sxs-lookup"><span data-stu-id="e102e-252">The exception are the Open() and Close() overloads that do not take a timeout.</span></span> <span data-ttu-id="e102e-253">而是使用衍生類別所提供的預設逾時值。</span><span class="sxs-lookup"><span data-stu-id="e102e-253">These use a default timeout value supplied by the derived class.</span></span> <span data-ttu-id="e102e-254"><xref:System.ServiceModel.Channels.CommunicationObject> 會公開兩個名為 <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> 和 <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> 的受保護抽象屬性，其定義為：</span><span class="sxs-lookup"><span data-stu-id="e102e-254"><xref:System.ServiceModel.Channels.CommunicationObject> exposes two protected abstract properties named <xref:System.ServiceModel.Channels.CommunicationObject.DefaultCloseTimeout%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.DefaultOpenTimeout%2A> defined as:</span></span>  
  
 `protected abstract TimeSpan DefaultCloseTimeout { get; }`  
  
 `protected abstract TimeSpan DefaultOpenTimeout { get; }`  
  
 <span data-ttu-id="e102e-255">衍生類別會實作這些屬性，為不接受逾時值的 Open() 和 Close() 多載提供預設逾時。</span><span class="sxs-lookup"><span data-stu-id="e102e-255">A derived class implements these properties to provide the default timeout for the Open() and Close() overloads that do not take a timeout value.</span></span> <span data-ttu-id="e102e-256">然後，Open() 和 Close() 實作會委派至接受逾時的多載，以傳遞預設逾時值，例如：</span><span class="sxs-lookup"><span data-stu-id="e102e-256">Then the Open() and Close() implementations delegate to the overload that takes a timeout passing it the default timeout value, for example:</span></span>  
  
 `public void Open()`  
  
 `{`  
  
 `this.Open(this.DefaultOpenTimeout);`  
  
 `}`  
  
#### <a name="idefaultcommunicationtimeouts"></a><span data-ttu-id="e102e-257">IDefaultCommunicationTimeouts</span><span class="sxs-lookup"><span data-stu-id="e102e-257">IDefaultCommunicationTimeouts</span></span>  
 <span data-ttu-id="e102e-258">這個介面有四個唯讀屬性，為 Open、Send、Receive 和 Close 提供預設逾時值。</span><span class="sxs-lookup"><span data-stu-id="e102e-258">This interface has four read-only properties for providing default timeout values for open, send, receive, and close.</span></span> <span data-ttu-id="e102e-259">每個實作都負責以適當方式取得預設值。</span><span class="sxs-lookup"><span data-stu-id="e102e-259">Each implementation is responsible for obtaining the default values in whatever manner appropriate.</span></span> <span data-ttu-id="e102e-260">為提供便利，<xref:System.ServiceModel.Channels.ChannelFactoryBase> 和 <xref:System.ServiceModel.Channels.ChannelListenerBase> 會將這些值都預設為 1 分鐘。</span><span class="sxs-lookup"><span data-stu-id="e102e-260">As a convenience, <xref:System.ServiceModel.Channels.ChannelFactoryBase> and <xref:System.ServiceModel.Channels.ChannelListenerBase> default these values to 1 minute each.</span></span>
