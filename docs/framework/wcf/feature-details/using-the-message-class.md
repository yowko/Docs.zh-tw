---
title: 使用 Message 類別
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: d1d62bfb-2aa3-4170-b6f8-c93d3afdbbed
ms.openlocfilehash: 0ff65d9173838a8eb8850253e62d822f06942f26
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
ms.locfileid: "33508978"
---
# <a name="using-the-message-class"></a><span data-ttu-id="047df-102">使用 Message 類別</span><span class="sxs-lookup"><span data-stu-id="047df-102">Using the Message Class</span></span>
<span data-ttu-id="047df-103"><xref:System.ServiceModel.Channels.Message>類別是 Windows Communication Foundation (WCF) 的基礎。</span><span class="sxs-lookup"><span data-stu-id="047df-103">The <xref:System.ServiceModel.Channels.Message> class is fundamental to Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="047df-104">用戶端和服務之間的通訊，最終結果都是要傳送和接收 <xref:System.ServiceModel.Channels.Message> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="047df-104">All communication between clients and services ultimately results in <xref:System.ServiceModel.Channels.Message> instances being sent and received.</span></span>  
  
 <span data-ttu-id="047df-105">您通常不會直接和 <xref:System.ServiceModel.Channels.Message> 類別進行互動。</span><span class="sxs-lookup"><span data-stu-id="047df-105">You would not usually interact with the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="047df-106">相反地，WCF 服務模型建構，例如資料合約、 訊息合約和作業合約，可用來描述傳入和傳出訊息。</span><span class="sxs-lookup"><span data-stu-id="047df-106">Instead, WCF service model constructs, such as data contracts, message contracts, and operation contracts, are used to describe incoming and outgoing messages.</span></span> <span data-ttu-id="047df-107">不過，在某些進階案例中，您可以直接使用 <xref:System.ServiceModel.Channels.Message> 類別來設計程式。</span><span class="sxs-lookup"><span data-stu-id="047df-107">However, in some advanced scenarios you can program using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="047df-108">例如，您可能想要使用 <xref:System.ServiceModel.Channels.Message> 類別：</span><span class="sxs-lookup"><span data-stu-id="047df-108">For example, you might want to use the <xref:System.ServiceModel.Channels.Message> class:</span></span>  
  
-   <span data-ttu-id="047df-109">當您需要其他建立傳出訊息內容的方法 (例如，直接從磁碟上的檔案建立訊息)，而非序列化 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 物件時。</span><span class="sxs-lookup"><span data-stu-id="047df-109">When you need an alternative way of creating outgoing message contents (for example, creating a message directly from a file on disk) instead of serializing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects.</span></span>  
  
-   <span data-ttu-id="047df-110">當您需要其他使用傳入訊息內容的方法 (例如，要將 XSLT 轉換套用至未經處理的 XML 內容)，而非還原序列化至 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 物件。</span><span class="sxs-lookup"><span data-stu-id="047df-110">When you need an alternative way of using incoming message contents (for example, when you want to apply an XSLT transformation to the raw XML contents) instead of deserializing into [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] objects.</span></span>  
  
-   <span data-ttu-id="047df-111">當您需要以一般方法處理訊息，而不管訊息內容時 (例如，當建置路由器、負載平衡器或發行/訂閱系統遞送或轉寄訊息時)。</span><span class="sxs-lookup"><span data-stu-id="047df-111">When you need to deal with messages in a general way regardless of message contents (for example, when routing or forwarding messages when building a router, load-balancer, or a publish-subscribe system).</span></span>  
  
 <span data-ttu-id="047df-112">使用之前<xref:System.ServiceModel.Channels.Message>類別，讓自己熟悉如何使用中的 WCF 資料傳輸架構[資料傳輸架構概觀](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="047df-112">Before using the <xref:System.ServiceModel.Channels.Message> class, familiarize yourself with the WCF data transfer architecture in [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).</span></span>  
  
 <span data-ttu-id="047df-113"><xref:System.ServiceModel.Channels.Message> 是資料的一般用途容器，但是其設計則緊密遵循 SOAP 通訊協定中的訊息設計。</span><span class="sxs-lookup"><span data-stu-id="047df-113">A <xref:System.ServiceModel.Channels.Message> is a general-purpose container for data, but its design closely follows the design of a message in the SOAP protocol.</span></span> <span data-ttu-id="047df-114">就和在 SOAP 中一樣，訊息同時具有訊息本文和標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-114">Just like in SOAP, a message has both a message body and headers.</span></span> <span data-ttu-id="047df-115">訊息本文中包含實際的承載資料，而標頭則包含其他具名的資料容器。</span><span class="sxs-lookup"><span data-stu-id="047df-115">The message body contains the actual payload data, while the headers contain additional named data containers.</span></span> <span data-ttu-id="047df-116">讀取及撰寫本文和標頭的規則不太一樣，例如，標頭一定會在記憶體中緩衝處理並且可不限次數以任何順序存取，而本文可能只讀取一次，並可能進行資料流處理。</span><span class="sxs-lookup"><span data-stu-id="047df-116">The rules for reading and writing the body and the headers are different, for example, the headers are always buffered in memory and may be accessed in any order any number of times, while the body may be read only once and may be streamed.</span></span> <span data-ttu-id="047df-117">一般來說，使用 SOAP 時，訊息本文會對映至 SOAP 本文，而訊息標頭則對映至 SOAP 標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-117">Normally, when using SOAP, the message body is mapped to the SOAP body and the message headers are mapped to the SOAP headers.</span></span>  
  
## <a name="using-the-message-class-in-operations"></a><span data-ttu-id="047df-118">在作業中使用 Message 類別</span><span class="sxs-lookup"><span data-stu-id="047df-118">Using the Message Class in Operations</span></span>  
 <span data-ttu-id="047df-119">您可以使用 <xref:System.ServiceModel.Channels.Message> 類別做為作業的輸入參數、作業的傳回值或同時使用以上兩者。</span><span class="sxs-lookup"><span data-stu-id="047df-119">You can use the <xref:System.ServiceModel.Channels.Message> class as an input parameter of an operation, the return value of an operation, or both.</span></span> <span data-ttu-id="047df-120">如果在作業的任意處使用 <xref:System.ServiceModel.Channels.Message>，則會套用下列限制：</span><span class="sxs-lookup"><span data-stu-id="047df-120">If <xref:System.ServiceModel.Channels.Message> is used anywhere in an operation, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="047df-121">作業不可具有任何 `out` 或 `ref` 參數。</span><span class="sxs-lookup"><span data-stu-id="047df-121">The operation cannot have any `out` or `ref` parameters.</span></span>  
  
-   <span data-ttu-id="047df-122">不可有一個以上的 `input` 參數。</span><span class="sxs-lookup"><span data-stu-id="047df-122">There cannot be more than one `input` parameter.</span></span> <span data-ttu-id="047df-123">如果出現參數，這個參數必須為 Message 或是訊息合約類型。</span><span class="sxs-lookup"><span data-stu-id="047df-123">If the parameter is present, it must be either Message or a message contract type.</span></span>  
  
-   <span data-ttu-id="047df-124">傳回類型必須為 `void`、`Message` 或訊息合約類型。</span><span class="sxs-lookup"><span data-stu-id="047df-124">The return type must be either `void`, `Message`, or a message contract type.</span></span>  
  
 <span data-ttu-id="047df-125">下列程式碼範例包含了有效的作業合約。</span><span class="sxs-lookup"><span data-stu-id="047df-125">The following code example contains a valid operation contract.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#1)]
 [!code-vb[C_UsingTheMessageClass#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#1)]  
  
## <a name="creating-basic-messages"></a><span data-ttu-id="047df-126">建立基本訊息</span><span class="sxs-lookup"><span data-stu-id="047df-126">Creating Basic Messages</span></span>  
 <span data-ttu-id="047df-127"><xref:System.ServiceModel.Channels.Message> 類別會提供可用來建立基本訊息的靜態 `CreateMessage` 處理站方法。</span><span class="sxs-lookup"><span data-stu-id="047df-127">The <xref:System.ServiceModel.Channels.Message> class provides static `CreateMessage` factory methods that you can use to create basic messages.</span></span>  
  
 <span data-ttu-id="047df-128">所有 `CreateMessage` 多載都會採用型別為 <xref:System.ServiceModel.Channels.MessageVersion> 的版本參數，這表示要用於訊息的 SOAP 和 WS-Addressing 版本。</span><span class="sxs-lookup"><span data-stu-id="047df-128">All `CreateMessage` overloads take a version parameter of type <xref:System.ServiceModel.Channels.MessageVersion> that indicates the SOAP and WS-Addressing versions to use for the message.</span></span> <span data-ttu-id="047df-129">如果您要使用與傳入訊息相同的通訊協定版本，則可以使用 <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> 執行個體上從 <xref:System.ServiceModel.OperationContext> 屬性取得的 <xref:System.ServiceModel.OperationContext.Current%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="047df-129">If you want to use the same protocol versions as the incoming message, you can use the <xref:System.ServiceModel.OperationContext.IncomingMessageVersion%2A> property on the <xref:System.ServiceModel.OperationContext> instance obtained from the <xref:System.ServiceModel.OperationContext.Current%2A> property.</span></span> <span data-ttu-id="047df-130">大多數 `CreateMessage` 多載也會有字串參數，可指出要用於訊息的 SOAP 動作。</span><span class="sxs-lookup"><span data-stu-id="047df-130">Most `CreateMessage` overloads also have a string parameter that indicates the SOAP action to use for the message.</span></span> <span data-ttu-id="047df-131">您可以將版本設定為 `None`，即可停用 SOAP 封套產生作業；這則訊息只會包含本文。</span><span class="sxs-lookup"><span data-stu-id="047df-131">Version can be set to `None` to disable SOAP envelope generation; the message consists of only the body.</span></span>  
  
## <a name="creating-messages-from-objects"></a><span data-ttu-id="047df-132">從物件建立訊息</span><span class="sxs-lookup"><span data-stu-id="047df-132">Creating Messages from Objects</span></span>  
 <span data-ttu-id="047df-133">僅採用一個版本和動作、最基本的 `CreateMessage` 多載，會建立帶有空本文的訊息。</span><span class="sxs-lookup"><span data-stu-id="047df-133">The most basic `CreateMessage` overload that takes only a version and an action creates a message with an empty body.</span></span> <span data-ttu-id="047df-134">其他多載則會採用額外的 <xref:System.Object> 參數；這樣會建立本文是所提供之物件的序列化表示之訊息。</span><span class="sxs-lookup"><span data-stu-id="047df-134">Another overload takes an additional <xref:System.Object> parameter; this creates a message whose body is the serialized representation of the given object.</span></span> <span data-ttu-id="047df-135">使用 <xref:System.Runtime.Serialization.DataContractSerializer> 的預設值來進行序列化。</span><span class="sxs-lookup"><span data-stu-id="047df-135">Use the <xref:System.Runtime.Serialization.DataContractSerializer> with default settings for serialization.</span></span> <span data-ttu-id="047df-136">如果您要使用不同的序列化程式，或者要以不同的方式設定 `DataContractSerializer`，請使用也會採用 `CreateMessage` 參數的 `XmlObjectSerializer` 多載。</span><span class="sxs-lookup"><span data-stu-id="047df-136">If you want to use a different serializer, or you want the `DataContractSerializer` configured differently, use the `CreateMessage` overload that also takes an `XmlObjectSerializer` parameter.</span></span>  
  
 <span data-ttu-id="047df-137">例如，若要傳回訊息中的物件，您可以使用下列程式碼。</span><span class="sxs-lookup"><span data-stu-id="047df-137">For example, to return an object in a message, you can use the following code.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#2)]
 [!code-vb[C_UsingTheMessageClass#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#2)]  
  
## <a name="creating-messages-from-xml-readers"></a><span data-ttu-id="047df-138">從 XML 讀取器建立訊息</span><span class="sxs-lookup"><span data-stu-id="047df-138">Creating Messages from XML Readers</span></span>  
 <span data-ttu-id="047df-139">`CreateMessage` 多載會對本文採用 <xref:System.Xml.XmlReader> 或 <xref:System.Xml.XmlDictionaryReader>，而不是採用物件。</span><span class="sxs-lookup"><span data-stu-id="047df-139">There are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> for the body instead of an object.</span></span> <span data-ttu-id="047df-140">在這個情況下，訊息的本文會包含讀取自所傳遞 XML 讀取器時所產生的 XML。</span><span class="sxs-lookup"><span data-stu-id="047df-140">In this case, the body of the message contains the XML that results from reading from the passed XML reader.</span></span> <span data-ttu-id="047df-141">例如，下列程式碼傳回的訊息，其本文內容便是從 XML 檔案讀取而來。</span><span class="sxs-lookup"><span data-stu-id="047df-141">For example, the following code returns a message with body contents read from an XML file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#3)]
 [!code-vb[C_UsingTheMessageClass#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#3)]  
  
 <span data-ttu-id="047df-142">此外，有一些 `CreateMessage` 多載會採用 <xref:System.Xml.XmlReader> 或 <xref:System.Xml.XmlDictionaryReader>，用以表示整個訊息而不單單是本文而已。</span><span class="sxs-lookup"><span data-stu-id="047df-142">Additionally, there are `CreateMessage` overloads that take an <xref:System.Xml.XmlReader> or an <xref:System.Xml.XmlDictionaryReader> that represents the entire message and not just the body.</span></span> <span data-ttu-id="047df-143">這些多載也會採用整數 `maxSizeOfHeaders` 參數。</span><span class="sxs-lookup"><span data-stu-id="047df-143">These overloads also take an integer `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="047df-144">只要一建立訊息時，標頭一定會在記憶體中進行緩衝處理，而這個參數會限制所進行的緩衝數量。</span><span class="sxs-lookup"><span data-stu-id="047df-144">Headers are always buffered into memory as soon as the message is created, and this parameter limits the amount of buffering that takes place.</span></span> <span data-ttu-id="047df-145">如果 XML 是來自不受信任的來源，則將此參數設定為安全的值以降低阻絕服務攻擊的可能性則相當重要。</span><span class="sxs-lookup"><span data-stu-id="047df-145">It is important to set this parameter to a safe value if the XML is coming from an untrusted source to mitigate the possibility of a denial of service attack.</span></span> <span data-ttu-id="047df-146">XML 讀取器所表示之訊息的 SOAP 和 WS-Addressing 版本必須符合使用版本參數所指出的版本。</span><span class="sxs-lookup"><span data-stu-id="047df-146">The SOAP and WS-Addressing versions of the message the XML reader represents must match the versions indicated using the version parameter.</span></span>  
  
## <a name="creating-messages-with-bodywriter"></a><span data-ttu-id="047df-147">使用 BodyWriter 建立訊息</span><span class="sxs-lookup"><span data-stu-id="047df-147">Creating Messages with BodyWriter</span></span>  
 <span data-ttu-id="047df-148">一個 `CreateMessage` 多載會採用 `BodyWriter` 執行個體以描述訊息的本文。</span><span class="sxs-lookup"><span data-stu-id="047df-148">One `CreateMessage` overload takes a `BodyWriter` instance to describe the body of the message.</span></span> <span data-ttu-id="047df-149">`BodyWriter` 是一種抽象類別 (Abstract Class)，衍生之後可以自訂建立訊息本文的方式。</span><span class="sxs-lookup"><span data-stu-id="047df-149">A `BodyWriter` is an abstract class that can be derived to customize how message bodies are created.</span></span> <span data-ttu-id="047df-150">您也可以建立自己的 `BodyWriter` 衍生類別 (Derived Class)，以自訂的方式描述訊息本文。</span><span class="sxs-lookup"><span data-stu-id="047df-150">You can create your own `BodyWriter` derived class to describe message bodies in a custom way.</span></span> <span data-ttu-id="047df-151">您必須覆寫會採用 `BodyWriter.OnWriteBodyContents` 的 <xref:System.Xml.XmlDictionaryWriter> 方法，這個方法會負責寫出本文。</span><span class="sxs-lookup"><span data-stu-id="047df-151">You must override the `BodyWriter.OnWriteBodyContents` method that takes an <xref:System.Xml.XmlDictionaryWriter>; this method is responsible for writing out the body.</span></span>  
  
 <span data-ttu-id="047df-152">本文寫入器可以經過緩衝處理或非緩衝處理 (資料流處理)。</span><span class="sxs-lookup"><span data-stu-id="047df-152">Body writers can be buffered or non-buffered (streamed).</span></span> <span data-ttu-id="047df-153">緩衝處理的本文寫入器可不限次數寫出其內容，而資料流處理的本文寫入器只能寫出內容一次。</span><span class="sxs-lookup"><span data-stu-id="047df-153">Buffered body writers can write out their contents any number of times, while streamed ones can write out their contents only once.</span></span> <span data-ttu-id="047df-154">`IsBuffered` 屬性會指出本文寫入器是否有經過緩衝處理。</span><span class="sxs-lookup"><span data-stu-id="047df-154">The `IsBuffered` property indicates whether a body writer is buffered or not.</span></span> <span data-ttu-id="047df-155">您可以呼叫受保護的 `BodyWriter` 建構函式 (Constructor) 來為本文寫入器設定此屬性，而此建構函式會採用 `isBuffered` 布林 (Boolean) 參數。</span><span class="sxs-lookup"><span data-stu-id="047df-155">You can set this for your body writer by calling the protected `BodyWriter` constructor that takes an `isBuffered` boolean parameter.</span></span> <span data-ttu-id="047df-156">本文寫入器支援從非緩衝處理的本文寫入器建立緩衝處理的本文寫入器。</span><span class="sxs-lookup"><span data-stu-id="047df-156">Body writers support creating a buffered body writer from a non-buffered body writer.</span></span> <span data-ttu-id="047df-157">您可以覆寫 `OnCreateBufferedCopy` 方法以自訂這個程序。</span><span class="sxs-lookup"><span data-stu-id="047df-157">You can override the `OnCreateBufferedCopy` method to customize this process.</span></span> <span data-ttu-id="047df-158">根據預設，將會使用包含 `OnWriteBodyContents` 所傳回之 XML 的記憶體中緩衝區。</span><span class="sxs-lookup"><span data-stu-id="047df-158">By default, an in-memory buffer that contains the XML returned by `OnWriteBodyContents` is used.</span></span> <span data-ttu-id="047df-159">`OnCreateBufferedCopy` 則會採用 `maxBufferSize` 整數參數，如果您覆寫這個方法，就不得建立大於此大小上限的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="047df-159">`OnCreateBufferedCopy` takes a `maxBufferSize` integer parameter; if you override this method, you must not create buffers larger than this maximum size.</span></span>  
  
 <span data-ttu-id="047df-160">`BodyWriter` 類別會提供 `WriteBodyContents` 和 `CreateBufferedCopy` 方法，而這些方法分別是圍繞在 `OnWriteBodyContents` 和 `OnCreateBufferedCopy` 方法的精簡型包裝函式。</span><span class="sxs-lookup"><span data-stu-id="047df-160">The `BodyWriter` class provides the `WriteBodyContents` and `CreateBufferedCopy` methods, which are essentially thin wrappers around `OnWriteBodyContents` and `OnCreateBufferedCopy` methods, respectively.</span></span> <span data-ttu-id="047df-161">這些方法會執行狀態檢查，以確定沒有多次存取非緩衝處理的本文寫入器。</span><span class="sxs-lookup"><span data-stu-id="047df-161">These methods perform state checking to ensure that a non-buffered body writer is not accessed more than once.</span></span> <span data-ttu-id="047df-162">只有在建立以 `Message` 為基礎的自訂 `BodyWriters` 衍生類別時，才會直接呼叫這些方法。</span><span class="sxs-lookup"><span data-stu-id="047df-162">These methods are called directly only when creating custom `Message` derived classes based on `BodyWriters`.</span></span>  
  
## <a name="creating-fault-messages"></a><span data-ttu-id="047df-163">建立錯誤訊息</span><span class="sxs-lookup"><span data-stu-id="047df-163">Creating Fault Messages</span></span>  
 <span data-ttu-id="047df-164">您可以使用特定 `CreateMessage` 多載來建立 SOAP 錯誤訊息。</span><span class="sxs-lookup"><span data-stu-id="047df-164">You can use certain `CreateMessage` overloads to create SOAP fault messages.</span></span> <span data-ttu-id="047df-165">其中最基本的錯誤訊息會採用描述該錯誤的 <xref:System.ServiceModel.Channels.MessageFault> 物件。</span><span class="sxs-lookup"><span data-stu-id="047df-165">The most basic of these takes a <xref:System.ServiceModel.Channels.MessageFault> object that describes the fault.</span></span> <span data-ttu-id="047df-166">也會針對便利性而提供其他多載。</span><span class="sxs-lookup"><span data-stu-id="047df-166">Other overloads are provided for convenience.</span></span> <span data-ttu-id="047df-167">第一個這樣的多載會採用 `FaultCode` 和原因字串，並透過會使用此資訊的 `MessageFault` 來建立 `MessageFault.CreateFault`。</span><span class="sxs-lookup"><span data-stu-id="047df-167">The first such overload takes a `FaultCode` and a reason string and creates a `MessageFault` using `MessageFault.CreateFault` using this information.</span></span> <span data-ttu-id="047df-168">其他多載則會採用詳細資訊物件，並將該物件、錯誤碼和原因一起傳遞至 `CreateFault`。</span><span class="sxs-lookup"><span data-stu-id="047df-168">The other overload takes a detail object and also passes it to `CreateFault` together with the fault code and the reason.</span></span> <span data-ttu-id="047df-169">例如，下列作業會傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="047df-169">For example, the following operation returns a fault.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#4)]
 [!code-vb[C_UsingTheMessageClass#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#4)]  
  
## <a name="extracting-message-body-data"></a><span data-ttu-id="047df-170">擷取訊息本文資料</span><span class="sxs-lookup"><span data-stu-id="047df-170">Extracting Message Body Data</span></span>  
 <span data-ttu-id="047df-171">`Message` 類別支援多種方法，可從其本文擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="047df-171">The `Message` class supports multiple ways of extracting information from its body.</span></span> <span data-ttu-id="047df-172">這些方法則分類為下列類別：</span><span class="sxs-lookup"><span data-stu-id="047df-172">These can be classified into the following categories:</span></span>  
  
-   <span data-ttu-id="047df-173">取得一次寫出至 XML 寫入器的訊息本文。</span><span class="sxs-lookup"><span data-stu-id="047df-173">Getting the entire message body written out at once to an XML writer.</span></span> <span data-ttu-id="047df-174">這指*撰寫郵件*。</span><span class="sxs-lookup"><span data-stu-id="047df-174">This is referred to as *writing a message*.</span></span>  
  
-   <span data-ttu-id="047df-175">取得訊息本文的 XML 讀取器。</span><span class="sxs-lookup"><span data-stu-id="047df-175">Getting an XML reader over the message body.</span></span> <span data-ttu-id="047df-176">這樣可讓您在之後有需要時，一點一點的存取訊息本文。</span><span class="sxs-lookup"><span data-stu-id="047df-176">This enables you to later access the message body piece-by-piece as required.</span></span> <span data-ttu-id="047df-177">這指*讀取訊息*。</span><span class="sxs-lookup"><span data-stu-id="047df-177">This is referred to as *reading a message*.</span></span>  
  
-   <span data-ttu-id="047df-178">整個訊息 (包含其本文) 都可複製至 <xref:System.ServiceModel.Channels.MessageBuffer> 型別的記憶體中緩衝區。</span><span class="sxs-lookup"><span data-stu-id="047df-178">The entire message, including its body, can be copied to an in-memory buffer of the <xref:System.ServiceModel.Channels.MessageBuffer> type.</span></span> <span data-ttu-id="047df-179">這指*將訊息複製*。</span><span class="sxs-lookup"><span data-stu-id="047df-179">This is referred to as *copying a message*.</span></span>  
  
 <span data-ttu-id="047df-180">不管您使用何種方式存取本文，都只能存取 `Message` 本文一次。</span><span class="sxs-lookup"><span data-stu-id="047df-180">You can access the body of a `Message` only once, regardless of how it is accessed.</span></span> <span data-ttu-id="047df-181">訊息物件中帶有 `State` 屬性，這個屬性一開始會設定為「已建立」。</span><span class="sxs-lookup"><span data-stu-id="047df-181">A message object has a `State` property, which is initially set to Created.</span></span> <span data-ttu-id="047df-182">先前的清單中所描述的三個存取方法，會分別將狀態設定為「已寫入」、「已讀取」和「已複製」。</span><span class="sxs-lookup"><span data-stu-id="047df-182">The three access methods described in the preceding list set the state to Written, Read, and Copied, respectively.</span></span> <span data-ttu-id="047df-183">此外，`Close` 方法可以在不再需要訊息本文內容時，將狀態設定為「已關閉」。</span><span class="sxs-lookup"><span data-stu-id="047df-183">Additionally, a `Close` method can set the state to Closed when the message body contents are no longer required.</span></span> <span data-ttu-id="047df-184">您只能在「已建立」狀態中存取訊息本文，而在變更狀態之後，就無法再回到「已建立」狀態。</span><span class="sxs-lookup"><span data-stu-id="047df-184">The message body can be accessed only in the Created state, and there is no way to go back to the Created state after the state has changed.</span></span>  
  
## <a name="writing-messages"></a><span data-ttu-id="047df-185">寫入訊息</span><span class="sxs-lookup"><span data-stu-id="047df-185">Writing Messages</span></span>  
 <span data-ttu-id="047df-186"><xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 方法會將所提供的 `Message` 執行個體的本文內容寫出至所提供的 XML 寫入器。</span><span class="sxs-lookup"><span data-stu-id="047df-186">The <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method writes out the body contents of a given `Message` instance to a given XML writer.</span></span> <span data-ttu-id="047df-187"><xref:System.ServiceModel.Channels.Message.WriteBody%2A> 方法會執行相同的動作，差別在於它是將本文內容放在適當的包裝函式項目中 (例如，<`soap:body`>)。</span><span class="sxs-lookup"><span data-stu-id="047df-187">The <xref:System.ServiceModel.Channels.Message.WriteBody%2A> method does the same, except that it encloses the body contents in the appropriate wrapper element (for example, <`soap:body`>).</span></span> <span data-ttu-id="047df-188">最後，<xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 會寫出整個訊息，包括包裝的 SOAP 封套和標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-188">Finally, <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> writes out the entire message, including the wrapping SOAP envelope and the headers.</span></span> <span data-ttu-id="047df-189">如果關閉 SOAP (版本為 `MessageVersion.None`)，這三個方法都會執行相同的動作：寫出訊息本文內容。</span><span class="sxs-lookup"><span data-stu-id="047df-189">If SOAP is turned off (Version is `MessageVersion.None`), all three methods do the same thing: they write out the message body contents.</span></span>  
  
 <span data-ttu-id="047df-190">例如，下列程式碼會將傳入訊息的本文寫出至檔案。</span><span class="sxs-lookup"><span data-stu-id="047df-190">For example, the following code writes out the body of an incoming message to a file.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#5)]
 [!code-vb[C_UsingTheMessageClass#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#5)]  
  
 <span data-ttu-id="047df-191">有兩個額外的 Helper 方法會寫出特定 SOAP 開始項目標記。</span><span class="sxs-lookup"><span data-stu-id="047df-191">Two additional helper methods write out certain SOAP start element tags.</span></span> <span data-ttu-id="047df-192">這些方法不會存取訊息本文，因此不會變更訊息狀態。</span><span class="sxs-lookup"><span data-stu-id="047df-192">These methods do not access the message body and so they do not change the message state.</span></span> <span data-ttu-id="047df-193">這些活動包括：</span><span class="sxs-lookup"><span data-stu-id="047df-193">These include:</span></span>  
  
-   <span data-ttu-id="047df-194"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> 會寫入開始本文項目，例如 `<soap:Body>`。</span><span class="sxs-lookup"><span data-stu-id="047df-194"><xref:System.ServiceModel.Channels.Message.WriteStartBody%2A> writes the start body element, for example, `<soap:Body>`.</span></span>  
  
-   <span data-ttu-id="047df-195"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> 會寫入開始封套項目，例如 `<soap:Envelope>`。</span><span class="sxs-lookup"><span data-stu-id="047df-195"><xref:System.ServiceModel.Channels.Message.WriteStartEnvelope%2A> writes the start envelope element, for example, `<soap:Envelope>`.</span></span>  
  
 <span data-ttu-id="047df-196">若要寫入對應的結束項目標記，請在對應的 XML 寫入器上呼叫 `WriteEndElement`。</span><span class="sxs-lookup"><span data-stu-id="047df-196">To write the corresponding end element tags, call `WriteEndElement` on the corresponding XML writer.</span></span> <span data-ttu-id="047df-197">這些方法很少被直接呼叫。</span><span class="sxs-lookup"><span data-stu-id="047df-197">These methods are rarely called directly.</span></span>  
  
## <a name="reading-messages"></a><span data-ttu-id="047df-198">讀取訊息</span><span class="sxs-lookup"><span data-stu-id="047df-198">Reading Messages</span></span>  
 <span data-ttu-id="047df-199">讀取訊息本文的主要方法為呼叫 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>。</span><span class="sxs-lookup"><span data-stu-id="047df-199">The primary way to read a message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A>.</span></span> <span data-ttu-id="047df-200">您會回到可用來讀取訊息本文的 <xref:System.Xml.XmlDictionaryReader>。</span><span class="sxs-lookup"><span data-stu-id="047df-200">You get back an <xref:System.Xml.XmlDictionaryReader> that you can use to read the message body.</span></span> <span data-ttu-id="047df-201">請注意，只要一呼叫 <xref:System.ServiceModel.Channels.Message>，<xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> 就會轉換至「已讀取」狀態，而不是在您使用傳回的 XML 讀取器時轉換。</span><span class="sxs-lookup"><span data-stu-id="047df-201">Note that the <xref:System.ServiceModel.Channels.Message> transitions to the Read state as soon as <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> is called, and not when you use the returned XML reader.</span></span>  
  
 <span data-ttu-id="047df-202"><xref:System.ServiceModel.Channels.Message.GetBody%2A> 方法也可讓您以具有型別的物件存取訊息本文。</span><span class="sxs-lookup"><span data-stu-id="047df-202">The <xref:System.ServiceModel.Channels.Message.GetBody%2A> method also enables you to access the message body as a typed object.</span></span> <span data-ttu-id="047df-203">這個方法會在內部使用 `GetReaderAtBodyContents`，因此也會將訊息狀態轉換至 <xref:System.ServiceModel.Channels.MessageState.Read> 狀態 (請參閱 <xref:System.ServiceModel.Channels.Message.State%2A> 屬性)。</span><span class="sxs-lookup"><span data-stu-id="047df-203">Internally, this method uses `GetReaderAtBodyContents`, and so it also transitions the message state to the <xref:System.ServiceModel.Channels.MessageState.Read> state (see the <xref:System.ServiceModel.Channels.Message.State%2A> property).</span></span>  
  
 <span data-ttu-id="047df-204">最佳作法是檢查 <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> 屬性，在此情況下訊息本文為空，而且 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> 會擲回 <xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="047df-204">It is good practice to check the <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property, in which case the message body is empty and <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents%2A> throws an <xref:System.InvalidOperationException>.</span></span> <span data-ttu-id="047df-205">因此，如果這是接收的訊息 (例如，回覆)，您可能也要檢查指出訊息中是否包含錯誤的 <xref:System.ServiceModel.Channels.Message.IsFault%2A>。</span><span class="sxs-lookup"><span data-stu-id="047df-205">Also, if it is a received message (for example, the reply), you may also want to check <xref:System.ServiceModel.Channels.Message.IsFault%2A>, which indicates whether the message contains a fault.</span></span>  
  
 <span data-ttu-id="047df-206"><xref:System.ServiceModel.Channels.Message.GetBody%2A> 最基本的多載會使用以預設值設定，且已停用 <xref:System.Runtime.Serialization.DataContractSerializer> 配額的 <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A>，將訊息本文還原序列化至型別的執行個體 (由泛型參數所指定)。</span><span class="sxs-lookup"><span data-stu-id="047df-206">The most basic overload of <xref:System.ServiceModel.Channels.Message.GetBody%2A> deserializes the message body into an instance of a type (indicated by the generic parameter) using a <xref:System.Runtime.Serialization.DataContractSerializer> configured with the default settings and with the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> quota disabled.</span></span> <span data-ttu-id="047df-207">如果您要使用不同的序列化引擎，或者以非預設的方法設定 `DataContractSerializer`，請使用會採用 <xref:System.ServiceModel.Channels.Message.GetBody%2A> 的 <xref:System.Runtime.Serialization.XmlObjectSerializer> 多載。</span><span class="sxs-lookup"><span data-stu-id="047df-207">If you want to use a different serialization engine, or configure the `DataContractSerializer` in a non-default way, use the <xref:System.ServiceModel.Channels.Message.GetBody%2A> overload that takes an <xref:System.Runtime.Serialization.XmlObjectSerializer>.</span></span>  
  
 <span data-ttu-id="047df-208">例如，下列程式碼會從含有序列化 `Person` 物件的訊息本文中擷取資料，並列印出人員的名稱。</span><span class="sxs-lookup"><span data-stu-id="047df-208">For example, the following code extracts data from a message body that contains a serialized `Person` object and prints out the person’s name.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#6)]
 [!code-vb[C_UsingTheMessageClass#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#6)]  
  
## <a name="copying-a-message-into-a-buffer"></a><span data-ttu-id="047df-209">將訊息複製至緩衝區</span><span class="sxs-lookup"><span data-stu-id="047df-209">Copying a Message into a Buffer</span></span>  
 <span data-ttu-id="047df-210">有時候您需要多次存取訊息本文，例如，要將相同訊息轉寄給屬於發行者/訂閱者系統一部分之多個目的端時。</span><span class="sxs-lookup"><span data-stu-id="047df-210">Sometimes it is necessary to access the message body more than once, for example, to forward the same message to multiple destinations as part of a publisher-subscriber system.</span></span> <span data-ttu-id="047df-211">在此情況下，需要在記憶體中緩衝處理整個訊息 (包括本文)。</span><span class="sxs-lookup"><span data-stu-id="047df-211">In this case, it is necessary to buffer the entire message (including the body) in memory.</span></span> <span data-ttu-id="047df-212">藉由呼叫 <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29> 即可達到此目的。</span><span class="sxs-lookup"><span data-stu-id="047df-212">You can do this by calling <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%28System.Int32%29>.</span></span> <span data-ttu-id="047df-213">這個方法會採用表示緩衝區大小上限的整數參數，而且建立不會超過此大小的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="047df-213">This method takes an integer parameter that represents the maximum buffer size, and creates a buffer not larger than this size.</span></span> <span data-ttu-id="047df-214">如果訊息是來自不受信任的來源，則將此項設為安全的值就顯得相當重要。</span><span class="sxs-lookup"><span data-stu-id="047df-214">It is important to set this to a safe value if the message is coming from an untrusted source.</span></span>  
  
 <span data-ttu-id="047df-215">緩衝區會當做 <xref:System.ServiceModel.Channels.MessageBuffer> 執行個體傳回。</span><span class="sxs-lookup"><span data-stu-id="047df-215">The buffer is returned as a <xref:System.ServiceModel.Channels.MessageBuffer> instance.</span></span> <span data-ttu-id="047df-216">有數種方法可讓您存取緩衝區中的資料。</span><span class="sxs-lookup"><span data-stu-id="047df-216">You can access data in the buffer in several ways.</span></span> <span data-ttu-id="047df-217">主要的方法為呼叫 <xref:System.ServiceModel.Channels.Message.CreateMessage%2A>，以從緩衝區中建立 `Message` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="047df-217">The primary way is to call <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> to create `Message` instances from the buffer.</span></span>  
  
 <span data-ttu-id="047df-218">另一個存取緩衝區資料的方法為實作 <xref:System.Xml.XPath.IXPathNavigable> 介面，而 <xref:System.ServiceModel.Channels.MessageBuffer> 類別會實作這個介面以直接存取基礎 XML。</span><span class="sxs-lookup"><span data-stu-id="047df-218">Another way to access the data in the buffer is to implement the <xref:System.Xml.XPath.IXPathNavigable> interface that the <xref:System.ServiceModel.Channels.MessageBuffer> class implements to access the underlying XML directly.</span></span> <span data-ttu-id="047df-219">有些 <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> 多載可讓您建立節點配額所保護的 <xref:System.Xml.XPath> 導覽，進而限制可造訪的 XML 節點數。</span><span class="sxs-lookup"><span data-stu-id="047df-219">Some <xref:System.ServiceModel.Channels.MessageBuffer.CreateNavigator%2A> overloads allow you to create <xref:System.Xml.XPath> navigators protected by a node quota, limiting the number of XML nodes that can be visited.</span></span> <span data-ttu-id="047df-220">這樣做可防止長處理時間所導致的阻絕服務攻擊。</span><span class="sxs-lookup"><span data-stu-id="047df-220">This helps prevent denial of service attacks based on lengthy processing time.</span></span> <span data-ttu-id="047df-221">預設會停用此配額。</span><span class="sxs-lookup"><span data-stu-id="047df-221">This quote is disabled by default.</span></span> <span data-ttu-id="047df-222">有些 `CreateNavigator` 多載會讓您使用 <xref:System.Xml.XmlSpace> 列舉搭配預設值 `XmlSpace.None`，以指定在 XML 中處理空白字元的方式。</span><span class="sxs-lookup"><span data-stu-id="047df-222">Some `CreateNavigator` overloads allow you to specify how white space should be handled in the XML using the <xref:System.Xml.XmlSpace> enumeration, with the default being `XmlSpace.None`.</span></span>  
  
 <span data-ttu-id="047df-223">最後一個存取訊息緩衝區內容的方法為使用 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 將內容寫出至資料流。</span><span class="sxs-lookup"><span data-stu-id="047df-223">A final way to access the contents of a message buffer is to write out its contents to a stream using <xref:System.ServiceModel.Channels.Message.WriteMessage%2A>.</span></span>  
  
 <span data-ttu-id="047df-224">下列範例會示範使用 `MessageBuffer` 的處理序：傳入訊息會轉寄至多個收件者，然後記錄至檔案。</span><span class="sxs-lookup"><span data-stu-id="047df-224">The following example demonstrates the process of working with a `MessageBuffer`: an incoming message is forwarded to multiple recipients, and then logged to a file.</span></span> <span data-ttu-id="047df-225">沒有緩衝處理的話，則不可能這樣做，這樣的話只能存取一次訊息本文。</span><span class="sxs-lookup"><span data-stu-id="047df-225">Without buffering, this is not possible, because the message body can then be accessed only once.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#7)]
 [!code-vb[C_UsingTheMessageClass#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#7)]  
  
 <span data-ttu-id="047df-226">`MessageBuffer` 類別則具有不重要的成員。</span><span class="sxs-lookup"><span data-stu-id="047df-226">The `MessageBuffer` class has other members worth noting.</span></span> <span data-ttu-id="047df-227">不再需要緩衝區內容時，可以呼叫 <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> 方法釋放資源。</span><span class="sxs-lookup"><span data-stu-id="047df-227">The <xref:System.ServiceModel.Channels.MessageBuffer.Close%2A> method can be called to free resources when the buffer contents are no longer required.</span></span> <span data-ttu-id="047df-228"><xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> 屬性會傳回所配置緩衝區的大小。</span><span class="sxs-lookup"><span data-stu-id="047df-228">The <xref:System.ServiceModel.Channels.MessageBuffer.BufferSize%2A> property returns the size of the allocated buffer.</span></span> <span data-ttu-id="047df-229"><xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> 屬性則會傳回訊息的 MIME 內容型別。</span><span class="sxs-lookup"><span data-stu-id="047df-229">The <xref:System.ServiceModel.Channels.MessageBuffer.MessageContentType%2A> property returns the MIME content type of the message.</span></span>  
  
## <a name="accessing-the-message-body-for-debugging"></a><span data-ttu-id="047df-230">存取訊息本文以進行偵錯</span><span class="sxs-lookup"><span data-stu-id="047df-230">Accessing the Message Body for Debugging</span></span>  
 <span data-ttu-id="047df-231">為了進行偵錯，您可以呼叫 <xref:System.ServiceModel.Channels.Message.ToString%2A> 方法而取得以訊息做為字串的表示。</span><span class="sxs-lookup"><span data-stu-id="047df-231">For debugging purposes, you can call the <xref:System.ServiceModel.Channels.Message.ToString%2A> method to get a representation of the message as a string.</span></span> <span data-ttu-id="047df-232">這個表示通常會符合訊息在網路上的呈現方式 (若此訊息是以文字編碼器編碼)，差別在於 XML 會針對人們可讀取性達成更佳的格式化效果。</span><span class="sxs-lookup"><span data-stu-id="047df-232">This representation generally matches the way a message would look on the wire if it were encoded with the text encoder, except that the XML would be better formatted for human readability.</span></span> <span data-ttu-id="047df-233">此項的例外為訊息本文。</span><span class="sxs-lookup"><span data-stu-id="047df-233">The one exception to this is the message body.</span></span> <span data-ttu-id="047df-234">本文只能讀取一次，而且 `ToString` 不會變更訊息狀態。</span><span class="sxs-lookup"><span data-stu-id="047df-234">The body can be read only once, and `ToString` does not change the message state.</span></span> <span data-ttu-id="047df-235">因此，`ToString`方法可能無法存取本文，並可能替代預留位置 （例如，"…"或三個點） 而非訊息本文。</span><span class="sxs-lookup"><span data-stu-id="047df-235">Therefore, the `ToString` method might not be able to access the body and might substitute a placeholder (for example, "…" or three dots) instead of the message body.</span></span> <span data-ttu-id="047df-236">所以，如果訊息的本文內容十分重要，請勿使用 `ToString` 來記錄訊息。</span><span class="sxs-lookup"><span data-stu-id="047df-236">Therefore, do not use `ToString` to log messages if the body content of the messages is important.</span></span>  
  
## <a name="accessing-other-message-parts"></a><span data-ttu-id="047df-237">存取其他訊息部分</span><span class="sxs-lookup"><span data-stu-id="047df-237">Accessing Other Message Parts</span></span>  
 <span data-ttu-id="047df-238">將會提供各種屬性以存取訊息 (而非其本文內容) 的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="047df-238">Various properties are provided to access information about the message other than its body contents.</span></span> <span data-ttu-id="047df-239">不過，一旦關閉訊息就無法呼叫這些屬性：</span><span class="sxs-lookup"><span data-stu-id="047df-239">However, these cannot be called once the message has been closed:</span></span>  
  
-   <span data-ttu-id="047df-240"><xref:System.ServiceModel.Channels.Message.Headers%2A> 屬性表示訊息標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-240">The <xref:System.ServiceModel.Channels.Message.Headers%2A> property represents the message headers.</span></span> <span data-ttu-id="047df-241">請參閱這個主題稍後的 「 使用標頭 」 一節。</span><span class="sxs-lookup"><span data-stu-id="047df-241">See the section on "Working with Headers" later in this topic.</span></span>  
  
-   <span data-ttu-id="047df-242"><xref:System.ServiceModel.Channels.Message.Properties%2A> 屬性表示訊息屬性，這些訊息屬性為附加至訊息 (傳送訊息時通常不會發出的訊息) 的具名資料片段。</span><span class="sxs-lookup"><span data-stu-id="047df-242">The <xref:System.ServiceModel.Channels.Message.Properties%2A> property represents the message properties, which are pieces of named data attached to the message that do not generally get emitted when the message is sent.</span></span> <span data-ttu-id="047df-243">請參閱本主題稍後的「使用屬性」這一節。</span><span class="sxs-lookup"><span data-stu-id="047df-243">See the section on "Working with Properties" later in this topic.</span></span>  
  
-   <span data-ttu-id="047df-244"><xref:System.ServiceModel.Channels.Message.Version%2A> 屬性會指出與訊息相關聯的 SOAP 和 WS-Addressing 版本，而若停用 SOAP，則指出 `None`。</span><span class="sxs-lookup"><span data-stu-id="047df-244">The <xref:System.ServiceModel.Channels.Message.Version%2A> property indicates the SOAP and WS-Addressing version associated with the message, or `None` if SOAP is disabled.</span></span>  
  
-   <span data-ttu-id="047df-245">如果訊息為 SOAP 錯誤訊息，<xref:System.ServiceModel.Channels.Message.IsFault%2A> 屬性會傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="047df-245">The <xref:System.ServiceModel.Channels.Message.IsFault%2A> property returns `true` if the message is a SOAP fault message.</span></span>  
  
-   <span data-ttu-id="047df-246">如果訊息為空，則 <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> 屬性會傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="047df-246">The <xref:System.ServiceModel.Channels.Message.IsEmpty%2A> property returns `true` if the message is empty.</span></span>  
  
 <span data-ttu-id="047df-247">您可以使用 <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> 方法，存取以特定名稱和命名空間所識別之本文包裝函式項目 (例如，`<soap:Body>`) 上的特定屬性。</span><span class="sxs-lookup"><span data-stu-id="047df-247">You can use the <xref:System.ServiceModel.Channels.Message.GetBodyAttribute%28System.String%2CSystem.String%29> method to access a particular attribute on the body wrapper element (for example, `<soap:Body>`) identified by a particular name and namespace.</span></span> <span data-ttu-id="047df-248">如果找不到這類屬性，則會傳回 `null`。</span><span class="sxs-lookup"><span data-stu-id="047df-248">If such an attribute is not found, `null` is returned.</span></span> <span data-ttu-id="047df-249">只有當 `Message` 處於「已建立」狀態時 (訊息本文尚未被存取)，才能呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="047df-249">This method can be called only when the `Message` is in the Created state (when the message body has not yet been accessed).</span></span>  
  
## <a name="working-with-headers"></a><span data-ttu-id="047df-250">使用標頭</span><span class="sxs-lookup"><span data-stu-id="047df-250">Working with Headers</span></span>  
 <span data-ttu-id="047df-251">A`Message`可以包含任何數目的具名 XML 片段，稱為*標頭*。</span><span class="sxs-lookup"><span data-stu-id="047df-251">A `Message` can contain any number of named XML fragments, called *headers*.</span></span> <span data-ttu-id="047df-252">每個片段通常都會對映至 SOAP 標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-252">Each fragment normally maps to a SOAP header.</span></span> <span data-ttu-id="047df-253">您可以透過型別為 `Headers` 的 <xref:System.ServiceModel.Channels.MessageHeaders> 屬性來存取標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-253">Headers are accessed through the `Headers` property of type <xref:System.ServiceModel.Channels.MessageHeaders>.</span></span> <span data-ttu-id="047df-254"><xref:System.ServiceModel.Channels.MessageHeaders> 是 <xref:System.ServiceModel.Channels.MessageHeaderInfo> 物件的集合，而您可以藉由標頭的 <xref:System.Collections.IEnumerable> 介面或索引子 (Indexer) 來存取個別標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-254"><xref:System.ServiceModel.Channels.MessageHeaders> is a collection of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects, and individual headers can be accessed through its <xref:System.Collections.IEnumerable> interface or through its indexer.</span></span> <span data-ttu-id="047df-255">例如，下列程式碼會列出 `Message` 中所有標頭的名稱。</span><span class="sxs-lookup"><span data-stu-id="047df-255">For example, the following code lists the names of all the headers in a `Message`.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#8)]
 [!code-vb[C_UsingTheMessageClass#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#8)]  
  
#### <a name="adding-removing-finding-headers"></a><span data-ttu-id="047df-256">新增、移除、尋找標頭</span><span class="sxs-lookup"><span data-stu-id="047df-256">Adding, Removing, Finding Headers</span></span>  
 <span data-ttu-id="047df-257">您可以使用 <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> 方法，將新標頭新增至所有現有標頭的尾端。</span><span class="sxs-lookup"><span data-stu-id="047df-257">You can add a new header at the end of all existing headers using the <xref:System.ServiceModel.Channels.MessageHeaders.Add%2A> method.</span></span> <span data-ttu-id="047df-258">您也可以使用 <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> 方法在特定索引中插入標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-258">You can use the <xref:System.ServiceModel.Channels.MessageHeaders.Insert%2A> method to insert a header at a particular index.</span></span> <span data-ttu-id="047df-259">現有的標頭會因插入的項目而移位。</span><span class="sxs-lookup"><span data-stu-id="047df-259">Existing headers are shifted for the inserted item.</span></span> <span data-ttu-id="047df-260">將會根據標頭的索引排列標頭的順序，而第一個可用的索引為 0。</span><span class="sxs-lookup"><span data-stu-id="047df-260">Headers are ordered according to their index, and the first available index is 0.</span></span> <span data-ttu-id="047df-261">您可以使用各種 <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> 方法多載，從不同的 `Message` 或 `MessageHeaders` 執行個體中加入標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-261">You can use the various <xref:System.ServiceModel.Channels.MessageHeaders.CopyHeadersFrom%2A> method overloads to add headers from a different `Message` or `MessageHeaders` instance.</span></span> <span data-ttu-id="047df-262">有些多載會複製一則個別標頭，而其他多載則複製所有標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-262">Some overloads copy one individual header, while others copy all of them.</span></span> <span data-ttu-id="047df-263"><xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> 方法會移除所有標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-263">The <xref:System.ServiceModel.Channels.MessageHeaders.Clear%2A> method removes all headers.</span></span> <span data-ttu-id="047df-264"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> 方法則會移除特定索引的標頭 (該標頭之後的所有標頭都會移位)。</span><span class="sxs-lookup"><span data-stu-id="047df-264">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAt%2A> method removes a header at a particular index (shifting all headers after it).</span></span> <span data-ttu-id="047df-265"><xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> 方法會移除具有特定名稱和命名空間的所有標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-265">The <xref:System.ServiceModel.Channels.MessageHeaders.RemoveAll%2A> method removes all headers with a particular name and namespace.</span></span>  
  
 <span data-ttu-id="047df-266">您可使用 <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> 方法擷取特定標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-266">Retrieve a particular header using the <xref:System.ServiceModel.Channels.MessageHeaders.FindHeader%2A> method.</span></span> <span data-ttu-id="047df-267">這個方法會採用要尋找的標頭名稱和命名空間，並傳回其索引。</span><span class="sxs-lookup"><span data-stu-id="047df-267">This method takes the name and namespace of the header to find, and returns its index.</span></span> <span data-ttu-id="047df-268">如果標頭在多個地方出現，則會擲出例外狀況。</span><span class="sxs-lookup"><span data-stu-id="047df-268">If the header occurs more than once, an exception is thrown.</span></span> <span data-ttu-id="047df-269">如果找不到標頭，則會傳回 -1。</span><span class="sxs-lookup"><span data-stu-id="047df-269">If the header is not found, it returns -1.</span></span>  
  
 <span data-ttu-id="047df-270">在 SOAP 標頭模型中，標頭所擁有的 `Actor` 值會指定標頭的預定收件者。</span><span class="sxs-lookup"><span data-stu-id="047df-270">In the SOAP header model, headers can have an `Actor` value that specifies the intended recipient of the header.</span></span> <span data-ttu-id="047df-271">最基本的 `FindHeader` 多載只會搜尋用於訊息最終接收者的標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-271">The most basic `FindHeader` overload searches only headers intended for the ultimate receiver of the message.</span></span> <span data-ttu-id="047df-272">不過，其他多載則可讓您指定搜尋中所含的 `Actor` 值。</span><span class="sxs-lookup"><span data-stu-id="047df-272">However, another overload enables you to specify which `Actor` values are included in the search.</span></span> <span data-ttu-id="047df-273">如需詳細資訊，請參閱 SOAP 規格。</span><span class="sxs-lookup"><span data-stu-id="047df-273">For more information, see the SOAP specification.</span></span>  
  
 <span data-ttu-id="047df-274">將會提供 <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> 方法以將標頭從 <xref:System.ServiceModel.Channels.MessageHeaders> 集合複製至 <xref:System.ServiceModel.Channels.MessageHeaderInfo> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="047df-274">A <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> method is provided to copy headers from a <xref:System.ServiceModel.Channels.MessageHeaders> collection to an array of <xref:System.ServiceModel.Channels.MessageHeaderInfo> objects.</span></span>  
  
 <span data-ttu-id="047df-275">若要存取標頭中的 XML 資料，您可以對特定標頭索引呼叫 <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> 並傳回 XML 讀取器。</span><span class="sxs-lookup"><span data-stu-id="047df-275">To access the XML data in a header, you can call <xref:System.ServiceModel.Channels.MessageHeaders.GetReaderAtHeader%2A> and return an XML reader for the specific header index.</span></span> <span data-ttu-id="047df-276">如果您要將標頭內容還原序列化至物件，請使用 <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> 或其他多載。</span><span class="sxs-lookup"><span data-stu-id="047df-276">If you want to deserialize the header contents into an object, use <xref:System.ServiceModel.Channels.MessageHeaders.GetHeader%60%601%28System.Int32%29> or one of the other overloads.</span></span> <span data-ttu-id="047df-277">最基本的多載會使用以預設方法設定的 <xref:System.Runtime.Serialization.DataContractSerializer> 來還原序列化標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-277">The most basic overloads deserialize headers using the <xref:System.Runtime.Serialization.DataContractSerializer> configured in the default way.</span></span> <span data-ttu-id="047df-278">如果您要使用不同的序列化程式或不同的 `DataContractSerializer` 組態，請使用下列其中一個會採用 `XmlObjectSerializer` 的多載。</span><span class="sxs-lookup"><span data-stu-id="047df-278">If you want to use a different serializer or a different configuration of the `DataContractSerializer`, use one of the overloads that take an `XmlObjectSerializer`.</span></span> <span data-ttu-id="047df-279">也會有採用標頭名稱、命名空間和選擇性採用 `Actor` 值清單，而不採用索引的多載；而這是 `FindHeader` 和 `GetHeader` 的組合。</span><span class="sxs-lookup"><span data-stu-id="047df-279">There are also overloads that take the header name, namespace, and optionally a list of `Actor` values instead of an index; this is a combination of `FindHeader` and `GetHeader`.</span></span>  
  
## <a name="working-with-properties"></a><span data-ttu-id="047df-280">使用屬性</span><span class="sxs-lookup"><span data-stu-id="047df-280">Working with Properties</span></span>  
 <span data-ttu-id="047df-281">`Message` 執行個體中可包含任意數目、任意型別的具名物件。</span><span class="sxs-lookup"><span data-stu-id="047df-281">A `Message` instance can contain an arbitrary number of named objects of arbitrary types.</span></span> <span data-ttu-id="047df-282">您可以透過型別為 `Properties` 的 `MessageProperties` 屬性來存取這個集合。</span><span class="sxs-lookup"><span data-stu-id="047df-282">This collection is accessed through the `Properties` property of type `MessageProperties`.</span></span> <span data-ttu-id="047df-283">這個集合會實作 <xref:System.Collections.Generic.IDictionary%602> 介面，並且會做為從 <xref:System.String> 到 <xref:System.Object> 的對應。</span><span class="sxs-lookup"><span data-stu-id="047df-283">The collection implements the <xref:System.Collections.Generic.IDictionary%602> interface and acts as a mapping from <xref:System.String> to <xref:System.Object>.</span></span> <span data-ttu-id="047df-284">一般來說，屬性值是否未直接對應至 wire 上的訊息任何部分，但而是提供各種訊息處理提示的各種通道 WCF 通道堆疊中或<xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29>服務架構。</span><span class="sxs-lookup"><span data-stu-id="047df-284">Normally, property values do not map directly to any part of the message on the wire, but rather provide various message processing hints to the various channels in the WCF channel stack or to the <xref:System.ServiceModel.Channels.MessageHeaders.CopyTo%28System.ServiceModel.Channels.MessageHeaderInfo%5B%5D%2CSystem.Int32%29> service framework.</span></span> <span data-ttu-id="047df-285">如需範例，請參閱[資料傳輸架構概觀](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="047df-285">For an example, see [Data Transfer Architectural Overview](../../../../docs/framework/wcf/feature-details/data-transfer-architectural-overview.md).</span></span>  
  
## <a name="inheriting-from-the-message-class"></a><span data-ttu-id="047df-286">繼承自 Message 類別</span><span class="sxs-lookup"><span data-stu-id="047df-286">Inheriting from the Message Class</span></span>  
 <span data-ttu-id="047df-287">如果使用 `CreateMessage` 建立的內建訊息類型不符合您的需求，請建立衍生自 `Message` 類別的類別。</span><span class="sxs-lookup"><span data-stu-id="047df-287">If the built-in message types created using `CreateMessage` do not meet your requirements, create a class that derives from the `Message` class.</span></span>  
  
### <a name="defining-the-message-body-contents"></a><span data-ttu-id="047df-288">定義訊息本文內容</span><span class="sxs-lookup"><span data-stu-id="047df-288">Defining the Message Body Contents</span></span>  
 <span data-ttu-id="047df-289">有三種主要技術可讓您在訊息本文內存取資料：寫入、讀取以及將資料複製至緩衝區。</span><span class="sxs-lookup"><span data-stu-id="047df-289">Three primary techniques exist for accessing data within a message body: writing, reading, and copying it to a buffer.</span></span> <span data-ttu-id="047df-290">這些作業最後會導致在 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> 的衍生類別上，分別呼叫 <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>、<xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 和 `Message` 方法。</span><span class="sxs-lookup"><span data-stu-id="047df-290">These operations ultimately result in the <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A>, <xref:System.ServiceModel.Channels.Message.OnGetReaderAtBodyContents%2A>, and <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> methods being called, respectively, on your derived class of `Message`.</span></span> <span data-ttu-id="047df-291">基底 `Message` 類別可保證，針對每個 `Message` 執行個體只會呼叫其中一個方法，而且該方法不會呼叫超過一次。</span><span class="sxs-lookup"><span data-stu-id="047df-291">The base `Message` class guarantees that only one of these methods is called for each `Message` instance, and that it is not called more than once.</span></span> <span data-ttu-id="047df-292">基底類別也會確保不會在關閉的訊息上呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="047df-292">The base class also ensures that the methods are not called on a closed message.</span></span> <span data-ttu-id="047df-293">因此在您的實作中不需要追蹤訊息狀態。</span><span class="sxs-lookup"><span data-stu-id="047df-293">There is no need to track the message state in your implementation.</span></span>  
  
 <span data-ttu-id="047df-294"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> 是一種抽象方法，而且必須進行實作。</span><span class="sxs-lookup"><span data-stu-id="047df-294"><xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%2A> is an abstract method and must be implemented.</span></span> <span data-ttu-id="047df-295">定義訊息之本文內容最基本的方法為使用這個方法來寫入。</span><span class="sxs-lookup"><span data-stu-id="047df-295">The most basic way to define the body contents of your message is to write using this method.</span></span> <span data-ttu-id="047df-296">例如，下列訊息包含 100,000 個 1 到 20 的亂數。</span><span class="sxs-lookup"><span data-stu-id="047df-296">For example, the following message contains 100,000 random numbers from 1 to 20.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#9)]
 [!code-vb[C_UsingTheMessageClass#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#9)]  
  
 <span data-ttu-id="047df-297">`OnGetReaderAtBodyContents` 和 `OnCreateBufferedCopy` 方法都具有可用於大多數情況的預設實作。</span><span class="sxs-lookup"><span data-stu-id="047df-297">The `OnGetReaderAtBodyContents` and `OnCreateBufferedCopy` methods have default implementations that work for most cases.</span></span> <span data-ttu-id="047df-298">預設實作會呼叫 `OnWriteBodyContents`，然後緩衝處理結果，再使用產生的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="047df-298">The default implementations call `OnWriteBodyContents`, buffer the results, and work with the resulting buffer.</span></span> <span data-ttu-id="047df-299">不過，在某些情況下，只有此實作可能不太夠。</span><span class="sxs-lookup"><span data-stu-id="047df-299">However, in some cases this may not be enough.</span></span> <span data-ttu-id="047df-300">在先前的範例中，讀取訊息會造成緩衝處理 100,000 個 XML 項目，而這可能不是想要的目的。</span><span class="sxs-lookup"><span data-stu-id="047df-300">In the preceding example, reading the message results in 100,000 XML elements being buffered, which might not be desirable.</span></span> <span data-ttu-id="047df-301">您可能想要覆寫 `OnGetReaderAtBodyContents`，以傳回提供亂數的自訂 `XmlDictionaryReader` 衍生類別。</span><span class="sxs-lookup"><span data-stu-id="047df-301">You might want to override `OnGetReaderAtBodyContents` to return a custom `XmlDictionaryReader` derived class that serves up random numbers.</span></span> <span data-ttu-id="047df-302">您接著可以覆寫 `OnWriteBodyContents` 以使用 `OnGetReaderAtBodyContents` 正確傳回的讀取器，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="047df-302">You can then override `OnWriteBodyContents` to use the reader that the `OnGetReaderAtBodyContents` property returns, as shown in the following example.</span></span>  
  
 [!code-csharp[C_UsingTheMessageClass#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_usingthemessageclass/cs/source.cs#10)]
 [!code-vb[C_UsingTheMessageClass#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_usingthemessageclass/vb/source.vb#10)]  
  
 <span data-ttu-id="047df-303">同樣地，您可能想要覆寫 `OnCreateBufferedCopy` 以傳回自己的 `MessageBuffer` 衍生類別。</span><span class="sxs-lookup"><span data-stu-id="047df-303">Similarly, you might want to override `OnCreateBufferedCopy` to return your own `MessageBuffer` derived class.</span></span>  
  
 <span data-ttu-id="047df-304">除了提供訊息本文內容以外，您的訊息衍生類別也必須覆寫 `Version`、`Headers` 和 `Properties` 屬性。</span><span class="sxs-lookup"><span data-stu-id="047df-304">In addition to providing message body contents, your message derived class must also override the `Version`, `Headers`, and `Properties` properties.</span></span>  
  
 <span data-ttu-id="047df-305">請注意，如果建立訊息複本，該複本會使用原始的訊息標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-305">Note that if you create a copy of a message, the copy uses the message headers from the original.</span></span>  
  
### <a name="other-members-that-can-be-overridden"></a><span data-ttu-id="047df-306">可以覆寫的其他成員</span><span class="sxs-lookup"><span data-stu-id="047df-306">Other Members that Can Be Overridden</span></span>  
 <span data-ttu-id="047df-307">您可以覆寫 <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>、<xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> 和 <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> 方法，以指定寫出 SOAP 信封、SOAP 標頭和 SOAP 本文項目開始標記的方法。這些方法通常會對應至 `<soap:Envelope>`、`<soap:Header>` 和 `<soap:Body>`。</span><span class="sxs-lookup"><span data-stu-id="047df-307">You can override the <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.Message.OnWriteStartBody%2A> methods to specify how the SOAP envelope, SOAP headers, and SOAP body element start tags are written out. These normally correspond to `<soap:Envelope>`, `<soap:Header>`, and `<soap:Body>`.</span></span> <span data-ttu-id="047df-308">如果 `Version` 正確地傳回 `MessageVersion.None`，則這些方法一般不應該寫出任何項目。</span><span class="sxs-lookup"><span data-stu-id="047df-308">These methods should normally not write anything out if the `Version` property returns `MessageVersion.None`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="047df-309">`OnGetReaderAtBodyContents` 預設實作會在呼叫 `OnWriteStartEnvelope` 和緩衝處理結果之前，先呼叫 `OnWriteStartBody` 和 `OnWriteBodyContents`。</span><span class="sxs-lookup"><span data-stu-id="047df-309">The default implementation of `OnGetReaderAtBodyContents` calls `OnWriteStartEnvelope` and `OnWriteStartBody` before calling `OnWriteBodyContents` and buffering the results.</span></span> <span data-ttu-id="047df-310">如此將不會寫出標頭。</span><span class="sxs-lookup"><span data-stu-id="047df-310">Headers are not written out.</span></span>  
  
 <span data-ttu-id="047df-311">覆寫 <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> 方法，以變更從各種訊息片段建構整個訊息的方法。</span><span class="sxs-lookup"><span data-stu-id="047df-311">Override the <xref:System.ServiceModel.Channels.Message.OnWriteMessage%2A> method to change the way the entire message is constructed from its various pieces.</span></span> <span data-ttu-id="047df-312">將會從 `OnWriteMessage` 和預設 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 實作中呼叫 <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="047df-312">The `OnWriteMessage` method is called from <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> and from the default <xref:System.ServiceModel.Channels.Message.OnCreateBufferedCopy%2A> implementation.</span></span> <span data-ttu-id="047df-313">請注意，覆寫 <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> 不是最佳作法。</span><span class="sxs-lookup"><span data-stu-id="047df-313">Note that overriding <xref:System.ServiceModel.Channels.Message.WriteMessage%2A> is not a best practice.</span></span> <span data-ttu-id="047df-314">最好是覆寫適當的 `On` 方法 (例如，<xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>、<xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A> 和 <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>)。</span><span class="sxs-lookup"><span data-stu-id="047df-314">It is better to override the appropriate `On` methods (for example, <xref:System.ServiceModel.Channels.Message.OnWriteStartEnvelope%2A>, <xref:System.ServiceModel.Channels.Message.OnWriteStartHeaders%2A>, and <xref:System.ServiceModel.Channels.BodyWriter.OnWriteBodyContents%2A>.</span></span>  
  
 <span data-ttu-id="047df-315">覆寫 <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> 以覆寫偵錯期間呈現訊息本文的方法。</span><span class="sxs-lookup"><span data-stu-id="047df-315">Override <xref:System.ServiceModel.Channels.Message.OnBodyToString%2A> to override how your message body is represented during debugging.</span></span> <span data-ttu-id="047df-316">預設是以三個點 ("…") 來表示。</span><span class="sxs-lookup"><span data-stu-id="047df-316">The default is to represent it as three dots ("…").</span></span> <span data-ttu-id="047df-317">請注意，當訊息狀態為「已關閉」以外的狀態時，就可以多次呼叫這個方法。</span><span class="sxs-lookup"><span data-stu-id="047df-317">Note that this method can be called multiple times when the message state is anything other than Closed.</span></span> <span data-ttu-id="047df-318">實作這個方法後，絕不能造成任何動作只能執行一次 (例如，從順向資料流讀取)。</span><span class="sxs-lookup"><span data-stu-id="047df-318">An implementation of this method should never cause any action that must be performed only once (such as reading from a forward-only stream).</span></span>  
  
 <span data-ttu-id="047df-319">覆寫 <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> 方法以允許存取 SOAP 本文項目上的屬性。</span><span class="sxs-lookup"><span data-stu-id="047df-319">Override the <xref:System.ServiceModel.Channels.Message.OnGetBodyAttribute%2A> method to allow access to attributes on the SOAP body element.</span></span> <span data-ttu-id="047df-320">這個方法可以無限次數呼叫，但 `Message` 基底類別會保證只有當訊息處於「已建立」狀態時才會呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="047df-320">This method can be called any number of times, but the `Message` base type guarantees that it is only called when the message is in the Created state.</span></span> <span data-ttu-id="047df-321">您不需要檢查實作中的狀態。</span><span class="sxs-lookup"><span data-stu-id="047df-321">It is not required to check the state in an implementation.</span></span> <span data-ttu-id="047df-322">預設實作一定會傳回 `null`，表示在本文項目上沒有任何屬性。</span><span class="sxs-lookup"><span data-stu-id="047df-322">The default implementation always returns `null`, which indicates that there are no attributes on the body element.</span></span>  
  
 <span data-ttu-id="047df-323">如果不再需要訊息本文，同時 `Message` 物件必須執行特殊清除動作，這時您可以覆寫 <xref:System.ServiceModel.Channels.Message.OnClose%2A>。</span><span class="sxs-lookup"><span data-stu-id="047df-323">If your `Message` object must do any special cleanup when the message body is no longer required, you can override <xref:System.ServiceModel.Channels.Message.OnClose%2A>.</span></span> <span data-ttu-id="047df-324">預設實作不做任何動作。</span><span class="sxs-lookup"><span data-stu-id="047df-324">The default implementation does nothing.</span></span>  
  
 <span data-ttu-id="047df-325">您可以覆寫 `IsEmpty` 和 `IsFault` 屬性。</span><span class="sxs-lookup"><span data-stu-id="047df-325">The `IsEmpty` and `IsFault` properties can be overridden.</span></span> <span data-ttu-id="047df-326">根據預設，這兩個屬性都會傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="047df-326">By default, both return `false`.</span></span>
