---
title: "有害訊息處理"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 8d1c5e5a-7928-4a80-95ed-d8da211b8595
caps.latest.revision: "29"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 8202c9f715944c6d556c0023444475838cfd5eab
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/22/2017
---
# <a name="poison-message-handling"></a><span data-ttu-id="acf84-102">有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="acf84-102">Poison Message Handling</span></span>
<span data-ttu-id="acf84-103">A*有害訊息*是超過嘗試傳遞至應用程式的最大數目的訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-103">A *poison message* is a message that has exceeded the maximum number of delivery attempts to the application.</span></span> <span data-ttu-id="acf84-104">這種情形可能會在佇列架構的應用程式因為錯誤而無法處理訊息時發生。</span><span class="sxs-lookup"><span data-stu-id="acf84-104">This situation can arise when a queue-based application cannot process a message because of errors.</span></span> <span data-ttu-id="acf84-105">為了符合可靠性的需求，佇列的應用程式會在交易中接收訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-105">To meet reliability demands, a queued application receives messages under a transaction.</span></span> <span data-ttu-id="acf84-106">若中止了接收佇列訊息的交易，則會讓訊息留在佇列中，而訊息將會在新的交易中重試。</span><span class="sxs-lookup"><span data-stu-id="acf84-106">Aborting the transaction in which a queued message was received leaves the message in the queue so that the message is retried under a new transaction.</span></span> <span data-ttu-id="acf84-107">如果造成交易中止的問題未予以更正，則接收的應用程式可能會卡在接收及中止相同訊息的迴圈中，直到超過傳遞嘗試次數的上限為止，因而形成有害訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-107">If the problem that caused the transaction to abort is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until the maximum number of delivery attempts has been exceeded and a poison message results.</span></span>  
  
 <span data-ttu-id="acf84-108">訊息變成有害訊息的原因有許多種。</span><span class="sxs-lookup"><span data-stu-id="acf84-108">A message can become a poison message for many reasons.</span></span> <span data-ttu-id="acf84-109">最常見的原因是在應用程式中所發生的特定原因。</span><span class="sxs-lookup"><span data-stu-id="acf84-109">The most common reasons are application specific.</span></span> <span data-ttu-id="acf84-110">例如，如果應用程式從佇列讀取訊息，並且執行某些資料庫處理，應用程式可能因為無法在該資料庫上取得鎖定，而造成中止交易。</span><span class="sxs-lookup"><span data-stu-id="acf84-110">For example, if an application reads a message from a queue and performs some database processing, the application may fail to get a lock on the database, causing it to abort the transaction.</span></span> <span data-ttu-id="acf84-111">由於資料庫交易中止，訊息會留在佇列中，造成應用程式再次讀取該訊息，並重新嘗試取得資料庫鎖定。</span><span class="sxs-lookup"><span data-stu-id="acf84-111">Because the database transaction was aborted, the message remains in the queue, which causes the application to reread the message a second time and make another attempt to acquire a lock on the database.</span></span> <span data-ttu-id="acf84-112">如果訊息包含無效的資訊，則也可能變成有害的。</span><span class="sxs-lookup"><span data-stu-id="acf84-112">Messages can also become poison if they contain invalid information.</span></span> <span data-ttu-id="acf84-113">例如，採購單可能包含無效的客戶編號。</span><span class="sxs-lookup"><span data-stu-id="acf84-113">For example, a purchase order may contain an invalid customer number.</span></span> <span data-ttu-id="acf84-114">在這些情況下，應用程式可能自動中止交易，而迫使訊息成為有害訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-114">In these cases, the application may voluntarily abort the transaction and force the message to become a poison message.</span></span>  
  
 <span data-ttu-id="acf84-115">在鮮少的情況下，訊息可能會無法分派至應用程式。</span><span class="sxs-lookup"><span data-stu-id="acf84-115">On rare occasions, messages can fail to get dispatched to the application.</span></span> <span data-ttu-id="acf84-116">[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] 層可能會發現與訊息相關的問題，例如，訊息的框架錯誤、附加的訊息認證無效，或是無效的動作標頭。</span><span class="sxs-lookup"><span data-stu-id="acf84-116">The [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] layer may find a problem with the message, such as if the message has the wrong frame, invalid message credentials attached to it, or an invalid action header.</span></span> <span data-ttu-id="acf84-117">在這些情況中，應用程式絕不會接收該訊息，不過，訊息仍然可能會變成有害訊息，並且以手動方式處理。</span><span class="sxs-lookup"><span data-stu-id="acf84-117">In these cases, the application never receives the message; however, the message can still become a poison message and be processed manually.</span></span>  
  
## <a name="handling-poison-messages"></a><span data-ttu-id="acf84-118">處理有害訊息</span><span class="sxs-lookup"><span data-stu-id="acf84-118">Handling Poison Messages</span></span>  
 <span data-ttu-id="acf84-119">在 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 中，有害訊息處理提供了一項機制，可讓接收的應用程式處理無法分派至應用程式的訊息，或是雖分派至應用程式，卻因應用程式本身的問題而無法處理的訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-119">In [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], poison message handling provides a mechanism for a receiving application to deal with messages that cannot be dispatched to the application, or messages that are dispatched to the application but which fail to be processed because of application-specific reasons.</span></span> <span data-ttu-id="acf84-120">有害訊息處理是由每個可用佇列繫結中的以下屬性所設定：</span><span class="sxs-lookup"><span data-stu-id="acf84-120">Poison message handling is configured by the following properties in each of the available queued bindings:</span></span>  
  
-   <span data-ttu-id="acf84-121">`ReceiveRetryCount`。</span><span class="sxs-lookup"><span data-stu-id="acf84-121">`ReceiveRetryCount`.</span></span> <span data-ttu-id="acf84-122">整數值，表示從應用程式佇列傳遞至應用程式的訊息重試次數上限。</span><span class="sxs-lookup"><span data-stu-id="acf84-122">An integer value that indicates the maximum number of times to retry delivery of a message from the application queue to the application.</span></span> <span data-ttu-id="acf84-123">預設值為 5。</span><span class="sxs-lookup"><span data-stu-id="acf84-123">The default value is 5.</span></span> <span data-ttu-id="acf84-124">這個值對於立即重試即可修正問題的情況來說就已足夠，例如資料庫上發生暫時死結時。</span><span class="sxs-lookup"><span data-stu-id="acf84-124">This is sufficient in cases where an immediate retry fixes the problem, such as with a temporary deadlock on a database.</span></span>  
  
-   <span data-ttu-id="acf84-125">`MaxRetryCycles`。</span><span class="sxs-lookup"><span data-stu-id="acf84-125">`MaxRetryCycles`.</span></span> <span data-ttu-id="acf84-126">整數值，表示重試週期的上限。</span><span class="sxs-lookup"><span data-stu-id="acf84-126">An integer value that indicates the maximum number of retry cycles.</span></span> <span data-ttu-id="acf84-127">重試週期包含從應用程式佇列將訊息傳輸至重試子佇列，然後在經過一段可設定的延遲之後，再從重試子佇列傳回應用程式佇列，重新嘗試傳遞。</span><span class="sxs-lookup"><span data-stu-id="acf84-127">A retry cycle consists of transferring a message from the application queue to the retry subqueue and, after a configurable delay, from the retry subqueue back into the application queue to reattempt delivery.</span></span> <span data-ttu-id="acf84-128">預設值為 2。</span><span class="sxs-lookup"><span data-stu-id="acf84-128">The default value is 2.</span></span> <span data-ttu-id="acf84-129">在 [!INCLUDE[wv](../../../../includes/wv-md.md)] 上，訊息最多會嘗試 (`ReceiveRetryCount` +1) * (`MaxRetryCycles` + 1) 次。</span><span class="sxs-lookup"><span data-stu-id="acf84-129">On [!INCLUDE[wv](../../../../includes/wv-md.md)], the message is tried a maximum of (`ReceiveRetryCount` +1) * (`MaxRetryCycles` + 1) times.</span></span> <span data-ttu-id="acf84-130">在 `MaxRetryCycles` 和 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 上則會忽略 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="acf84-130">`MaxRetryCycles` is ignored on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
-   <span data-ttu-id="acf84-131">`RetryCycleDelay`。</span><span class="sxs-lookup"><span data-stu-id="acf84-131">`RetryCycleDelay`.</span></span> <span data-ttu-id="acf84-132">重試週期之間的時間延遲。</span><span class="sxs-lookup"><span data-stu-id="acf84-132">The time delay between retry cycles.</span></span> <span data-ttu-id="acf84-133">預設值為 30 分鐘。</span><span class="sxs-lookup"><span data-stu-id="acf84-133">The default value is 30 minutes.</span></span> <span data-ttu-id="acf84-134">`MaxRetryCycles` 和 `RetryCycleDelay` 會一起提供解決問題的機制，透過定期延遲之後的重試，進行問題的修正。</span><span class="sxs-lookup"><span data-stu-id="acf84-134">`MaxRetryCycles` and `RetryCycleDelay` together provide a mechanism to address the problem where a retry after a periodic delay fixes the problem.</span></span> <span data-ttu-id="acf84-135">例如，這個機制會處理 SQL Server 中所設定等待交易認可的鎖定資料列。</span><span class="sxs-lookup"><span data-stu-id="acf84-135">For example, this handles a locked row set in SQL Server pending transaction commit.</span></span>  
  
-   <span data-ttu-id="acf84-136">`ReceiveErrorHandling`。</span><span class="sxs-lookup"><span data-stu-id="acf84-136">`ReceiveErrorHandling`.</span></span> <span data-ttu-id="acf84-137">列舉型別，指出要針對達到重試次數上限之後，而導致傳遞失敗的訊息所採取的動作。</span><span class="sxs-lookup"><span data-stu-id="acf84-137">An enumeration that indicates the action to take for a message that has failed delivery after the maximum number of retries has been attempted.</span></span> <span data-ttu-id="acf84-138">這個值可以是 Fault、Drop、Reject 和 Move。</span><span class="sxs-lookup"><span data-stu-id="acf84-138">The values can be Fault, Drop, Reject, and Move.</span></span> <span data-ttu-id="acf84-139">預設選項為 Fault。</span><span class="sxs-lookup"><span data-stu-id="acf84-139">The default option is Fault.</span></span>  
  
-   <span data-ttu-id="acf84-140">Fault：</span><span class="sxs-lookup"><span data-stu-id="acf84-140">Fault.</span></span> <span data-ttu-id="acf84-141">這個選項會將錯誤傳送至造成 `ServiceHost` 失敗的接聽項。</span><span class="sxs-lookup"><span data-stu-id="acf84-141">This option sends a fault to the listener that caused the `ServiceHost` to fault.</span></span> <span data-ttu-id="acf84-142">訊息必須藉由某種外部機制從應用程式佇列中移除，應用程式才能繼續處理佇列中的訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-142">The message must be removed from the application queue by some external mechanism before the application can continue to process messages from the queue.</span></span>  
  
-   <span data-ttu-id="acf84-143">Drop：</span><span class="sxs-lookup"><span data-stu-id="acf84-143">Drop.</span></span> <span data-ttu-id="acf84-144">這個選項會捨棄有害訊息，而且該訊息永遠不會傳遞至應用程式。</span><span class="sxs-lookup"><span data-stu-id="acf84-144">This option drops the poison message and the message is never delivered to the application.</span></span> <span data-ttu-id="acf84-145">如果訊息的 `TimeToLive` 屬性此時已過期，那麼訊息便可能會出現在傳送者寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="acf84-145">If the message's `TimeToLive` property has expired at this point, then the message may appear in the sender's dead-letter queue.</span></span> <span data-ttu-id="acf84-146">如果未過期的話，訊息不會出現在任何位置。</span><span class="sxs-lookup"><span data-stu-id="acf84-146">If not, the message does not appear anywhere.</span></span> <span data-ttu-id="acf84-147">這個選項表示，使用者尚未指定訊息遺失時的做法。</span><span class="sxs-lookup"><span data-stu-id="acf84-147">This option indicates that the user has not specified what to do if the message is lost.</span></span>  
  
-   <span data-ttu-id="acf84-148">Reject：</span><span class="sxs-lookup"><span data-stu-id="acf84-148">Reject.</span></span> <span data-ttu-id="acf84-149">這個選項只在 [!INCLUDE[wv](../../../../includes/wv-md.md)] 上提供。</span><span class="sxs-lookup"><span data-stu-id="acf84-149">This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span> <span data-ttu-id="acf84-150">這個選項會指示 Message Queuing (MSMQ) 將負值通知傳回傳送的佇列管理員，說明應用程式無法接收訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-150">This instructs Message Queuing (MSMQ) to send a negative acknowledgement back to the sending queue manager that the application cannot receive the message.</span></span> <span data-ttu-id="acf84-151">訊息會放在傳送的佇列管理員寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="acf84-151">The message is placed in the sending queue manager's dead-letter queue.</span></span>  
  
-   <span data-ttu-id="acf84-152">Move：</span><span class="sxs-lookup"><span data-stu-id="acf84-152">Move.</span></span> <span data-ttu-id="acf84-153">這個選項只在 [!INCLUDE[wv](../../../../includes/wv-md.md)] 上提供。</span><span class="sxs-lookup"><span data-stu-id="acf84-153">This option is available only on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span> <span data-ttu-id="acf84-154">這個選項會將有害訊息移到有害訊息佇列，以便之後讓有害訊息處理應用程式進行處理。</span><span class="sxs-lookup"><span data-stu-id="acf84-154">This moves the poison message to a poison-message queue for later processing by a poison-message handling application.</span></span> <span data-ttu-id="acf84-155">有害訊息佇列是應用程式佇列的子佇列。</span><span class="sxs-lookup"><span data-stu-id="acf84-155">The poison-message queue is a subqueue of the application queue.</span></span> <span data-ttu-id="acf84-156">有害訊息處理應用程式可以是 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 服務，可從有害佇列中讀取訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-156">A poison-message handling application can be a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service that reads messages out of the poison queue.</span></span> <span data-ttu-id="acf84-157">有害佇列是應用程式佇列的子佇列，並可以定址為 net.msmq://\<*機器名稱*>/*applicationQueue*; poison，其中*電腦名稱*是佇列所在的電腦名稱和*applicationQueue*是應用程式專屬佇列的名稱。</span><span class="sxs-lookup"><span data-stu-id="acf84-157">The poison queue is a subqueue of the application queue and can be addressed as net.msmq://\<*machine-name*>/*applicationQueue*;poison, where *machine-name* is the name of the computer on which the queue resides and the *applicationQueue* is the name of the application-specific queue.</span></span>  
  
 <span data-ttu-id="acf84-158">以下為訊息的嘗試傳遞次數上限：</span><span class="sxs-lookup"><span data-stu-id="acf84-158">The following are the maximum number of delivery attempts made for a message:</span></span>  
  
-   <span data-ttu-id="acf84-159">在 [!INCLUDE[wv](../../../../includes/wv-md.md)] 上為 ((ReceiveRetryCount+1) * (MaxRetryCycles + 1))。</span><span class="sxs-lookup"><span data-stu-id="acf84-159">((ReceiveRetryCount+1) * (MaxRetryCycles + 1)) on [!INCLUDE[wv](../../../../includes/wv-md.md)].</span></span>  
  
-   <span data-ttu-id="acf84-160">在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上為 (ReceiveRetryCount + 1)。</span><span class="sxs-lookup"><span data-stu-id="acf84-160">(ReceiveRetryCount + 1) on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="acf84-161">成功傳遞的訊息不會有任何重試次數。</span><span class="sxs-lookup"><span data-stu-id="acf84-161">No retries are made for a message that is delivered successfully.</span></span>  
  
 <span data-ttu-id="acf84-162">為了持續追蹤嘗試讀取訊息的次數，[!INCLUDE[wv](../../../../includes/wv-md.md)] 會保留一個計算中止計數之永久訊息屬性，以及另一個移動計數屬性，此屬性會計算訊息在應用程式佇列和子佇列之間移動的次數。</span><span class="sxs-lookup"><span data-stu-id="acf84-162">To keep track of the number of times a message read is attempted, [!INCLUDE[wv](../../../../includes/wv-md.md)] maintains a durable message property that counts the number of aborts and a move count property that counts the number of times the message moves between the application queue and subqueues.</span></span> <span data-ttu-id="acf84-163">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 通道會使用這些屬性計算接收重試次數和重試週期數。</span><span class="sxs-lookup"><span data-stu-id="acf84-163">The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel uses these to compute the receive retry count and the retry cycles count.</span></span> <span data-ttu-id="acf84-164">在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上，中止計數會保留在 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 通道在記憶體中，並且在應用程式失敗時予以重設。</span><span class="sxs-lookup"><span data-stu-id="acf84-164">On [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], the abort count is maintained in memory by the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel and is reset if the application fails.</span></span> <span data-ttu-id="acf84-165">同時，[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 通道可隨時在記憶體中保留最多 256 個訊息的中止計數。</span><span class="sxs-lookup"><span data-stu-id="acf84-165">Also, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] channel can hold the abort counts for up to 256 messages in memory at any time.</span></span> <span data-ttu-id="acf84-166">如果讀取第 257 個訊息，那麼最舊訊息的中止計數就會重設。</span><span class="sxs-lookup"><span data-stu-id="acf84-166">If a 257th message is read, then the oldest message's abort count is reset.</span></span>  
  
 <span data-ttu-id="acf84-167">中止計數和移動計數屬性可透過作業內容提供給服務作業。</span><span class="sxs-lookup"><span data-stu-id="acf84-167">The abort count and move count properties are available to the service operation through the operation context.</span></span> <span data-ttu-id="acf84-168">以下程式碼範例將說明如何存取這兩個屬性。</span><span class="sxs-lookup"><span data-stu-id="acf84-168">The following code example shows how to access them.</span></span>  
  
 [!code-csharp[S_UE_MSMQ_Poison#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/service.cs#1)]  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="acf84-169"> 提供兩個標準的佇列繫結：</span><span class="sxs-lookup"><span data-stu-id="acf84-169"> provides two standard queued bindings:</span></span>  
  
-   <span data-ttu-id="acf84-170"><xref:System.ServiceModel.NetMsmqBinding>。</span><span class="sxs-lookup"><span data-stu-id="acf84-170"><xref:System.ServiceModel.NetMsmqBinding>.</span></span> <span data-ttu-id="acf84-171">[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 繫結，適合用來與其他 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 端點進行以佇列為主的通訊。</span><span class="sxs-lookup"><span data-stu-id="acf84-171">A [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] binding suitable for performing queue-based communication with other [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] endpoints.</span></span>  
  
-   <span data-ttu-id="acf84-172"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>。</span><span class="sxs-lookup"><span data-stu-id="acf84-172"><xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding>.</span></span> <span data-ttu-id="acf84-173">此繫結適合用來與現有的訊息佇列應用程式進行通訊。</span><span class="sxs-lookup"><span data-stu-id="acf84-173">A binding suitable for communicating with existing Message Queuing applications.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="acf84-174">您可以根據 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 服務的需求，在這兩個繫結中修改這些屬性。</span><span class="sxs-lookup"><span data-stu-id="acf84-174">You can alter properties in these bindings based on the requirements of your [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service.</span></span> <span data-ttu-id="acf84-175">對於接收應用程式而言，整個有害訊息處理機制是在本機上進行的。</span><span class="sxs-lookup"><span data-stu-id="acf84-175">The entire poison message handling mechanism is local to the receiving application.</span></span> <span data-ttu-id="acf84-176">傳送應用程式看不到這個程序，除非接收應用程式最後停止並且將負值通知傳回至傳送者。</span><span class="sxs-lookup"><span data-stu-id="acf84-176">The process is invisible to the sending application unless the receiving application ultimately stops and sends a negative acknowledgment back to the sender.</span></span> <span data-ttu-id="acf84-177">在這種情況下，訊息會移到傳送者寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="acf84-177">In that case, the message is moved to the sender's dead-letter queue.</span></span>  
  
## <a name="best-practice-handling-msmqpoisonmessageexception"></a><span data-ttu-id="acf84-178">最佳做法：處理 MsmqPoisonMessageException</span><span class="sxs-lookup"><span data-stu-id="acf84-178">Best Practice: Handling MsmqPoisonMessageException</span></span>  
 <span data-ttu-id="acf84-179">當服務判定訊息是有害時，佇列的傳輸便會擲回 <xref:System.ServiceModel.MsmqPoisonMessageException>，其中包含有害訊息的 `LookupId`。</span><span class="sxs-lookup"><span data-stu-id="acf84-179">When the service determines that a message is poison, the queued transport throws a <xref:System.ServiceModel.MsmqPoisonMessageException> that contains the `LookupId` of the poison message.</span></span>  
  
 <span data-ttu-id="acf84-180">接收應用程式可實作 <xref:System.ServiceModel.Dispatcher.IErrorHandler> 介面，以處理應用程式所需的任何錯誤。</span><span class="sxs-lookup"><span data-stu-id="acf84-180">A receiving application can implement the <xref:System.ServiceModel.Dispatcher.IErrorHandler> interface to handle any errors that the application requires.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="acf84-181">[擴充對錯誤處理和報告的控制](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md)。</span><span class="sxs-lookup"><span data-stu-id="acf84-181"> [Extending Control Over Error Handling and Reporting](../../../../docs/framework/wcf/samples/extending-control-over-error-handling-and-reporting.md).</span></span>  
  
 <span data-ttu-id="acf84-182">應用程式可能需要以某種自動處理的方式將有害訊息移至有害訊息序列，讓服務能夠存取佇列中其餘的訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-182">The application may require some kind of automated handling of poison messages that moves the poison messages to a poison message queue so that the service can access the rest of the messages in the queue.</span></span> <span data-ttu-id="acf84-183">唯一會使用錯誤處理常式機制接聽有害訊息例外狀況的情況，是在 <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> 設定設為 <xref:System.ServiceModel.ReceiveErrorHandling.Fault> 的時候。</span><span class="sxs-lookup"><span data-stu-id="acf84-183">The only scenario for using the error-handler mechanism to listen for poison-message exceptions is when the <xref:System.ServiceModel.Configuration.MsmqBindingElementBase.ReceiveErrorHandling%2A> setting is set to <xref:System.ServiceModel.ReceiveErrorHandling.Fault>.</span></span> <span data-ttu-id="acf84-184">Message Queuing 3.0 的有害訊息範例會示範這種行為。</span><span class="sxs-lookup"><span data-stu-id="acf84-184">The poison-message sample for Message Queuing 3.0 demonstrates this behavior.</span></span> <span data-ttu-id="acf84-185">以下將說明處理有害訊息時所採取的步驟，包括最佳做法：</span><span class="sxs-lookup"><span data-stu-id="acf84-185">The following outlines the steps to take to handle poison messages, including best practices:</span></span>  
  
1.  <span data-ttu-id="acf84-186">請確認您的有害設定能反映您應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="acf84-186">Ensure your poison settings reflect the requirements of your application.</span></span> <span data-ttu-id="acf84-187">處理設定時，務必確實了解 [!INCLUDE[wv](../../../../includes/wv-md.md)]、[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上訊息佇列功能之間的差異。</span><span class="sxs-lookup"><span data-stu-id="acf84-187">When working with the settings, ensure that you understand the differences between the capabilities of Message Queuing on [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
2.  <span data-ttu-id="acf84-188">如有需要，請實作 `IErrorHandler` 來處理有害訊息錯誤。</span><span class="sxs-lookup"><span data-stu-id="acf84-188">If required, implement the `IErrorHandler` to handle poison-message errors.</span></span> <span data-ttu-id="acf84-189">由於將 `ReceiveErrorHandling` 設為 `Fault` 時需要使用手動機制將有害訊息從佇列中移出，或更正外部相關的問題，因此通常的使用方式是在 `IErrorHandler` 設為 `ReceiveErrorHandling` 時實作 `Fault`，如下列程式碼中所示。</span><span class="sxs-lookup"><span data-stu-id="acf84-189">Because setting `ReceiveErrorHandling` to `Fault` requires a manual mechanism to move the poison message out of the queue or to correct an external dependent issue, the typical usage is to implement `IErrorHandler` when `ReceiveErrorHandling` is set to `Fault`, as shown in the following code.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonerrorhandler.cs#2)]  
  
3.  <span data-ttu-id="acf84-190">建立服務行為可使用的 `PoisonBehaviorAttribute`。</span><span class="sxs-lookup"><span data-stu-id="acf84-190">Create a `PoisonBehaviorAttribute` that the service behavior can use.</span></span> <span data-ttu-id="acf84-191">這個行為會在發送器上安裝 `IErrorHandler`。</span><span class="sxs-lookup"><span data-stu-id="acf84-191">The behavior installs the `IErrorHandler` on the dispatcher.</span></span> <span data-ttu-id="acf84-192">請參閱以下程式碼範例。</span><span class="sxs-lookup"><span data-stu-id="acf84-192">See the following code example.</span></span>  
  
     [!code-csharp[S_UE_MSMQ_Poison#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/s_ue_msmq_poison/cs/poisonbehaviorattribute.cs#3)]  
  
4.  <span data-ttu-id="acf84-193">確認您的服務已加上有害行為屬性的註解。</span><span class="sxs-lookup"><span data-stu-id="acf84-193">Ensure that your service is annotated with the poison behavior attribute.</span></span>  
  
  
  
 <span data-ttu-id="acf84-194">此外，如果 `ReceiveErrorHandling` 設為 `Fault`，則 `ServiceHost` 會在遇到有害訊息時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="acf84-194">In addition, if the `ReceiveErrorHandling` is set to `Fault`, the `ServiceHost` faults when encountering the poison message.</span></span> <span data-ttu-id="acf84-195">您可以連結到發生錯誤的事件並關閉服務、採取更正的動作，然後重新啟動。</span><span class="sxs-lookup"><span data-stu-id="acf84-195">You can hook up to the faulted event and shut down the service, take corrective actions, and restart.</span></span> <span data-ttu-id="acf84-196">例如，可以標註傳播至 `LookupId` 的 <xref:System.ServiceModel.MsmqPoisonMessageException> 中的 `IErrorHandler`，當服務主機發生錯誤時，您就可以使用 `System.Messaging` API 接收來自佇列的訊息 (使用 `LookupId` 移除佇列中的訊息)，以及將訊息保存在某些外部儲存區或另一個佇列中。</span><span class="sxs-lookup"><span data-stu-id="acf84-196">For example, the `LookupId` in the <xref:System.ServiceModel.MsmqPoisonMessageException> propagated to the `IErrorHandler` can be noted and when the service host faults, you could use the `System.Messaging` API to receive the message from the queue using the `LookupId` to remove the message from the queue and store the message in some external store or another queue.</span></span> <span data-ttu-id="acf84-197">然後您可以重新啟動 `ServiceHost` 並繼續進行正常處理。</span><span class="sxs-lookup"><span data-stu-id="acf84-197">You can then restart `ServiceHost` to resume normal processing.</span></span> <span data-ttu-id="acf84-198">[有害訊息處理 MSMQ 4.0 中](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md)示範此行為。</span><span class="sxs-lookup"><span data-stu-id="acf84-198">The [Poison Message Handling in MSMQ 4.0](../../../../docs/framework/wcf/samples/poison-message-handling-in-msmq-4-0.md) demonstrates this behavior.</span></span>  
  
## <a name="transaction-time-out-and-poison-messages"></a><span data-ttu-id="acf84-199">異動逾時及有害訊息</span><span class="sxs-lookup"><span data-stu-id="acf84-199">Transaction Time-Out and Poison Messages</span></span>  
 <span data-ttu-id="acf84-200">佇列傳輸通道和使用者程式碼之間可能會發生一種類別的錯誤。</span><span class="sxs-lookup"><span data-stu-id="acf84-200">A class of errors can occur between the queued transport channel and the user code.</span></span> <span data-ttu-id="acf84-201">這些錯誤可能會在中間的各層中偵測到，例如訊息安全層或服務分派邏輯。</span><span class="sxs-lookup"><span data-stu-id="acf84-201">These errors can be detected by layers in-between, such as the message security layer or the service dispatching logic.</span></span> <span data-ttu-id="acf84-202">例如，在 SOAP 安全層中偵測到遺失了 X.509 憑證，以及遺失的動作就是訊息會被分派至應用程式的情況。</span><span class="sxs-lookup"><span data-stu-id="acf84-202">For example, a missing X.509 certificate detected in the SOAP security layer and a missing action are cases where the message does get dispatched to the application.</span></span> <span data-ttu-id="acf84-203">發生這類情況時，服務模型會捨棄訊息。</span><span class="sxs-lookup"><span data-stu-id="acf84-203">When this happens, the service model drops the message.</span></span> <span data-ttu-id="acf84-204">由於訊息是在交易中讀取，而且不會提供交易的結果，因此交易最後會逾時、中止，而訊息則會放回佇列中。</span><span class="sxs-lookup"><span data-stu-id="acf84-204">Because the message is read in a transaction and an outcome for that transaction cannot be provided, the transaction eventually times out, aborts, and the message is put back into the queue.</span></span> <span data-ttu-id="acf84-205">換言之，針對特定類別的錯誤，交易不會立即中止，而是會等待直到交易逾時。您可以使用 <xref:System.ServiceModel.ServiceBehaviorAttribute> 修改服務的交易逾時。</span><span class="sxs-lookup"><span data-stu-id="acf84-205">In other words, for a certain class of errors, the transaction does not immediately abort but waits until the transaction times out. You can modify the transaction time-out for a service using <xref:System.ServiceModel.ServiceBehaviorAttribute>.</span></span>  
  
 <span data-ttu-id="acf84-206">若要能在電腦上通用的原則下變更交易逾時，請修改 machine.config 檔案，並且設定適當的交易逾時。要注意的是，交易最後會根據所設定的逾時而中止，並回到佇列中，並且會遞增其中止計數。</span><span class="sxs-lookup"><span data-stu-id="acf84-206">To change the transaction time-out on a computer-wide basis, modify the machine.config file and set the appropriate transaction time-out. It is important to note that, depending on the time-out set in the transaction, the transaction eventually aborts and goes back to the queue and its abort count is incremented.</span></span> <span data-ttu-id="acf84-207">最後，訊息會變成有害，並且根據使用者的設定進行正確的處置。</span><span class="sxs-lookup"><span data-stu-id="acf84-207">Eventually, the message becomes poison and the right disposition is made according to the user settings.</span></span>  
  
## <a name="sessions-and-poison-messages"></a><span data-ttu-id="acf84-208">工作階段及有害訊息</span><span class="sxs-lookup"><span data-stu-id="acf84-208">Sessions and Poison Messages</span></span>  
 <span data-ttu-id="acf84-209">工作階段如同單一訊息一樣，會進行相同的重試和有害訊息處理程序。</span><span class="sxs-lookup"><span data-stu-id="acf84-209">A session undergoes the same retry and poison-message handling procedures as a single message.</span></span> <span data-ttu-id="acf84-210">先前所列出的有害訊息屬性會套用到整個工作階段。</span><span class="sxs-lookup"><span data-stu-id="acf84-210">The properties previously listed for poison messages apply to the entire session.</span></span> <span data-ttu-id="acf84-211">這表示會重試整個工作階段，而且如果訊息遭拒絕，將移至最後的有害訊息佇列或傳送者寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="acf84-211">This means that the entire session is retried and goes to a final poison-message queue or the sender’s dead-letter queue if the message is rejected.</span></span>  
  
## <a name="batching-and-poison-messages"></a><span data-ttu-id="acf84-212">批次處理及有害訊息</span><span class="sxs-lookup"><span data-stu-id="acf84-212">Batching and Poison Messages</span></span>  
 <span data-ttu-id="acf84-213">如果訊息變成有害訊息，而且是批次的一部分，那麼整個批次都會復原，而通道會回到一次讀取一個訊息的狀態。</span><span class="sxs-lookup"><span data-stu-id="acf84-213">If a message becomes a poison message and is part of a batch, then the entire batch is rolled back and the channel returns to reading one message at a time.</span></span> [!INCLUDE[crabout](../../../../includes/crabout-md.md)]<span data-ttu-id="acf84-214">批次處理，請參閱[異動中批次處理的訊息](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</span><span class="sxs-lookup"><span data-stu-id="acf84-214"> batching, see [Batching Messages in a Transaction](../../../../docs/framework/wcf/feature-details/batching-messages-in-a-transaction.md)</span></span>  
  
## <a name="poison-message-handling-for-messages-in-a-poison-queue"></a><span data-ttu-id="acf84-215">有害佇列中之訊息的有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="acf84-215">Poison-message Handling for Messages in a Poison Queue</span></span>  
 <span data-ttu-id="acf84-216">當訊息放入有害訊息佇列時，有害訊息處理就不會結束。</span><span class="sxs-lookup"><span data-stu-id="acf84-216">Poison-message handling does not end when a message is placed in the poison-message queue.</span></span> <span data-ttu-id="acf84-217">有害訊息佇列中的訊息必須繼續讀取和處理。</span><span class="sxs-lookup"><span data-stu-id="acf84-217">Messages in the poison-message queue must still be read and handled.</span></span> <span data-ttu-id="acf84-218">您可以在最終有害子佇列中讀取訊息時，使用有害訊息處理設定的子集。</span><span class="sxs-lookup"><span data-stu-id="acf84-218">You can use a subset of the poison-message handling settings when reading messages from the final poison subqueue.</span></span> <span data-ttu-id="acf84-219">適當的設定為 `ReceiveRetryCount` 和 `ReceiveErrorHandling`。</span><span class="sxs-lookup"><span data-stu-id="acf84-219">The applicable settings are `ReceiveRetryCount` and `ReceiveErrorHandling`.</span></span> <span data-ttu-id="acf84-220">您可以將 `ReceiveErrorHandling` 設定為 Drop、Reject 或 Fault。</span><span class="sxs-lookup"><span data-stu-id="acf84-220">You can set `ReceiveErrorHandling` to Drop, Reject, or Fault.</span></span> <span data-ttu-id="acf84-221">如果 `MaxRetryCycles` 設為 Move，則會忽略 `ReceiveErrorHandling` 並且擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="acf84-221">`MaxRetryCycles` is ignored and an exception is thrown if `ReceiveErrorHandling` is set to Move.</span></span>  
  
## <a name="windows-vista-windows-server-2003-and-windows-xp-differences"></a><span data-ttu-id="acf84-222">Windows Vista、Windows Server 2003 及 Windows XP 的差異</span><span class="sxs-lookup"><span data-stu-id="acf84-222">Windows Vista, Windows Server 2003, and Windows XP Differences</span></span>  
 <span data-ttu-id="acf84-223">如之前所述，並非所有有害訊息處理設定都適用於 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="acf84-223">As noted earlier, not all poison-message handling settings apply to [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> <span data-ttu-id="acf84-224">下列 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)]、[!INCLUDE[wxp](../../../../includes/wxp-md.md)] 和 [!INCLUDE[wv](../../../../includes/wv-md.md)] 上之訊息佇列間的主要差異，都與有害訊息處理相關：</span><span class="sxs-lookup"><span data-stu-id="acf84-224">The following key differences between Message Queuing on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], [!INCLUDE[wxp](../../../../includes/wxp-md.md)], and [!INCLUDE[wv](../../../../includes/wv-md.md)] are relevant to poison-message handling:</span></span>  
  
-   <span data-ttu-id="acf84-225">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的訊息佇列支援子佇列，而 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 則不支援子佇列。</span><span class="sxs-lookup"><span data-stu-id="acf84-225">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports subqueues, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not support subqueues.</span></span> <span data-ttu-id="acf84-226">子佇列是在有害訊息處理中使用。</span><span class="sxs-lookup"><span data-stu-id="acf84-226">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="acf84-227">重試佇列和有害佇列都是應用程式佇列的子佇列，應用程式佇列是根據有害訊息處理設定而建立的。</span><span class="sxs-lookup"><span data-stu-id="acf84-227">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="acf84-228">`MaxRetryCycles` 會指示要建立多少重試子佇列。</span><span class="sxs-lookup"><span data-stu-id="acf84-228">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="acf84-229">因此，當在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 或 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上執行時，會略過 `MaxRetryCycles` 並且不允許 `ReceiveErrorHandling.Move`。</span><span class="sxs-lookup"><span data-stu-id="acf84-229">Therefore, when running on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] or [!INCLUDE[wxp](../../../../includes/wxp-md.md)], `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
-   <span data-ttu-id="acf84-230">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的訊息佇列支援負值通知，而 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 則不支援。</span><span class="sxs-lookup"><span data-stu-id="acf84-230">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports negative acknowledgment, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not.</span></span> <span data-ttu-id="acf84-231">來自接收佇列管理員的負認可會造成傳送佇列管理員將拒絕的訊息放在寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="acf84-231">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="acf84-232">因此，`ReceiveErrorHandling.Reject` 和 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 不可使用 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="acf84-232">As such, `ReceiveErrorHandling.Reject` is not allowed with [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
-   <span data-ttu-id="acf84-233">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的訊息佇列支援能夠保留嘗試傳遞訊息之計數的訊息屬性</span><span class="sxs-lookup"><span data-stu-id="acf84-233">Message Queuing in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="acf84-234">這個中止計數屬性無法在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上使用。</span><span class="sxs-lookup"><span data-stu-id="acf84-234">This abort count property is not available on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> <span data-ttu-id="acf84-235">由於 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 會在記憶體中保留中止計數，因此當伺服陣列中超過一個以上的 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 服務讀取相同的訊息時，這個屬性可能就無法包含精確的值。</span><span class="sxs-lookup"><span data-stu-id="acf84-235">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service in a farm.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="acf84-236">請參閱</span><span class="sxs-lookup"><span data-stu-id="acf84-236">See Also</span></span>  
 [<span data-ttu-id="acf84-237">佇列概觀</span><span class="sxs-lookup"><span data-stu-id="acf84-237">Queues Overview</span></span>](../../../../docs/framework/wcf/feature-details/queues-overview.md)  
 [<span data-ttu-id="acf84-238">Windows Vista、Windows Server 2003 和 Windows XP 之間的佇列功能差異</span><span class="sxs-lookup"><span data-stu-id="acf84-238">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>](../../../../docs/framework/wcf/feature-details/diff-in-queue-in-vista-server-2003-windows-xp.md)  
 [<span data-ttu-id="acf84-239">指定及處理合約與服務中的錯誤</span><span class="sxs-lookup"><span data-stu-id="acf84-239">Specifying and Handling Faults in Contracts and Services</span></span>](../../../../docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md)
