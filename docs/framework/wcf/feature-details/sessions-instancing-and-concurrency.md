---
title: "工作階段、執行個體與並行"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 50797a3b-7678-44ed-8138-49ac1602f35b
caps.latest.revision: "16"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 5d4559f177b05f7d238c9f30649a5b01af7fb6f9
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/22/2017
---
# <a name="sessions-instancing-and-concurrency"></a><span data-ttu-id="9e83e-102">工作階段、執行個體與並行</span><span class="sxs-lookup"><span data-stu-id="9e83e-102">Sessions, Instancing, and Concurrency</span></span>
<span data-ttu-id="9e83e-103">「 *工作階段* 」(Session) 是兩個端點之間所傳送之所有訊息的相互關聯。</span><span class="sxs-lookup"><span data-stu-id="9e83e-103">A *session* is a correlation of all messages sent between two endpoints.</span></span> <span data-ttu-id="9e83e-104">「*執行個體* 」(Instancing) 是指控制使用者定義之服務物件的存留時間，以及其相關的 <xref:System.ServiceModel.InstanceContext> 物件。</span><span class="sxs-lookup"><span data-stu-id="9e83e-104">*Instancing* refers to controlling the lifetime of user-defined service objects and their related <xref:System.ServiceModel.InstanceContext> objects.</span></span> <span data-ttu-id="9e83e-105">「*並行* 」(Concurrency) 是指控制在 <xref:System.ServiceModel.InstanceContext> 中同時執行的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="9e83e-105">*Concurrency* is the term given to the control of the number of threads executing in an <xref:System.ServiceModel.InstanceContext> at the same time.</span></span>  
  
 <span data-ttu-id="9e83e-106">本主題將說明這些設定、這些設定的使用方式，以及這些設定間的各種互動。</span><span class="sxs-lookup"><span data-stu-id="9e83e-106">This topic describes these settings, how to use them, and the various interactions between them.</span></span>  
  
## <a name="sessions"></a><span data-ttu-id="9e83e-107">工作階段</span><span class="sxs-lookup"><span data-stu-id="9e83e-107">Sessions</span></span>  
 <span data-ttu-id="9e83e-108">當服務合約將 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 屬性設定為 <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType> 時，該合約會指出所有的呼叫 (即支援呼叫的基礎訊息交換模式) 必須是同一個對話的一部分。</span><span class="sxs-lookup"><span data-stu-id="9e83e-108">When a service contract sets the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.SessionMode.Required?displayProperty=nameWithType>, that contract is saying that all calls (that is, the underlying message exchanges that support the calls) must be part of the same conversation.</span></span> <span data-ttu-id="9e83e-109">如果合約指定其允許工作階段，但不需要工作階段，則用戶端可以連線，並選擇是否要建立工作階段。</span><span class="sxs-lookup"><span data-stu-id="9e83e-109">If a contract specifies that it allows sessions but does not require one, clients can connect and either establish a session or not.</span></span> <span data-ttu-id="9e83e-110">如果工作階段終止並透過相同之工作階段型的通道傳送訊息，就會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9e83e-110">If the session ends and a message is sent over the same session-based channel an exception is thrown.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="9e83e-111"> 工作階段在概念上有下列主要特色：</span><span class="sxs-lookup"><span data-stu-id="9e83e-111"> sessions have the following main conceptual features:</span></span>  
  
-   <span data-ttu-id="9e83e-112">工作階段是由呼叫的應用程式明確地初始化及終止。</span><span class="sxs-lookup"><span data-stu-id="9e83e-112">They are explicitly initiated and terminated by the calling application.</span></span>  
  
-   <span data-ttu-id="9e83e-113">工作階段期間傳遞的訊息是依其接收的順序進行處理。</span><span class="sxs-lookup"><span data-stu-id="9e83e-113">Messages delivered during a session are processed in the order in which they are received.</span></span>  
  
-   <span data-ttu-id="9e83e-114">工作階段會將一群訊息互相關聯為對話。</span><span class="sxs-lookup"><span data-stu-id="9e83e-114">Sessions correlate a group of messages into a conversation.</span></span> <span data-ttu-id="9e83e-115">此相互關聯的意義是一種抽象概念。</span><span class="sxs-lookup"><span data-stu-id="9e83e-115">The meaning of that correlation is an abstraction.</span></span> <span data-ttu-id="9e83e-116">例如，某個工作階段架構通道可能會根據共用的網路連線將訊息相互關聯，而另一個工作階段架構通道可能會根據訊息本文內的共用標記將訊息相互關聯。</span><span class="sxs-lookup"><span data-stu-id="9e83e-116">For instance, one session-based channel may correlate messages based on a shared network connection while another session-based channel may correlate messages based on a shared tag in the message body.</span></span> <span data-ttu-id="9e83e-117">這些可以衍生自工作階段的功能視相互關聯的本質而定。</span><span class="sxs-lookup"><span data-stu-id="9e83e-117">The features that can be derived from the session depend on the nature of the correlation.</span></span>  
  
-   <span data-ttu-id="9e83e-118">沒有與 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 工作階段關聯的一般資料存放區。</span><span class="sxs-lookup"><span data-stu-id="9e83e-118">There is no general data store associated with a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] session.</span></span>  
  
 <span data-ttu-id="9e83e-119">如果您很熟悉 <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> 應用程式內的 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 類別及其所提供的功能，則您可能會注意到這類工作階段和 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 工作階段之間有下列不同之處：</span><span class="sxs-lookup"><span data-stu-id="9e83e-119">If you are familiar with the <xref:System.Web.SessionState.HttpSessionState?displayProperty=nameWithType> class in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] applications and the functionality it provides, you might notice the following differences between that kind of session and [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] sessions:</span></span>  
  
-   [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]<span data-ttu-id="9e83e-120"> 工作階段一律由伺服器啟動。</span><span class="sxs-lookup"><span data-stu-id="9e83e-120"> sessions are always server-initiated.</span></span>  
  
-   [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]<span data-ttu-id="9e83e-121"> 工作階段具有隱含未排序特性。</span><span class="sxs-lookup"><span data-stu-id="9e83e-121"> sessions are implicitly unordered.</span></span>  
  
-   [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)]<span data-ttu-id="9e83e-122"> 工作階段提供了跨要求的一般資料儲存機制。</span><span class="sxs-lookup"><span data-stu-id="9e83e-122"> sessions provide a general data storage mechanism across requests.</span></span>  
  
 <span data-ttu-id="9e83e-123">用戶端應用程式和服務應用程式會以不同的方式與工作階段互動。</span><span class="sxs-lookup"><span data-stu-id="9e83e-123">Client applications and service applications interact with sessions in different ways.</span></span> <span data-ttu-id="9e83e-124">用戶端應用程式會初始化工作階段，接著並接收及處理在工作階段內傳送的訊息。</span><span class="sxs-lookup"><span data-stu-id="9e83e-124">Client applications initiate sessions and then receive and process the messages sent within the session.</span></span> <span data-ttu-id="9e83e-125">服務應用程式可以將工作階段當做擴充點使用，以便加入其他行為。</span><span class="sxs-lookup"><span data-stu-id="9e83e-125">Service applications can use sessions as an extensibility point to add additional behavior.</span></span> <span data-ttu-id="9e83e-126">其做法是直接使用 <xref:System.ServiceModel.InstanceContext> 或實作自訂的執行個體內容提供者。</span><span class="sxs-lookup"><span data-stu-id="9e83e-126">This is done by working directly with the <xref:System.ServiceModel.InstanceContext> or implementing a custom instance context provider.</span></span>  
  
## <a name="instancing"></a><span data-ttu-id="9e83e-127">執行個體</span><span class="sxs-lookup"><span data-stu-id="9e83e-127">Instancing</span></span>  
 <span data-ttu-id="9e83e-128">執行個體行為 (使用 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 屬性設定) 會控制 <xref:System.ServiceModel.InstanceContext> 對傳入訊息建立回應的方法。</span><span class="sxs-lookup"><span data-stu-id="9e83e-128">The instancing behavior (set by using the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property) controls how the <xref:System.ServiceModel.InstanceContext> is created in response to incoming messages.</span></span> <span data-ttu-id="9e83e-129">根據預設，每一個 <xref:System.ServiceModel.InstanceContext> 都會與一個使用者定義的服務物件產生關聯，因此 (在預設的情形下) 設定 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> 屬性也會控制使用者定義之服務物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="9e83e-129">By default, each <xref:System.ServiceModel.InstanceContext> is associated with one user-defined service object, so (in the default case) setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> property also controls the instancing of user-defined service objects.</span></span> <span data-ttu-id="9e83e-130"><xref:System.ServiceModel.InstanceContextMode> 列舉型別 (Enumeration) 會定義執行個體模式。</span><span class="sxs-lookup"><span data-stu-id="9e83e-130">The <xref:System.ServiceModel.InstanceContextMode> enumeration defines the instancing modes.</span></span>  
  
 <span data-ttu-id="9e83e-131">以下為可用的執行個體模式：</span><span class="sxs-lookup"><span data-stu-id="9e83e-131">The following instancing modes are available:</span></span>  
  
-   <span data-ttu-id="9e83e-132"><xref:System.ServiceModel.InstanceContextMode.PerCall>：為每個用戶端要求所建立的新 <xref:System.ServiceModel.InstanceContext> (因此為服務物件)。</span><span class="sxs-lookup"><span data-stu-id="9e83e-132"><xref:System.ServiceModel.InstanceContextMode.PerCall>: A new <xref:System.ServiceModel.InstanceContext> (and therefore service object) is created for each client request.</span></span>  
  
-   <span data-ttu-id="9e83e-133"><xref:System.ServiceModel.InstanceContextMode.PerSession>：為每個新用戶端工作階段所建立的新 <xref:System.ServiceModel.InstanceContext> (因此為服務物件)，並維持該工作階段的存留期 (這麼做需要支援工作階段的繫結)。</span><span class="sxs-lookup"><span data-stu-id="9e83e-133"><xref:System.ServiceModel.InstanceContextMode.PerSession>: A new <xref:System.ServiceModel.InstanceContext> (and therefore service object) is created for each new client session and maintained for the lifetime of that session (this requires a binding that supports sessions).</span></span>  
  
-   <span data-ttu-id="9e83e-134"><xref:System.ServiceModel.InstanceContextMode.Single>：單一的 <xref:System.ServiceModel.InstanceContext> (因此為服務物件)，負責處理所有應用程式之存留期的用戶端要求。</span><span class="sxs-lookup"><span data-stu-id="9e83e-134"><xref:System.ServiceModel.InstanceContextMode.Single>: A single <xref:System.ServiceModel.InstanceContext> (and therefore service object) handles all client requests for the lifetime of the application.</span></span>  
  
 <span data-ttu-id="9e83e-135">下列程式碼範例示範預設的 <xref:System.ServiceModel.InstanceContextMode> 值，在服務類別上會明確地設定 <xref:System.ServiceModel.InstanceContextMode.PerSession> 。</span><span class="sxs-lookup"><span data-stu-id="9e83e-135">The following code example shows the default <xref:System.ServiceModel.InstanceContextMode> value, <xref:System.ServiceModel.InstanceContextMode.PerSession> being explicitly set on a service class.</span></span>  
  
```  
[ServiceBehavior(InstanceContextMode=InstanceContextMode.PerSession)]   
public class CalculatorService : ICalculatorInstance   
{   
    ...  
}  
```  
  
 <span data-ttu-id="9e83e-136">當 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 屬性控制釋放 <xref:System.ServiceModel.InstanceContext> 的頻率時，<xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> 和 <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A?displayProperty=nameWithType> 屬性會控制釋放服務物件的時機。</span><span class="sxs-lookup"><span data-stu-id="9e83e-136">And while the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property controls how often the <xref:System.ServiceModel.InstanceContext> is released, the <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> and <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A?displayProperty=nameWithType> properties control when the service object is released.</span></span>  
  
### <a name="well-known-singleton-services"></a><span data-ttu-id="9e83e-137">已知的單一服務</span><span class="sxs-lookup"><span data-stu-id="9e83e-137">Well-Known Singleton Services</span></span>  
 <span data-ttu-id="9e83e-138">單一執行個體服務物件的其中一個變化有時可能會很有用處：您可以自行建立服務物件，並建立使用該物件的服務主機。</span><span class="sxs-lookup"><span data-stu-id="9e83e-138">One variation on single instance service objects is sometimes useful: you can create a service object yourself and create the service host using that object.</span></span> <span data-ttu-id="9e83e-139">若要這麼做，您必須同時將 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 屬性設定為 <xref:System.ServiceModel.InstanceContextMode.Single>，否則在開啟服務主機時會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9e83e-139">To do so, you must also set the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property to <xref:System.ServiceModel.InstanceContextMode.Single> or an exception is thrown when the service host is opened.</span></span>  
  
 <span data-ttu-id="9e83e-140">請使用 <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> 建構函式建立此類服務。</span><span class="sxs-lookup"><span data-stu-id="9e83e-140">Use the <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType> constructor to create such a service.</span></span> <span data-ttu-id="9e83e-141">當您想要將特定物件執行個體提供給單一服務使用時，它提供了另一種實作自訂 <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> 的方式。</span><span class="sxs-lookup"><span data-stu-id="9e83e-141">It provides an alternative to implementing a custom <xref:System.ServiceModel.Dispatcher.IInstanceContextInitializer?displayProperty=nameWithType> when you wish to provide a specific object instance for use by a singleton service.</span></span> <span data-ttu-id="9e83e-142">當服務實作類型很難建構時 (例如，無法實作沒有參數的預設公用建構函式時)，您可以使用這個多載。</span><span class="sxs-lookup"><span data-stu-id="9e83e-142">You can use this overload when your service implementation type is difficult to construct (for example, if it does not implement a default parameterless public constructor).</span></span>  
  
 <span data-ttu-id="9e83e-143">請注意，提供物件給這個建構函式時，某些與 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] 執行個體行為相關的功能會以不同的方式運作。</span><span class="sxs-lookup"><span data-stu-id="9e83e-143">Note that when an object is provided to this constructor, some features related to the [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] instancing behavior work differently.</span></span> <span data-ttu-id="9e83e-144">例如，提供單一物件執行個體時，呼叫 <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> 將沒有任何作用。</span><span class="sxs-lookup"><span data-stu-id="9e83e-144">For example, calling <xref:System.ServiceModel.InstanceContext.ReleaseServiceInstance%2A?displayProperty=nameWithType> has no effect when a singleton object instance is provided.</span></span> <span data-ttu-id="9e83e-145">同樣的，也會忽略任何其他執行個體的釋放機制。</span><span class="sxs-lookup"><span data-stu-id="9e83e-145">Similarly, any other instance-release mechanism is ignored.</span></span> <span data-ttu-id="9e83e-146"><xref:System.ServiceModel.ServiceHost> 的行為就像是所有作業都已將 <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> 屬性設定為 <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9e83e-146">The <xref:System.ServiceModel.ServiceHost> always behaves as if the <xref:System.ServiceModel.OperationBehaviorAttribute.ReleaseInstanceMode%2A?displayProperty=nameWithType> property is set to <xref:System.ServiceModel.ReleaseInstanceMode.None?displayProperty=nameWithType> for all operations.</span></span>  
  
### <a name="sharing-instancecontext-objects"></a><span data-ttu-id="9e83e-147">共用 InstanceContext 物件</span><span class="sxs-lookup"><span data-stu-id="9e83e-147">Sharing InstanceContext Objects</span></span>  
 <span data-ttu-id="9e83e-148">您也可以自行執行該關聯，以控制哪個工作階段通道或呼叫應與哪個 <xref:System.ServiceModel.InstanceContext> 物件產生關聯。</span><span class="sxs-lookup"><span data-stu-id="9e83e-148">You can also control which sessionful channel or call is associated with which <xref:System.ServiceModel.InstanceContext> object by performing that association yourself.</span></span>  
  
## <a name="concurrency"></a><span data-ttu-id="9e83e-149">並行</span><span class="sxs-lookup"><span data-stu-id="9e83e-149">Concurrency</span></span>  
 <span data-ttu-id="9e83e-150">並行是指控制在 <xref:System.ServiceModel.InstanceContext> 內同時為作用中的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="9e83e-150">Concurrency is the control of the number of threads active in an <xref:System.ServiceModel.InstanceContext> at any one time.</span></span> <span data-ttu-id="9e83e-151">這是透過使用 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> 與 <xref:System.ServiceModel.ConcurrencyMode> 列舉型別的方式予以控制。</span><span class="sxs-lookup"><span data-stu-id="9e83e-151">This is controlled by using the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A?displayProperty=nameWithType> with the <xref:System.ServiceModel.ConcurrencyMode> enumeration.</span></span>  
  
 <span data-ttu-id="9e83e-152">以下為可用的三種並行模式：</span><span class="sxs-lookup"><span data-stu-id="9e83e-152">The following three concurrency modes are available:</span></span>  
  
-   <span data-ttu-id="9e83e-153"><xref:System.ServiceModel.ConcurrencyMode.Single>：每一個執行個體內容同時最多可以在執行個體內容中，擁有一個處理訊息的執行緒。</span><span class="sxs-lookup"><span data-stu-id="9e83e-153"><xref:System.ServiceModel.ConcurrencyMode.Single>: Each instance context is allowed to have a maximum of one thread processing messages in the instance context at a time.</span></span> <span data-ttu-id="9e83e-154">其他希望使用相同執行個體內容的執行緒必須封鎖，直到原始的執行緒結束執行個體內容為止。</span><span class="sxs-lookup"><span data-stu-id="9e83e-154">Other threads wishing to use the same instance context must block until the original thread exits the instance context.</span></span>  
  
-   <span data-ttu-id="9e83e-155"><xref:System.ServiceModel.ConcurrencyMode.Multiple>：每一個服務執行個體都可以同時擁有多個處理訊息的執行緒。</span><span class="sxs-lookup"><span data-stu-id="9e83e-155"><xref:System.ServiceModel.ConcurrencyMode.Multiple>: Each service instance can have multiple threads processing messages concurrently.</span></span> <span data-ttu-id="9e83e-156">此服務實作必須是安全執行緒，才能使用這種並行模式。</span><span class="sxs-lookup"><span data-stu-id="9e83e-156">The service implementation must be thread-safe to use this concurrency mode.</span></span>  
  
-   <span data-ttu-id="9e83e-157"><xref:System.ServiceModel.ConcurrencyMode.Reentrant>：每一個服務執行個體在同一時間內會處理一個訊息，但接受可重新進入 (Re-entrant) 的作業呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-157"><xref:System.ServiceModel.ConcurrencyMode.Reentrant>: Each service instance processes one message at a time, but accepts re-entrant operation calls.</span></span> <span data-ttu-id="9e83e-158">此服務只在其透過 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 用戶端物件向外呼叫時，才會接受這些呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-158">The service only accepts these calls when it is calling out through a [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] client object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9e83e-159">您應該了解，開發能夠安全地使用一個以上之執行緒的程式碼，可能會很難順利地撰寫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-159">Understanding and developing code that safely uses more than one thread can be difficult to write successfully.</span></span> <span data-ttu-id="9e83e-160">在使用 <xref:System.ServiceModel.ConcurrencyMode.Multiple> 或 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> 值之前，請確定已適當地設計您的服務以使用這些模式</span><span class="sxs-lookup"><span data-stu-id="9e83e-160">Before using <xref:System.ServiceModel.ConcurrencyMode.Multiple> or <xref:System.ServiceModel.ConcurrencyMode.Reentrant> values, ensure that your service is properly designed for these modes.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="9e83e-161"> <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>。</span><span class="sxs-lookup"><span data-stu-id="9e83e-161"> <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A>.</span></span>  
  
 <span data-ttu-id="9e83e-162">並存的使用與執行個體模式有關。</span><span class="sxs-lookup"><span data-stu-id="9e83e-162">The use of concurrency is related to the instancing mode.</span></span> <span data-ttu-id="9e83e-163">在<xref:System.ServiceModel.InstanceContextMode.PerCall>執行個體中，並行無關，因為每個訊息會處理新<xref:System.ServiceModel.InstanceContext>，因此，永遠不會多個執行緒是作用中<xref:System.ServiceModel.InstanceContext>。</span><span class="sxs-lookup"><span data-stu-id="9e83e-163">In <xref:System.ServiceModel.InstanceContextMode.PerCall> instancing, concurrency is not relevant, because each message is processed by a new <xref:System.ServiceModel.InstanceContext> and, therefore, never more than one thread is active in the <xref:System.ServiceModel.InstanceContext>.</span></span>  
  
 <span data-ttu-id="9e83e-164">下列程式碼會示範將 <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> 屬性設定為 <xref:System.ServiceModel.ConcurrencyMode.Multiple>。</span><span class="sxs-lookup"><span data-stu-id="9e83e-164">The following code example demonstrates setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> property to <xref:System.ServiceModel.ConcurrencyMode.Multiple>.</span></span>  
  
```  
[ServiceBehavior(ConcurrencyMode=ConcurrencyMode.Multiple, InstanceContextMode = InstanceContextMode.Single)]   
public class CalculatorService : ICalculatorConcurrency   
{   
    ...  
}  
```  
  
## <a name="sessions-interact-with-instancecontext-settings"></a><span data-ttu-id="9e83e-165">與 InstanceContext 設定互動的工作階段</span><span class="sxs-lookup"><span data-stu-id="9e83e-165">Sessions Interact with InstanceContext Settings</span></span>  
 <span data-ttu-id="9e83e-166">工作階段和 <xref:System.ServiceModel.InstanceContext> 會根據合約內 <xref:System.ServiceModel.SessionMode> 列舉型別值的組合以及服務實作上的 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 屬性而進行互動，以控制通道與特定服務物件的關聯。</span><span class="sxs-lookup"><span data-stu-id="9e83e-166">Sessions and <xref:System.ServiceModel.InstanceContext> interact depending upon the combination of the value of the <xref:System.ServiceModel.SessionMode> enumeration in a contract and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property on the service implementation, which controls the association between channels and specific service objects.</span></span>  
  
 <span data-ttu-id="9e83e-167">下表根據服務的 <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> 屬性與 <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> 屬性等值的組合，說明支援工作階段或不支援工作階段之傳入通道的結果。</span><span class="sxs-lookup"><span data-stu-id="9e83e-167">The following table shows the result of an incoming channel either supporting sessions or not supporting sessions given a service's combination of the values of the <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> property and the <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A?displayProperty=nameWithType> property.</span></span>  
  
|<span data-ttu-id="9e83e-168">InstanceContextMode 值</span><span class="sxs-lookup"><span data-stu-id="9e83e-168">InstanceContextMode value</span></span>|<xref:System.ServiceModel.SessionMode.Required>|<xref:System.ServiceModel.SessionMode.Allowed>|<xref:System.ServiceModel.SessionMode.NotAllowed>|  
|-------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<span data-ttu-id="9e83e-169">PerCall</span><span class="sxs-lookup"><span data-stu-id="9e83e-169">PerCall</span></span>|<span data-ttu-id="9e83e-170">-工作階段通道的行為： 工作階段和<xref:System.ServiceModel.InstanceContext>每個呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-170">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each call.</span></span><br /><span data-ttu-id="9e83e-171">的無工作階段通道行為： 擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9e83e-171">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="9e83e-172">-工作階段通道的行為： 工作階段和<xref:System.ServiceModel.InstanceContext>每個呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-172">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each call.</span></span><br /><span data-ttu-id="9e83e-173">的無工作階段通道行為：<xref:System.ServiceModel.InstanceContext>每個呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-173">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|<span data-ttu-id="9e83e-174">-工作階段通道的行為： 擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9e83e-174">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="9e83e-175">的無工作階段通道行為：<xref:System.ServiceModel.InstanceContext>每個呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-175">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|  
|<span data-ttu-id="9e83e-176">PerSession</span><span class="sxs-lookup"><span data-stu-id="9e83e-176">PerSession</span></span>|<span data-ttu-id="9e83e-177">-工作階段通道的行為： 工作階段和<xref:System.ServiceModel.InstanceContext>每個通道。</span><span class="sxs-lookup"><span data-stu-id="9e83e-177">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each channel.</span></span><br /><span data-ttu-id="9e83e-178">的無工作階段通道行為： 擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9e83e-178">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="9e83e-179">-工作階段通道的行為： 工作階段和<xref:System.ServiceModel.InstanceContext>每個通道。</span><span class="sxs-lookup"><span data-stu-id="9e83e-179">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for each channel.</span></span><br /><span data-ttu-id="9e83e-180">的無工作階段通道行為：<xref:System.ServiceModel.InstanceContext>每個呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-180">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|<span data-ttu-id="9e83e-181">-工作階段通道的行為： 擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9e83e-181">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="9e83e-182">的無工作階段通道行為：<xref:System.ServiceModel.InstanceContext>每個呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-182">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each call.</span></span>|  
|<span data-ttu-id="9e83e-183">Single</span><span class="sxs-lookup"><span data-stu-id="9e83e-183">Single</span></span>|<span data-ttu-id="9e83e-184">-工作階段通道的行為： 工作階段，另一個<xref:System.ServiceModel.InstanceContext>所有呼叫。</span><span class="sxs-lookup"><span data-stu-id="9e83e-184">-   Behavior with sessionful channel: A session and one <xref:System.ServiceModel.InstanceContext> for all calls.</span></span><br /><span data-ttu-id="9e83e-185">的無工作階段通道行為： 擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9e83e-185">-   Behavior with sessionless channel: An exception is thrown.</span></span>|<span data-ttu-id="9e83e-186">-工作階段通道的行為： 工作階段和<xref:System.ServiceModel.InstanceContext>建立或使用者指定 singleton。</span><span class="sxs-lookup"><span data-stu-id="9e83e-186">-   Behavior with sessionful channel: A session and <xref:System.ServiceModel.InstanceContext> for the created or user-specified singleton.</span></span><br /><span data-ttu-id="9e83e-187">的無工作階段通道行為：<xref:System.ServiceModel.InstanceContext>建立或使用者指定 singleton。</span><span class="sxs-lookup"><span data-stu-id="9e83e-187">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for the created or user-specified singleton.</span></span>|<span data-ttu-id="9e83e-188">-工作階段通道的行為： 擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="9e83e-188">-   Behavior with sessionful channel: An exception is thrown.</span></span><br /><span data-ttu-id="9e83e-189">的無工作階段通道行為：<xref:System.ServiceModel.InstanceContext>每個建立之單一個體或使用者指定之單一。</span><span class="sxs-lookup"><span data-stu-id="9e83e-189">-   Behavior with sessionless channel: An <xref:System.ServiceModel.InstanceContext> for each created singleton or for the user-specified singleton.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="9e83e-190">請參閱</span><span class="sxs-lookup"><span data-stu-id="9e83e-190">See Also</span></span>  
 [<span data-ttu-id="9e83e-191">使用工作階段</span><span class="sxs-lookup"><span data-stu-id="9e83e-191">Using Sessions</span></span>](../../../../docs/framework/wcf/using-sessions.md)  
 [<span data-ttu-id="9e83e-192">如何：建立需要工作階段的服務</span><span class="sxs-lookup"><span data-stu-id="9e83e-192">How to: Create a Service That Requires Sessions</span></span>](../../../../docs/framework/wcf/feature-details/how-to-create-a-service-that-requires-sessions.md)  
 [<span data-ttu-id="9e83e-193">如何：控制服務執行個體</span><span class="sxs-lookup"><span data-stu-id="9e83e-193">How to: Control Service Instancing</span></span>](../../../../docs/framework/wcf/feature-details/how-to-control-service-instancing.md)  
 [<span data-ttu-id="9e83e-194">並行</span><span class="sxs-lookup"><span data-stu-id="9e83e-194">Concurrency</span></span>](../../../../docs/framework/wcf/samples/concurrency.md)  
 [<span data-ttu-id="9e83e-195">執行個體</span><span class="sxs-lookup"><span data-stu-id="9e83e-195">Instancing</span></span>](../../../../docs/framework/wcf/samples/instancing.md)  
 [<span data-ttu-id="9e83e-196">工作階段</span><span class="sxs-lookup"><span data-stu-id="9e83e-196">Session</span></span>](../../../../docs/framework/wcf/samples/session.md)
