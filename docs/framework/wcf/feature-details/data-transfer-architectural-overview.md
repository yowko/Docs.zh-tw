---
title: "資料傳輸架構概觀"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology:
- dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords:
- data transfer [WCF], architectural overview
ms.assetid: 343c2ca2-af53-4936-a28c-c186b3524ee9
caps.latest.revision: 
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload:
- dotnet
ms.openlocfilehash: 829635bd7fd73b58004c59862f4d589e95f67f9b
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/22/2017
---
# <a name="data-transfer-architectural-overview"></a><span data-ttu-id="d9e16-102">資料傳輸架構概觀</span><span class="sxs-lookup"><span data-stu-id="d9e16-102">Data Transfer Architectural Overview</span></span>
[!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]<span data-ttu-id="d9e16-103"> 可以想成是訊息基礎架構。</span><span class="sxs-lookup"><span data-stu-id="d9e16-103"> can be thought of as a messaging infrastructure.</span></span> <span data-ttu-id="d9e16-104">它可以接收訊息、加以處理，然後分派到使用者程式碼執行進一步動作，或是使用使用者程式碼提供的資料建構訊息，然後傳遞到目的地。</span><span class="sxs-lookup"><span data-stu-id="d9e16-104">It can receive messages, process them, and dispatch them to user code for further action, or it can construct messages from data given by user code and deliver them to a destination.</span></span> <span data-ttu-id="d9e16-105">此主題將針對進階程式開發人員，描述處理訊息與所包含資料的架構。</span><span class="sxs-lookup"><span data-stu-id="d9e16-105">This topic, which is intended for advanced developers, describes the architecture for handling messages and the contained data.</span></span> <span data-ttu-id="d9e16-106">如需如何傳送與接收資料的簡化型工作導向檢視，請參閱 [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-106">For a simpler, task-oriented view of how to send and receive data, see [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d9e16-107">此主題討論無法藉由檢查 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 物件模型能夠得知的 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 實作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="d9e16-107">This topic discusses [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] implementation details that are not visible by examining the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] object model.</span></span> <span data-ttu-id="d9e16-108">關於已記載的實作詳細資料，依序有兩件需要注意的事項。</span><span class="sxs-lookup"><span data-stu-id="d9e16-108">Two words of caution are in order with regard to documented implementation details.</span></span> <span data-ttu-id="d9e16-109">首先，描述已經過簡化，實際的實作可能會因為最佳化或其他原因而更為複雜。</span><span class="sxs-lookup"><span data-stu-id="d9e16-109">First, the descriptions are simplified; actual implementation may be more complex due to optimizations or other reasons.</span></span> <span data-ttu-id="d9e16-110">第二，絕不要依賴特定的實作詳細資料 (即使已記載於文件中)，因為這些詳細資料可能會在不同的版本中 (甚至是在服務版本中) 變更而不另行通知。</span><span class="sxs-lookup"><span data-stu-id="d9e16-110">Second, you should never rely on specific implementation details, even documented ones, because these may change without notice from version to version or even in a servicing release.</span></span>  
  
## <a name="basic-architecture"></a><span data-ttu-id="d9e16-111">基本架構</span><span class="sxs-lookup"><span data-stu-id="d9e16-111">Basic Architecture</span></span>  
 <span data-ttu-id="d9e16-112">核心[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]訊息處理功能是<xref:System.ServiceModel.Channels.Message>類別中將詳細說明[使用 Message 類別](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-112">At the core of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] message-handling capabilities is the <xref:System.ServiceModel.Channels.Message> class, which is described in detail in [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span> <span data-ttu-id="d9e16-113">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 的執行階段元件可以分為兩個主要部分：通道堆疊與服務架構，其中使用 <xref:System.ServiceModel.Channels.Message> 類別當做連接點。</span><span class="sxs-lookup"><span data-stu-id="d9e16-113">The run-time components of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] can be divided into two major parts: the channel stack and the service framework, with the <xref:System.ServiceModel.Channels.Message> class being the connection point.</span></span>  
  
 <span data-ttu-id="d9e16-114">通道堆疊負責在有效 <xref:System.ServiceModel.Channels.Message> 執行個體，以及對應至傳送或接收訊息資料的某些動作之間進行轉換。</span><span class="sxs-lookup"><span data-stu-id="d9e16-114">The channel stack is responsible for converting between a valid <xref:System.ServiceModel.Channels.Message> instance and some action that corresponds to the sending or receiving of message data.</span></span> <span data-ttu-id="d9e16-115">在傳送端，通道堆疊會取用有效的 <xref:System.ServiceModel.Channels.Message> 執行個體，然後在經過某些處理後，執行邏輯上對應至傳送訊息的某些動作。</span><span class="sxs-lookup"><span data-stu-id="d9e16-115">On the sending side, the channel stack takes a valid <xref:System.ServiceModel.Channels.Message> instance and, after some processing, performs some action that logically corresponds to sending the message.</span></span> <span data-ttu-id="d9e16-116">這些動作可能是傳送 TCP 或 HTTP 封包、將訊息存放在訊息佇列中、將訊息寫入資料庫、將訊息儲存在檔案共用，或是任何視實作而定的其他動作。</span><span class="sxs-lookup"><span data-stu-id="d9e16-116">The action may be sending TCP or HTTP packets, queuing the message in Message Queuing, writing the message to a database, saving it to a file share, or any other action, depending on the implementation.</span></span> <span data-ttu-id="d9e16-117">最常見的動作是透過網路通訊協定傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-117">The most common action is sending the message over a network protocol.</span></span> <span data-ttu-id="d9e16-118">在接收端，則發生相反的情況—偵測到動作 (可能是 TCP 或 HTTP 封包抵達，或是任何其他動作)，然後在經過處理後，通道堆疊會將這個動作轉換為有效的 <xref:System.ServiceModel.Channels.Message> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="d9e16-118">On the receive side, the opposite happens—an action is detected (which may be TCP or HTTP packets arriving or any other action), and, after processing, the channel stack converts this action into a valid <xref:System.ServiceModel.Channels.Message> instance.</span></span>  
  
 <span data-ttu-id="d9e16-119">您可以藉由直接使用 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 類別與通道堆疊來使用 <xref:System.ServiceModel.Channels.Message> 。</span><span class="sxs-lookup"><span data-stu-id="d9e16-119">You can use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] by using the <xref:System.ServiceModel.Channels.Message> class and the channel stack directly.</span></span> <span data-ttu-id="d9e16-120">但是，這麼做是很困難並且耗時的。</span><span class="sxs-lookup"><span data-stu-id="d9e16-120">However, doing so is difficult and time-consuming.</span></span> <span data-ttu-id="d9e16-121">此外， <xref:System.ServiceModel.Channels.Message> 物件不支援中繼資料，因此如果以這種方式使用 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] ，將無法產生強型別 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 用戶端。</span><span class="sxs-lookup"><span data-stu-id="d9e16-121">Additionally, the <xref:System.ServiceModel.Channels.Message> object provides no metadata support, so you cannot generate strongly typed [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients if you use [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] in this manner.</span></span>  
  
 <span data-ttu-id="d9e16-122">因此， [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 會包含提供易於使用之程式設計模型的服務架構，讓您用來建構與接收 `Message` 物件。</span><span class="sxs-lookup"><span data-stu-id="d9e16-122">Therefore, [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] includes a service framework that provides an easy-to-use programming model that you can use to construct and receive `Message` objects.</span></span> <span data-ttu-id="d9e16-123">服務架構會透過服務合約的概念，將服務對應至 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 型別，然後將訊息分派至使用者作業，這個作業是使用 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 屬性標記的單純 <xref:System.ServiceModel.OperationContractAttribute> 方法 (如需詳細資料，請參閱 [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md))。</span><span class="sxs-lookup"><span data-stu-id="d9e16-123">The service framework maps services to [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types through the notion of service contracts, and dispatches messages to user operations that are simply [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] methods marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute (for more details, see [Designing Service Contracts](../../../../docs/framework/wcf/designing-service-contracts.md)).</span></span> <span data-ttu-id="d9e16-124">這些方法會有參數與傳回值。</span><span class="sxs-lookup"><span data-stu-id="d9e16-124">These methods may have parameters and return values.</span></span> <span data-ttu-id="d9e16-125">在服務端，服務架構會將傳入的 <xref:System.ServiceModel.Channels.Message> 執行個體轉換成參數，然後將傳回值轉換成傳出的 <xref:System.ServiceModel.Channels.Message> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="d9e16-125">On the service side, the service framework converts incoming <xref:System.ServiceModel.Channels.Message> instances into parameters and converts return values into outgoing <xref:System.ServiceModel.Channels.Message> instances.</span></span> <span data-ttu-id="d9e16-126">在用戶端，則執行相反的動作。</span><span class="sxs-lookup"><span data-stu-id="d9e16-126">On the client side, it does the opposite.</span></span> <span data-ttu-id="d9e16-127">例如，請考量下列 `FindAirfare` 作業。</span><span class="sxs-lookup"><span data-stu-id="d9e16-127">For example, consider the `FindAirfare` operation below.</span></span>  
  
 [!code-csharp[c_DataArchitecture#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#1)]
 [!code-vb[c_DataArchitecture#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#1)]  
  
 <span data-ttu-id="d9e16-128">假設在用戶端呼叫 `FindAirfare` 。</span><span class="sxs-lookup"><span data-stu-id="d9e16-128">Suppose `FindAirfare` is called on the client.</span></span> <span data-ttu-id="d9e16-129">用戶端的服務架構會將 `FromCity` 和 `ToCity` 參數轉換成傳出的 <xref:System.ServiceModel.Channels.Message> 執行個體，並將其傳遞至要傳送的通道堆疊。</span><span class="sxs-lookup"><span data-stu-id="d9e16-129">The service framework on the client converts the `FromCity` and `ToCity` parameters into an outgoing <xref:System.ServiceModel.Channels.Message> instance and passes it to the channel stack to be sent.</span></span>  
  
 <span data-ttu-id="d9e16-130">在服務端，當來自通道堆疊的 <xref:System.ServiceModel.Channels.Message> 執行個體抵達時，服務架構會從訊息擷取相關資料以填入 `FromCity` 和 `ToCity` 參數，然後呼叫服務端的 `FindAirfare` 方法。</span><span class="sxs-lookup"><span data-stu-id="d9e16-130">On the service side, when a <xref:System.ServiceModel.Channels.Message> instance arrives from the channel stack, the service framework extracts the relevant data from the message to populate the `FromCity` and `ToCity` parameters and then calls the service-side `FindAirfare` method.</span></span> <span data-ttu-id="d9e16-131">當方法傳回時，服務架構會取用傳回的整數值以及 `IsDirectFlight` 輸出參數，然後建立包含這項資訊的 <xref:System.ServiceModel.Channels.Message> 物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="d9e16-131">When the method returns, the service framework takes the returned integer value and the `IsDirectFlight` output parameter and creates a <xref:System.ServiceModel.Channels.Message> object instance that contains this information.</span></span> <span data-ttu-id="d9e16-132">然後將 `Message` 執行個體傳遞至要傳回用戶端的通道堆疊。</span><span class="sxs-lookup"><span data-stu-id="d9e16-132">It then passes the `Message` instance to the channel stack to be sent back to the client.</span></span>  
  
 <span data-ttu-id="d9e16-133">在用戶端，包含回應訊息的 <xref:System.ServiceModel.Channels.Message> 執行個體會出現在通道堆疊。</span><span class="sxs-lookup"><span data-stu-id="d9e16-133">On the client side, a <xref:System.ServiceModel.Channels.Message> instance that contains the response message emerges from the channel stack.</span></span> <span data-ttu-id="d9e16-134">服務架構會擷取傳回值以及 `IsDirectFlight` 值，然後將這些傳回給用戶端的呼叫者。</span><span class="sxs-lookup"><span data-stu-id="d9e16-134">The service framework extracts the return value and the `IsDirectFlight` value and returns these to the caller of the client.</span></span>  
  
## <a name="message-class"></a><span data-ttu-id="d9e16-135">訊息類別</span><span class="sxs-lookup"><span data-stu-id="d9e16-135">Message Class</span></span>  
 <span data-ttu-id="d9e16-136"><xref:System.ServiceModel.Channels.Message> 類別是要用來當做訊息的抽象表示法，但其設計與 SOAP 訊息有強烈關聯。</span><span class="sxs-lookup"><span data-stu-id="d9e16-136">The <xref:System.ServiceModel.Channels.Message> class is intended to be an abstract representation of a message, but its design is strongly tied to the SOAP message.</span></span> <span data-ttu-id="d9e16-137"><xref:System.ServiceModel.Channels.Message> 包含三段主要的資訊：訊息本文、訊息標頭和訊息屬性。</span><span class="sxs-lookup"><span data-stu-id="d9e16-137">A <xref:System.ServiceModel.Channels.Message> contains three major pieces of information: a message body, message headers, and message properties.</span></span>  
  
## <a name="message-body"></a><span data-ttu-id="d9e16-138">訊息本文</span><span class="sxs-lookup"><span data-stu-id="d9e16-138">Message Body</span></span>  
 <span data-ttu-id="d9e16-139">訊息本文是用來表示訊息的實際資料承載。</span><span class="sxs-lookup"><span data-stu-id="d9e16-139">The message body is intended to represent the actual data payload of the message.</span></span> <span data-ttu-id="d9e16-140">訊息本文一定會當做 XML Infoset 表示。</span><span class="sxs-lookup"><span data-stu-id="d9e16-140">The message body is always represented as an XML Infoset.</span></span> <span data-ttu-id="d9e16-141">這並不表示在 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 中建立或接收的所有訊息都必須使用 XML 格式。</span><span class="sxs-lookup"><span data-stu-id="d9e16-141">This does not mean that all messages created or received in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] must be in XML format.</span></span> <span data-ttu-id="d9e16-142">而是留給通道堆疊決定如何解譯訊息本文。</span><span class="sxs-lookup"><span data-stu-id="d9e16-142">It is up to the channel stack to decide how to interpret the message body.</span></span> <span data-ttu-id="d9e16-143">可能會將本文當做 XML 發出、轉換成某些其他格式，或甚至整個省略。</span><span class="sxs-lookup"><span data-stu-id="d9e16-143">It may emit it as XML, convert it to some other format, or even omit it entirely.</span></span> <span data-ttu-id="d9e16-144">當然，在使用 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 提供的大多數繫結時，訊息本文會表示為 SOAP 封套之本文區段中的 XML 內容。</span><span class="sxs-lookup"><span data-stu-id="d9e16-144">Of course, with most of the bindings [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] supplies, the message body is represented as XML content in the body section of a SOAP envelope.</span></span>  
  
 <span data-ttu-id="d9e16-145">重點是要了解 `Message` 類別不一定需要包含使用 XML 資料表示本文的緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d9e16-145">It is important to realize that the `Message` class does not necessarily contain a buffer with XML data representing the body.</span></span> <span data-ttu-id="d9e16-146">就邏輯上來說， `Message` 會包含 XML Infoset，但是可能會使用動態方式建構這個 Infoset，並且一定不會以實體方式存在記憶體中。</span><span class="sxs-lookup"><span data-stu-id="d9e16-146">Logically, `Message` contains an XML Infoset, but this Infoset may be dynamically constructed and may never physically exist in memory.</span></span>  
  
### <a name="putting-data-into-the-message-body"></a><span data-ttu-id="d9e16-147">將資料放入訊息本文</span><span class="sxs-lookup"><span data-stu-id="d9e16-147">Putting Data into the Message Body</span></span>  
 <span data-ttu-id="d9e16-148">在將資料放入訊息本文方面並沒有統一的機制。</span><span class="sxs-lookup"><span data-stu-id="d9e16-148">There is no uniform mechanism to put data into a message body.</span></span> <span data-ttu-id="d9e16-149"><xref:System.ServiceModel.Channels.Message> 類別有一個抽象方法， <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>，它會取用 <xref:System.Xml.XmlDictionaryWriter>。</span><span class="sxs-lookup"><span data-stu-id="d9e16-149">The <xref:System.ServiceModel.Channels.Message> class has an abstract method, <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, which takes an <xref:System.Xml.XmlDictionaryWriter>.</span></span> <span data-ttu-id="d9e16-150"><xref:System.ServiceModel.Channels.Message> 類別的每個子類別會負責覆寫這個方法，然後寫入專屬的內容。</span><span class="sxs-lookup"><span data-stu-id="d9e16-150">Each subclass of the <xref:System.ServiceModel.Channels.Message> class is responsible for overriding this method and writing out its own contents.</span></span> <span data-ttu-id="d9e16-151">訊息本文邏輯上會包含 `OnWriteBodyContent` 產生的 XML Infoset。</span><span class="sxs-lookup"><span data-stu-id="d9e16-151">The message body logically contains the XML Infoset that `OnWriteBodyContent` produces.</span></span> <span data-ttu-id="d9e16-152">例如，請考量下列 `Message` 子類別。</span><span class="sxs-lookup"><span data-stu-id="d9e16-152">For example, consider the following `Message` subclass.</span></span>  
  
 [!code-csharp[c_DataArchitecture#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#2)]
 [!code-vb[c_DataArchitecture#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#2)]  
  
 <span data-ttu-id="d9e16-153">實際上 `AirfareRequestMessage` 執行個體只包含兩個字串 ("fromCity" 和 "toCity")。</span><span class="sxs-lookup"><span data-stu-id="d9e16-153">Physically, an `AirfareRequestMessage` instance contains only two strings ("fromCity" and "toCity").</span></span> <span data-ttu-id="d9e16-154">但是，邏輯上訊息會包含下列 XML Infoset：</span><span class="sxs-lookup"><span data-stu-id="d9e16-154">However, logically the message contains the following XML infoset:</span></span>  
  
```xml  
<airfareRequest>  
    <from>Tokyo</from>  
    <to>London</to>  
</airfareRequest>  
```  
  
 <span data-ttu-id="d9e16-155">當然，通常不會使用這種方式建立訊息，因為您可以使用服務架構從作業合約參數建立像之前的訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-155">Of course, you would normally not create messages in this manner, because you can use the service framework to create a message like the preceding one from operation contract parameters.</span></span> <span data-ttu-id="d9e16-156">此外， <xref:System.ServiceModel.Channels.Message> 類別有靜態 `CreateMessage` 方法，您可以用來搭配內容的一般型別建立訊息：空白訊息、包含使用 <xref:System.Runtime.Serialization.DataContractSerializer>序列化為 XML 之物件的訊息、包含 SOAP 錯誤的訊息，以及包含使用 <xref:System.Xml.XmlReader>表示之 XML 的訊息等等。</span><span class="sxs-lookup"><span data-stu-id="d9e16-156">Additionally, the <xref:System.ServiceModel.Channels.Message> class has static `CreateMessage` methods that you can use to create messages with common types of content: an empty message, a message that contains an object serialized to XML with the <xref:System.Runtime.Serialization.DataContractSerializer>, a message that contains a SOAP fault, a message that contains XML represented by an <xref:System.Xml.XmlReader>, and so on.</span></span>  
  
### <a name="getting-data-from-a-message-body"></a><span data-ttu-id="d9e16-157">從訊息本文取得資料</span><span class="sxs-lookup"><span data-stu-id="d9e16-157">Getting Data from a Message Body</span></span>  
 <span data-ttu-id="d9e16-158">您可以使用兩種主要方法擷取儲存在訊息本文中的資料：</span><span class="sxs-lookup"><span data-stu-id="d9e16-158">You can extract the data stored in a message body in two main ways:</span></span>  
  
-   <span data-ttu-id="d9e16-159">您可以藉由呼叫 <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 方法然後傳入 XML 寫入器，一次取得整個訊息本文。</span><span class="sxs-lookup"><span data-stu-id="d9e16-159">You can get the entire message body at one time by calling the <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29> method and passing in an XML writer.</span></span> <span data-ttu-id="d9e16-160">完整的訊息本文會寫至這個寫入器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-160">The complete message body is written out to this writer.</span></span> <span data-ttu-id="d9e16-161">一次取得整個訊息本文也稱為「 *寫入訊息*」(Writing a Message)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-161">Getting the entire message body at one time is also called *writing a message*.</span></span> <span data-ttu-id="d9e16-162">當傳送訊息時寫入主要是由通道堆疊完成，通道堆疊的某些部分通常能夠存取整個訊息本文、加以編碼然後傳送。</span><span class="sxs-lookup"><span data-stu-id="d9e16-162">Writing is done primarily by the channel stack when sending messages—some part of the channel stack will usually get access to the entire message body, encode it, and send it.</span></span>  
  
-   <span data-ttu-id="d9e16-163">從訊息本文取得資訊的另一種方法，是呼叫 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> 然後取得 XML 讀取器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-163">Another way to get information out of the message body is to call <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents> and get an XML reader.</span></span> <span data-ttu-id="d9e16-164">然後可以藉由呼叫讀取器上的方法，依需要以循序方式存取訊息本文。</span><span class="sxs-lookup"><span data-stu-id="d9e16-164">The message body can then be accessed sequentially as needed by calling methods on the reader.</span></span> <span data-ttu-id="d9e16-165">以片段方式取得訊息本文也稱為「 *讀取訊息*」(Reading a Message)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-165">Getting the message body piece-by-piece is also called *reading a message*.</span></span> <span data-ttu-id="d9e16-166">主要是服務架構會在接收訊息時使用讀取訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-166">Reading the message is primarily used by the service framework when receiving messages.</span></span> <span data-ttu-id="d9e16-167">例如，當 <xref:System.Runtime.Serialization.DataContractSerializer> 正在使用時，服務架構會透過本文取得 XML 讀取器，並且將其傳遞給還原序列化引擎，然後就會開始逐一讀取訊息項目並建構對應的物件圖形。</span><span class="sxs-lookup"><span data-stu-id="d9e16-167">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> is in use, the service framework will get an XML reader over the body and pass it to the deserialization engine, which will then start reading the message element-by-element and constructing the corresponding object graph.</span></span>  
  
 <span data-ttu-id="d9e16-168">訊息本文只能擷取一次。</span><span class="sxs-lookup"><span data-stu-id="d9e16-168">A message body can be retrieved only once.</span></span> <span data-ttu-id="d9e16-169">就可以使用順向資料流。</span><span class="sxs-lookup"><span data-stu-id="d9e16-169">This makes it possible to work with forward-only streams.</span></span> <span data-ttu-id="d9e16-170">例如，您可以寫入 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 覆寫，以便從 <xref:System.IO.FileStream> 讀取然後使用 XML Infoset 的方式傳回結果。</span><span class="sxs-lookup"><span data-stu-id="d9e16-170">For example, you can write an <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> override that reads from a <xref:System.IO.FileStream> and returns the results as an XML Infoset.</span></span> <span data-ttu-id="d9e16-171">您永遠不會將需要 「 倒轉 」 至檔案的開頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-171">You will never need to "rewind" to the beginning of the file.</span></span>  
  
 <span data-ttu-id="d9e16-172">`WriteBodyContents` 和 `GetReaderAtBodyContents` 方法只會檢查之前從未擷取過訊息本文，然後分別呼叫 `OnWriteBodyContents` 或 `OnGetReaderAtBodyContents`。</span><span class="sxs-lookup"><span data-stu-id="d9e16-172">The `WriteBodyContents` and `GetReaderAtBodyContents` methods simply check that the message body has never been retrieved before, and then call `OnWriteBodyContents` or `OnGetReaderAtBodyContents`, respectively.</span></span>  
  
## <a name="message-usage-in-wcf"></a><span data-ttu-id="d9e16-173">WCF 中的訊息使用方式</span><span class="sxs-lookup"><span data-stu-id="d9e16-173">Message Usage in WCF</span></span>  
 <span data-ttu-id="d9e16-174">大部分的訊息都能夠分類為「 *傳出* 」(Outgoing) (由服務架構建立並透過通道堆疊傳送) 或「 *傳入* 」(Incoming) (來自通道堆疊並由服務架構解譯)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-174">Most messages can be classified as either *outgoing* (those that are created by the service framework to be sent by the channel stack) or *incoming* (those that arrive from the channel stack and are interpreted by the service framework).</span></span> <span data-ttu-id="d9e16-175">此外，通道堆疊可以在經過緩衝處理或資料流模式中運作。</span><span class="sxs-lookup"><span data-stu-id="d9e16-175">Furthermore, the channel stack can operate in either buffered or streaming mode.</span></span> <span data-ttu-id="d9e16-176">服務架構可能也會公開經過資料流處理或非資料流處理的程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="d9e16-176">The service framework may also expose a streamed or nonstreamed programming model.</span></span> <span data-ttu-id="d9e16-177">這種做法會造成下表列出的案例，以及其實作的簡化詳細資料。</span><span class="sxs-lookup"><span data-stu-id="d9e16-177">This leads to the cases listed in the following table, along with simplified details of their implementation.</span></span>  
  
|<span data-ttu-id="d9e16-178">訊息類型</span><span class="sxs-lookup"><span data-stu-id="d9e16-178">Message type</span></span>|<span data-ttu-id="d9e16-179">訊息中的本文資料</span><span class="sxs-lookup"><span data-stu-id="d9e16-179">Body data in message</span></span>|<span data-ttu-id="d9e16-180">寫入 (OnWriteBodyContents) 實作</span><span class="sxs-lookup"><span data-stu-id="d9e16-180">Write (OnWriteBodyContents) implementation</span></span>|<span data-ttu-id="d9e16-181">讀取 (OnGetReaderAtBodyContents) 實作</span><span class="sxs-lookup"><span data-stu-id="d9e16-181">Read (OnGetReaderAtBodyContents) Implementation</span></span>|  
|------------------|--------------------------|--------------------------------------------------|-------------------------------------------------------|  
|<span data-ttu-id="d9e16-182">傳出，從經過非資料流處理的程式設計模型建立</span><span class="sxs-lookup"><span data-stu-id="d9e16-182">Outgoing, created from nonstreamed programming model</span></span>|<span data-ttu-id="d9e16-183">寫入訊息需要的資料 (例如，物件與需要序列化它的 <xref:System.Runtime.Serialization.DataContractSerializer> 執行個體)\*</span><span class="sxs-lookup"><span data-stu-id="d9e16-183">The data needed to write the message (for example, an object and the <xref:System.Runtime.Serialization.DataContractSerializer> instance needed to serialize it)\*</span></span>|<span data-ttu-id="d9e16-184">自訂邏輯以根據儲存資料寫出訊息 (例如，呼叫 `WriteObject` 上的 `DataContractSerializer` (如果這是使用中的序列化程式))\*</span><span class="sxs-lookup"><span data-stu-id="d9e16-184">Custom logic to write out the message based on the stored data (for example, call `WriteObject` on the `DataContractSerializer` if that is the serializer in use)\*</span></span>|<span data-ttu-id="d9e16-185">呼叫 `OnWriteBodyContents`、緩衝處理結果、透過緩衝區傳回 XML 讀取器</span><span class="sxs-lookup"><span data-stu-id="d9e16-185">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="d9e16-186">傳出，從經過資料流處理的程式設計模型建立</span><span class="sxs-lookup"><span data-stu-id="d9e16-186">Outgoing, created from streamed programming model</span></span>|<span data-ttu-id="d9e16-187">使用要寫入之資料的 `Stream`\*</span><span class="sxs-lookup"><span data-stu-id="d9e16-187">The `Stream` with the data to be written\*</span></span>|<span data-ttu-id="d9e16-188">使用 <xref:System.Xml.IStreamProvider> 機制從儲存的資料流寫出資料\*</span><span class="sxs-lookup"><span data-stu-id="d9e16-188">Write out data from the stored stream using the <xref:System.Xml.IStreamProvider> mechanism\*</span></span>|<span data-ttu-id="d9e16-189">呼叫 `OnWriteBodyContents`、緩衝處理結果、透過緩衝區傳回 XML 讀取器</span><span class="sxs-lookup"><span data-stu-id="d9e16-189">Call `OnWriteBodyContents`, buffer the results, return an XML reader over the buffer</span></span>|  
|<span data-ttu-id="d9e16-190">從資料流通道堆疊傳入</span><span class="sxs-lookup"><span data-stu-id="d9e16-190">Incoming from streaming channel stack</span></span>|<span data-ttu-id="d9e16-191">`Stream` 物件，表示透過網路傳入並且搭配 <xref:System.Xml.XmlReader> 的資料</span><span class="sxs-lookup"><span data-stu-id="d9e16-191">A `Stream` object that represents the data coming in over the network with an <xref:System.Xml.XmlReader> over it</span></span>|<span data-ttu-id="d9e16-192">使用 `XmlReader` 從儲存的 `WriteNode` 寫出內容</span><span class="sxs-lookup"><span data-stu-id="d9e16-192">Write out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="d9e16-193">傳回儲存的 `XmlReader`</span><span class="sxs-lookup"><span data-stu-id="d9e16-193">Returns the stored `XmlReader`</span></span>|  
|<span data-ttu-id="d9e16-194">從非資料流的通道堆疊傳入</span><span class="sxs-lookup"><span data-stu-id="d9e16-194">Incoming from nonstreaming channel stack</span></span>|<span data-ttu-id="d9e16-195">包含搭配 `XmlReader` 之本文資料的緩衝區</span><span class="sxs-lookup"><span data-stu-id="d9e16-195">A buffer that contains body data with an `XmlReader` over it</span></span>|<span data-ttu-id="d9e16-196">使用 `XmlReader` 從儲存的 `WriteNode`寫出內容</span><span class="sxs-lookup"><span data-stu-id="d9e16-196">Writes out the contents from the stored `XmlReader` using `WriteNode`</span></span>|<span data-ttu-id="d9e16-197">傳回儲存的 lang</span><span class="sxs-lookup"><span data-stu-id="d9e16-197">Returns the stored lang</span></span>|  
  
 <span data-ttu-id="d9e16-198">\*這些項目都不會直接實作在`Message`子類別，但在子類別的<xref:System.ServiceModel.Channels.BodyWriter>類別。</span><span class="sxs-lookup"><span data-stu-id="d9e16-198">\* These items are not implemented directly in `Message` subclasses, but in subclasses of the <xref:System.ServiceModel.Channels.BodyWriter> class.</span></span> <span data-ttu-id="d9e16-199">如需 <xref:System.ServiceModel.Channels.BodyWriter>的詳細資訊，請參閱 [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-199">For more information about the <xref:System.ServiceModel.Channels.BodyWriter>, see [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
## <a name="message-headers"></a><span data-ttu-id="d9e16-200">訊息標頭</span><span class="sxs-lookup"><span data-stu-id="d9e16-200">Message Headers</span></span>  
 <span data-ttu-id="d9e16-201">包含標頭的訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-201">A message may contain headers.</span></span> <span data-ttu-id="d9e16-202">標頭邏輯上是由與名稱、命名空間，以及一些其他屬性關聯的 XML Infoset 所組成。</span><span class="sxs-lookup"><span data-stu-id="d9e16-202">A header logically consists of an XML Infoset that is associated with a name, a namespace, and a few other properties.</span></span> <span data-ttu-id="d9e16-203">使用 `Headers` 的 <xref:System.ServiceModel.Channels.Message>屬性可以存取訊息標頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-203">Message headers are accessed using the `Headers` property on <xref:System.ServiceModel.Channels.Message>.</span></span> <span data-ttu-id="d9e16-204">每個標頭是由 <xref:System.ServiceModel.Channels.MessageHeader> 類別表示。</span><span class="sxs-lookup"><span data-stu-id="d9e16-204">Each header is represented by a <xref:System.ServiceModel.Channels.MessageHeader> class.</span></span> <span data-ttu-id="d9e16-205">通常當使用設定的通道堆疊搭配 SOAP 訊息運作時，訊息標頭會對應到 SOAP 訊息標頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-205">Normally, message headers are mapped to SOAP message headers when using a channel stack configured to work with SOAP messages.</span></span>  
  
 <span data-ttu-id="d9e16-206">將資訊放入訊息標頭以及從中擷取資訊就像使用訊息本文。</span><span class="sxs-lookup"><span data-stu-id="d9e16-206">Putting information into a message header and extracting information from it is similar to using the message body.</span></span> <span data-ttu-id="d9e16-207">因為不支援資料流所以處理序稍微經過簡化。</span><span class="sxs-lookup"><span data-stu-id="d9e16-207">The process is somewhat simplified because streaming is not supported.</span></span> <span data-ttu-id="d9e16-208">您可以存取相同標頭的內容一次以上，並且以任意順序存取標頭，以強制一定要緩衝處理標頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-208">It is possible to access the contents of the same header more than once, and headers can be accessed in arbitrary order, forcing headers to always be buffered.</span></span> <span data-ttu-id="d9e16-209">並沒有取得標頭之 XML 讀取器的一般用途機制，但是 `MessageHeader` 內部有個 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 子類別，表示具備這類功能的可讀取標頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-209">There is no general-purpose mechanism available to get an XML reader over a header, but there is a `MessageHeader` subclass internal to [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that represents a readable header with such a capability.</span></span> <span data-ttu-id="d9e16-210">當使用自訂應用程式標頭的訊息傳入時， `MessageHeader` 的型別是由通道堆疊建立。</span><span class="sxs-lookup"><span data-stu-id="d9e16-210">This type of `MessageHeader` is created by the channel stack when a message with custom application headers comes in.</span></span> <span data-ttu-id="d9e16-211">這可讓服務架構使用還原序列化引擎 (例如 <xref:System.Runtime.Serialization.DataContractSerializer>) 來解譯這些標頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-211">This enables the service framework to use a deserialization engine, such as the <xref:System.Runtime.Serialization.DataContractSerializer>, to interpret these headers.</span></span>  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="d9e16-212"> [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-212"> [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
## <a name="message-properties"></a><span data-ttu-id="d9e16-213">郵件內容</span><span class="sxs-lookup"><span data-stu-id="d9e16-213">Message Properties</span></span>  
 <span data-ttu-id="d9e16-214">訊息會包含屬性。</span><span class="sxs-lookup"><span data-stu-id="d9e16-214">A message may contain properties.</span></span> <span data-ttu-id="d9e16-215">「 *屬性* 」(Property) 是與字串名稱關聯的任何 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 物件。</span><span class="sxs-lookup"><span data-stu-id="d9e16-215">A *property* is any [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] object that is associated with a string name.</span></span> <span data-ttu-id="d9e16-216">透過 `Properties` 的 `Message`屬性可以存取屬性。</span><span class="sxs-lookup"><span data-stu-id="d9e16-216">Properties are accessed through the `Properties` property on `Message`.</span></span>  
  
 <span data-ttu-id="d9e16-217">不像訊息本文和訊息標頭 (通常會分別對應至 SOAP 本文與 SOAP 標頭)，訊息屬性通常不會與訊息一起傳送或接收。</span><span class="sxs-lookup"><span data-stu-id="d9e16-217">Unlike the message body and message headers (which normally map to the SOAP body and SOAP headers, respectively), message properties are normally not sent or received along with the messages.</span></span> <span data-ttu-id="d9e16-218">訊息屬性的存在主要是當做通訊機制，將有關訊息的資料在通道堆疊的各個通道之間傳遞，以及在通道堆疊與服務模型之間傳遞。</span><span class="sxs-lookup"><span data-stu-id="d9e16-218">Message properties exist primarily as a communication mechanism to pass data about the message between the various channels in the channel stack, and between the channel stack and the service model.</span></span>  
  
 <span data-ttu-id="d9e16-219">例如，包含當做 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 一部分的 HTTP 傳輸通道，當其將回應傳送至用戶端時，能夠產生各種 HTTP 狀態碼，例如「404 (找不到)」和「500 (內部伺服器錯誤)」。</span><span class="sxs-lookup"><span data-stu-id="d9e16-219">For example, the HTTP transport channel included as part of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] is capable of producing various HTTP status codes, such as "404 (Not Found)" and "500 (Internal Server Error)," when it sends replies to clients.</span></span> <span data-ttu-id="d9e16-220">在傳送之前的回覆訊息，它會檢查是否`Properties`的`Message`包含稱為"httpResponse"，其中包含的型別物件的屬性<xref:System.ServiceModel.Channels.HttpResponseMessageProperty>。</span><span class="sxs-lookup"><span data-stu-id="d9e16-220">Before sending a reply message, it checks to see whether the `Properties` of the `Message` contain a property called "httpResponse" that contains an object of type <xref:System.ServiceModel.Channels.HttpResponseMessageProperty>.</span></span> <span data-ttu-id="d9e16-221">如果找到這類屬性，它會查看 <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> 屬性然後使用該狀態碼。</span><span class="sxs-lookup"><span data-stu-id="d9e16-221">If such a property is found, it will look at the <xref:System.ServiceModel.Channels.HttpResponseMessageProperty.StatusCode%2A> property and use that status code.</span></span> <span data-ttu-id="d9e16-222">如果找不到，就會使用預設「200 (確定)」代碼。</span><span class="sxs-lookup"><span data-stu-id="d9e16-222">If it is not found, the default "200 (OK)" code is used.</span></span>  
  
 [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="d9e16-223"> [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-223"> [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md).</span></span>  
  
### <a name="the-message-as-a-whole"></a><span data-ttu-id="d9e16-224">整個訊息</span><span class="sxs-lookup"><span data-stu-id="d9e16-224">The Message as a Whole</span></span>  
 <span data-ttu-id="d9e16-225">到目前為止，已經單獨討論過存取訊息各部分的方法。</span><span class="sxs-lookup"><span data-stu-id="d9e16-225">So far, we have discussed methods for accessing the various parts of the message in isolation.</span></span> <span data-ttu-id="d9e16-226">但是， <xref:System.ServiceModel.Channels.Message> 類別也提供方法與整個訊息一起運作。</span><span class="sxs-lookup"><span data-stu-id="d9e16-226">However, the <xref:System.ServiceModel.Channels.Message> class also provides methods to work with the entire message as a whole.</span></span> <span data-ttu-id="d9e16-227">例如， `WriteMessage` 方法會將整個訊息寫出至 XML 寫入器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-227">For example, the `WriteMessage` method writes out the entire message to an XML writer.</span></span>  
  
 <span data-ttu-id="d9e16-228">為了要能夠這樣做，就必須在整個 `Message` 執行個體與 XML Infoset 之間定義對應。</span><span class="sxs-lookup"><span data-stu-id="d9e16-228">For this to be possible, a mapping must be defined between the entire `Message` instance and an XML Infoset.</span></span> <span data-ttu-id="d9e16-229">事實上這類對應已經存在： [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 會使用 SOAP 標準定義這個對應。</span><span class="sxs-lookup"><span data-stu-id="d9e16-229">Such a mapping, in fact, exists: [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] uses the SOAP standard to define this mapping.</span></span> <span data-ttu-id="d9e16-230">當寫出 `Message` 執行個體當做 XML Infoset 時，產生的 Infoset 是包含訊息的有效 SOAP 封套。</span><span class="sxs-lookup"><span data-stu-id="d9e16-230">When a `Message` instance is written out as an XML Infoset, the resulting Infoset is the valid SOAP envelope that contains the message.</span></span> <span data-ttu-id="d9e16-231">因此， `WriteMessage` 通常會執行下列步驟：</span><span class="sxs-lookup"><span data-stu-id="d9e16-231">Thus, `WriteMessage` would normally perform the following steps:</span></span>  
  
1.  <span data-ttu-id="d9e16-232">寫入 SOAP 封套項目開頭標記。</span><span class="sxs-lookup"><span data-stu-id="d9e16-232">Write the SOAP envelope element opening tag.</span></span>  
  
2.  <span data-ttu-id="d9e16-233">寫入 SOAP 標頭項目開頭標記、寫出所有的標頭，然後關閉標頭項目。</span><span class="sxs-lookup"><span data-stu-id="d9e16-233">Write the SOAP header element opening tag, write out all of the headers, and close the header element.</span></span>  
  
3.  <span data-ttu-id="d9e16-234">寫入 SOAP 本文項目開頭標記。</span><span class="sxs-lookup"><span data-stu-id="d9e16-234">Write the SOAP body element opening tag.</span></span>  
  
4.  <span data-ttu-id="d9e16-235">呼叫 `WriteBodyContents` 或對等的方法以寫出本文。</span><span class="sxs-lookup"><span data-stu-id="d9e16-235">Call `WriteBodyContents` or an equivalent method to write out the body.</span></span>  
  
5.  <span data-ttu-id="d9e16-236">關閉本文與封套項目。</span><span class="sxs-lookup"><span data-stu-id="d9e16-236">Close the body and envelope elements.</span></span>  
  
 <span data-ttu-id="d9e16-237">之前的步驟與 SOAP 標準緊密相關。</span><span class="sxs-lookup"><span data-stu-id="d9e16-237">The preceding steps are closely tied to the SOAP standard.</span></span> <span data-ttu-id="d9e16-238">因為事實上存在多個 SOAP 版本導致情況變得複雜；例如，可以在不了解使用中之 SOAP 版本的情況下正確寫出 SOAP 封套項目。</span><span class="sxs-lookup"><span data-stu-id="d9e16-238">This is complicated by the fact that multiple versions of SOAP exist, for example, it is impossible to write out the SOAP envelope element correctly without knowing the SOAP version in use.</span></span> <span data-ttu-id="d9e16-239">同樣地，在某些案例中，可能想要完全關閉這項複雜的 SOAP 特定對應。</span><span class="sxs-lookup"><span data-stu-id="d9e16-239">Also, in some cases, it may be desirable to turn off this complex SOAP-specific mapping completely.</span></span>  
  
 <span data-ttu-id="d9e16-240">針對這些用途，在 `Version` 會提供 `Message`屬性。</span><span class="sxs-lookup"><span data-stu-id="d9e16-240">For these purposes, a `Version` property is provided on `Message`.</span></span> <span data-ttu-id="d9e16-241">當寫出訊息時可以設定要使用的 SOAP 版本，或是可以設定為 `None` 以避免任何 SOAP 特定對應。</span><span class="sxs-lookup"><span data-stu-id="d9e16-241">It can be set to the SOAP version to use when writing out the message, or it can be set to `None` to prevent any SOAP-specific mappings.</span></span> <span data-ttu-id="d9e16-242">如果 `Version` 屬性設定為 `None`，與整個訊息一起運作的方法會當做訊息只是由其本文所組成；例如， `WriteMessage` 只會呼叫 `WriteBodyContents` 而不是執行上述列出的多個步驟。</span><span class="sxs-lookup"><span data-stu-id="d9e16-242">If the `Version` property is set to `None`, methods that work with the entire message act as if the message consisted of its body only, for example, `WriteMessage` would simply call `WriteBodyContents` instead of performing the multiple steps listed above.</span></span> <span data-ttu-id="d9e16-243">預期在傳入訊息上，將會自動偵測 `Version` 並正確設定。</span><span class="sxs-lookup"><span data-stu-id="d9e16-243">It is expected that on incoming messages, `Version` will be auto-detected and set correctly.</span></span>  
  
## <a name="the-channel-stack"></a><span data-ttu-id="d9e16-244">通道堆疊</span><span class="sxs-lookup"><span data-stu-id="d9e16-244">The Channel Stack</span></span>  
  
### <a name="channels"></a><span data-ttu-id="d9e16-245">通道</span><span class="sxs-lookup"><span data-stu-id="d9e16-245">Channels</span></span>  
 <span data-ttu-id="d9e16-246">如同之前所述，通道堆疊負責將傳出 <xref:System.ServiceModel.Channels.Message> 執行個體轉換成某些動作 (例如在網路上傳送封包)，或是將某些動作 (例如接收網路封包) 轉換成傳入 `Message` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="d9e16-246">As stated before, the channel stack is responsible for converting outgoing <xref:System.ServiceModel.Channels.Message> instances into some action (such as sending packets over the network), or converting some action (such as receiving network packets) into incoming `Message` instances.</span></span>  
  
 <span data-ttu-id="d9e16-247">通道堆疊是由一或多個依順序排列的通道組成。</span><span class="sxs-lookup"><span data-stu-id="d9e16-247">The channel stack is composed of one or more channels ordered in a sequence.</span></span> <span data-ttu-id="d9e16-248">傳出 `Message` 執行個體會傳遞至堆疊中的第一個通道 (也稱為「 *最上層通道*」(Topmost Channel))，然後再向下傳遞至堆疊中的下一個通道，以此類推。</span><span class="sxs-lookup"><span data-stu-id="d9e16-248">An outgoing `Message` instance is passed to the first channel in the stack (also called the *topmost channel*), which passes it to the next channel down in stack, and so on.</span></span> <span data-ttu-id="d9e16-249">訊息會終止在最後一個通道，稱為「 *傳輸通道*」(Transport Channel)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-249">The message terminates in the last channel, which is called the *transport channel*.</span></span> <span data-ttu-id="d9e16-250">傳入訊息來自傳輸通道，並且會在堆疊的通道間向上傳遞。</span><span class="sxs-lookup"><span data-stu-id="d9e16-250">Incoming messages originate in the transport channel and are passed from channel to channel up the stack.</span></span> <span data-ttu-id="d9e16-251">從最上層通道，訊息通常會傳遞至服務架構。</span><span class="sxs-lookup"><span data-stu-id="d9e16-251">From the topmost channel, the message is usually passed into the service framework.</span></span> <span data-ttu-id="d9e16-252">雖然這是應用程式訊息的常見模式，某些通道的運作方式卻有些不同；例如，通道可能會在沒有收到上層通道所傳遞訊息的情況下，傳送專屬的基礎結構訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-252">While this is the usual pattern for application messages, some channels may work slightly differently, for example, they may send their own infrastructure messages without being passed a message from a channel above.</span></span>  
  
 <span data-ttu-id="d9e16-253">當訊息在堆疊內傳遞時，通道可能會在訊息上以各種方式作業。</span><span class="sxs-lookup"><span data-stu-id="d9e16-253">Channels may operate on the message in various ways as it passes through the stack.</span></span> <span data-ttu-id="d9e16-254">最常見的作業是將標頭新增至傳出訊息，然後讀取傳入訊息上的標頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-254">The most common operation is adding a header to an outgoing message and reading headers on an incoming message.</span></span> <span data-ttu-id="d9e16-255">例如，通道可能會計算訊息的數位簽章，然後將其新增當做標頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-255">For example, a channel may compute the digital signature of a message and add it as a header.</span></span> <span data-ttu-id="d9e16-256">通道也會在傳入訊息上檢查這個數位簽章標頭，然後封鎖沒有有效簽章的訊息避免在通道堆疊向上傳遞。</span><span class="sxs-lookup"><span data-stu-id="d9e16-256">A channel may also inspect this digital signature header on incoming messages and block messages that do not have a valid signature from making their way up the channel stack.</span></span> <span data-ttu-id="d9e16-257">通道通常也會設定或檢查訊息屬性。</span><span class="sxs-lookup"><span data-stu-id="d9e16-257">Channels also often set or inspect message properties.</span></span> <span data-ttu-id="d9e16-258">訊息本文通常不會修改 (雖然允許這麼做)；例如， [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 安全性通道能夠加密訊息本文。</span><span class="sxs-lookup"><span data-stu-id="d9e16-258">The message body is usually not modified, although this is allowed, for example, the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] security channel can encrypt the message body.</span></span>  
  
### <a name="transport-channels-and-message-encoders"></a><span data-ttu-id="d9e16-259">傳輸通道與訊息編碼器</span><span class="sxs-lookup"><span data-stu-id="d9e16-259">Transport Channels and Message Encoders</span></span>  
 <span data-ttu-id="d9e16-260">堆疊中的最底層通道負責將傳出 <xref:System.ServiceModel.Channels.Message>(其他通道已修改過) 實際轉換為某些動作。</span><span class="sxs-lookup"><span data-stu-id="d9e16-260">The bottommost channel in the stack is responsible for actually transforming an outgoing <xref:System.ServiceModel.Channels.Message>, as modified by other channels, into some action.</span></span> <span data-ttu-id="d9e16-261">在接收端，這是將某些動作轉換為讓其他通道處理之 `Message` 的通道。</span><span class="sxs-lookup"><span data-stu-id="d9e16-261">On the receive side, this is the channel that converts some action into a `Message` that other channels process.</span></span>  
  
 <span data-ttu-id="d9e16-262">如同之前所述，動作可能有很多種：經由各種通訊協定傳送或接收網路封包、在資料庫中讀取或寫入訊息，或是在訊息佇列中新增或清除佇列訊息，以提供為數不多的範例。</span><span class="sxs-lookup"><span data-stu-id="d9e16-262">As stated previously, the actions may be varied: sending or receiving network packets over various protocols, reading or writing the message in a database, or queuing or dequeuing the message in a Message Queuing queue, to provide but a few examples.</span></span> <span data-ttu-id="d9e16-263">所有這些動作都有個共通點：需要在 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]`Message` 執行個體與能夠傳送、接收、寫入、新增佇列或清除佇列的實際位元組群組之間轉換。</span><span class="sxs-lookup"><span data-stu-id="d9e16-263">All these actions have one thing in common: they require a transformation between the [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]`Message` instance and an actual group of bytes that can be sent, received, read, written, queued, or dequeued.</span></span> <span data-ttu-id="d9e16-264">將 `Message` 轉換為位元組群組的程序稱為「 *編碼*」(Encoding)，而從位元組群組建立 `Message` 的反向程序稱為「 *解碼*」(Decoding)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-264">The process of converting a `Message` into a group of bytes is called *encoding*, and the reverse process of creating a `Message` from a group of bytes is called *decoding*.</span></span>  
  
 <span data-ttu-id="d9e16-265">大部分的傳輸通道會使用稱為「 *訊息編碼器* 」(Message Encoder) 的元件以完成編碼與解碼工作。</span><span class="sxs-lookup"><span data-stu-id="d9e16-265">Most transport channels use components called *message encoders* to accomplish the encoding and decoding work.</span></span> <span data-ttu-id="d9e16-266">訊息編碼器是 <xref:System.ServiceModel.Channels.MessageEncoder> 類別的子類別。</span><span class="sxs-lookup"><span data-stu-id="d9e16-266">A message encoder is a subclass of the <xref:System.ServiceModel.Channels.MessageEncoder> class.</span></span> <span data-ttu-id="d9e16-267">`MessageEncoder` 包含各種 `ReadMessage` 和 `WriteMessage` 方法多載，以便在 `Message` 和位元組群組之間轉換。</span><span class="sxs-lookup"><span data-stu-id="d9e16-267">`MessageEncoder` includes various `ReadMessage` and `WriteMessage` method overloads to convert between `Message` and groups of bytes.</span></span>  
  
 <span data-ttu-id="d9e16-268">在傳送端，緩衝處理的傳輸通道會將從上一層通道接收到的 `Message` 物件傳遞到 `WriteMessage`。</span><span class="sxs-lookup"><span data-stu-id="d9e16-268">On the sending side, a buffering transport channel passes the `Message` object that it received from a channel above it to `WriteMessage`.</span></span> <span data-ttu-id="d9e16-269">它會取回位元組陣列，然後用來執行其動作 (例如將這些位元組封裝成有效 TCP 封包，然後將它們傳送至正確的目的地)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-269">It gets back an array of bytes, which it then uses to perform its action (such as packaging these bytes as valid TCP packets and sending them to the correct destination).</span></span> <span data-ttu-id="d9e16-270">資料流傳輸通道會先建立 `Stream` (例如，透過傳出 TCP 連線)，然後同時傳遞需要傳送的 `Stream` 和 `Message` 至適當 `WriteMessage` 多載以寫出訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-270">A streaming transport channel first creates a `Stream` (for example, over the outgoing TCP connection), and then passes both the `Stream` and the `Message` it needs to send to the appropriate `WriteMessage` overload, which writes out the message.</span></span>  
  
 <span data-ttu-id="d9e16-271">在接收端，緩衝處理的傳輸通道會將傳入位元組 (例如，從傳入 TCP 封包) 擷取至陣列中，然後呼叫 `ReadMessage` 以取得能夠在通道堆疊進一步向上傳遞的 `Message` 物件。</span><span class="sxs-lookup"><span data-stu-id="d9e16-271">On the receiving side, a buffering transport channel extracts incoming bytes (for example, from incoming TCP packets) into an array and calls `ReadMessage` to get a `Message` object that it can pass further up the channel stack.</span></span> <span data-ttu-id="d9e16-272">資料流傳輸通道會建立 `Stream` 物件 (例如，經由傳入 TCP 連線的網路資料流)，然後將其傳遞至 `ReadMessage` 以取回 `Message` 物件。</span><span class="sxs-lookup"><span data-stu-id="d9e16-272">A streaming transport channel creates a `Stream` object (for example, a network stream over the incoming TCP connection) and passes that to `ReadMessage` to get back a `Message` object.</span></span>  
  
 <span data-ttu-id="d9e16-273">傳輸通道與訊息編碼器之間的分隔並不是強制性的；可以寫入不使用訊息編碼器的傳輸通道。</span><span class="sxs-lookup"><span data-stu-id="d9e16-273">The separation between the transport channels and the message encoder is not mandatory; it is possible to write a transport channel that does not use a message encoder.</span></span> <span data-ttu-id="d9e16-274">但是，這項分隔的優點是容易撰寫。</span><span class="sxs-lookup"><span data-stu-id="d9e16-274">However, the advantage of this separation is ease of composition.</span></span> <span data-ttu-id="d9e16-275">只要傳輸通道只使用基底 <xref:System.ServiceModel.Channels.MessageEncoder>，就能夠使用任何 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 或協力廠商訊息編碼器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-275">As long as a transport channel uses only the base <xref:System.ServiceModel.Channels.MessageEncoder>, it can work with any [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] or third-party message encoder.</span></span> <span data-ttu-id="d9e16-276">同樣地，相同的編碼器通常能夠在任何傳輸通道中使用。</span><span class="sxs-lookup"><span data-stu-id="d9e16-276">Likewise, the same encoder can normally be used in any transport channel.</span></span>  
  
### <a name="message-encoder-operation"></a><span data-ttu-id="d9e16-277">訊息編碼器作業</span><span class="sxs-lookup"><span data-stu-id="d9e16-277">Message Encoder Operation</span></span>  
 <span data-ttu-id="d9e16-278">若要描述編碼器的一般作業，考量下列四種案例會有幫助。</span><span class="sxs-lookup"><span data-stu-id="d9e16-278">To describe the typical operation of an encoder, it is useful to consider the following four cases.</span></span>  
  
|<span data-ttu-id="d9e16-279">運算</span><span class="sxs-lookup"><span data-stu-id="d9e16-279">Operation</span></span>|<span data-ttu-id="d9e16-280">註解</span><span class="sxs-lookup"><span data-stu-id="d9e16-280">Comment</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="d9e16-281">編碼，經過緩衝處理</span><span class="sxs-lookup"><span data-stu-id="d9e16-281">Encoding, Buffered</span></span>|<span data-ttu-id="d9e16-282">在經過緩衝處理模式中，編碼器通常會建立大小會變動的緩衝區，然後在緩衝區建立 XML 寫入器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-282">In buffered mode, the encoder normally creates a variable-size buffer and then creates an XML writer over it.</span></span> <span data-ttu-id="d9e16-283">然後它會在要編碼的訊息上呼叫 <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> 以寫出標頭，然後本文會使用 <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>，如同本主題中說明有關 `Message` 的之前章節。</span><span class="sxs-lookup"><span data-stu-id="d9e16-283">It then calls <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> on the message being encoded, which writes out the headers and then the body using <xref:System.ServiceModel.Channels.Message.WriteBodyContents%28System.Xml.XmlDictionaryWriter%29>, as explained in the preceding section about `Message` in this topic.</span></span> <span data-ttu-id="d9e16-284">然後就會傳回緩衝區的內容 (以位元組陣列表示) 以便讓傳輸通道使用。</span><span class="sxs-lookup"><span data-stu-id="d9e16-284">The contents of the buffer (represented as an array of bytes) are then returned for the transport channel to use.</span></span>|  
|<span data-ttu-id="d9e16-285">編碼，經過資料流處理</span><span class="sxs-lookup"><span data-stu-id="d9e16-285">Encoding, Streamed</span></span>|<span data-ttu-id="d9e16-286">在經過資料流處理模式中，作業類似上述說明，但是更為簡單。</span><span class="sxs-lookup"><span data-stu-id="d9e16-286">In streamed mode, the operation is similar to the above, but simpler.</span></span> <span data-ttu-id="d9e16-287">不需要緩衝區。</span><span class="sxs-lookup"><span data-stu-id="d9e16-287">There is no need for a buffer.</span></span> <span data-ttu-id="d9e16-288">XML 寫入器會以一般方式在資料流上建立，然後在 <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> 上呼叫 `Message` 以寫出至這個寫入器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-288">An XML writer is normally created over the stream and <xref:System.ServiceModel.Channels.Message.WriteMessage%28System.Xml.XmlWriter%29> is called on the `Message` to write it out to this writer.</span></span>|  
|<span data-ttu-id="d9e16-289">解碼，經過緩衝處理</span><span class="sxs-lookup"><span data-stu-id="d9e16-289">Decoding, Buffered</span></span>|<span data-ttu-id="d9e16-290">當在經過緩衝處理模式中進行解碼時，通常會建立包含經過緩衝處理資料的特殊 `Message` 子類別。</span><span class="sxs-lookup"><span data-stu-id="d9e16-290">When decoding in buffered mode, a special `Message` subclass that contains the buffered data is normally created.</span></span> <span data-ttu-id="d9e16-291">會讀取訊息的標頭，然後建立位於訊息本文上的 XML 讀取器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-291">The headers of the message are read, and an XML reader positioned on the message body is created.</span></span> <span data-ttu-id="d9e16-292">這是會跟 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>一起傳回的讀取器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-292">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
|<span data-ttu-id="d9e16-293">解碼，經過資料流處理</span><span class="sxs-lookup"><span data-stu-id="d9e16-293">Decoding, Streamed</span></span>|<span data-ttu-id="d9e16-294">當在經過資料流處理模式中進行解碼時，通常會建立特別訊息子類別。</span><span class="sxs-lookup"><span data-stu-id="d9e16-294">When decoding in streamed mode, a special Message subclass is normally created.</span></span> <span data-ttu-id="d9e16-295">資料流的進階程度剛好足以讀取所有標頭並位於訊息本文上。</span><span class="sxs-lookup"><span data-stu-id="d9e16-295">The stream is advanced just enough to read all the headers and position it on the message body.</span></span> <span data-ttu-id="d9e16-296">然後會在資料流上建立 XML 讀取器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-296">An XML reader is then created over the stream.</span></span> <span data-ttu-id="d9e16-297">這是會跟 <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>一起傳回的讀取器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-297">This is the reader that will be returned with <xref:System.ServiceModel.Channels.Message.GetReaderAtBodyContents>.</span></span>|  
  
 <span data-ttu-id="d9e16-298">編碼器也能夠執行其他功能。</span><span class="sxs-lookup"><span data-stu-id="d9e16-298">Encoders can perform other functions as well.</span></span> <span data-ttu-id="d9e16-299">例如，編碼器能夠集區 XML 讀取器和寫入器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-299">For example, the encoders can pool XML readers and writers.</span></span> <span data-ttu-id="d9e16-300">有需要就建立新的 XML 讀取器或寫入器是很昂貴的。</span><span class="sxs-lookup"><span data-stu-id="d9e16-300">It is expensive to create a new XML reader or writer every time one is needed.</span></span> <span data-ttu-id="d9e16-301">因此，編碼器通常會使用可設定的大小，維護讀取器的集區以及寫入器的集區。</span><span class="sxs-lookup"><span data-stu-id="d9e16-301">Therefore, encoders normally maintain a pool of readers and a pool of writers of configurable size.</span></span> <span data-ttu-id="d9e16-302">中的先前所述的編碼器作業說明，每當的片語使用 「 建立 XML 讀取器/寫入器 」 時，通常表示 「 從集區取用一個，或如果無法使用，請建立一個 」。</span><span class="sxs-lookup"><span data-stu-id="d9e16-302">In the descriptions of encoder operation described previously, whenever the phrase "create an XML reader/writer" is used, it normally means "take one from the pool, or create one if one is not available."</span></span> <span data-ttu-id="d9e16-303">編碼器 (和解碼時所建立的 `Message` 子類別) 包含邏輯，在不再需要使用讀取器和寫入器時 (例如，當 `Message` 已關閉) 將其傳回至集區。</span><span class="sxs-lookup"><span data-stu-id="d9e16-303">The encoder (and the `Message` subclasses it creates while decoding) contain logic to return readers and writers to the pools once they are no longer needed (for example, when the `Message` is closed).</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="d9e16-304"> 提供三種訊息編碼器 (雖然可以建立其他的自訂類型)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-304"> provides three message encoders, although it is possible to create additional custom types.</span></span> <span data-ttu-id="d9e16-305">提供的類型為文字、二進位以及訊息傳輸最佳化機制 (MTOM)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-305">The supplied types are Text, Binary, and Message Transmission Optimization Mechanism (MTOM).</span></span> <span data-ttu-id="d9e16-306">在 [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md)中會詳細描述這些類型。</span><span class="sxs-lookup"><span data-stu-id="d9e16-306">These are described in detail in [Choosing a Message Encoder](../../../../docs/framework/wcf/feature-details/choosing-a-message-encoder.md).</span></span>  
  
### <a name="the-istreamprovider-interface"></a><span data-ttu-id="d9e16-307">IStreamProvider 介面</span><span class="sxs-lookup"><span data-stu-id="d9e16-307">The IStreamProvider Interface</span></span>  
 <span data-ttu-id="d9e16-308">將含有經過資料流處理之本文的傳出訊息寫入至 XML 寫入器時， <xref:System.ServiceModel.Channels.Message> 將會在其 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 實作中使用類似下面一連串的呼叫：</span><span class="sxs-lookup"><span data-stu-id="d9e16-308">When writing an outgoing message that contains a streamed body to an XML writer, the <xref:System.ServiceModel.Channels.Message> uses a sequence of calls similar to the following in its <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> implementation:</span></span>  
  
-   <span data-ttu-id="d9e16-309">在資料流前面寫入任何必要的資訊，(例如，開頭 XML 標記)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-309">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
-   <span data-ttu-id="d9e16-310">寫入資料流。</span><span class="sxs-lookup"><span data-stu-id="d9e16-310">Write the stream.</span></span>  
  
-   <span data-ttu-id="d9e16-311">在資料流後面寫入任何資訊，(例如，結束 XML 標記)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-311">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="d9e16-312">這很適合用在類似文字 XML 編碼方式的編碼。</span><span class="sxs-lookup"><span data-stu-id="d9e16-312">This works well with encodings that are similar to the textual XML encoding.</span></span> <span data-ttu-id="d9e16-313">但是，有些編碼並不會將 XML Infoset 資訊 (例如，XML 項目的開頭及結束標記) 與包含在項目內的資料放在一起。</span><span class="sxs-lookup"><span data-stu-id="d9e16-313">However, some encodings do not place XML Infoset information (for example, tags for starting and ending XML elements) together with the data contained within elements.</span></span> <span data-ttu-id="d9e16-314">例如，在 MTOM 編碼中，訊息會分割為多個部分。</span><span class="sxs-lookup"><span data-stu-id="d9e16-314">For example, in the MTOM encoding, the message is split into multiple parts.</span></span> <span data-ttu-id="d9e16-315">其中一個部分會包含 XML Infoset，而這其中可能會包含實際項目內容之其他部分的參考。</span><span class="sxs-lookup"><span data-stu-id="d9e16-315">One part contains the XML Infoset, which may contain references to other parts for actual element contents.</span></span> <span data-ttu-id="d9e16-316">XML Infoset 通常會比資料流處理後的內容還要小，因此合理的做法是先緩衝處理 Infoset，再將它寫出，然後以資料流的處理方式寫入內容。</span><span class="sxs-lookup"><span data-stu-id="d9e16-316">The XML Infoset is normally small compared to the streamed contents, so it makes sense to buffer the Infoset, write it out, and then write the contents in a streamed way.</span></span> <span data-ttu-id="d9e16-317">這表示在寫入結尾項目標記以前，應該還沒有寫出資料流。</span><span class="sxs-lookup"><span data-stu-id="d9e16-317">This means that by the time the closing element tag is written, the stream should not have been written out yet.</span></span>  
  
 <span data-ttu-id="d9e16-318">為此，這時會使用 <xref:System.Xml.IStreamProvider> 介面。</span><span class="sxs-lookup"><span data-stu-id="d9e16-318">For this purpose, the <xref:System.Xml.IStreamProvider> interface is used.</span></span> <span data-ttu-id="d9e16-319">這個介面具有可以傳回要寫入之資料流的 <xref:System.Xml.IStreamProvider.GetStream> 方法。</span><span class="sxs-lookup"><span data-stu-id="d9e16-319">The interface has a <xref:System.Xml.IStreamProvider.GetStream> method that returns the stream to be written.</span></span> <span data-ttu-id="d9e16-320">寫出 <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> 中已由資料流處理之訊息本文的正確方式如下所示：</span><span class="sxs-lookup"><span data-stu-id="d9e16-320">The correct way to write out a streamed message body in <xref:System.ServiceModel.Channels.Message.OnWriteBodyContents%28System.Xml.XmlDictionaryWriter%29> is as follows:</span></span>  
  
1.  <span data-ttu-id="d9e16-321">在資料流前面寫入任何必要的資訊，(例如，開頭 XML 標記)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-321">Write any necessary information preceding the stream (for example, the opening XML tag).</span></span>  
  
2.  <span data-ttu-id="d9e16-322">配合傳回要寫入之資料流的 `WriteValue` 實作，在接受 <xref:System.Xml.XmlDictionaryWriter> 的 <xref:System.Xml.IStreamProvider>上呼叫 `IStreamProvider` 多載。</span><span class="sxs-lookup"><span data-stu-id="d9e16-322">Call the `WriteValue` overload on the <xref:System.Xml.XmlDictionaryWriter> that takes an <xref:System.Xml.IStreamProvider>, with an `IStreamProvider` implementation that returns the stream to be written.</span></span>  
  
3.  <span data-ttu-id="d9e16-323">在資料流後面寫入任何資訊，(例如，結束 XML 標記)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-323">Write any information following the stream (for example, the closing XML tag).</span></span>  
  
 <span data-ttu-id="d9e16-324">透過這種方式，XML 寫入器就可以選擇呼叫 <xref:System.Xml.IStreamProvider.GetStream> 以及寫出經過資料流處理之資料的時機。</span><span class="sxs-lookup"><span data-stu-id="d9e16-324">With this approach, the XML writer has a choice of when to call <xref:System.Xml.IStreamProvider.GetStream> and write out the streamed data.</span></span> <span data-ttu-id="d9e16-325">例如，文字及二進位 XML 寫入器將立即呼叫此方法，並在開始與結束標記之間寫出資料流處理內容。</span><span class="sxs-lookup"><span data-stu-id="d9e16-325">For example, the textual and binary XML writers will call it immediately and write out the streamed contents in-between the start and end tags.</span></span> <span data-ttu-id="d9e16-326">MTOM 寫入器則可能會決定於稍後準備好要寫入訊息的適當部分時，再呼叫 <xref:System.Xml.IStreamProvider.GetStream> 。</span><span class="sxs-lookup"><span data-stu-id="d9e16-326">The MTOM writer may decide to call <xref:System.Xml.IStreamProvider.GetStream> later, when it is ready to write the appropriate part of the message.</span></span>  
  
## <a name="representing-data-in-the-service-framework"></a><span data-ttu-id="d9e16-327">在服務架構中表示資料</span><span class="sxs-lookup"><span data-stu-id="d9e16-327">Representing Data in the Service Framework</span></span>  
 <span data-ttu-id="d9e16-328">如同在此主題的「基本架構」章節中所述，服務架構是 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 的一部分，此外，也負責在訊息資料的方便使用之程式設計模型與實際 `Message` 執行個體之間進行轉換。</span><span class="sxs-lookup"><span data-stu-id="d9e16-328">As stated in the "Basic Architecture" section of this topic, the service framework is the part of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] that, among other things, is responsible for converting between a user-friendly programming model for message data and actual `Message` instances.</span></span> <span data-ttu-id="d9e16-329">通常訊息交換在服務架構中會表示為使用 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 屬性標記的 <xref:System.ServiceModel.OperationContractAttribute> 方法。</span><span class="sxs-lookup"><span data-stu-id="d9e16-329">Normally, a message exchange is represented in the service framework as a [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] method marked with the <xref:System.ServiceModel.OperationContractAttribute> attribute.</span></span> <span data-ttu-id="d9e16-330">方法可以取用某些參數然後傳回值或輸出參數 (或兩者皆是)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-330">The method can take in some parameters and can return a return value or out parameters (or both).</span></span> <span data-ttu-id="d9e16-331">在服務端，輸入參數代表傳入訊息，而傳回值與輸出參數代表傳出訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-331">On the service side, the input parameters represent the incoming message, and the return value and out parameters represent the outgoing message.</span></span> <span data-ttu-id="d9e16-332">在用戶端，則是反向作業。</span><span class="sxs-lookup"><span data-stu-id="d9e16-332">On the client side, the reverse is true.</span></span> <span data-ttu-id="d9e16-333">在 [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)中會詳細描述使用參數與傳回值之描述訊息的程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="d9e16-333">The programming model for describing messages using parameters and the return value is described in detail in [Specifying Data Transfer in Service Contracts](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).</span></span> <span data-ttu-id="d9e16-334">但是，這個章節將提供簡短的概觀。</span><span class="sxs-lookup"><span data-stu-id="d9e16-334">However, this section will provide a brief overview.</span></span>  
  
## <a name="programming-models"></a><span data-ttu-id="d9e16-335">程式設計模型</span><span class="sxs-lookup"><span data-stu-id="d9e16-335">Programming Models</span></span>  
 <span data-ttu-id="d9e16-336">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 服務架構支援五種不同的描述訊息程式設計模型：</span><span class="sxs-lookup"><span data-stu-id="d9e16-336">The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service framework supports five different programming models for describing messages:</span></span>  
  
### <a name="1-the-empty-message"></a><span data-ttu-id="d9e16-337">1.空訊息</span><span class="sxs-lookup"><span data-stu-id="d9e16-337">1. The Empty Message</span></span>  
 <span data-ttu-id="d9e16-338">這是最單純的案例。</span><span class="sxs-lookup"><span data-stu-id="d9e16-338">This is the simplest case.</span></span> <span data-ttu-id="d9e16-339">若要描述空的傳入訊息，請不要使用任何輸入參數。</span><span class="sxs-lookup"><span data-stu-id="d9e16-339">To describe an empty incoming message, do not use any input parameters.</span></span>  
  
 [!code-csharp[C_DataArchitecture#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#3)]
 [!code-vb[C_DataArchitecture#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#3)]  
  
 <span data-ttu-id="d9e16-340">若要描述空的傳出訊息，請使用 void 傳回值並且不要使用任何輸出參數：</span><span class="sxs-lookup"><span data-stu-id="d9e16-340">To describe an empty outgoing message, use a void return value and do not use any out parameters:</span></span>  
  
 [!code-csharp[C_DataArchitecture#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#4)]
 [!code-vb[C_DataArchitecture#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#4)]  
  
 <span data-ttu-id="d9e16-341">請注意這與單向作業合約不同：</span><span class="sxs-lookup"><span data-stu-id="d9e16-341">Note that this is different from a one-way operation contract:</span></span>  
  
 [!code-csharp[C_DataArchitecture#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#5)]
 [!code-vb[C_DataArchitecture#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#5)]  
  
 <span data-ttu-id="d9e16-342">在 `SetDesiredTemperature` 範例中，會描述雙向訊息交換模式。</span><span class="sxs-lookup"><span data-stu-id="d9e16-342">In the `SetDesiredTemperature` example, a two-way message exchange pattern is described.</span></span> <span data-ttu-id="d9e16-343">訊息會從作業傳回，但是訊息為空的。</span><span class="sxs-lookup"><span data-stu-id="d9e16-343">A message is returned from the operation, but it is empty.</span></span> <span data-ttu-id="d9e16-344">可以從作業傳回錯誤。</span><span class="sxs-lookup"><span data-stu-id="d9e16-344">It is possible to return a fault from the operation.</span></span> <span data-ttu-id="d9e16-345">在 "Set Lightbulb" 範例中，訊息交換模式是單向的，所以沒有需要描述的傳出訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-345">In the "Set Lightbulb" example, the message exchange pattern is one-way, so there is no outgoing message to describe.</span></span> <span data-ttu-id="d9e16-346">在此例中服務無法將任何狀態傳回用戶端。</span><span class="sxs-lookup"><span data-stu-id="d9e16-346">The service cannot communicate any status back to the client in this case.</span></span>  
  
### <a name="2-using-the-message-class-directly"></a><span data-ttu-id="d9e16-347">2.直接使用訊息類別</span><span class="sxs-lookup"><span data-stu-id="d9e16-347">2. Using the Message Class Directly</span></span>  
 <span data-ttu-id="d9e16-348">可以在作業合約中直接使用 <xref:System.ServiceModel.Channels.Message> 類別 (或是其中一個子類別)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-348">It is possible to use the <xref:System.ServiceModel.Channels.Message> class (or one of its subclasses) directly in an operation contract.</span></span> <span data-ttu-id="d9e16-349">在此例中，服務架構只會在不進行任何處理的情況下把作業的 `Message` 傳遞給通道堆疊 (反之亦然)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-349">In this case, the service framework just passes the `Message` from the operation to the channel stack and vice versa, with no further processing.</span></span>  
  
 <span data-ttu-id="d9e16-350">直接使用 `Message` 有兩個主要的使用案例。</span><span class="sxs-lookup"><span data-stu-id="d9e16-350">There are two main use cases for using `Message` directly.</span></span> <span data-ttu-id="d9e16-351">當沒有任何其他程式設計模型能提供足夠的彈性以描述訊息時，您可以在進階案例使用它。</span><span class="sxs-lookup"><span data-stu-id="d9e16-351">You can use this for advanced scenarios, when none of the other programming models gives you enough flexibility to describe your message.</span></span> <span data-ttu-id="d9e16-352">例如，您可能想要使用磁碟上的檔案描述訊息，將檔案的屬性變成訊息標頭，而檔案的內容變成訊息本文。</span><span class="sxs-lookup"><span data-stu-id="d9e16-352">For example, you might want to use files on disk to describe a message, with the file’s properties becoming message headers and the file’s contents becoming the message body.</span></span> <span data-ttu-id="d9e16-353">然後可以建立類似下列的項目。</span><span class="sxs-lookup"><span data-stu-id="d9e16-353">You can then create something similar to the following.</span></span>  
  
 [!code-csharp[C_DataArchitecture#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#6)]
 [!code-vb[C_DataArchitecture#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#6)]  
  
 <span data-ttu-id="d9e16-354">第二種在作業合約中常見的 `Message` 使用方式，是當服務不在意特定的訊息內容，並且將訊息當做黑箱進行作業時。</span><span class="sxs-lookup"><span data-stu-id="d9e16-354">The second common use for `Message` in an operation contract is when a service does not care about the particular message contents and acts on the message as on a black box.</span></span> <span data-ttu-id="d9e16-355">例如，您可能會有將訊息轉寄給多個其他收件者的服務。</span><span class="sxs-lookup"><span data-stu-id="d9e16-355">For example, you might have a service that forwards messages to multiple other recipients.</span></span> <span data-ttu-id="d9e16-356">合約寫入方式可以如下所示。</span><span class="sxs-lookup"><span data-stu-id="d9e16-356">The contract can be written as follows.</span></span>  
  
 [!code-csharp[C_DataArchitecture#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#7)]
 [!code-vb[C_DataArchitecture#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#7)]  
  
 <span data-ttu-id="d9e16-357">動作 ="\*"行有效地關閉訊息分派，並可確保所有訊息都傳送至`IForwardingService`合約使其能夠`ForwardMessage`作業。</span><span class="sxs-lookup"><span data-stu-id="d9e16-357">The Action="\*" line effectively turns off message dispatching and ensures that all messages sent to the `IForwardingService` contract make their way to the `ForwardMessage` operation.</span></span> <span data-ttu-id="d9e16-358">（一般來說，發送器會檢查訊息的"Action"標頭，來判斷它用來進行哪些作業。</span><span class="sxs-lookup"><span data-stu-id="d9e16-358">(Normally, the dispatcher would examine the message’s "Action" header to determine which operation it is intended for.</span></span> <span data-ttu-id="d9e16-359">動作 ="\*「 代表 」 的動作標頭的所有可能值 」。)動作的組合 ="\*"與使用 Message 當做參數稱為 「 通用合約 」，因為它是能夠接收所有可能的訊息。</span><span class="sxs-lookup"><span data-stu-id="d9e16-359">Action="\*" means "all possible values of the Action header".) The combination of Action="\*" and using Message as a parameter is known as the "universal contract" because it is able to receive all possible messages.</span></span> <span data-ttu-id="d9e16-360">若要能夠傳送所有可能的訊息，請使用 Message 當做傳回值，並設定`ReplyAction`至 「\*"。</span><span class="sxs-lookup"><span data-stu-id="d9e16-360">To be able to send all possible messages, use Message as the return value and set `ReplyAction` to "\*".</span></span> <span data-ttu-id="d9e16-361">這會避免服務架構新增專屬的 Action 標頭，讓您能夠使用傳回的 `Message` 物件控制這個標頭。</span><span class="sxs-lookup"><span data-stu-id="d9e16-361">This will prevent the service framework from adding its own Action header, enabling you to control this header using the `Message` object you return.</span></span>  
  
### <a name="3-message-contracts"></a><span data-ttu-id="d9e16-362">3.訊息合約</span><span class="sxs-lookup"><span data-stu-id="d9e16-362">3. Message Contracts</span></span>  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="d9e16-363"> 提供宣告式程式設計模型以描述訊息，稱為「 *訊息合約*」(Message Contract)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-363"> provides a declarative programming model for describing messages, called *message contracts*.</span></span> <span data-ttu-id="d9e16-364">這個模型在 [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)中有更詳細的說明。</span><span class="sxs-lookup"><span data-stu-id="d9e16-364">This model is described in detail in [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md).</span></span> <span data-ttu-id="d9e16-365">整個訊息在本質上是由使用像是 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 和 <xref:System.ServiceModel.MessageBodyMemberAttribute> 之屬性的單一 <xref:System.ServiceModel.MessageHeaderAttribute> 型別表示，以描述訊息合約類別與訊息之間的對應方式。</span><span class="sxs-lookup"><span data-stu-id="d9e16-365">Essentially, the entire message is represented by a single [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type that uses attributes like the <xref:System.ServiceModel.MessageBodyMemberAttribute> and <xref:System.ServiceModel.MessageHeaderAttribute> to describe which parts of the message contract class should map to which part of the message.</span></span>  
  
 <span data-ttu-id="d9e16-366">訊息合約提供對產生的 `Message` 執行個體提供許多控制 (雖然很明顯地不像直接使用 `Message` 類別一樣能夠提供那麼多的控制)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-366">Message contracts provide a lot of control over the resulting `Message` instances (although obviously not as much control as using the `Message` class directly).</span></span> <span data-ttu-id="d9e16-367">例如，訊息本文通常是由多段資訊所組成，每段資訊以專屬的 XML 項目表示。</span><span class="sxs-lookup"><span data-stu-id="d9e16-367">For example, message bodies are often composed of multiple pieces of information, each represented by its own XML element.</span></span> <span data-ttu-id="d9e16-368">這些項目可能會直接發生在本文中 (「*不包裝* 」(Bare) 模式)，或是可能「 *包裝* 」(Wrapped) 在內含 XML 項目中。</span><span class="sxs-lookup"><span data-stu-id="d9e16-368">These elements can either occur directly in the body (*bare* mode) or can be *wrapped* in an encompassing XML element.</span></span> <span data-ttu-id="d9e16-369">使用訊息合約程式設計模型能夠讓您決定要使用不包裝或包裝模式，然後控制包裝函式與命名空間名稱。</span><span class="sxs-lookup"><span data-stu-id="d9e16-369">Using the message contract programming model enables you to make the bare-versus-wrapped decision and control the name of the wrapper name and namespace.</span></span>  
  
 <span data-ttu-id="d9e16-370">下列訊息合約的程式碼範例示範這些功能。</span><span class="sxs-lookup"><span data-stu-id="d9e16-370">The following code example of a message contract demonstrates these features.</span></span>  
  
 [!code-csharp[C_DataArchitecture#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#9)]
 [!code-vb[C_DataArchitecture#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#9)]  
  
 <span data-ttu-id="d9e16-371">標記為要序列化的項目 (使用 <xref:System.ServiceModel.MessageBodyMemberAttribute>、 <xref:System.ServiceModel.MessageHeaderAttribute>或其他相關屬性) 必須可序列化，才能參與訊息合約。</span><span class="sxs-lookup"><span data-stu-id="d9e16-371">Items marked to be serialized (with the <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute>, or other related attributes) must be serializable to participate in a message contract.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="d9e16-372"> 本主題稍後的＜序列化＞一節。</span><span class="sxs-lookup"><span data-stu-id="d9e16-372"> the "Serialization" section later in this topic.</span></span>  
  
### <a name="4-parameters"></a><span data-ttu-id="d9e16-373">4.參數</span><span class="sxs-lookup"><span data-stu-id="d9e16-373">4. Parameters</span></span>  
 <span data-ttu-id="d9e16-374">想要描述作業而在多個資料片段執行作業的程式開發人員，通常不需要訊息合約提供的控制等級。</span><span class="sxs-lookup"><span data-stu-id="d9e16-374">Often, a developer who wants to describe an operation that acts on multiple pieces of data does not need the degree of control that message contracts provide.</span></span> <span data-ttu-id="d9e16-375">例如，當建立新的服務時，人們通常不想決定要使用不包裝或包裝模式，以及決定包裝函式項目的名稱。</span><span class="sxs-lookup"><span data-stu-id="d9e16-375">For example, when creating new services, one does not usually want to make the bare-versus-wrapped decision and decide on the wrapper element name.</span></span> <span data-ttu-id="d9e16-376">做這些決定通常需要深入了解 Web 服務與 SOAP。</span><span class="sxs-lookup"><span data-stu-id="d9e16-376">Making these decisions often requires deep knowledge of Web services and SOAP.</span></span>  
  
 <span data-ttu-id="d9e16-377">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 服務架構可以自動挑選最佳與最互通的 SOAP 表示法，以便在不需要強迫使用者做這些選擇的情況下，傳送或接收多個相關的資訊片段。</span><span class="sxs-lookup"><span data-stu-id="d9e16-377">The [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service framework can automatically pick the best and most interoperable SOAP representation for sending or receiving multiple related pieces of information, without forcing these choices on the user.</span></span> <span data-ttu-id="d9e16-378">只要描述這些資訊片段當做作業合約的參數或傳回值，就可以完成這個動作。</span><span class="sxs-lookup"><span data-stu-id="d9e16-378">This is accomplished by simply describing these pieces of information as parameters or return values of an operation contract.</span></span> <span data-ttu-id="d9e16-379">例如，請考量下列作業合約。</span><span class="sxs-lookup"><span data-stu-id="d9e16-379">For example, consider the following operation contract.</span></span>  
  
 [!code-csharp[C_DataArchitecture#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_dataarchitecture/cs/source.cs#11)]
 [!code-vb[C_DataArchitecture#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_dataarchitecture/vb/source.vb#11)]  
  
 <span data-ttu-id="d9e16-380">服務架構會自動決定將所有三項資訊片段 (`customerID`、 `item`和 `quantity`) 放入訊息本文，然後將其包裝在名為 `SubmitOrderRequest`的包裝函式項目中。</span><span class="sxs-lookup"><span data-stu-id="d9e16-380">The service framework automatically decides to put all three pieces of information (`customerID`, `item`, and `quantity`) into the message body and wrap them in a wrapper element named `SubmitOrderRequest`.</span></span>  
  
 <span data-ttu-id="d9e16-381">建議方法是將要傳送或接收的資訊描述當做作業合約參數的簡單清單，除非有特殊原因必須使用更複雜的訊息合約或 `Message` 架構的程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="d9e16-381">Describing the information to be sent or received as a simple list of operation contract parameters is the recommended approach, unless special reasons exist to move to the more-complex message contract or `Message`-based programming models.</span></span>  
  
### <a name="5-stream"></a><span data-ttu-id="d9e16-382">5.資料流</span><span class="sxs-lookup"><span data-stu-id="d9e16-382">5. Stream</span></span>  
 <span data-ttu-id="d9e16-383">在作業合約中使用 `Stream` 或其中一個子類別，或是當做訊息合約中的單獨訊息本文部分，可以視為與上述不同的程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="d9e16-383">Using `Stream` or one of its subclasses in an operation contract or as a sole message body part in a message contract can be considered a separate programming model from the ones described above.</span></span> <span data-ttu-id="d9e16-384">以這種方式使用 `Stream` 是確保合約能夠用在經過資料流處理方式的唯一辦法，除非寫入專屬的與資料流相容之 `Message` 子類別。</span><span class="sxs-lookup"><span data-stu-id="d9e16-384">Using `Stream` in this way is the only way to guarantee that your contract will be usable in a streamed fashion, short of writing your own streaming-compatible `Message` subclass.</span></span> [!INCLUDE[crdefault](../../../../includes/crdefault-md.md)]<span data-ttu-id="d9e16-385">[大型的資料與資料流](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-385"> [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="d9e16-386">當以這種方式使用 `Stream` 或其中一個子類別時，就不會叫用序列化程式。</span><span class="sxs-lookup"><span data-stu-id="d9e16-386">When `Stream` or one of its subclasses is used in this way, the serializer is not invoked.</span></span> <span data-ttu-id="d9e16-387">針對傳出訊息會建立特殊的資料流 `Message` 子類別，然後會如同 <xref:System.Xml.IStreamProvider> 介面上章節中所述寫出資料流。</span><span class="sxs-lookup"><span data-stu-id="d9e16-387">For outgoing messages, a special streaming `Message` subclass is created and the stream is written out as described in the section on the <xref:System.Xml.IStreamProvider> interface.</span></span> <span data-ttu-id="d9e16-388">針對傳入訊息，服務架構會在傳入訊息上建立 `Stream` 子類別，然後將其提供給作業使用。</span><span class="sxs-lookup"><span data-stu-id="d9e16-388">For incoming messages, the service framework creates a `Stream` subclass over the incoming message and provides it to the operation.</span></span>  
  
## <a name="programming-model-restrictions"></a><span data-ttu-id="d9e16-389">程式設計模型限制</span><span class="sxs-lookup"><span data-stu-id="d9e16-389">Programming Model Restrictions</span></span>  
 <span data-ttu-id="d9e16-390">上述的程式設計模型不能任意組合。</span><span class="sxs-lookup"><span data-stu-id="d9e16-390">The programming models described above cannot be arbitrarily combined.</span></span> <span data-ttu-id="d9e16-391">例如，如果作業接受訊息合約類型，訊息合約必須是其唯一的輸入參數。</span><span class="sxs-lookup"><span data-stu-id="d9e16-391">For example, if an operation accepts a message contract type, the message contract must be its only input parameter.</span></span> <span data-ttu-id="d9e16-392">此外，然後作業必須傳回空訊息 (屬於 void 的傳回型別) 或另一個訊息合約。</span><span class="sxs-lookup"><span data-stu-id="d9e16-392">Furthermore, the operation must then either return an empty message (return type of void) or another message contract.</span></span> <span data-ttu-id="d9e16-393">在每個特定程式設計模型的主題中會描述這些程式設計模型限制： [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md)、 [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md)和 [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-393">These programming model restrictions are described in the topics for each specific programming model: [Using Message Contracts](../../../../docs/framework/wcf/feature-details/using-message-contracts.md), [Using the Message Class](../../../../docs/framework/wcf/feature-details/using-the-message-class.md), and [Large Data and Streaming](../../../../docs/framework/wcf/feature-details/large-data-and-streaming.md).</span></span>  
  
## <a name="message-formatters"></a><span data-ttu-id="d9e16-394">訊息格式器</span><span class="sxs-lookup"><span data-stu-id="d9e16-394">Message Formatters</span></span>  
 <span data-ttu-id="d9e16-395">藉由將名為「 *訊息格式器* 」(Message Formatter) 的元件插入服務架構可以支援上述程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="d9e16-395">The programming models described above are supported by plugging in components called *message formatters* into the service framework.</span></span> <span data-ttu-id="d9e16-396">訊息格式器是實作 <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> 或 <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> 介面 (或兩者都是) 的型別，以便分別在用戶端與服務 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 用戶端使用。</span><span class="sxs-lookup"><span data-stu-id="d9e16-396">Message formatters are types that implement the <xref:System.ServiceModel.Dispatcher.IClientMessageFormatter> or <xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter> interface, or both, for use in clients and service [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] clients, respectively.</span></span>  
  
 <span data-ttu-id="d9e16-397">通常是藉由行為插入訊息格式器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-397">Message formatters are normally plugged in by behaviors.</span></span> <span data-ttu-id="d9e16-398">例如， <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 會插入資料合約訊息格式器。</span><span class="sxs-lookup"><span data-stu-id="d9e16-398">For example, the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> plugs in the data contract message formatter.</span></span> <span data-ttu-id="d9e16-399">可以藉由在服務端的 <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> 方法中將 <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> 設定為正確的格式器，或是藉由在用戶端的 <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> 方法中將 <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> 設定為正確的格式器以達到此目的。</span><span class="sxs-lookup"><span data-stu-id="d9e16-399">This is done on the service side by setting <xref:System.ServiceModel.Dispatcher.DispatchOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.DispatchOperation%29> method, or on the client side by setting <xref:System.ServiceModel.Dispatcher.ClientOperation.Formatter%2A> to the correct formatter in the <xref:System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior%28System.ServiceModel.Description.OperationDescription%2CSystem.ServiceModel.Dispatcher.ClientOperation%29> method.</span></span>  
  
 <span data-ttu-id="d9e16-400">下表列出訊息格式器可能會實作的方法。</span><span class="sxs-lookup"><span data-stu-id="d9e16-400">The following tables lists the methods that a message formatter may implement.</span></span>  
  
|<span data-ttu-id="d9e16-401">介面</span><span class="sxs-lookup"><span data-stu-id="d9e16-401">Interface</span></span>|<span data-ttu-id="d9e16-402">方法</span><span class="sxs-lookup"><span data-stu-id="d9e16-402">Method</span></span>|<span data-ttu-id="d9e16-403">動作</span><span class="sxs-lookup"><span data-stu-id="d9e16-403">Action</span></span>|  
|---------------|------------|------------|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.DeserializeRequest%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="d9e16-404">將傳入 `Message` 轉換成作業參數</span><span class="sxs-lookup"><span data-stu-id="d9e16-404">Converts an incoming `Message` to operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IDispatchMessageFormatter.SerializeReply%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%2CSystem.Object%29>|<span data-ttu-id="d9e16-405">從作業傳回值/輸出參數建立傳出 `Message`</span><span class="sxs-lookup"><span data-stu-id="d9e16-405">Creates an outgoing `Message` from operation return value/out parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.SerializeRequest%28System.ServiceModel.Channels.MessageVersion%2CSystem.Object%5B%5D%29>|<span data-ttu-id="d9e16-406">從作業參數建立傳出 `Message`</span><span class="sxs-lookup"><span data-stu-id="d9e16-406">Creates an outgoing `Message` from operation parameters</span></span>|  
|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter>|<xref:System.ServiceModel.Dispatcher.IClientMessageFormatter.DeserializeReply%28System.ServiceModel.Channels.Message%2CSystem.Object%5B%5D%29>|<span data-ttu-id="d9e16-407">將傳入 `Message` 轉換為傳回值/輸出參數</span><span class="sxs-lookup"><span data-stu-id="d9e16-407">Converts an incoming `Message` to a return value/out parameters</span></span>|  
  
## <a name="serialization"></a><span data-ttu-id="d9e16-408">序列化</span><span class="sxs-lookup"><span data-stu-id="d9e16-408">Serialization</span></span>  
 <span data-ttu-id="d9e16-409">當您使用訊息合約或參數描述訊息內容時，必須使用序列化在 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 型別與 XML Infoset 表示法之間進行轉換。</span><span class="sxs-lookup"><span data-stu-id="d9e16-409">Whenever you use message contracts or parameters to describe message contents, you must use serialization to convert between [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types and XML Infoset representation.</span></span> <span data-ttu-id="d9e16-410">序列化會用在 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]的其他地方；例如 <xref:System.ServiceModel.Channels.Message> 有個泛型 <xref:System.ServiceModel.Channels.Message.GetBody%2A> 方法，您可以用來讀取還原序列化為物件之訊息的整個本文。</span><span class="sxs-lookup"><span data-stu-id="d9e16-410">Serialization is used in other places in [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)], for example, <xref:System.ServiceModel.Channels.Message> has a Generic <xref:System.ServiceModel.Channels.Message.GetBody%2A> method that you can use to read the entire body of the message deserialized into an object.</span></span>  
  
 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)]<span data-ttu-id="d9e16-411"> 支援兩種「不必經過任何處理就可以直接使用」的序列化技術，以序列化與還原序列化參數及訊息部分： <xref:System.Runtime.Serialization.DataContractSerializer> 和 `XmlSerializer`。</span><span class="sxs-lookup"><span data-stu-id="d9e16-411"> supports two serialization technologies "out of the box" for serializing and deserializing parameters and message parts: the <xref:System.Runtime.Serialization.DataContractSerializer> and the `XmlSerializer`.</span></span> <span data-ttu-id="d9e16-412">此外，您可以撰寫自訂序列化程式。</span><span class="sxs-lookup"><span data-stu-id="d9e16-412">Additionally, you can write custom serializers.</span></span> <span data-ttu-id="d9e16-413">但是， [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 的其他部分 (例如泛型 `GetBody` 方法或 SOAP 錯誤序列化) 可能會限制只能使用 <xref:System.Runtime.Serialization.XmlObjectSerializer> 子類別 (<xref:System.Runtime.Serialization.DataContractSerializer> 和 <xref:System.Runtime.Serialization.NetDataContractSerializer>，但不是 <xref:System.Xml.Serialization.XmlSerializer>)，或甚至被硬式編碼為只能使用 <xref:System.Runtime.Serialization.DataContractSerializer>。</span><span class="sxs-lookup"><span data-stu-id="d9e16-413">However, other parts of [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] (such as the Generic `GetBody` method or SOAP fault serialization) may be restricted to use only the <xref:System.Runtime.Serialization.XmlObjectSerializer> subclasses (<xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>, but not the <xref:System.Xml.Serialization.XmlSerializer>), or may even be hard-coded to use only the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span>  
  
 <span data-ttu-id="d9e16-414">`XmlSerializer` 是在 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web 服務中使用的序列化引擎。</span><span class="sxs-lookup"><span data-stu-id="d9e16-414">The `XmlSerializer` is the serialization engine used in [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] Web services.</span></span> <span data-ttu-id="d9e16-415">`DataContractSerializer` 是了解新資料合約程式設計模型的新序列化引擎。</span><span class="sxs-lookup"><span data-stu-id="d9e16-415">The `DataContractSerializer` is the new serialization engine that understands the new data contract programming model.</span></span> <span data-ttu-id="d9e16-416">`DataContractSerializer` 是預設選擇，而您可以使用 `XmlSerializer` 屬性，針對個別作業選擇使用 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> 。</span><span class="sxs-lookup"><span data-stu-id="d9e16-416">`DataContractSerializer` is the default choice, and the choice to use the `XmlSerializer` can be made on a per-operation basis using the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.DataContractFormatAttribute%2A> attribute.</span></span>  
  
 <span data-ttu-id="d9e16-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 和 <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> 是分別負責插入 `DataContractSerializer` 與 `XmlSerializer`之訊息格式器的作業行為。</span><span class="sxs-lookup"><span data-stu-id="d9e16-417"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> and <xref:System.ServiceModel.Description.XmlSerializerOperationBehavior> are the operation behaviors responsible for plugging in the message formatters for the `DataContractSerializer` and the `XmlSerializer`, respectively.</span></span> <span data-ttu-id="d9e16-418"><xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 行為實際上能夠與任何衍生自 <xref:System.Runtime.Serialization.XmlObjectSerializer>的序列化程式共同運作，其中包含 <xref:System.Runtime.Serialization.NetDataContractSerializer> (在「使用獨立序列化」中會詳細描述)。</span><span class="sxs-lookup"><span data-stu-id="d9e16-418">The <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> behavior can actually operate with any serializer that derives from <xref:System.Runtime.Serialization.XmlObjectSerializer>, including the <xref:System.Runtime.Serialization.NetDataContractSerializer> (described in detail in Using Stand-Alone Serialization).</span></span> <span data-ttu-id="d9e16-419">行為會呼叫其中一個 `CreateSerializer` 虛擬方法多載以取得序列化程式。</span><span class="sxs-lookup"><span data-stu-id="d9e16-419">The behavior calls one of the `CreateSerializer` virtual method overloads to obtain the serializer.</span></span> <span data-ttu-id="d9e16-420">若要插入不同的序列化程式，請建立新的 <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> 子類別，然後同時覆寫 `CreateSerializer` 多載。</span><span class="sxs-lookup"><span data-stu-id="d9e16-420">To plug in a different serializer, create a new <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior> subclass and override both `CreateSerializer` overloads.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d9e16-421">請參閱</span><span class="sxs-lookup"><span data-stu-id="d9e16-421">See Also</span></span>  
 [<span data-ttu-id="d9e16-422">指定服務合約中的資料傳輸</span><span class="sxs-lookup"><span data-stu-id="d9e16-422">Specifying Data Transfer in Service Contracts</span></span>](../../../../docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md)
