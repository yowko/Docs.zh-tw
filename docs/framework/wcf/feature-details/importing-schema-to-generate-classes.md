---
title: 匯入結構描述以產生類別
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- WCF, schema import and export
- XsdDataContractImporter class
ms.assetid: b9170583-8c34-43bd-97bb-6c0c8dddeee0
ms.openlocfilehash: d7b5cb57e921fa802207d2ad606ba3535b78a77b
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/28/2019
ms.locfileid: "64587018"
---
# <a name="importing-schema-to-generate-classes"></a><span data-ttu-id="de61a-102">匯入結構描述以產生類別</span><span class="sxs-lookup"><span data-stu-id="de61a-102">Importing Schema to Generate Classes</span></span>
<span data-ttu-id="de61a-103">若要從可與 Windows Communication Foundation (WCF) 的結構描述產生類別，使用<xref:System.Runtime.Serialization.XsdDataContractImporter>類別。</span><span class="sxs-lookup"><span data-stu-id="de61a-103">To generate classes from schemas that are usable with Windows Communication Foundation (WCF), use the <xref:System.Runtime.Serialization.XsdDataContractImporter> class.</span></span> <span data-ttu-id="de61a-104">這個主題將說明處理程序和變化。</span><span class="sxs-lookup"><span data-stu-id="de61a-104">This topic describes the process and variations.</span></span>  
  
## <a name="the-import-process"></a><span data-ttu-id="de61a-105">匯入程序</span><span class="sxs-lookup"><span data-stu-id="de61a-105">The Import Process</span></span>
 <span data-ttu-id="de61a-106">結構描述匯入程序是從 <xref:System.Xml.Schema.XmlSchemaSet> 開始，並產生 <xref:System.CodeDom.CodeCompileUnit>。</span><span class="sxs-lookup"><span data-stu-id="de61a-106">The schema import process starts with an <xref:System.Xml.Schema.XmlSchemaSet> and produces a <xref:System.CodeDom.CodeCompileUnit>.</span></span>  
  
 <span data-ttu-id="de61a-107">`XmlSchemaSet` 是 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 的結構描述物件模型 (SOM) 的一部分，它代表一組 XML 結構描述定義語言 (Schema definition language，XSD) 結構描述文件。</span><span class="sxs-lookup"><span data-stu-id="de61a-107">The `XmlSchemaSet` is a part of the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]’s Schema Object Model (SOM) that represents a set of XML Schema definition language (XSD) schema documents.</span></span> <span data-ttu-id="de61a-108">如果要從一組 XSD 文件建立 `XmlSchemaSet` 物件，請還原序列化各文件至 <xref:System.Xml.Schema.XmlSchema> 物件中 (使用 <xref:System.Xml.Serialization.XmlSerializer>)，然後新增這些物件至新的 `XmlSchemaSet`。</span><span class="sxs-lookup"><span data-stu-id="de61a-108">To create an `XmlSchemaSet` object from a set of XSD documents, deserialize each document into an <xref:System.Xml.Schema.XmlSchema> object (using the <xref:System.Xml.Serialization.XmlSerializer>) and add these objects to a new `XmlSchemaSet`.</span></span>  
  
 <span data-ttu-id="de61a-109">`CodeCompileUnit` 是 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 的 Code Document Object Model (CodeDOM) 的一部分，它會以抽象方式表示 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 程式碼。</span><span class="sxs-lookup"><span data-stu-id="de61a-109">The `CodeCompileUnit` is part of the [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]’s Code Document Object Model (CodeDOM) that represents [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] code in an abstract way.</span></span> <span data-ttu-id="de61a-110">如果要從 `CodeCompileUnit` 產生實際的程式碼，請使用 <xref:System.CodeDom.Compiler.CodeDomProvider> 類別的子類別，例如 <xref:Microsoft.CSharp.CSharpCodeProvider> 或 <xref:Microsoft.VisualBasic.VBCodeProvider> 類別。</span><span class="sxs-lookup"><span data-stu-id="de61a-110">To generate the actual code from a `CodeCompileUnit`, use a subclass of the <xref:System.CodeDom.Compiler.CodeDomProvider> class, such as the <xref:Microsoft.CSharp.CSharpCodeProvider> or <xref:Microsoft.VisualBasic.VBCodeProvider> class.</span></span>  
  
### <a name="to-import-a-schema"></a><span data-ttu-id="de61a-111">匯入結構描述</span><span class="sxs-lookup"><span data-stu-id="de61a-111">To import a schema</span></span>  
  
1. <span data-ttu-id="de61a-112">建立 <xref:System.Runtime.Serialization.XsdDataContractImporter>的執行個體。</span><span class="sxs-lookup"><span data-stu-id="de61a-112">Create an instance of the <xref:System.Runtime.Serialization.XsdDataContractImporter>.</span></span>  
  
2. <span data-ttu-id="de61a-113">選擇性。</span><span class="sxs-lookup"><span data-stu-id="de61a-113">Optional.</span></span> <span data-ttu-id="de61a-114">傳遞建構函式中的 `CodeCompileUnit`。</span><span class="sxs-lookup"><span data-stu-id="de61a-114">Pass a `CodeCompileUnit` in the constructor.</span></span> <span data-ttu-id="de61a-115">在結構描述匯入期間產生的型別會新增至這個 `CodeCompileUnit` 執行個體，而不是從空白的 `CodeCompileUnit` 開始。</span><span class="sxs-lookup"><span data-stu-id="de61a-115">The types generated during schema import are added to this `CodeCompileUnit` instance instead of starting with a blank `CodeCompileUnit`.</span></span>  
  
3. <span data-ttu-id="de61a-116">選擇性。</span><span class="sxs-lookup"><span data-stu-id="de61a-116">Optional.</span></span> <span data-ttu-id="de61a-117">呼叫其中一個 <xref:System.Runtime.Serialization.XsdDataContractImporter.CanImport%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="de61a-117">Call one of the <xref:System.Runtime.Serialization.XsdDataContractImporter.CanImport%2A> methods.</span></span> <span data-ttu-id="de61a-118">此方法會判斷指定的結構描述是否為有效資料合約結構描述，且可以匯入。</span><span class="sxs-lookup"><span data-stu-id="de61a-118">The method determines whether the given schema is a valid data contract schema and can be imported.</span></span> <span data-ttu-id="de61a-119">`CanImport` 方法有和 `Import` 相同的多載 (下一個步驟)。</span><span class="sxs-lookup"><span data-stu-id="de61a-119">The `CanImport` method has the same overloads as `Import` (the next step).</span></span>  
  
4. <span data-ttu-id="de61a-120">呼叫其中一個多載 `Import` 方法，例如 <xref:System.Runtime.Serialization.XsdDataContractImporter.Import%28System.Xml.Schema.XmlSchemaSet%29> 方法。</span><span class="sxs-lookup"><span data-stu-id="de61a-120">Call one of the overloaded `Import` methods, for example, the <xref:System.Runtime.Serialization.XsdDataContractImporter.Import%28System.Xml.Schema.XmlSchemaSet%29> method.</span></span>  
  
     <span data-ttu-id="de61a-121">最簡單的多載是採用 `XmlSchemaSet`，並匯入在該結構描述集中找到的所有型別，包括匿名型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-121">The simplest overload takes an `XmlSchemaSet` and imports all types, including anonymous types, found in that schema set.</span></span> <span data-ttu-id="de61a-122">其他的多載可讓您指定要匯入的 XSD 型別或型別清單 (以 <xref:System.Xml.XmlQualifiedName> 或 `XmlQualifiedName` 物件集合的格式)。</span><span class="sxs-lookup"><span data-stu-id="de61a-122">Other overloads allow you to specify the XSD type or a list of types to import (in the form of an <xref:System.Xml.XmlQualifiedName> or a collection of `XmlQualifiedName` objects).</span></span> <span data-ttu-id="de61a-123">在這個案例中，只會匯入指定的型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-123">In this case, only the specified types are imported.</span></span> <span data-ttu-id="de61a-124">多載會採用匯入 <xref:System.Xml.Schema.XmlSchemaElement> 之特定項目的 `XmlSchemaSet`，以及其相關型別 (無論是否為匿名)。</span><span class="sxs-lookup"><span data-stu-id="de61a-124">An overload takes an <xref:System.Xml.Schema.XmlSchemaElement> that imports a particular element out of the `XmlSchemaSet`, as well as its associated type (whether it is anonymous or not).</span></span> <span data-ttu-id="de61a-125">這個多載會傳回 `XmlQualifiedName`，表示針對這個項目所產生之型別的資料合約名稱。</span><span class="sxs-lookup"><span data-stu-id="de61a-125">This overload returns an `XmlQualifiedName`, which represents the data contract name of the type generated for this element.</span></span>  
  
     <span data-ttu-id="de61a-126">`Import` 方法的多個呼叫會造成將多個項目新增至相同的 `CodeCompileUnit`。</span><span class="sxs-lookup"><span data-stu-id="de61a-126">Multiple calls of the `Import` method result in multiple items being added to the same `CodeCompileUnit`.</span></span> <span data-ttu-id="de61a-127">如果型別已經存在，便不會產生至 `CodeCompileUnit` 中。</span><span class="sxs-lookup"><span data-stu-id="de61a-127">A type is not generated into the `CodeCompileUnit` if it already exists there.</span></span> <span data-ttu-id="de61a-128">請在相同的 `Import` 上多次呼叫 `XsdDataContractImporter`，而不要使用多個 `XsdDataContractImporter` 物件。</span><span class="sxs-lookup"><span data-stu-id="de61a-128">Call `Import` multiple times on the same `XsdDataContractImporter` instead of using multiple `XsdDataContractImporter` objects.</span></span> <span data-ttu-id="de61a-129">這是避免產生重複型別的建議方式。</span><span class="sxs-lookup"><span data-stu-id="de61a-129">This is the recommended way to avoid duplicate types being generated.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="de61a-130">如果在匯入期間發生失敗，`CodeCompileUnit` 將會處於無法預測的狀態。</span><span class="sxs-lookup"><span data-stu-id="de61a-130">If there is a failure during import, the `CodeCompileUnit` will be in an unpredictable state.</span></span> <span data-ttu-id="de61a-131">使用源自失敗之匯入的 `CodeCompileUnit` 可能會讓您暴露在安全性弱點中。</span><span class="sxs-lookup"><span data-stu-id="de61a-131">Using a `CodeCompileUnit` resulting from a failed import could expose you to security vulnerabilities.</span></span>  
  
5. <span data-ttu-id="de61a-132">請透過 `CodeCompileUnit` 屬性存取 <xref:System.Runtime.Serialization.XsdDataContractImporter.CodeCompileUnit%2A> 。</span><span class="sxs-lookup"><span data-stu-id="de61a-132">Access the `CodeCompileUnit` through the <xref:System.Runtime.Serialization.XsdDataContractImporter.CodeCompileUnit%2A> property.</span></span>  
  
### <a name="import-options-customizing-the-generated-types"></a><span data-ttu-id="de61a-133">匯入選項：自訂產生的型別</span><span class="sxs-lookup"><span data-stu-id="de61a-133">Import Options: Customizing the Generated Types</span></span>  
 <span data-ttu-id="de61a-134">您可以將 <xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A> 的 <xref:System.Runtime.Serialization.XsdDataContractImporter> 屬性設定為 <xref:System.Runtime.Serialization.ImportOptions> 類別的執行個體，以控制匯入處理程序的各方面。</span><span class="sxs-lookup"><span data-stu-id="de61a-134">You can set the <xref:System.Runtime.Serialization.XsdDataContractImporter.Options%2A> property of the <xref:System.Runtime.Serialization.XsdDataContractImporter> to an instance of the <xref:System.Runtime.Serialization.ImportOptions> class to control various aspects of the import process.</span></span> <span data-ttu-id="de61a-135">選項的數目會直接影響到所產生的型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-135">A number of options directly influence the types that are generated.</span></span>  
  
#### <a name="controlling-the-access-level-generateinternal-or-the-internal-switch"></a><span data-ttu-id="de61a-136">控制存取層級 (GenerateInternal 或 /internal 參數)</span><span class="sxs-lookup"><span data-stu-id="de61a-136">Controlling the Access Level (GenerateInternal or the /internal switch)</span></span>  
 <span data-ttu-id="de61a-137">這會對應至 **/ 內部**上切換[ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)。</span><span class="sxs-lookup"><span data-stu-id="de61a-137">This corresponds to the **/internal** switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span>  
  
 <span data-ttu-id="de61a-138">一般來說，公用型別是從結構描述產生的，其中包含私用欄位和相符的公用資料成員屬性。</span><span class="sxs-lookup"><span data-stu-id="de61a-138">Normally, public types are generated from schema, with private fields and matching public data member properties.</span></span> <span data-ttu-id="de61a-139">如果要改為產生內部型別，請將 <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> 屬性設定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="de61a-139">To generate internal types instead, set the <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> property to `true`.</span></span>  
  
 <span data-ttu-id="de61a-140">下列範例會顯示當 <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> 屬性設定為 `true.` 時，轉換成內部類別的結構描述。</span><span class="sxs-lookup"><span data-stu-id="de61a-140">The following example shows a schema transformed into an internal class when the <xref:System.Runtime.Serialization.ImportOptions.GenerateInternal%2A> property is set to `true.`</span></span>  
  
 [!code-csharp[c_SchemaImportExport#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#2)]
 [!code-vb[c_SchemaImportExport#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#2)]  
  
#### <a name="controlling-namespaces-namespaces-or-the-namespace-switch"></a><span data-ttu-id="de61a-141">控制命名空間 (Namespaces 或 /namespace 參數)</span><span class="sxs-lookup"><span data-stu-id="de61a-141">Controlling Namespaces (Namespaces or the /namespace switch)</span></span>  
 <span data-ttu-id="de61a-142">這會對應至 **/namespace**切換成開啟`Svcutil.exe`工具。</span><span class="sxs-lookup"><span data-stu-id="de61a-142">This corresponds to the **/namespace** switch on the `Svcutil.exe` tool.</span></span>  
  
 <span data-ttu-id="de61a-143">一般來說，從結構描述產生的型別會產生至[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]命名空間，與每個對應至特定的 XSD 命名空間[!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)]中所述的對應根據的命名空間[Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="de61a-143">Normally, types generated from schema are generated into [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] namespaces, with each XSD namespace corresponding to a particular [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] namespace according to a mapping described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span> <span data-ttu-id="de61a-144">您可以將 <xref:System.Runtime.Serialization.ImportOptions.Namespaces%2A> 屬性設定為 <xref:System.Collections.Generic.Dictionary%602>，以自訂這個對應。</span><span class="sxs-lookup"><span data-stu-id="de61a-144">You can customize this mapping by the <xref:System.Runtime.Serialization.ImportOptions.Namespaces%2A> property to a <xref:System.Collections.Generic.Dictionary%602>.</span></span> <span data-ttu-id="de61a-145">如果在目錄中找到指定的 XSD 命名空間，相符的 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 命名空間也是取自您的目錄。</span><span class="sxs-lookup"><span data-stu-id="de61a-145">If a given XSD namespace is found in the dictionary, the matching [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] namespace is also taken from your dictionary.</span></span>  
  
 <span data-ttu-id="de61a-146">例如，請試想下列結構描述。</span><span class="sxs-lookup"><span data-stu-id="de61a-146">For example, consider the following schema.</span></span>  
  
 [!code-xml[c_SchemaImportExport#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#10)]  
  
 <span data-ttu-id="de61a-147">下列範例會使用`Namespaces`屬性來對應`http://schemas.contoso.com/carSchema`至"Contoso.Cars"的命名空間。</span><span class="sxs-lookup"><span data-stu-id="de61a-147">The following example uses the `Namespaces` property to map the `http://schemas.contoso.com/carSchema` namespace to "Contoso.Cars".</span></span>  
  
 [!code-csharp[c_SchemaImportExport#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#8)]
 [!code-vb[c_SchemaImportExport#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#8)]  
  
#### <a name="adding-the-serializableattribute-generateserializable-or-the-serializable-switch"></a><span data-ttu-id="de61a-148">新增 SerializableAttribute (GenerateSerializable 或 /serializable 參數)</span><span class="sxs-lookup"><span data-stu-id="de61a-148">Adding the SerializableAttribute (GenerateSerializable or the /serializable switch)</span></span>  
 <span data-ttu-id="de61a-149">這會對應至 **/serializable**切換成開啟`Svcutil.exe`工具。</span><span class="sxs-lookup"><span data-stu-id="de61a-149">This corresponds to the **/serializable** switch on the `Svcutil.exe` tool.</span></span>  
  
 <span data-ttu-id="de61a-150">有時對於從結構描述產生的型別來說，可在 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 執行階段序列化引擎中使用是很重要的 (例如，<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=nameWithType> 和 <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> 類別)。</span><span class="sxs-lookup"><span data-stu-id="de61a-150">Sometimes it is important for the types generated from the schema to be usable with [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] runtime serialization engines (for example, the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter?displayProperty=nameWithType> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> classes).</span></span> <span data-ttu-id="de61a-151">當針對 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 遠端使用型別時，這很有用。</span><span class="sxs-lookup"><span data-stu-id="de61a-151">This is useful when using types for [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] remoting.</span></span> <span data-ttu-id="de61a-152">如果要啟用，除了一般的 <xref:System.SerializableAttribute> 屬性之外，您還必須將 <xref:System.Runtime.Serialization.DataContractAttribute> 屬性套用至所產生的型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-152">To enable this, you must apply the <xref:System.SerializableAttribute> attribute to the generated types in addition to the regular <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="de61a-153">如果 `GenerateSerializable` 匯入選項設定為 `true`，便會自動產生此屬性。</span><span class="sxs-lookup"><span data-stu-id="de61a-153">The attribute is generated automatically if the `GenerateSerializable` import option is set to `true`.</span></span>  
  
 <span data-ttu-id="de61a-154">下列範例會顯示由 `Vehicle` 匯入選項設定為 `GenerateSerializable` 所產生的 `true` 類別。</span><span class="sxs-lookup"><span data-stu-id="de61a-154">The following example shows the `Vehicle` class generated with the `GenerateSerializable` import option set to `true`.</span></span>  
  
 [!code-csharp[c_SchemaImportExport#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#4)]
 [!code-vb[c_SchemaImportExport#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#4)]  
  
#### <a name="adding-data-binding-support-enabledatabinding-or-the-enabledatabinding-switch"></a><span data-ttu-id="de61a-155">新增資料繫結支援 (EnableDataBinding 或 /enableDataBinding 參數)</span><span class="sxs-lookup"><span data-stu-id="de61a-155">Adding Data Binding Support (EnableDataBinding or the /enableDataBinding switch)</span></span>  
 <span data-ttu-id="de61a-156">這會對應至 **/enableDataBinding** Svcutil.exe 工具上切換。</span><span class="sxs-lookup"><span data-stu-id="de61a-156">This corresponds to the **/enableDataBinding** switch on the Svcutil.exe tool.</span></span>  
  
 <span data-ttu-id="de61a-157">有時，您可能會想要將從結構描述產生的型別，繫結至圖形使用者介面元件，讓這些型別之執行個體的更新可以自動更新 UI。</span><span class="sxs-lookup"><span data-stu-id="de61a-157">Sometimes, you may want to bind the types generated from the schema to graphical user interface components so that any update to instances of these types will automatically update the UI.</span></span> <span data-ttu-id="de61a-158">`XsdDataContractImporter` 可以產生以任何屬性變更都會觸發事件的方式實作 <xref:System.ComponentModel.INotifyPropertyChanged> 介面的型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-158">The `XsdDataContractImporter` can generate types that implement the <xref:System.ComponentModel.INotifyPropertyChanged> interface in such a way that any property change triggers an event.</span></span> <span data-ttu-id="de61a-159">如果您要產生用於用戶端 UI 程式設計環境，以支援這個介面 (例如 Windows Presentation Foundation (WPF)) 的類型，設定<xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A>屬性設`true`啟用這項功能。</span><span class="sxs-lookup"><span data-stu-id="de61a-159">If you are generating types for use with a client UI programming environment that supports this interface (such as Windows Presentation Foundation (WPF)), set the <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> property to `true` to enable this feature.</span></span>  
  
 <span data-ttu-id="de61a-160">下列範例會顯示由 `Vehicle` 設定為 <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> 所產生的 `true` 類別。</span><span class="sxs-lookup"><span data-stu-id="de61a-160">The following example shows the `Vehicle` class generated with the <xref:System.Runtime.Serialization.ImportOptions.EnableDataBinding%2A> set to `true`.</span></span>  
  
 [!code-csharp[C_SchemaImportExport#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#5)]
 [!code-vb[C_SchemaImportExport#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#5)]  
  
### <a name="import-options-choosing-collection-types"></a><span data-ttu-id="de61a-161">匯入選項：選擇集合型別</span><span class="sxs-lookup"><span data-stu-id="de61a-161">Import Options: Choosing Collection Types</span></span>  
 <span data-ttu-id="de61a-162">XML 中有兩種特殊模式表示項目的集合：項目的清單以及兩個項目之間的關聯。</span><span class="sxs-lookup"><span data-stu-id="de61a-162">Two special patterns in XML represent collections of items: lists of items and associations between one item and another.</span></span> <span data-ttu-id="de61a-163">以下是字串清單的範例。</span><span class="sxs-lookup"><span data-stu-id="de61a-163">The following is an example of a list of strings.</span></span>  
  
 [!code-xml[C_SchemaImportExport#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#11)]  
  
 <span data-ttu-id="de61a-164">以下是字串和整數之間關聯的範例 (`city name` 和 `population`)。</span><span class="sxs-lookup"><span data-stu-id="de61a-164">The following is an example of an association between a string and an integer (`city name` and `population`).</span></span>  
  
 [!code-xml[C_SchemaImportExport#12](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#12)]  
  
> [!NOTE]
>  <span data-ttu-id="de61a-165">任何關聯也都可以視為是清單。</span><span class="sxs-lookup"><span data-stu-id="de61a-165">Any association could also be considered a list.</span></span> <span data-ttu-id="de61a-166">例如，您可以將前述關聯視為是剛好有兩個欄位 (字串欄位和整數欄位) 之複雜 `city` 物件的清單。</span><span class="sxs-lookup"><span data-stu-id="de61a-166">For example, you can view the preceding association as a list of complex `city` objects that happen to have two fields (a string field and an integer field).</span></span> <span data-ttu-id="de61a-167">這兩種模式在 XSD 結構描述中都有表示法。</span><span class="sxs-lookup"><span data-stu-id="de61a-167">Both patterns have a representation in the XSD Schema.</span></span> <span data-ttu-id="de61a-168">沒有任何方法可以區分清單和關聯，因此這種模式都被視為清單除非特定 wcf 的特殊註釋是出現在結構描述。</span><span class="sxs-lookup"><span data-stu-id="de61a-168">There is no way to differentiate between a list and an association, so such patterns are always treated as lists unless a special annotation specific to WCF is present in the schema.</span></span> <span data-ttu-id="de61a-169">附註會指出指定的模式表示關聯。</span><span class="sxs-lookup"><span data-stu-id="de61a-169">The annotation indicates that a given pattern represents an association.</span></span> <span data-ttu-id="de61a-170">如需詳細資訊，請參閱 < [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="de61a-170">For more information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>  
  
 <span data-ttu-id="de61a-171">一般來說，會匯入清單做為衍生自泛型清單的集合資料合約或做為 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 陣列，視結構描述是否遵循集合的標準命名樣式而定。</span><span class="sxs-lookup"><span data-stu-id="de61a-171">Normally, a list is imported as a collection data contract that derives from a Generic List or as a [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] array, depending on whether or not the schema follows the standard naming pattern for collections.</span></span> <span data-ttu-id="de61a-172">這描述更詳細地[集合 Types in Data Contracts](../../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md)。</span><span class="sxs-lookup"><span data-stu-id="de61a-172">This is described in more detail in [Collection Types in Data Contracts](../../../../docs/framework/wcf/feature-details/collection-types-in-data-contracts.md).</span></span> <span data-ttu-id="de61a-173">關聯通常會被匯入做為 <xref:System.Collections.Generic.Dictionary%602> 或衍生自目錄物件的集合資料合約。</span><span class="sxs-lookup"><span data-stu-id="de61a-173">Associations are normally imported as either a <xref:System.Collections.Generic.Dictionary%602> or a collection data contract that derives from the dictionary object.</span></span> <span data-ttu-id="de61a-174">例如，請試想下列結構描述。</span><span class="sxs-lookup"><span data-stu-id="de61a-174">For example, consider the following schema.</span></span>  
  
 [!code-xml[c_SchemaImportExport#13](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/common/source.config#13)]  
  
 <span data-ttu-id="de61a-175">其匯入如下所示 (顯示欄位而非屬性以具可讀性)。</span><span class="sxs-lookup"><span data-stu-id="de61a-175">This would be imported as follows (fields are shown instead of properties for readability).</span></span>  
  
 [!code-csharp[c_SchemaImportExport#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#6)]
 [!code-vb[c_SchemaImportExport#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#6)]  
  
 <span data-ttu-id="de61a-176">您可以自訂為此類結構描述模式所產生的集合型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-176">It is possible to customize the collection types that are generated for such schema patterns.</span></span> <span data-ttu-id="de61a-177">例如，您可能會想要產生衍生自 <xref:System.ComponentModel.BindingList%601> 而非 <xref:System.Collections.Generic.List%601> 類別的集合，以便將型別繫結至清單方塊，並讓它在集合的內容變更時自動更新。</span><span class="sxs-lookup"><span data-stu-id="de61a-177">For example, you may want to generate collections deriving from the <xref:System.ComponentModel.BindingList%601> instead of the <xref:System.Collections.Generic.List%601> class in order to bind the type to a list box and have it be automatically updated when the contents of the collection change.</span></span> <span data-ttu-id="de61a-178">如果要執行這項操作，請將 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 類別的 <xref:System.Runtime.Serialization.ImportOptions> 屬性設定為要使用之集合型別的清單 (之後稱為參照型別)。</span><span class="sxs-lookup"><span data-stu-id="de61a-178">To do this, set the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> class to a list of collection types to be used (hereafter known as the referenced types).</span></span> <span data-ttu-id="de61a-179">當匯入集合時，便會掃描這份參照集合型別的清單，並使用最符合的集合 (如果找得到的話)。</span><span class="sxs-lookup"><span data-stu-id="de61a-179">When importing any collection, this list of referenced collection types is scanned and the best-matching collection is used if one is found.</span></span> <span data-ttu-id="de61a-180">關聯只會針對實作一般性或非一般性 <xref:System.Collections.IDictionary> 介面的型別進行對應，而清單會針對任何支援的集合型別進行對應。</span><span class="sxs-lookup"><span data-stu-id="de61a-180">Associations are matched only against types that implement either the generic or the nongeneric <xref:System.Collections.IDictionary> interface, while lists are matched against any supported collection type.</span></span>  
  
 <span data-ttu-id="de61a-181">例如，如果 <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> 屬性設定為 <xref:System.ComponentModel.BindingList%601>，前例中的 `people` 型別便會產生如下。</span><span class="sxs-lookup"><span data-stu-id="de61a-181">For example, if the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property is set to a <xref:System.ComponentModel.BindingList%601>, the `people` type in the preceding example is generated as follows.</span></span>  
  
 [!code-csharp[C_SchemaImportExport#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_schemaimportexport/cs/source.cs#7)]
 [!code-vb[C_SchemaImportExport#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_schemaimportexport/vb/source.vb#7)]  
  
 <span data-ttu-id="de61a-182">封閉式泛型被視為最符合的型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-182">A closed generic is considered the best match.</span></span> <span data-ttu-id="de61a-183">例如，如果型別 `BindingList(Of Integer)` 和 <xref:System.Collections.ArrayList> 傳遞至參照型別的集合，在結構描述中找到的任何整數清單都會匯入做為 `BindingList(Of Integer)`。</span><span class="sxs-lookup"><span data-stu-id="de61a-183">For example, if the types `BindingList(Of Integer)` and <xref:System.Collections.ArrayList> are passed to the collection of referenced types, any lists of integers found in schema are imported as a `BindingList(Of Integer)`.</span></span> <span data-ttu-id="de61a-184">任何其他清單 (例如 `List(Of String)`) 都會匯入做為 `ArrayList`。</span><span class="sxs-lookup"><span data-stu-id="de61a-184">Any other lists, for example, a `List(Of String)`, are imported as an `ArrayList`.</span></span>  
  
 <span data-ttu-id="de61a-185">如果將實作泛型 `IDictionary` 介面的型別新增至參照型別的集合，其型別參數必須是完全開啟或完全封閉的。</span><span class="sxs-lookup"><span data-stu-id="de61a-185">If a type that implements the generic `IDictionary` interface is added to the collection of referenced types, its type parameters must either be fully open or fully closed.</span></span>  
  
 <span data-ttu-id="de61a-186">不允許重複。</span><span class="sxs-lookup"><span data-stu-id="de61a-186">Duplicates are not allowed.</span></span> <span data-ttu-id="de61a-187">例如，您無法同時將 `List(Of Integer)` 和 `Collection(Of Integer)` 新增至參照型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-187">For example, you cannot add both a `List(Of Integer)` and a `Collection(Of Integer)` to the referenced types.</span></span> <span data-ttu-id="de61a-188">這會讓它無法判斷當在結構描述中找到整數清單時，應使用何者。</span><span class="sxs-lookup"><span data-stu-id="de61a-188">That would make it impossible to determine which should be used when a list of integers is found in schema.</span></span> <span data-ttu-id="de61a-189">只有當結構描述中有公開重複問題的型別時，才會偵測到重複。</span><span class="sxs-lookup"><span data-stu-id="de61a-189">Duplicates will be detected only if there is a type in schema that exposes the duplicates problem.</span></span> <span data-ttu-id="de61a-190">例如，如果匯入的結構描述不包含整數的清單，便會允許它在參照型別集合中有 `List(Of Integer)` 和 `Collection(Of Integer)`，但是這兩者不會造成任何影響。</span><span class="sxs-lookup"><span data-stu-id="de61a-190">For example, if the imported schema does not contain lists of integers, it is allowed to have both the `List(Of Integer)` and the `Collection(Of Integer)` in the referenced types collection, but neither will have any effect.</span></span>  
  
 <span data-ttu-id="de61a-191">所參照集合型別機制對於複雜型別的集合 (包括其他集合的集合)，運作效果都一樣好，而不只是適合基本型別的集合。</span><span class="sxs-lookup"><span data-stu-id="de61a-191">The referenced collection types mechanism works equally well for collections of complex types (including collections of other collections), and not just for collections of primitives.</span></span>  
  
 <span data-ttu-id="de61a-192">`ReferencedCollectionTypes`屬性會對應至 **/collectionType** SvcUtil.exe 工具上切換。</span><span class="sxs-lookup"><span data-stu-id="de61a-192">The `ReferencedCollectionTypes` property corresponds to the **/collectionType** switch on the SvcUtil.exe tool.</span></span> <span data-ttu-id="de61a-193">請注意，如果要參照多個集合的型別， **/collectionType**參數必須指定多次。</span><span class="sxs-lookup"><span data-stu-id="de61a-193">Note that to reference multiple collection types, the **/collectionType** switch must be specified multiple times.</span></span> <span data-ttu-id="de61a-194">如果類型不在 MsCorLib.dll 中，其參考組件必須也是使用 **/參考**切換。</span><span class="sxs-lookup"><span data-stu-id="de61a-194">If the type is not in the MsCorLib.dll, its assembly must also be referenced using the **/reference** switch.</span></span>  
  
#### <a name="import-options-referencing-existing-types"></a><span data-ttu-id="de61a-195">匯入選項：參照現有型別</span><span class="sxs-lookup"><span data-stu-id="de61a-195">Import Options: Referencing Existing Types</span></span>  
 <span data-ttu-id="de61a-196">結構描述中的型別偶而會對應至現有的 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 型別，而不需要從頭開始產生這些型別 </span><span class="sxs-lookup"><span data-stu-id="de61a-196">Occasionally, types in schema correspond to existing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types, and there is no need to generate these types from scratch.</span></span> <span data-ttu-id="de61a-197">(本節只適用於非集合型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-197">(This section applies only to noncollection types.</span></span> <span data-ttu-id="de61a-198">對於集合型別，請參閱上一節)。</span><span class="sxs-lookup"><span data-stu-id="de61a-198">For collection types, see the preceding section.)</span></span>  
  
 <span data-ttu-id="de61a-199">例如，您可能會有標準的全公司「人員」資料合約類型，固定用於表示人員。</span><span class="sxs-lookup"><span data-stu-id="de61a-199">For example, you may have a standard company-wide "Person" data contract type that you always want used when representing a person.</span></span> <span data-ttu-id="de61a-200">只要有服務使用這個型別，且其結構描述出現在服務中繼資料中，當匯入這個結構描述時，您可能會想要重複使用現有的 `Person` 型別，而非為每個服務產生新的型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-200">Whenever some service makes use of this type, and its schema appears in the service metadata, you may want to reuse the existing `Person` type when importing this schema instead of generating a new one for every service.</span></span>  
  
 <span data-ttu-id="de61a-201">如果要執行這項操作，請將您要重複使用之 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 型別的清單傳遞至 <xref:System.Runtime.Serialization.ImportOptions.ReferencedTypes%2A> 類別上 <xref:System.Runtime.Serialization.ImportOptions> 屬性傳回的集合中。</span><span class="sxs-lookup"><span data-stu-id="de61a-201">To do this, pass a list of [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] types that you want to reuse into the collection the <xref:System.Runtime.Serialization.ImportOptions.ReferencedTypes%2A> property returns on the <xref:System.Runtime.Serialization.ImportOptions> class.</span></span> <span data-ttu-id="de61a-202">如果其中任何型別的資料合約名稱和命名空間符合結構描述型別的名稱和命名空間，便會執行結構比較。</span><span class="sxs-lookup"><span data-stu-id="de61a-202">If any of these types have a data contract name and namespace that matches the name and namespace of a schema type, a structural comparison is performed.</span></span> <span data-ttu-id="de61a-203">如果判斷出型別同時具有相符的名稱和結構，便會重複使用現有的 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 型別，而非產生新的型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-203">If it is determined that the types have both matching names and matching structures, the existing [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] type is reused instead of generating a new one.</span></span> <span data-ttu-id="de61a-204">如果只有名稱符合，但結構不符合，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="de61a-204">If only the name matches but not the structure, an exception is thrown.</span></span> <span data-ttu-id="de61a-205">請注意，當參照型別時，不允許進行版本控制 (例如，新增選擇性資料成員)。</span><span class="sxs-lookup"><span data-stu-id="de61a-205">Note that there is no allowance for versioning when referencing types (for example, adding new optional data members).</span></span> <span data-ttu-id="de61a-206">結構必須完全相符。</span><span class="sxs-lookup"><span data-stu-id="de61a-206">The structures must match exactly.</span></span>  
  
 <span data-ttu-id="de61a-207">將多個有相同資料合約名稱和命名空間的型別新增至參照型別集合是合法的，只要沒有結構描述型別使用該名稱和命名空間匯入即可。</span><span class="sxs-lookup"><span data-stu-id="de61a-207">It is legal to add multiple types with the same data contract name and namespace to the referenced types collection, as long as no schema types are imported with that name and namespace.</span></span> <span data-ttu-id="de61a-208">這可讓您輕鬆地將組件中的所有型別新增至集合，而不需擔心並未實際發生在結構描述中的型別有重複。</span><span class="sxs-lookup"><span data-stu-id="de61a-208">This allows you to easily add all the types in an assembly to the collection without worrying about duplicates for types that do not actually occur in schema.</span></span>  
  
 <span data-ttu-id="de61a-209">`ReferencedTypes`屬性會對應至 **/參考**切換移入特定的 Svcutil.exe 工具的作業模式。</span><span class="sxs-lookup"><span data-stu-id="de61a-209">The `ReferencedTypes` property corresponds to the **/reference** switch in certain modes of operation of the Svcutil.exe tool.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de61a-210">當使用 Svcutil.exe 或 （在 Visual Studio)**加入服務參考**會自動參照 MsCorLib.dll 中的類型的所有工具。</span><span class="sxs-lookup"><span data-stu-id="de61a-210">When using the Svcutil.exe or (in Visual Studio) the **Add Service Reference** tools, all of the types in MsCorLib.dll are automatically referenced.</span></span>  
  
#### <a name="import-options-importing-non-datacontract-schema-as-ixmlserializable-types"></a><span data-ttu-id="de61a-211">匯入選項：匯入非 DataContract 結構描述，做為 IXmlSerializable 型別</span><span class="sxs-lookup"><span data-stu-id="de61a-211">Import Options: Importing Non-DataContract Schema as IXmlSerializable types</span></span>  
 <span data-ttu-id="de61a-212"><xref:System.Runtime.Serialization.XsdDataContractImporter> 支援結構描述的有限子集。</span><span class="sxs-lookup"><span data-stu-id="de61a-212">The <xref:System.Runtime.Serialization.XsdDataContractImporter> supports a limited subset of the schema.</span></span> <span data-ttu-id="de61a-213">如果有不支援的結構描述建構存在 (例如，XML 屬性)，匯入嘗試便會失敗並有例外狀況。</span><span class="sxs-lookup"><span data-stu-id="de61a-213">If unsupported schema constructs are present (for example, XML attributes), the import attempt fails with an exception.</span></span> <span data-ttu-id="de61a-214">然而，將 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> 屬性設定為 `true` 可延伸受支援的結構描述範圍。</span><span class="sxs-lookup"><span data-stu-id="de61a-214">However, setting the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> property to `true` extends the range of schema supported.</span></span> <span data-ttu-id="de61a-215">當設定為 `true` 時，<xref:System.Runtime.Serialization.XsdDataContractImporter> 會產生實作 <xref:System.Xml.Serialization.IXmlSerializable> 介面的型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-215">When set to `true`, the <xref:System.Runtime.Serialization.XsdDataContractImporter> generates types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span> <span data-ttu-id="de61a-216">如此可直接存取這些型別的 XML 表示法。</span><span class="sxs-lookup"><span data-stu-id="de61a-216">This enables direct access to the XML representation of these types.</span></span>  
  
##### <a name="design-considerations"></a><span data-ttu-id="de61a-217">設計考量</span><span class="sxs-lookup"><span data-stu-id="de61a-217">Design Considerations</span></span>  
  
- <span data-ttu-id="de61a-218">直接使用較弱型別的 XML 表示法可能會很困難。</span><span class="sxs-lookup"><span data-stu-id="de61a-218">It may be difficult to work with the weakly typed XML representation directly.</span></span> <span data-ttu-id="de61a-219">請考慮使用另一種序列化引擎 (例如 <xref:System.Xml.Serialization.XmlSerializer>) 以強型別方式來使用與資料合約不相容的結構描述。</span><span class="sxs-lookup"><span data-stu-id="de61a-219">Consider using an alternative serialization engine, such as the <xref:System.Xml.Serialization.XmlSerializer>, to work with schema not compatible with data contracts in a strongly typed way.</span></span> <span data-ttu-id="de61a-220">如需詳細資訊，請參閱 <<c0> [ 使用 XmlSerializer 類別](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md)。</span><span class="sxs-lookup"><span data-stu-id="de61a-220">For more information, see [Using the XmlSerializer Class](../../../../docs/framework/wcf/feature-details/using-the-xmlserializer-class.md).</span></span>  
  
- <span data-ttu-id="de61a-221">即使 <xref:System.Runtime.Serialization.XsdDataContractImporter> 屬性設定為 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A>，有些結構描述建構仍然無法由 `true` 匯入。</span><span class="sxs-lookup"><span data-stu-id="de61a-221">Some schema constructs cannot be imported by the <xref:System.Runtime.Serialization.XsdDataContractImporter> even when the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> property is set to `true`.</span></span> <span data-ttu-id="de61a-222">請再次考慮針對此類案例使用 <xref:System.Xml.Serialization.XmlSerializer>。</span><span class="sxs-lookup"><span data-stu-id="de61a-222">Again, consider using the <xref:System.Xml.Serialization.XmlSerializer> for such cases.</span></span>  
  
- <span data-ttu-id="de61a-223">確切的結構描述建構將會同時支援時<xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A>是`true`或是`false`所述[Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)。</span><span class="sxs-lookup"><span data-stu-id="de61a-223">The exact schema constructs that are supported both when <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> is `true` or `false` are described in [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>  
  
- <span data-ttu-id="de61a-224">所產生的 <xref:System.Xml.Serialization.IXmlSerializable> 型別的結構描述在匯入和匯出時不會保留逼真度。</span><span class="sxs-lookup"><span data-stu-id="de61a-224">Schema for generated <xref:System.Xml.Serialization.IXmlSerializable> types do not retain fidelity when imported and exported.</span></span> <span data-ttu-id="de61a-225">也就是說，從產生的型別匯出結構描述然後匯入做為類別並不會傳回原始的結構描述。</span><span class="sxs-lookup"><span data-stu-id="de61a-225">That is, exporting the schema from the generated types and importing as classes does not return the original schema.</span></span>  
  
 <span data-ttu-id="de61a-226">您或許可以結合 <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> 選項與之前所述的 <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> 選項。</span><span class="sxs-lookup"><span data-stu-id="de61a-226">It is possible to combine the <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> option with the <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> option previously described.</span></span> <span data-ttu-id="de61a-227">對於必須產生做為 <xref:System.Xml.Serialization.IXmlSerializable> 實作的型別，會在使用 <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> 功能時跳過結構檢查。</span><span class="sxs-lookup"><span data-stu-id="de61a-227">For types that have to be generated as <xref:System.Xml.Serialization.IXmlSerializable> implementations, the structural check is skipped when using the <xref:System.ServiceModel.Description.ServiceContractGenerator.ReferencedTypes%2A> feature.</span></span>  
  
 <span data-ttu-id="de61a-228"><xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A>選項對應至 **/importXmlTypes** Svcutil.exe 工具上切換。</span><span class="sxs-lookup"><span data-stu-id="de61a-228">The <xref:System.Runtime.Serialization.ImportOptions.ImportXmlType%2A> option corresponds to the **/importXmlTypes** switch on the Svcutil.exe tool.</span></span>  
  
##### <a name="working-with-generated-ixmlserializable-types"></a><span data-ttu-id="de61a-229">使用所產生的 IXmlSerializable 型別</span><span class="sxs-lookup"><span data-stu-id="de61a-229">Working with Generated IXmlSerializable Types</span></span>  
 <span data-ttu-id="de61a-230">所產生的 `IXmlSerializable` 型別包含名為 "nodesField" 的私用欄位，它會傳回 <xref:System.Xml.XmlNode> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="de61a-230">The generated `IXmlSerializable` types contain a private field, named "nodesField," that returns an array of <xref:System.Xml.XmlNode> objects.</span></span> <span data-ttu-id="de61a-231">當還原序列化此類型別的執行個體時，您可以使用 XML 文件物件模型，透過這個欄位直接存取 XML 資料。</span><span class="sxs-lookup"><span data-stu-id="de61a-231">When deserializing an instance of such a type, you can access the XML data directly through this field by using the XML Document Object Model.</span></span> <span data-ttu-id="de61a-232">當序列化這個型別的執行個體時，您可以將這個欄位設定為需要的 XML 資料，且它將會序列化。</span><span class="sxs-lookup"><span data-stu-id="de61a-232">When serializing an instance of this type, you can set this field to the desired XML data and it will be serialized.</span></span>  
  
 <span data-ttu-id="de61a-233">這是透過 `IXmlSerializable` 實作完成的。</span><span class="sxs-lookup"><span data-stu-id="de61a-233">This is accomplished through the `IXmlSerializable` implementation.</span></span> <span data-ttu-id="de61a-234">在所產生的 `IXmlSerializable` 型別中，<xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> 實作會呼叫 <xref:System.Runtime.Serialization.XmlSerializableServices.ReadNodes%2A> 類別的 <xref:System.Runtime.Serialization.XmlSerializableServices> 方法。</span><span class="sxs-lookup"><span data-stu-id="de61a-234">In the generated `IXmlSerializable` type, the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> implementation calls the <xref:System.Runtime.Serialization.XmlSerializableServices.ReadNodes%2A> method of the <xref:System.Runtime.Serialization.XmlSerializableServices> class.</span></span> <span data-ttu-id="de61a-235">此方法是 Helper 方法，會將透過 <xref:System.Xml.XmlReader> 提供的 XML 轉換為 <xref:System.Xml.XmlNode> 物件的陣列。</span><span class="sxs-lookup"><span data-stu-id="de61a-235">The method is a helper method that converts XML provided through an <xref:System.Xml.XmlReader> to an array of <xref:System.Xml.XmlNode> objects.</span></span> <span data-ttu-id="de61a-236"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> 實作會執行相反的操作，並將 `XmlNode` 物件的陣列轉換成 <xref:System.Xml.XmlWriter> 呼叫的序列。</span><span class="sxs-lookup"><span data-stu-id="de61a-236">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation does the opposite and converts the array of `XmlNode` objects to a sequence of <xref:System.Xml.XmlWriter> calls.</span></span> <span data-ttu-id="de61a-237">這是使用 <xref:System.Runtime.Serialization.XmlSerializableServices.WriteNodes%2A> 方法完成的。</span><span class="sxs-lookup"><span data-stu-id="de61a-237">This is accomplished using the <xref:System.Runtime.Serialization.XmlSerializableServices.WriteNodes%2A> method.</span></span>  
  
 <span data-ttu-id="de61a-238">您或許可以在所產生的 `IXmlSerializable` 類別上執行結構描述匯出處理程序。</span><span class="sxs-lookup"><span data-stu-id="de61a-238">It is possible to run the schema export process on the generated `IXmlSerializable` classes.</span></span> <span data-ttu-id="de61a-239">如前所述，將不會傳回原始的結構描述。</span><span class="sxs-lookup"><span data-stu-id="de61a-239">As previously stated, you will not get the original schema back.</span></span> <span data-ttu-id="de61a-240">相反地，您會收到"anyType"標準 XSD 型別，也就是任何 XSD 型別的萬用字元。</span><span class="sxs-lookup"><span data-stu-id="de61a-240">Instead, you will get the "anyType" standard XSD type, which is a wildcard for any XSD type.</span></span>  
  
 <span data-ttu-id="de61a-241">這可以藉由套用<xref:System.Xml.Serialization.XmlSchemaProviderAttribute>屬性設定為產生`IXmlSerializable`類別，並指定方法的呼叫<xref:System.Runtime.Serialization.XmlSerializableServices.AddDefaultSchema%2A>方法以產生"anyType"型別。</span><span class="sxs-lookup"><span data-stu-id="de61a-241">This is accomplished by applying the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to the generated `IXmlSerializable` classes and specifying a method that calls the <xref:System.Runtime.Serialization.XmlSerializableServices.AddDefaultSchema%2A> method to generate the "anyType" type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="de61a-242"><xref:System.Runtime.Serialization.XmlSerializableServices> 型別是為了支援這項特定功能而單獨存在的。</span><span class="sxs-lookup"><span data-stu-id="de61a-242">The <xref:System.Runtime.Serialization.XmlSerializableServices> type exists solely to support this particular feature.</span></span> <span data-ttu-id="de61a-243">並不建議用於其他方面。</span><span class="sxs-lookup"><span data-stu-id="de61a-243">It is not recommended for use for any other purpose.</span></span>  
  
#### <a name="import-options-advanced-options"></a><span data-ttu-id="de61a-244">匯入選項：進階選項</span><span class="sxs-lookup"><span data-stu-id="de61a-244">Import Options: Advanced Options</span></span>  
 <span data-ttu-id="de61a-245">以下是進階匯入選項：</span><span class="sxs-lookup"><span data-stu-id="de61a-245">The following are advanced import options:</span></span>  
  
- <span data-ttu-id="de61a-246"><xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="de61a-246"><xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> property.</span></span> <span data-ttu-id="de61a-247">請指定 <xref:System.CodeDom.Compiler.CodeDomProvider>，用於為所產生的類別產生程式碼。</span><span class="sxs-lookup"><span data-stu-id="de61a-247">Specify the <xref:System.CodeDom.Compiler.CodeDomProvider> to use to generate the code for the generated classes.</span></span> <span data-ttu-id="de61a-248">匯入機制會嘗試避免 <xref:System.CodeDom.Compiler.CodeDomProvider> 不支援的功能。</span><span class="sxs-lookup"><span data-stu-id="de61a-248">The import mechanism attempts to avoid features that the <xref:System.CodeDom.Compiler.CodeDomProvider> does not support.</span></span> <span data-ttu-id="de61a-249">如果沒有設定 <xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A>，使用 [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] 的完整功能便沒有限制。</span><span class="sxs-lookup"><span data-stu-id="de61a-249">If the <xref:System.Runtime.Serialization.ImportOptions.CodeProvider%2A> is not set, the full set of [!INCLUDE[dnprdnshort](../../../../includes/dnprdnshort-md.md)] features is used with no restrictions.</span></span>  
  
- <span data-ttu-id="de61a-250"><xref:System.Runtime.Serialization.ImportOptions.DataContractSurrogate%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="de61a-250"><xref:System.Runtime.Serialization.ImportOptions.DataContractSurrogate%2A> property.</span></span> <span data-ttu-id="de61a-251"><xref:System.Runtime.Serialization.IDataContractSurrogate> 實作可以使用這個屬性來指定。</span><span class="sxs-lookup"><span data-stu-id="de61a-251">An <xref:System.Runtime.Serialization.IDataContractSurrogate> implementation can be specified with this property.</span></span> <span data-ttu-id="de61a-252"><xref:System.Runtime.Serialization.IDataContractSurrogate> 會自訂匯入處理程序。</span><span class="sxs-lookup"><span data-stu-id="de61a-252">The <xref:System.Runtime.Serialization.IDataContractSurrogate> customizes the import process.</span></span> <span data-ttu-id="de61a-253">如需詳細資訊，請參閱 <<c0> [ 資料合約代理](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)。</span><span class="sxs-lookup"><span data-stu-id="de61a-253">For more information, see [Data Contract Surrogates](../../../../docs/framework/wcf/extending/data-contract-surrogates.md).</span></span> <span data-ttu-id="de61a-254">根據預設，不會使用 Surrogate。</span><span class="sxs-lookup"><span data-stu-id="de61a-254">By default, no surrogate is used.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="de61a-255">另請參閱</span><span class="sxs-lookup"><span data-stu-id="de61a-255">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.XsdDataContractImporter>
- <xref:System.Runtime.Serialization.XsdDataContractExporter>
- <xref:System.Runtime.Serialization.ImportOptions>
- [<span data-ttu-id="de61a-256">資料合約結構描述參考</span><span class="sxs-lookup"><span data-stu-id="de61a-256">Data Contract Schema Reference</span></span>](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)
- [<span data-ttu-id="de61a-257">資料合約代理</span><span class="sxs-lookup"><span data-stu-id="de61a-257">Data Contract Surrogates</span></span>](../../../../docs/framework/wcf/extending/data-contract-surrogates.md)
- [<span data-ttu-id="de61a-258">結構描述匯入和匯出</span><span class="sxs-lookup"><span data-stu-id="de61a-258">Schema Import and Export</span></span>](../../../../docs/framework/wcf/feature-details/schema-import-and-export.md)
- [<span data-ttu-id="de61a-259">從類別匯出結構描述</span><span class="sxs-lookup"><span data-stu-id="de61a-259">Exporting Schemas from Classes</span></span>](../../../../docs/framework/wcf/feature-details/exporting-schemas-from-classes.md)
- [<span data-ttu-id="de61a-260">資料合約結構描述參考</span><span class="sxs-lookup"><span data-stu-id="de61a-260">Data Contract Schema Reference</span></span>](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)
