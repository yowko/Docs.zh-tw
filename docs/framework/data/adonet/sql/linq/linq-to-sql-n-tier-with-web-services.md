---
title: LINQ to SQL 多層式架構與 Web 服務
ms.date: 03/30/2017
ms.assetid: 9cb10eb8-957f-4beb-a271-5f682016fed2
ms.openlocfilehash: 7b13a0cd77925423a12c093b1b5ac9b63ad7e019
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2019
ms.locfileid: "62033530"
---
# <a name="linq-to-sql-n-tier-with-web-services"></a><span data-ttu-id="31203-102">LINQ to SQL 多層式架構與 Web 服務</span><span class="sxs-lookup"><span data-stu-id="31203-102">LINQ to SQL N-Tier with Web Services</span></span>
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="31203-103">被專為中介層，例如 Web 服務鬆散結合的資料存取層 (DAL) 上使用。</span><span class="sxs-lookup"><span data-stu-id="31203-103">is designed especially for use on the middle tier in a loosely-coupled data access layer (DAL) such as a Web service.</span></span> <span data-ttu-id="31203-104">如果展示層是 ASP.NET 網頁，那麼您可以使用 <xref:System.Web.UI.WebControls.LinqDataSource> Web 伺服器控制項，管理使用者介面與中介層上的 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 之間的資料傳輸。</span><span class="sxs-lookup"><span data-stu-id="31203-104">If the presentation tier is an ASP.NET Web page, then you use the <xref:System.Web.UI.WebControls.LinqDataSource> Web server control to manage the data transfer between the user interface and [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] on the middle-tier.</span></span> <span data-ttu-id="31203-105">如果展示層不是 ASP.NET 網頁，則中介層和展示層都必須額外執行一些工作，以管理資料的序列化 (Serialization) 和還原序列化 (Deserialization)。</span><span class="sxs-lookup"><span data-stu-id="31203-105">If the presentation tier is not an ASP.NET page, then both the middle-tier and the presentation tier must do some additional work to manage the serialization and deserialization of data.</span></span>  
  
## <a name="setting-up-linq-to-sql-on-the-middle-tier"></a><span data-ttu-id="31203-106">設定中介層上的 LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="31203-106">Setting up LINQ to SQL on the Middle Tier</span></span>  
 <span data-ttu-id="31203-107">在 Web 服務或 N-Tier 應用程式中，中介層包含資料內容和實體類別。</span><span class="sxs-lookup"><span data-stu-id="31203-107">In a Web service or n-tier application, the middle tier contains the data context and the entity classes.</span></span> <span data-ttu-id="31203-108">您可以手動建立這些類別，或者使用 SQLMetal.exe 或[!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)]建立類別 (如文件他處所述)。</span><span class="sxs-lookup"><span data-stu-id="31203-108">You can create these classes manually, or by using either SQLMetal.exe or the [!INCLUDE[vs_ordesigner_long](../../../../../../includes/vs-ordesigner-long-md.md)] as described elsewhere in the documentation.</span></span> <span data-ttu-id="31203-109">在設計階段，您可以選擇是否要將實體類別設為可序列化。</span><span class="sxs-lookup"><span data-stu-id="31203-109">At design time, you have the option to make the entity classes serializable.</span></span> <span data-ttu-id="31203-110">如需詳細資訊，請參閱[如何：讓實體可序列化](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md)。</span><span class="sxs-lookup"><span data-stu-id="31203-110">For more information, see [How to: Make Entities Serializable](../../../../../../docs/framework/data/adonet/sql/linq/how-to-make-entities-serializable.md).</span></span> <span data-ttu-id="31203-111">另一個選擇是另外建立一組類別來封裝要序列化的資料，然後當您在 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] 查詢中傳回資料時，投影到這些可序列化的型別中。</span><span class="sxs-lookup"><span data-stu-id="31203-111">Another option is to create a separate set of classes that encapsulate the data to be serialized, and then project into those serializable types when you return data in your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries.</span></span>  
  
 <span data-ttu-id="31203-112">您接著可以定義介面以及用戶端將呼叫來擷取、插入和更新資料的方法。</span><span class="sxs-lookup"><span data-stu-id="31203-112">You then define the interface with the methods that the clients will call to retrieve, insert and update data.</span></span> <span data-ttu-id="31203-113">這些介面方法會包裝您的 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] 查詢。</span><span class="sxs-lookup"><span data-stu-id="31203-113">The interface methods wrap your [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] queries.</span></span> <span data-ttu-id="31203-114">您可以使用任何一種序列化機制來處理遠端方法呼叫和序列化資料。</span><span class="sxs-lookup"><span data-stu-id="31203-114">You can use any kind of serialization mechanism to handle the remote method calls and the serialization of data.</span></span> <span data-ttu-id="31203-115">唯一的要求是，如果物件模型中存在循環或雙向關係，例如標準 Northwind 物件模型中的 Customers 與 Orders 之間的關係，那麼就必須使用支援此關係的序列化程式。</span><span class="sxs-lookup"><span data-stu-id="31203-115">The only requirement is that if you have cyclic or bi-directional relationships in your object model, such as that between Customers and Orders in the standard Northwind object model, then you must use a serializer that supports it.</span></span> <span data-ttu-id="31203-116">Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> 支援雙向關聯性，但用於非 WCF Web 服務的 XmlSerializer 則否。</span><span class="sxs-lookup"><span data-stu-id="31203-116">The Windows Communication Foundation (WCF) <xref:System.Runtime.Serialization.DataContractSerializer> supports bi-directional relationships but the XmlSerializer that is used with non-WCF Web services does not.</span></span> <span data-ttu-id="31203-117">如果您選擇使用 XmlSerializer，就必須確定物件模型沒有循環關聯性。</span><span class="sxs-lookup"><span data-stu-id="31203-117">If you select to use the XmlSerializer, then you must make sure that your object model has no cyclic relationships.</span></span>  
  
 <span data-ttu-id="31203-118">如需有關 Windows Communication Foundation 的詳細資訊，請參閱 < [Windows Communication Foundation 服務和 Visual Studio 中的 WCF Data Services](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio)。</span><span class="sxs-lookup"><span data-stu-id="31203-118">For more information about Windows Communication Foundation, see [Windows Communication Foundation Services and WCF Data Services in Visual Studio](/visualstudio/data-tools/windows-communication-foundation-services-and-wcf-data-services-in-visual-studio).</span></span>  
  
 <span data-ttu-id="31203-119">在 <xref:System.Data.Linq.DataContext> 和實體類別上使用部分類別和方法連結 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 執行階段事件，以實作商務規則 (Business Rule) 或定義域特定邏輯。</span><span class="sxs-lookup"><span data-stu-id="31203-119">Implement your business rules or other domain-specific logic by using the partial classes and methods on the <xref:System.Data.Linq.DataContext> and entity classes to hook into [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] runtime events.</span></span> <span data-ttu-id="31203-120">如需詳細資訊，請參閱 <<c0> [ 實作多層式架構商務邏輯](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md)。</span><span class="sxs-lookup"><span data-stu-id="31203-120">For more information, see [Implementing N-Tier Business Logic](../../../../../../docs/framework/data/adonet/sql/linq/implementing-business-logic-linq-to-sql.md).</span></span>  
  
## <a name="defining-the-serializable-types"></a><span data-ttu-id="31203-121">定義可序列化的型別</span><span class="sxs-lookup"><span data-stu-id="31203-121">Defining the Serializable Types</span></span>  
 <span data-ttu-id="31203-122">用戶端或展示層必須有將從中介層接收之類別的型別定義。</span><span class="sxs-lookup"><span data-stu-id="31203-122">The client or presentation tier must have type definitions for the classes that it will be receiving from the middle tier.</span></span> <span data-ttu-id="31203-123">這些型別可以是實體類別本身，也可以是特殊類別，其中只包裝實體類別中用以遠端處理的特定欄位。</span><span class="sxs-lookup"><span data-stu-id="31203-123">Those types may be the entity classes themselves, or special classes that wrap only certain fields from the entity classes for remoting.</span></span> <span data-ttu-id="31203-124">在任何情況下，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]一概不管展示層如何取得這些型別定義的相關。</span><span class="sxs-lookup"><span data-stu-id="31203-124">In any case, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is completely unconcerned about how the presentation tier acquires those type definitions.</span></span> <span data-ttu-id="31203-125">例如，展示層可以使用 WCF 自動產生型別，或可以在 DLL 複本中定義這些型別，甚或是可以定義自己的型別版本。</span><span class="sxs-lookup"><span data-stu-id="31203-125">For example, the presentation tier could use WCF to generate the types automatically, or it could have a copy of a DLL in which those types are defined, or it could just define its own versions of the types.</span></span>  
  
## <a name="retrieving-and-inserting-data"></a><span data-ttu-id="31203-126">擷取和插入資料</span><span class="sxs-lookup"><span data-stu-id="31203-126">Retrieving and Inserting Data</span></span>  
 <span data-ttu-id="31203-127">中介層會定義介面，而此介面會指定展示層要如何存取資料。</span><span class="sxs-lookup"><span data-stu-id="31203-127">The middle tier defines an interface that specifies how the presentation tier accesses the data.</span></span> <span data-ttu-id="31203-128">例如 `GetProductByID(int productID)` 或 `GetCustomers()`。</span><span class="sxs-lookup"><span data-stu-id="31203-128">For example `GetProductByID(int productID)`, or `GetCustomers()`.</span></span> <span data-ttu-id="31203-129">在中介層上，方法主體通常會建立新的 <xref:System.Data.Linq.DataContext> 執行個體，然後對它的一個或多個資料表執行查詢。</span><span class="sxs-lookup"><span data-stu-id="31203-129">On the middle tier, the method body typically creates a new instance of the <xref:System.Data.Linq.DataContext>, executes a query against one or more of its table.</span></span> <span data-ttu-id="31203-130">中介層接著會以 <xref:System.Collections.Generic.IEnumerable%601> 傳回結果，其中 `T` 是實體類別或其他用來序列化的型別。</span><span class="sxs-lookup"><span data-stu-id="31203-130">The middle tier then returns the result as an <xref:System.Collections.Generic.IEnumerable%601>, where `T` is either an entity class or another type that is used for serialization.</span></span> <span data-ttu-id="31203-131">展示層絕不會直接傳送查詢變數給中介層，或直接從中介層接收查詢變數。</span><span class="sxs-lookup"><span data-stu-id="31203-131">The presentation tier never sends or receives query variables directly to or from the middle tier.</span></span> <span data-ttu-id="31203-132">這兩層會交換值、物件和具體資料集合。</span><span class="sxs-lookup"><span data-stu-id="31203-132">The two tiers exchange values, objects, and collections of concrete data.</span></span> <span data-ttu-id="31203-133">在收到集合之後，如有需要，展示層就可使用 [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] to Objects 來查詢它。</span><span class="sxs-lookup"><span data-stu-id="31203-133">After it has received a collection, the presentation tier can use [!INCLUDE[vbteclinq](../../../../../../includes/vbteclinq-md.md)] to Objects to query it if necessary.</span></span>  
  
 <span data-ttu-id="31203-134">插入資料時，展示層可建構新物件並將它傳送到中介層，或可以讓中介層根據其所提供的值建構物件。</span><span class="sxs-lookup"><span data-stu-id="31203-134">When inserting data, the presentation tier can construct a new object and send it to the middle tier, or it can have the middle tier construct the object based on values that it provides.</span></span> <span data-ttu-id="31203-135">一般來說，在 N-Tier 應用程式中擷取和插入資料，與在 2 層應用程式中的程序沒有太大差異。</span><span class="sxs-lookup"><span data-stu-id="31203-135">In general, retrieving and inserting data in n-tier applications does not differ much from the process in 2-tier applications.</span></span> <span data-ttu-id="31203-136">如需詳細資訊，請參閱 <<c0> [ 查詢資料庫](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md)並[制定和提交資料變更](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="31203-136">For more information, see [Querying the Database](../../../../../../docs/framework/data/adonet/sql/linq/querying-the-database.md) and [Making and Submitting Data Changes](../../../../../../docs/framework/data/adonet/sql/linq/making-and-submitting-data-changes.md).</span></span>  
  
## <a name="tracking-changes-for-updates-and-deletes"></a><span data-ttu-id="31203-137">追蹤變更以更新和刪除</span><span class="sxs-lookup"><span data-stu-id="31203-137">Tracking Changes for Updates and Deletes</span></span>  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="31203-138">支援以時間戳記為基礎的開放式並行存取 (Optimistic Concurrency) (也稱為 RowVersions) 和以原始值為基礎的開放式並行存取。</span><span class="sxs-lookup"><span data-stu-id="31203-138">supports optimistic concurrency based on timestamps (also named RowVersions) and on original values.</span></span> <span data-ttu-id="31203-139">如果資料庫資料表有時間戳記，則更新和刪除無論在中介層或展示層都不需要額外工作。</span><span class="sxs-lookup"><span data-stu-id="31203-139">If the database tables have timestamps, then updates and deletions require little extra work on either the middle-tier or presentation tier.</span></span> <span data-ttu-id="31203-140">不過，如果必須使用原始值來進行開放式並行存取檢查，那麼展示層就必須負責追蹤這些值，並在更新時送回這些值。</span><span class="sxs-lookup"><span data-stu-id="31203-140">However, if you must use original values for optimistic concurrency checks, then the presentation tier is responsible for tracking those values and sending them back when it makes updates.</span></span> <span data-ttu-id="31203-141">這是因為對展示層上的實體所做的變更並不會在中介層上追蹤。</span><span class="sxs-lookup"><span data-stu-id="31203-141">This is because changes that were made to entities on the presentation tier are not tracked on the middle tier.</span></span> <span data-ttu-id="31203-142">事實上，原始擷取實體的動作與最後更新它的動作，通常是由兩個完全不同的 <xref:System.Data.Linq.DataContext> 執行個體所執行。</span><span class="sxs-lookup"><span data-stu-id="31203-142">In fact, the original retrieval of an entity, and the eventual update made to it are typically performed by two completely separate instances of the <xref:System.Data.Linq.DataContext>.</span></span>  
  
 <span data-ttu-id="31203-143">展示層所做的變更愈多，追蹤這些變更並封裝送回中介層的工作就愈複雜。</span><span class="sxs-lookup"><span data-stu-id="31203-143">The greater the number of changes that the presentation tier makes, the more complex it becomes to track those changes and package them back to the middle tier.</span></span> <span data-ttu-id="31203-144">溝通變更的機制如何實作，端視應用程式而定。</span><span class="sxs-lookup"><span data-stu-id="31203-144">The implementation of a mechanism for communicating changes is completely up to the application.</span></span> <span data-ttu-id="31203-145">唯一的要求是，開放式並行存取檢查所需的這些原始值必須提供給 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="31203-145">The only requirement is that [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] must be given those original values that are required for optimistic concurrency checks.</span></span>  
  
 <span data-ttu-id="31203-146">如需詳細資訊，請參閱 <<c0> [ 資料擷取和 CUD 作業 (LINQ to SQL) 的多層式架構應用程式中](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md)。</span><span class="sxs-lookup"><span data-stu-id="31203-146">For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="31203-147">另請參閱</span><span class="sxs-lookup"><span data-stu-id="31203-147">See also</span></span>

- [<span data-ttu-id="31203-148">使用 LINQ to SQL 的多層式架構和遠端應用程式</span><span class="sxs-lookup"><span data-stu-id="31203-148">N-Tier and Remote Applications with LINQ to SQL</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/n-tier-and-remote-applications-with-linq-to-sql.md)
- <span data-ttu-id="31203-149">[LinqDataSource Web 伺服器控制項概觀](https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="31203-149">[LinqDataSource Web Server Control Overview](https://docs.microsoft.com/previous-versions/aspnet/bb547113(v=vs.100))</span></span>
