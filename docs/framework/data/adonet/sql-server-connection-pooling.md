---
title: SQL Server 連接共用 (ADO.NET)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 7e51d44e-7c4e-4040-9332-f0190fe36f07
ms.openlocfilehash: 2c73bec644a9a76ba05d3299183e8f1643c8e870
ms.sourcegitcommit: d2e1dfa7ef2d4e9ffae3d431cf6a4ffd9c8d378f
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/07/2019
ms.locfileid: "70794311"
---
# <a name="sql-server-connection-pooling-adonet"></a><span data-ttu-id="28ad6-102">SQL Server 連接共用 (ADO.NET)</span><span class="sxs-lookup"><span data-stu-id="28ad6-102">SQL Server Connection Pooling (ADO.NET)</span></span>
<span data-ttu-id="28ad6-103">連接到資料庫伺服器通常需要執行幾個很費時的步驟。</span><span class="sxs-lookup"><span data-stu-id="28ad6-103">Connecting to a database server typically consists of several time-consuming steps.</span></span> <span data-ttu-id="28ad6-104">必須要建立實體頻道 (如通訊端或具名管道)，必須建立與伺服器的初始信號交換、必須剖析連接字串資訊、伺服器必須要驗證連接，以及必須檢查是否已在現行交易中登記等。</span><span class="sxs-lookup"><span data-stu-id="28ad6-104">A physical channel such as a socket or a named pipe must be established, the initial handshake with the server must occur, the connection string information must be parsed, the connection must be authenticated by the server, checks must be run for enlisting in the current transaction, and so on.</span></span>  
  
 <span data-ttu-id="28ad6-105">實際上，大部分應用程式僅使用一個或幾個不同的連接組態。</span><span class="sxs-lookup"><span data-stu-id="28ad6-105">In practice, most applications use only one or a few different configurations for connections.</span></span> <span data-ttu-id="28ad6-106">這表示應用程式執行期間，將會重複開啟及關閉許多相同的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-106">This means that during application execution, many identical connections will be repeatedly opened and closed.</span></span> <span data-ttu-id="28ad6-107">為了將開啟連接的成本降至最低，ADO.NET 會使用一種稱為「*連接*共用」的優化技術。</span><span class="sxs-lookup"><span data-stu-id="28ad6-107">To minimize the cost of opening connections, ADO.NET uses an optimization technique called *connection pooling*.</span></span>  
  
 <span data-ttu-id="28ad6-108">連接共用可減少開啟新連接的必要次數。</span><span class="sxs-lookup"><span data-stu-id="28ad6-108">Connection pooling reduces the number of times that new connections must be opened.</span></span> <span data-ttu-id="28ad6-109">共用器*會維護實體連接的擁有*權。</span><span class="sxs-lookup"><span data-stu-id="28ad6-109">The *pooler* maintains ownership of the physical connection.</span></span> <span data-ttu-id="28ad6-110">它藉由讓每個指定連接組態的作用中連接集保持運行狀態，來管理連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-110">It manages connections by keeping alive a set of active connections for each given connection configuration.</span></span> <span data-ttu-id="28ad6-111">只要使用者針對連接呼叫 `Open`，共用器便會查看集區中是否有可用的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-111">Whenever a user calls `Open` on a connection, the pooler looks for an available connection in the pool.</span></span> <span data-ttu-id="28ad6-112">如果共用的連接可用，則共用器會將其傳回至呼叫端，而不會開啟新的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-112">If a pooled connection is available, it returns it to the caller instead of opening a new connection.</span></span> <span data-ttu-id="28ad6-113">應用程式針對連接呼叫 `Close` 時，共用器會將其傳回至共用的作用中連接集，而不會真正關閉它。</span><span class="sxs-lookup"><span data-stu-id="28ad6-113">When the application calls `Close` on the connection, the pooler returns it to the pooled set of active connections instead of closing it.</span></span> <span data-ttu-id="28ad6-114">連接一旦傳回至集區，便已備妥在下一次 `Open` 呼叫中重複使用。</span><span class="sxs-lookup"><span data-stu-id="28ad6-114">Once the connection is returned to the pool, it is ready to be reused on the next `Open` call.</span></span>  
  
 <span data-ttu-id="28ad6-115">只能共用具有相同組態的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-115">Only connections with the same configuration can be pooled.</span></span> <span data-ttu-id="28ad6-116">ADO.NET 會同時保留數個集區，每個集區各有一個集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-116">ADO.NET keeps several pools at the same time, one for each configuration.</span></span> <span data-ttu-id="28ad6-117">使用整合安全性時，會按連接字串及 Windows 識別將連接分成多個集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-117">Connections are separated into pools by connection string, and by Windows identity when integrated security is used.</span></span> <span data-ttu-id="28ad6-118">連接也會根據是否登記於交易中而進行共用。</span><span class="sxs-lookup"><span data-stu-id="28ad6-118">Connections are also pooled based on whether they are enlisted in a transaction.</span></span> <span data-ttu-id="28ad6-119">當使用 <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A> 時，<xref:System.Data.SqlClient.SqlCredential> 執行個體會影響連線集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-119">When using <xref:System.Data.SqlClient.SqlConnection.ChangePassword%2A>, the <xref:System.Data.SqlClient.SqlCredential> instance affects the connection pool.</span></span> <span data-ttu-id="28ad6-120">即使使用者 ID 和密碼相同，不同的 <xref:System.Data.SqlClient.SqlCredential> 執行個體仍將使用不同的連線集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-120">Different instances of <xref:System.Data.SqlClient.SqlCredential> will use different connection pools, even if the user ID and password are the same.</span></span>  
  
 <span data-ttu-id="28ad6-121">共用連接可顯著提高應用程式的效能及延展性。</span><span class="sxs-lookup"><span data-stu-id="28ad6-121">Pooling connections can significantly enhance the performance and scalability of your application.</span></span> <span data-ttu-id="28ad6-122">預設會在 ADO.NET 中啟用連接共用。</span><span class="sxs-lookup"><span data-stu-id="28ad6-122">By default, connection pooling is enabled in ADO.NET.</span></span> <span data-ttu-id="28ad6-123">除非您明確停用，否則在應用程式中開啟及關閉連接時，共用器會對連接進行最佳化。</span><span class="sxs-lookup"><span data-stu-id="28ad6-123">Unless you explicitly disable it, the pooler optimizes the connections as they are opened and closed in your application.</span></span> <span data-ttu-id="28ad6-124">您也可提供幾個連接字串修飾詞，以控制連接共用行為。</span><span class="sxs-lookup"><span data-stu-id="28ad6-124">You can also supply several connection string modifiers to control connection pooling behavior.</span></span> <span data-ttu-id="28ad6-125">如需詳細資訊，請參閱本章稍後的＜使用連接字串關鍵字控制連接共用＞。</span><span class="sxs-lookup"><span data-stu-id="28ad6-125">For more information, see "Controlling Connection Pooling with Connection String Keywords" later in this topic.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="28ad6-126">啟用連線集區時，若發生逾時錯誤或其他登入錯誤，就會擲回例外狀況，且在接下來五秒的「封鎖期間」內，後續連接嘗試都會失敗。</span><span class="sxs-lookup"><span data-stu-id="28ad6-126">When connection pooling is enabled, and if a timeout error or other login error occurs, an exception will be thrown and subsequent connection attempts will fail for the next five seconds, the "blocking period".</span></span> <span data-ttu-id="28ad6-127">如果應用程式嘗試在封鎖期間內連接，將再次擲回第一個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="28ad6-127">If the application attempts to connect within the blocking period, the first exception will be thrown again.</span></span> <span data-ttu-id="28ad6-128">封鎖期間結束後若仍失敗，會造成新的封鎖期間，且時間為前一次封鎖期間的兩倍，最長一分鐘。</span><span class="sxs-lookup"><span data-stu-id="28ad6-128">Subsequent failures after a blocking period ends will result in a new blocking periods that is twice as long as the previous blocking period, up to a maximum of one minute.</span></span>  
  
## <a name="pool-creation-and-assignment"></a><span data-ttu-id="28ad6-129">集區的建立及指派</span><span class="sxs-lookup"><span data-stu-id="28ad6-129">Pool Creation and Assignment</span></span>  
 <span data-ttu-id="28ad6-130">第一次開啟連接時，會根據精確的比對演算法建立連接集區，該演算法可將集區與連接中的連接字串相關聯。</span><span class="sxs-lookup"><span data-stu-id="28ad6-130">When a connection is first opened, a connection pool is created based on an exact matching algorithm that associates the pool with the connection string in the connection.</span></span> <span data-ttu-id="28ad6-131">每個連接集區與不同的連接字串相關聯。</span><span class="sxs-lookup"><span data-stu-id="28ad6-131">Each connection pool is associated with a distinct connection string.</span></span> <span data-ttu-id="28ad6-132">開啟新連接時，如果連接字串與現有集區並不完全相符，則會建立新集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-132">When a new connection is opened, if the connection string is not an exact match to an existing pool, a new pool is created.</span></span> <span data-ttu-id="28ad6-133">連接共用的方式是以每個處理序、每個應用程式定義域、每個連接字串，及 (使用整合安全性時) 每個 Windows 識別進行的。</span><span class="sxs-lookup"><span data-stu-id="28ad6-133">Connections are pooled per process, per application domain, per connection string and when integrated security is used, per Windows identity.</span></span> <span data-ttu-id="28ad6-134">連接字串必須完全符合；以不同順序針對同一連接所提供的關鍵字將會個別共用。</span><span class="sxs-lookup"><span data-stu-id="28ad6-134">Connection strings must also be an exact match; keywords supplied in a different order for the same connection will be pooled separately.</span></span>  
  
 <span data-ttu-id="28ad6-135">在下列 C# 範例中，會建立三個新的 <xref:System.Data.SqlClient.SqlConnection> 物件，但是只需要兩個連接集區來管理它們。</span><span class="sxs-lookup"><span data-stu-id="28ad6-135">In the following C# example, three new <xref:System.Data.SqlClient.SqlConnection> objects are created, but only two connection pools are required to manage them.</span></span> <span data-ttu-id="28ad6-136">請注意，第一個及第二個連接字串的不同之處在於指派給 `Initial Catalog` 的值不同。</span><span class="sxs-lookup"><span data-stu-id="28ad6-136">Note that the first and second connection strings differ by the value assigned for `Initial Catalog`.</span></span>  
  
```csharp
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=Northwind"))  
    {  
        connection.Open();        
        // Pool A is created.  
    }  
  
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=pubs"))  
    {  
        connection.Open();        
        // Pool B is created because the connection strings differ.  
    }  
  
using (SqlConnection connection = new SqlConnection(  
  "Integrated Security=SSPI;Initial Catalog=Northwind"))  
    {  
        connection.Open();        
        // The connection string matches pool A.  
    }  
```  
  
 <span data-ttu-id="28ad6-137">如果連接字串中未指定 `MinPoolSize` 或其指定為零，則會在一段非作用中期間後關閉集區中的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-137">If `MinPoolSize` is either not specified in the connection string or is specified as zero, the connections in the pool will be closed after a period of inactivity.</span></span> <span data-ttu-id="28ad6-138">不過，如果指定的 `MinPoolSize` 大於零，則在卸載 `AppDomain` 且處理序結束之前，不會損毀連接集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-138">However, if the specified `MinPoolSize` is greater than zero, the connection pool is not destroyed until the `AppDomain` is unloaded and the process ends.</span></span> <span data-ttu-id="28ad6-139">維護非作用中或空的集區僅會導致最小的系統負荷量。</span><span class="sxs-lookup"><span data-stu-id="28ad6-139">Maintenance of inactive or empty pools involves minimal system overhead.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="28ad6-140">發生嚴重錯誤 (如容錯移轉) 時，會自動清除集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-140">The pool is automatically cleared when a fatal error occurs, such as a failover.</span></span>  
  
## <a name="adding-connections"></a><span data-ttu-id="28ad6-141">加入連接</span><span class="sxs-lookup"><span data-stu-id="28ad6-141">Adding Connections</span></span>  
 <span data-ttu-id="28ad6-142">針對每個唯一連接字串可建立連接集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-142">A connection pool is created for each unique connection string.</span></span> <span data-ttu-id="28ad6-143">建立集區時，會建立多個連接物件並加入集區，以滿足最小集區大小需求。</span><span class="sxs-lookup"><span data-stu-id="28ad6-143">When a pool is created, multiple connection objects are created and added to the pool so that the minimum pool size requirement is satisfied.</span></span> <span data-ttu-id="28ad6-144">視需要將連接加入集區，直到達到指定的最大集區大小 (預設值是 100)。</span><span class="sxs-lookup"><span data-stu-id="28ad6-144">Connections are added to the pool as needed, up to the maximum pool size specified (100 is the default).</span></span> <span data-ttu-id="28ad6-145">連接關閉或處置時，會被釋放回集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-145">Connections are released back into the pool when they are closed or disposed.</span></span>  
  
 <span data-ttu-id="28ad6-146">要求 <xref:System.Data.SqlClient.SqlConnection> 物件時，如果存在可用的連接，則會從集區取得該物件。</span><span class="sxs-lookup"><span data-stu-id="28ad6-146">When a <xref:System.Data.SqlClient.SqlConnection> object is requested, it is obtained from the pool if a usable connection is available.</span></span> <span data-ttu-id="28ad6-147">若要連接可用，則連接必須未使用、具有相符的交易內容或不與任何交易內容關聯，並具有到伺服器的有效連結。</span><span class="sxs-lookup"><span data-stu-id="28ad6-147">To be usable, a connection must be unused, have a matching transaction context or be unassociated with any transaction context, and have a valid link to the server.</span></span>  
  
 <span data-ttu-id="28ad6-148">連接共用器會藉由重新配置釋放回集區的連接，來滿足連接的請求。</span><span class="sxs-lookup"><span data-stu-id="28ad6-148">The connection pooler satisfies requests for connections by reallocating connections as they are released back into the pool.</span></span> <span data-ttu-id="28ad6-149">如果已達到最大集區大小，但仍沒有可用的連接，則會將要求排入佇列。</span><span class="sxs-lookup"><span data-stu-id="28ad6-149">If the maximum pool size has been reached and no usable connection is available, the request is queued.</span></span> <span data-ttu-id="28ad6-150">共用器接下來會嘗試回收所有連接，直到達到逾時 (預設值是 15 秒)。</span><span class="sxs-lookup"><span data-stu-id="28ad6-150">The pooler then tries to reclaim any connections until the time-out is reached (the default is 15 seconds).</span></span> <span data-ttu-id="28ad6-151">如果連接逾時之前共用器無法滿足要求，則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="28ad6-151">If the pooler cannot satisfy the request before the connection times out, an exception is thrown.</span></span>  
  
> [!CAUTION]
> <span data-ttu-id="28ad6-152">強烈建議您在使用完連接後一律關閉該連接，以便將連接傳回集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-152">We strongly recommend that you always close the connection when you are finished using it so that the connection will be returned to the pool.</span></span> <span data-ttu-id="28ad6-153">您`Close`可以使用`Connection`物件的或`Dispose`方法，或開啟中`using` C#的語句內的所有連接，或 Visual Basic 中的`Using`語句，來執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="28ad6-153">You can do this using either the `Close` or `Dispose` methods of the `Connection` object, or by opening all connections inside a `using` statement in C#, or a `Using` statement in Visual Basic.</span></span> <span data-ttu-id="28ad6-154">可能不會將未明確關閉的連接加入或傳回集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-154">Connections that are not explicitly closed might not be added or returned to the pool.</span></span> <span data-ttu-id="28ad6-155">如需詳細資訊，請參閱[using 語句](../../../csharp/language-reference/keywords/using-statement.md)或[如何：處置 Visual Basic 的系統資源](../../../visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) 。</span><span class="sxs-lookup"><span data-stu-id="28ad6-155">For more information, see [using Statement](../../../csharp/language-reference/keywords/using-statement.md) or [How to: Dispose of a System Resource](../../../visual-basic/programming-guide/language-features/control-flow/how-to-dispose-of-a-system-resource.md) for Visual Basic.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="28ad6-156">請不要在您類別之 `Close` 方法中的 `Dispose`、`Connection` 或任何其他 Managed 物件上呼叫 `DataReader` 或 `Finalize`。</span><span class="sxs-lookup"><span data-stu-id="28ad6-156">Do not call `Close` or `Dispose` on a `Connection`, a `DataReader`, or any other managed object in the `Finalize` method of your class.</span></span> <span data-ttu-id="28ad6-157">在完成項中，只需釋放類別直接擁有的 Unmanaged 資源。</span><span class="sxs-lookup"><span data-stu-id="28ad6-157">In a finalizer, only release unmanaged resources that your class owns directly.</span></span> <span data-ttu-id="28ad6-158">如果類別未擁有任何 Unmanaged 資源，請不要在類別定義中包含 `Finalize` 方法。</span><span class="sxs-lookup"><span data-stu-id="28ad6-158">If your class does not own any unmanaged resources, do not include a `Finalize` method in your class definition.</span></span> <span data-ttu-id="28ad6-159">如需詳細資訊，請參閱[垃圾收集](../../../standard/garbage-collection/index.md)。</span><span class="sxs-lookup"><span data-stu-id="28ad6-159">For more information, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
<span data-ttu-id="28ad6-160">如需與開啟和關閉連接相關聯之事件的詳細資訊，請參閱 SQL Server 檔中的[Audit Login 事件類別](/sql/relational-databases/event-classes/audit-login-event-class)和[Audit 登出事件類別](/sql/relational-databases/event-classes/audit-logout-event-class)。</span><span class="sxs-lookup"><span data-stu-id="28ad6-160">For more info about the events associated with opening and closing connections, see [Audit Login Event Class](/sql/relational-databases/event-classes/audit-login-event-class) and [Audit Logout Event Class](/sql/relational-databases/event-classes/audit-logout-event-class) in the SQL Server documentation.</span></span>  
  
## <a name="removing-connections"></a><span data-ttu-id="28ad6-161">移除連接</span><span class="sxs-lookup"><span data-stu-id="28ad6-161">Removing Connections</span></span>  
 <span data-ttu-id="28ad6-162">如果集區中的連接已閒置大約 4 到 8 分鐘，或如果共用器偵測到與伺服器的連接已嚴重損毀，則連接共用器會從集區中移除該連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-162">The connection pooler removes a connection from the pool after it has been idle for approximately 4-8 minutes, or if the pooler detects that the connection with the server has been severed.</span></span> <span data-ttu-id="28ad6-163">請注意，只有嘗試與伺服器進行通訊後，才能偵測到嚴重損毀的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-163">Note that a severed connection can be detected only after attempting to communicate with the server.</span></span> <span data-ttu-id="28ad6-164">如果發現連接已不再連接到伺服器，則會將其標記為無效。</span><span class="sxs-lookup"><span data-stu-id="28ad6-164">If a connection is found that is no longer connected to the server, it is marked as invalid.</span></span> <span data-ttu-id="28ad6-165">只當關閉或回收無效的連接時，才會將它們從連接集區中移除。</span><span class="sxs-lookup"><span data-stu-id="28ad6-165">Invalid connections are removed from the connection pool only when they are closed or reclaimed.</span></span>  
  
 <span data-ttu-id="28ad6-166">如果連接是與已消失的伺服器連接，即使連接共用器尚未偵測到已嚴重損毀的連接並將其標記為無效，此連接還是會從集區中建立。</span><span class="sxs-lookup"><span data-stu-id="28ad6-166">If a connection exists to a server that has disappeared, this connection can be drawn from the pool even if the connection pooler has not detected the severed connection and marked it as invalid.</span></span> <span data-ttu-id="28ad6-167">這是因為檢查連接是否仍然有效的額外負荷抵銷了集區的優點，它導致了與伺服器之間的往返通訊。</span><span class="sxs-lookup"><span data-stu-id="28ad6-167">This is the case because the overhead of checking that the connection is still valid would eliminate the benefits of having a pooler by causing another round trip to the server to occur.</span></span> <span data-ttu-id="28ad6-168">發生此情況時，第一次嘗試使用該連接時將偵測到連接已嚴重損毀，並擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="28ad6-168">When this occurs, the first attempt to use the connection will detect that the connection has been severed, and an exception is thrown.</span></span>  
  
## <a name="clearing-the-pool"></a><span data-ttu-id="28ad6-169">清除集區</span><span class="sxs-lookup"><span data-stu-id="28ad6-169">Clearing the Pool</span></span>  
 <span data-ttu-id="28ad6-170">ADO.NET 2.0 引進兩種清除集區的新方法<xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> ： <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A>和。</span><span class="sxs-lookup"><span data-stu-id="28ad6-170">ADO.NET 2.0 introduced two new methods to clear the pool: <xref:System.Data.SqlClient.SqlConnection.ClearAllPools%2A> and <xref:System.Data.SqlClient.SqlConnection.ClearPool%2A>.</span></span> <span data-ttu-id="28ad6-171">`ClearAllPools` 會清除指定提供者的連接集區， `ClearPool` 會清除與特定連接相關聯的連接集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-171">`ClearAllPools` clears the connection pools for a given provider, and `ClearPool` clears the connection pool that is associated with a specific connection.</span></span> <span data-ttu-id="28ad6-172">如果呼叫時有正在使用中的連接，則會適當地標記它們。</span><span class="sxs-lookup"><span data-stu-id="28ad6-172">If there are connections being used at the time of the call, they are marked appropriately.</span></span> <span data-ttu-id="28ad6-173">而當連接關閉時，會捨棄它們，而不是將其傳回集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-173">When they are closed, they are discarded instead of being returned to the pool.</span></span>  
  
## <a name="transaction-support"></a><span data-ttu-id="28ad6-174">異動支援</span><span class="sxs-lookup"><span data-stu-id="28ad6-174">Transaction Support</span></span>  
 <span data-ttu-id="28ad6-175">從集區中描繪連接，並根據交易內容進行指派。</span><span class="sxs-lookup"><span data-stu-id="28ad6-175">Connections are drawn from the pool and assigned based on transaction context.</span></span> <span data-ttu-id="28ad6-176">除非已在連接字串中指定 `Enlist=false`，否則連接集區會確保將連接登記在 <xref:System.Transactions.Transaction.Current%2A>內容中。</span><span class="sxs-lookup"><span data-stu-id="28ad6-176">Unless `Enlist=false` is specified in the connection string, the connection pool makes sure that the connection is enlisted in the <xref:System.Transactions.Transaction.Current%2A> context.</span></span> <span data-ttu-id="28ad6-177">連接關閉並傳回到具有已登記 `System.Transactions` 交易的集區時會先擱置。如果下一個要求發出時此連接是可用狀態，具有相同 `System.Transactions` 交易之連接集區就會傳回相同的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-177">When a connection is closed and returned to the pool with an enlisted `System.Transactions` transaction, it is set aside in such a way that the next request for that connection pool with the same `System.Transactions` transaction will return the same connection if it is available.</span></span> <span data-ttu-id="28ad6-178">如果這類要求發出，但沒有可用的共用連接，則會從集區的非交易部分建立連接並登記。</span><span class="sxs-lookup"><span data-stu-id="28ad6-178">If such a request is issued, and there are no pooled connections available, a connection is drawn from the non-transacted part of the pool and enlisted.</span></span> <span data-ttu-id="28ad6-179">如果共用的連接可用，則共用器會將其傳回至呼叫端，而不會開啟新的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-179">If no connections are available in either area of the pool, a new connection is created and enlisted.</span></span>  
  
 <span data-ttu-id="28ad6-180">連接關閉時，會根據其交易內容將其釋放回集區，並置於適當的子區塊中。</span><span class="sxs-lookup"><span data-stu-id="28ad6-180">When a connection is closed, it is released back into the pool and into the appropriate subdivision based on its transaction context.</span></span> <span data-ttu-id="28ad6-181">因此，即使分散式交易仍處於暫止狀態，您仍可以關閉連接，而不會產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="28ad6-181">Therefore, you can close the connection without generating an error, even though a distributed transaction is still pending.</span></span> <span data-ttu-id="28ad6-182">這可讓您稍後再認可或中止分散式交易。</span><span class="sxs-lookup"><span data-stu-id="28ad6-182">This allows you to commit or abort the distributed transaction later.</span></span>  
  
## <a name="controlling-connection-pooling-with-connection-string-keywords"></a><span data-ttu-id="28ad6-183">使用連接字串關鍵字控制連接共用</span><span class="sxs-lookup"><span data-stu-id="28ad6-183">Controlling Connection Pooling with Connection String Keywords</span></span>  
 <span data-ttu-id="28ad6-184">`ConnectionString` 物件的 <xref:System.Data.SqlClient.SqlConnection> 屬性支援連接字串索引鍵/值配對，這些配對可用於調整連接共用邏輯的行為。</span><span class="sxs-lookup"><span data-stu-id="28ad6-184">The `ConnectionString` property of the <xref:System.Data.SqlClient.SqlConnection> object supports connection string key/value pairs that can be used to adjust the behavior of the connection pooling logic.</span></span> <span data-ttu-id="28ad6-185">如需詳細資訊，請參閱<xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>。</span><span class="sxs-lookup"><span data-stu-id="28ad6-185">For more information, see <xref:System.Data.SqlClient.SqlConnection.ConnectionString%2A>.</span></span>  
  
## <a name="pool-fragmentation"></a><span data-ttu-id="28ad6-186">集區片段</span><span class="sxs-lookup"><span data-stu-id="28ad6-186">Pool Fragmentation</span></span>  
 <span data-ttu-id="28ad6-187">集區片段是許多 Web 應用程式中的常見問題，這些應用程式可能會建立大量集區，並且直至處理序結束後才釋放它們。</span><span class="sxs-lookup"><span data-stu-id="28ad6-187">Pool fragmentation is a common problem in many Web applications where the application can create a large number of pools that are not freed until the process exits.</span></span> <span data-ttu-id="28ad6-188">這會使大量連接保持開啟狀態並消耗記憶體，導致效能降低。</span><span class="sxs-lookup"><span data-stu-id="28ad6-188">This leaves a large number of connections open and consuming memory, which results in poor performance.</span></span>  
  
### <a name="pool-fragmentation-due-to-integrated-security"></a><span data-ttu-id="28ad6-189">整合安全性導致的集區片段</span><span class="sxs-lookup"><span data-stu-id="28ad6-189">Pool Fragmentation Due to Integrated Security</span></span>  
 <span data-ttu-id="28ad6-190">可根據連接字串及使用者識別共用連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-190">Connections are pooled according to the connection string plus the user identity.</span></span> <span data-ttu-id="28ad6-191">因此，如果您在網站上使用基本驗證或 Windows 驗證，並使用整合安全性登入，則每個使用者會獲得一個集區。</span><span class="sxs-lookup"><span data-stu-id="28ad6-191">Therefore, if you use Basic authentication or Windows Authentication on the Web site and an integrated security login, you get one pool per user.</span></span> <span data-ttu-id="28ad6-192">雖然這會提升單一使用者之後續資料庫要求的效能，但該使用者無法利用其他使用者的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-192">Although this improves the performance of subsequent database requests for a single user, that user cannot take advantage of connections made by other users.</span></span> <span data-ttu-id="28ad6-193">這也會導致每個使用者至少存在一個與資料庫伺服器的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-193">It also results in at least one connection per user to the database server.</span></span> <span data-ttu-id="28ad6-194">這是特定 Web 應用程式架構的副作用，是開發人員在針對安全性與稽核需求方面必須考量的問題。</span><span class="sxs-lookup"><span data-stu-id="28ad6-194">This is a side effect of a particular Web application architecture that developers must weigh against security and auditing requirements.</span></span>  
  
### <a name="pool-fragmentation-due-to-many-databases"></a><span data-ttu-id="28ad6-195">多個資料庫導致的集區片段</span><span class="sxs-lookup"><span data-stu-id="28ad6-195">Pool Fragmentation Due to Many Databases</span></span>  
 <span data-ttu-id="28ad6-196">許多網際網路服務提供者在單一伺服器上裝載多個網站。</span><span class="sxs-lookup"><span data-stu-id="28ad6-196">Many Internet service providers host several Web sites on a single server.</span></span> <span data-ttu-id="28ad6-197">他們可以使用單一資料庫確認表單驗證登入，然後開啟該使用者或使用者群組之特定資料庫的連接。</span><span class="sxs-lookup"><span data-stu-id="28ad6-197">They may use a single database to confirm a Forms authentication login and then open a connection to a specific database for that user or group of users.</span></span> <span data-ttu-id="28ad6-198">驗證資料庫的連接可供所有人共用和使用。</span><span class="sxs-lookup"><span data-stu-id="28ad6-198">The connection to the authentication database is pooled and used by everyone.</span></span> <span data-ttu-id="28ad6-199">不過，每個資料庫存在單獨的連接集區，而這會增加伺服器連接的數目。</span><span class="sxs-lookup"><span data-stu-id="28ad6-199">However, there is a separate pool of connections to each database, which increase the number of connections to the server.</span></span>  
  
 <span data-ttu-id="28ad6-200">這也是應用程式設計的副作用。</span><span class="sxs-lookup"><span data-stu-id="28ad6-200">This is also a side-effect of the application design.</span></span> <span data-ttu-id="28ad6-201">有一個比較簡單的方法可避免此副作用，同時不會影響連接到 SQL Server 時的安全性。</span><span class="sxs-lookup"><span data-stu-id="28ad6-201">There is a relatively simple way to avoid this side effect without compromising security when you connect to SQL Server.</span></span> <span data-ttu-id="28ad6-202">連接到伺服器上的同一個資料庫，而不是連接到每個使用者或群組的個別資料庫，然後執行 Transact-SQL USE 陳述式，以變更為想要的資料庫。</span><span class="sxs-lookup"><span data-stu-id="28ad6-202">Instead of connecting to a separate database for each user or group, connect to the same database on the server and then execute the Transact-SQL USE statement to change to the desired database.</span></span> <span data-ttu-id="28ad6-203">下列程式碼片段會示範如何建立與 `master` 資料庫的初始連接，然後切換至 `databaseName` 字串變數中指定之目標資料庫。</span><span class="sxs-lookup"><span data-stu-id="28ad6-203">The following code fragment demonstrates creating an initial connection to the `master` database and then switching to the desired database specified in the `databaseName` string variable.</span></span>  
  
```vb  
' Assumes that command is a valid SqlCommand object and that  
' connectionString connects to master.  
    command.Text = "USE DatabaseName"  
Using connection As New SqlConnection(connectionString)  
    connection.Open()  
    command.ExecuteNonQuery()  
End Using  
```  
  
```csharp  
// Assumes that command is a SqlCommand object and that  
// connectionString connects to master.  
command.Text = "USE DatabaseName";  
using (SqlConnection connection = new SqlConnection(  
  connectionString))  
  {  
    connection.Open();  
    command.ExecuteNonQuery();  
  }  
```  
  
## <a name="application-roles-and-connection-pooling"></a><span data-ttu-id="28ad6-204">應用程式角色和連接共用</span><span class="sxs-lookup"><span data-stu-id="28ad6-204">Application Roles and Connection Pooling</span></span>  
 <span data-ttu-id="28ad6-205">呼叫 `sp_setapprole` 系統預存程序來啟動 SQL Server 應用程式角色後，便無法重設該連接的安全性內容。</span><span class="sxs-lookup"><span data-stu-id="28ad6-205">After a SQL Server application role has been activated by calling the `sp_setapprole` system stored procedure, the security context of that connection cannot be reset.</span></span> <span data-ttu-id="28ad6-206">不過，啟用共用後，連接會傳回到集區，並且在重複使用共用連接時發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="28ad6-206">However, if pooling is enabled, the connection is returned to the pool, and an error occurs when the pooled connection is reused.</span></span> <span data-ttu-id="28ad6-207">如需詳細資訊，請參閱知識庫檔 <<c0>OLE DB 資源分享的 SQL 應用程式角色錯誤」。</span><span class="sxs-lookup"><span data-stu-id="28ad6-207">For more information, see the Knowledge Base article, "[SQL application role errors with OLE DB resource pooling](https://support.microsoft.com/default.aspx?scid=KB;EN-US;Q229564)."</span></span>  
  
### <a name="application-role-alternatives"></a><span data-ttu-id="28ad6-208">應用程式角色替代方案</span><span class="sxs-lookup"><span data-stu-id="28ad6-208">Application Role Alternatives</span></span>  
 <span data-ttu-id="28ad6-209">建議您善加利用安全機制，以取代應用程式角色。</span><span class="sxs-lookup"><span data-stu-id="28ad6-209">We recommend that you take advantage of security mechanisms that you can use instead of application roles.</span></span> <span data-ttu-id="28ad6-210">如需詳細資訊，請參閱[在 SQL Server 中建立應用程式角色](./sql/creating-application-roles-in-sql-server.md)。</span><span class="sxs-lookup"><span data-stu-id="28ad6-210">For more information, see [Creating Application Roles in SQL Server](./sql/creating-application-roles-in-sql-server.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="28ad6-211">另請參閱</span><span class="sxs-lookup"><span data-stu-id="28ad6-211">See also</span></span>

- [<span data-ttu-id="28ad6-212">連接共用</span><span class="sxs-lookup"><span data-stu-id="28ad6-212">Connection Pooling</span></span>](connection-pooling.md)
- [<span data-ttu-id="28ad6-213">SQL Server 和 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="28ad6-213">SQL Server and ADO.NET</span></span>](./sql/index.md)
- [<span data-ttu-id="28ad6-214">效能計數器</span><span class="sxs-lookup"><span data-stu-id="28ad6-214">Performance Counters</span></span>](performance-counters.md)
- [<span data-ttu-id="28ad6-215">ADO.NET 概觀</span><span class="sxs-lookup"><span data-stu-id="28ad6-215">ADO.NET Overview</span></span>](ado-net-overview.md)
