---
title: XAML 語法詳細資料
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 3ac7d79660830601ca69951e56763fc923692b0e
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/22/2019
ms.locfileid: "69958792"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="7fbca-102">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="7fbca-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="7fbca-103">本主題定義用來描述 XAML 語法元素的詞彙。</span><span class="sxs-lookup"><span data-stu-id="7fbca-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="7fbca-104">本檔的其餘部分會經常使用這些詞彙, 這兩者都是針對 WPF 檔, 特別是針對使用 XAML 的其他架構, 或是在 .xaml 層級由 XAML 語言支援啟用的基本 XAML 概念。</span><span class="sxs-lookup"><span data-stu-id="7fbca-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="7fbca-105">本主題將針對[XAML 總覽 (WPF)](xaml-overview-wpf.md)主題中引進的基本術語進行擴充。</span><span class="sxs-lookup"><span data-stu-id="7fbca-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  

<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="7fbca-106">XAML 語言規格</span><span class="sxs-lookup"><span data-stu-id="7fbca-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="7fbca-107">在此定義的 XAML 語法詞彙也會在 XAML 語言規格中定義或參考。</span><span class="sxs-lookup"><span data-stu-id="7fbca-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="7fbca-108">XAML 是以 XML 為基礎的語言, 並在 XML 結構化規則之後遵循或擴充。</span><span class="sxs-lookup"><span data-stu-id="7fbca-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="7fbca-109">有些術語是從共用, 或是以描述 XML 語言或 XML 檔物件模型時常用的術語為基礎。</span><span class="sxs-lookup"><span data-stu-id="7fbca-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="7fbca-110">如需 XAML 語言規格的詳細資訊, 請從 Microsoft 下載中心下載[ \[MS-XAML\] ](https://go.microsoft.com/fwlink/?LinkId=114525) 。</span><span class="sxs-lookup"><span data-stu-id="7fbca-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="7fbca-111">XAML 和 CLR</span><span class="sxs-lookup"><span data-stu-id="7fbca-111">XAML and CLR</span></span>  
 <span data-ttu-id="7fbca-112">XAML 是一種標記語言。</span><span class="sxs-lookup"><span data-stu-id="7fbca-112">XAML is a markup language.</span></span> <span data-ttu-id="7fbca-113">Common language runtime (CLR) (如其名稱所隱含) 可啟用執行時間執行。</span><span class="sxs-lookup"><span data-stu-id="7fbca-113">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="7fbca-114">XAML 本身不是 CLR 執行時間直接取用的其中一個通用語言。</span><span class="sxs-lookup"><span data-stu-id="7fbca-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="7fbca-115">取而代之的是, 您可以將 XAML 視為支援它自己的型別系統。</span><span class="sxs-lookup"><span data-stu-id="7fbca-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="7fbca-116">WPF 使用的特定 XAML 剖析系統建基於 CLR 和 CLR 型別系統。</span><span class="sxs-lookup"><span data-stu-id="7fbca-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="7fbca-117">XAML 類型會對應至 CLR 類型, 以在剖析 WPF 的 XAML 時具現化運行時程表示。</span><span class="sxs-lookup"><span data-stu-id="7fbca-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="7fbca-118">基於這個理由, 本檔中語法討論的其餘部分將包含 CLR 型別系統的參考, 即使 XAML 語言規格中的對等語法討論不是如此。</span><span class="sxs-lookup"><span data-stu-id="7fbca-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="7fbca-119">(根據 XAML 語言規格層級, XAML 類型可以對應到任何其他類型系統, 這不一定是 CLR, 但這需要建立和使用不同的 XAML 剖析器)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="7fbca-120">類型和類別繼承的成員</span><span class="sxs-lookup"><span data-stu-id="7fbca-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="7fbca-121">當做[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]類型的 XAML 成員出現的屬性和事件, 通常會繼承自基底類型。</span><span class="sxs-lookup"><span data-stu-id="7fbca-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="7fbca-122">例如, 請考慮下列範例: `<Button Background="Blue" .../>`。</span><span class="sxs-lookup"><span data-stu-id="7fbca-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="7fbca-123">如果您要查看類別定義、反映結果或<xref:System.Windows.Controls.Button>檔,屬性在類別上不是立即宣告的屬性。<xref:System.Windows.Controls.Control.Background%2A></span><span class="sxs-lookup"><span data-stu-id="7fbca-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="7fbca-124">相反地<xref:System.Windows.Controls.Control.Background%2A> , 是繼承自基類<xref:System.Windows.Controls.Control> 。</span><span class="sxs-lookup"><span data-stu-id="7fbca-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="7fbca-125">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML 元素的類別繼承行為, 是從 XML 標記的架構強制式轉譯中大幅出發。</span><span class="sxs-lookup"><span data-stu-id="7fbca-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="7fbca-126">類別繼承可能會變得複雜, 特別是當中繼基類是抽象的, 或涉及介面時。</span><span class="sxs-lookup"><span data-stu-id="7fbca-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="7fbca-127">這是一項原因, 那就是 XAML 元素的集合及其允許的屬性, 很難正確地表示, 而且使用一般用於程式[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]設計的架構類型, 例如 DTD 或 XSD 格式。</span><span class="sxs-lookup"><span data-stu-id="7fbca-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format.</span></span> <span data-ttu-id="7fbca-128">另一個原因是 XAML 語言本身的擴充性和類型對應功能, 會排除所允許之類型和成員的任何固定標記法的完整性。</span><span class="sxs-lookup"><span data-stu-id="7fbca-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="7fbca-129">物件元素語法</span><span class="sxs-lookup"><span data-stu-id="7fbca-129">Object Element Syntax</span></span>  
 <span data-ttu-id="7fbca-130">*物件元素語法*是 XAML 標記語法, 會藉由宣告 XML 專案來具現化 CLR 類別或結構。</span><span class="sxs-lookup"><span data-stu-id="7fbca-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="7fbca-131">此語法類似其他標記語言 (例如 HTML) 的元素語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="7fbca-132">物件元素語法以左角括弧 (\<) 開頭, 後面緊接著要具現化之類別或結構的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="7fbca-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="7fbca-133">零或多個空格可以遵循類型名稱, 而且也可以在 object 元素上宣告零個或多個屬性, 並以一或多個空格分隔每個屬性名稱 = "value" 配對。</span><span class="sxs-lookup"><span data-stu-id="7fbca-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="7fbca-134">最後, 必須符合下列其中一項條件:</span><span class="sxs-lookup"><span data-stu-id="7fbca-134">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="7fbca-135">元素和標記必須以正斜線 (/) 關閉, 後面緊接著右角括弧 (>)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="7fbca-136">開頭標記必須以右角括弧 (>) 完成。</span><span class="sxs-lookup"><span data-stu-id="7fbca-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="7fbca-137">其他物件元素、屬性專案或內部文字則可以跟隨在開頭標記之後。</span><span class="sxs-lookup"><span data-stu-id="7fbca-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="7fbca-138">此處所包含的內容, 通常會受到元素的物件模型所限制。</span><span class="sxs-lookup"><span data-stu-id="7fbca-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="7fbca-139">物件元素的對等結束記號也必須存在, 以適當的對應, 並與其他開頭和結束記號配對進行平衡。</span><span class="sxs-lookup"><span data-stu-id="7fbca-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="7fbca-140">.NET 所實作為的 XAML 具有一組規則, 可將物件元素對應至類型、屬性為屬性或事件, 以及 XAML 命名空間與 CLR 命名空間加上元件。</span><span class="sxs-lookup"><span data-stu-id="7fbca-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="7fbca-141">針對 WPF 和 .NET Framework, XAML 物件專案會對應至[!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)]所參考元件中所定義的類型, 而屬性會對應至這些類型的成員。</span><span class="sxs-lookup"><span data-stu-id="7fbca-141">For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="7fbca-142">當您在 XAML 中參考 CLR 型別時, 您也可以存取該型別的繼承成員。</span><span class="sxs-lookup"><span data-stu-id="7fbca-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="7fbca-143">例如, 下列範例是物件專案語法, 可具現化<xref:System.Windows.Controls.Button>類別的新實例, 也會<xref:System.Windows.FrameworkElement.Name%2A>指定屬性和該屬性的值:</span><span class="sxs-lookup"><span data-stu-id="7fbca-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="7fbca-144">下列範例是物件元素語法, 其中也包含 XAML 內容屬性語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="7fbca-145">包含在內的內部文字將用來設定<xref:System.Windows.Controls.TextBox> XAML 內容<xref:System.Windows.Controls.TextBox.Text%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="7fbca-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="7fbca-146">內容模型</span><span class="sxs-lookup"><span data-stu-id="7fbca-146">Content Models</span></span>  
 <span data-ttu-id="7fbca-147">在語法方面, 類別可能支援使用當做 XAML 物件專案, 但當應用程式或頁面放在整體內容模型或專案樹狀結構的預期位置時, 該專案將只能在該元素中正常運作。</span><span class="sxs-lookup"><span data-stu-id="7fbca-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="7fbca-148">例如, <xref:System.Windows.Controls.MenuItem>通常應該只放在<xref:System.Windows.Controls.Primitives.MenuBase>衍生類別的子系, 例如<xref:System.Windows.Controls.Menu>。</span><span class="sxs-lookup"><span data-stu-id="7fbca-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="7fbca-149">特定專案的內容模型會記載為控制項的類別頁面上的備註一部分, 以及可當做[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML 專案使用的其他類別。</span><span class="sxs-lookup"><span data-stu-id="7fbca-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="7fbca-150">物件元素的屬性</span><span class="sxs-lookup"><span data-stu-id="7fbca-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="7fbca-151">XAML 中的屬性是由各種可能的語法所設定。</span><span class="sxs-lookup"><span data-stu-id="7fbca-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="7fbca-152">根據您所設定之屬性的基礎類型系統特性而定, 特定屬性可以使用哪種語法會有所不同。</span><span class="sxs-lookup"><span data-stu-id="7fbca-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="7fbca-153">藉由設定屬性的值, 您可以將功能或特性加入至物件, 因為它們存在於執行時間物件圖形中。</span><span class="sxs-lookup"><span data-stu-id="7fbca-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="7fbca-154">從物件元素建立之物件的初始狀態是以無參數的函式行為為基礎。</span><span class="sxs-lookup"><span data-stu-id="7fbca-154">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="7fbca-155">一般來說, 您的應用程式會使用任何指定物件的完全預設實例以外的專案。</span><span class="sxs-lookup"><span data-stu-id="7fbca-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="7fbca-156">屬性 (Attribute) 語法 (屬性(Property))</span><span class="sxs-lookup"><span data-stu-id="7fbca-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="7fbca-157">屬性語法是 XAML 標記語法, 會藉由宣告現有物件專案上的屬性來設定屬性的值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="7fbca-158">屬性名稱必須符合可支援相關物件專案之類別的屬性 (property) 的 CLR 成員名稱。</span><span class="sxs-lookup"><span data-stu-id="7fbca-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="7fbca-159">屬性名稱後面接著指派運算子 (=)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="7fbca-160">屬性值必須是括在引號內的字串。</span><span class="sxs-lookup"><span data-stu-id="7fbca-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7fbca-161">您可以使用替代引號將常值引號放在屬性中。</span><span class="sxs-lookup"><span data-stu-id="7fbca-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="7fbca-162">例如, 您可以使用單引號來宣告字串, 其中包含其中的雙引號字元。</span><span class="sxs-lookup"><span data-stu-id="7fbca-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="7fbca-163">無論您使用單引號或雙引號, 都應該使用相符的配對來開啟和關閉屬性值字串。</span><span class="sxs-lookup"><span data-stu-id="7fbca-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="7fbca-164">還有其他可用來處理任何特定 XAML 語法所加上之字元限制的逸出序列或其他技術。</span><span class="sxs-lookup"><span data-stu-id="7fbca-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="7fbca-165">請參閱[XML 字元實體和 XAML](../../xaml-services/xml-character-entities-and-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-165">See [XML Character Entities and XAML](../../xaml-services/xml-character-entities-and-xaml.md).</span></span>  
  
 <span data-ttu-id="7fbca-166">若要透過屬性語法設定, 屬性必須是公用的, 而且必須是可寫入的。</span><span class="sxs-lookup"><span data-stu-id="7fbca-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="7fbca-167">支援型別系統中的屬性值必須是實值型別, 或必須是參考型別, 而且在存取相關的支援型別時, XAML 處理器可以加以具現化或參照。</span><span class="sxs-lookup"><span data-stu-id="7fbca-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="7fbca-168">針對 WPF XAML 事件, 當做屬性名稱參考的事件必須是公用的, 而且具有公用委派。</span><span class="sxs-lookup"><span data-stu-id="7fbca-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="7fbca-169">屬性或事件必須是包含物件元素所具現化之類別或結構的成員。</span><span class="sxs-lookup"><span data-stu-id="7fbca-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="7fbca-170">屬性值的處理</span><span class="sxs-lookup"><span data-stu-id="7fbca-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="7fbca-171">開頭和結尾引號中包含的字串值是由 XAML 處理器處理。</span><span class="sxs-lookup"><span data-stu-id="7fbca-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="7fbca-172">對於屬性, 預設的處理行為取決於基礎 CLR 屬性的類型。</span><span class="sxs-lookup"><span data-stu-id="7fbca-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="7fbca-173">屬性值是以下列其中一種方式填入, 使用此處理順序:</span><span class="sxs-lookup"><span data-stu-id="7fbca-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="7fbca-174">如果 XAML 處理器遇到大括弧, 或衍生自<xref:System.Windows.Markup.MarkupExtension>的物件專案, 則會先評估參考的標記延伸, 而不是將值當做字串來處理, 而且標記延伸所傳回的物件會當做value.</span><span class="sxs-lookup"><span data-stu-id="7fbca-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="7fbca-175">在許多情況下, 標記延伸所傳回的物件將會是現有物件的參考, 或是延遲評估到執行時間的運算式, 而且不是新具現化的物件。</span><span class="sxs-lookup"><span data-stu-id="7fbca-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="7fbca-176">如果屬性是以屬性化<xref:System.ComponentModel.TypeConverter>的方式宣告, 或該屬性的實值型別是以屬性化<xref:System.ComponentModel.TypeConverter>, 則會將屬性的字串值提交至型別轉換器做為轉換輸入, 而轉換器會傳回新的物件實例。</span><span class="sxs-lookup"><span data-stu-id="7fbca-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="7fbca-177">如果沒有<xref:System.ComponentModel.TypeConverter>, 則會嘗試直接轉換為屬性類型。</span><span class="sxs-lookup"><span data-stu-id="7fbca-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="7fbca-178">這個最終層級是 XAML 語言基本型別之間的剖析器原生值直接轉換, 或在列舉中檢查已命名常數的名稱 (剖析器接著會存取相符的值)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="7fbca-179">列舉屬性值</span><span class="sxs-lookup"><span data-stu-id="7fbca-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="7fbca-180">Xaml 中的列舉是由 XAML 剖析器在本質上進行處理, 而且您應該指定其中一個列舉的已命名常數的字串名稱, 來指定列舉的成員。</span><span class="sxs-lookup"><span data-stu-id="7fbca-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="7fbca-181">針對 nonflag 列舉值, 原生行為是處理屬性值的字串, 並將其解析為其中一個列舉值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="7fbca-182">您未在格式*列舉*中指定列舉。*值*, 如同您在程式碼中所做的一樣。</span><span class="sxs-lookup"><span data-stu-id="7fbca-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="7fbca-183">相反地, 您只指定*值*, 而*列舉*是由您所設定之屬性的型別推斷。</span><span class="sxs-lookup"><span data-stu-id="7fbca-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="7fbca-184">如果您在*列舉*中指定屬性, 則為。*值*形式, 將無法正確解析。</span><span class="sxs-lookup"><span data-stu-id="7fbca-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="7fbca-185">針對旗標型列舉, 行為是以<xref:System.Enum.Parse%2A?displayProperty=nameWithType>方法為基礎。</span><span class="sxs-lookup"><span data-stu-id="7fbca-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="7fbca-186">您可以使用逗號分隔每個值, 以指定旗標型列舉的多個值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="7fbca-187">不過, 您無法結合未旗標型的列舉值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="7fbca-188">例如, 您不能使用逗號語法來嘗試建立, 其<xref:System.Windows.Trigger>作用於 nonflag 列舉的多個條件:</span><span class="sxs-lookup"><span data-stu-id="7fbca-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="7fbca-189">在 WPF 中, 支援可在 XAML 中設定之屬性的旗標型列舉很罕見。</span><span class="sxs-lookup"><span data-stu-id="7fbca-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="7fbca-190">不過, 其中一個列舉是<xref:System.Windows.Media.StyleSimulations>。</span><span class="sxs-lookup"><span data-stu-id="7fbca-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="7fbca-191">例如, 您可以使用逗點分隔的旗標型屬性語法來修改<xref:System.Windows.Documents.Glyphs>類別備註中提供的範例;可能會`StyleSimulations = "BoldSimulation,ItalicSimulation"`變成。 `StyleSimulations = "BoldSimulation"`</span><span class="sxs-lookup"><span data-stu-id="7fbca-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="7fbca-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>是另一個可指定多個列舉值的屬性。</span><span class="sxs-lookup"><span data-stu-id="7fbca-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="7fbca-193">不過, 這個屬性剛好是特殊案例, 因為<xref:System.Windows.Input.ModifierKeys>列舉支援它自己的型別轉換器。</span><span class="sxs-lookup"><span data-stu-id="7fbca-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="7fbca-194">修飾詞的類型轉換子會使用加號 (+) 做為分隔符號, 而不是逗號 (,)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="7fbca-195">這項轉換支援更傳統的語法來表示 Microsoft Windows 程式設計中的主要組合, 例如 "Ctrl + Alt"。</span><span class="sxs-lookup"><span data-stu-id="7fbca-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="7fbca-196">屬性和事件成員名稱參考</span><span class="sxs-lookup"><span data-stu-id="7fbca-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="7fbca-197">當指定屬性時, 您可以參考任何屬性或事件, 該專案會以您為包含物件專案所具現化之 CLR 類型的成員形式存在。</span><span class="sxs-lookup"><span data-stu-id="7fbca-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="7fbca-198">或者, 您可以參考附加屬性或附加事件, 而不受包含物件元素的影響。</span><span class="sxs-lookup"><span data-stu-id="7fbca-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="7fbca-199">(後續章節將討論附加的屬性)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="7fbca-200">您也可以使用*typeName*, 從任何可透過預設命名空間存取的物件來命名任何事件。*事件*的部分限定名稱;此語法支援附加路由事件的處理常式, 其中處理常式是用來處理從子專案路由的事件, 但父項目在其 members 資料表中也不會有該事件。</span><span class="sxs-lookup"><span data-stu-id="7fbca-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="7fbca-201">此語法類似附加事件語法, 但此處的事件不是真正的附加事件。</span><span class="sxs-lookup"><span data-stu-id="7fbca-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="7fbca-202">相反地, 您會參考具有限定名稱的事件。</span><span class="sxs-lookup"><span data-stu-id="7fbca-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="7fbca-203">如需詳細資訊, 請參閱[路由事件總覽](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="7fbca-204">在某些情況下, 有時會提供屬性名稱做為屬性的值, 而不是屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="7fbca-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="7fbca-205">該屬性名稱也可以包含限定詞, 例如以 [類型名稱] 格式指定的屬性。*dependencyPropertyName*。</span><span class="sxs-lookup"><span data-stu-id="7fbca-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="7fbca-206">這種情況在 XAML 中撰寫樣式或範本時很常見。</span><span class="sxs-lookup"><span data-stu-id="7fbca-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="7fbca-207">當做屬性值提供之屬性名稱的處理規則會不同, 而且是由所設定的屬性類型或特定 WPF 子系統的行為所控制。</span><span class="sxs-lookup"><span data-stu-id="7fbca-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="7fbca-208">如需詳細資訊, 請參閱設定[樣式和範本](../controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-208">For details, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="7fbca-209">屬性名稱的另一個用法是當屬性值描述屬性屬性關聯性時。</span><span class="sxs-lookup"><span data-stu-id="7fbca-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="7fbca-210">這項功能是用於資料系結和分鏡腳本目標, 而且是由<xref:System.Windows.PropertyPath>類別和其類型轉換器所啟用。</span><span class="sxs-lookup"><span data-stu-id="7fbca-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="7fbca-211">如需查閱語義的更完整描述, 請參閱[PROPERTYPATH XAML 語法](propertypath-xaml-syntax.md)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="7fbca-212">屬性元素語法</span><span class="sxs-lookup"><span data-stu-id="7fbca-212">Property Element Syntax</span></span>  
 <span data-ttu-id="7fbca-213">*屬性專案語法*是分歧的語法, 與元素的基本 XML 語法規則有點類似。</span><span class="sxs-lookup"><span data-stu-id="7fbca-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="7fbca-214">在 XML 中, 屬性的值是一種實際的字串, 唯一可能的變化是使用的字串編碼格式。</span><span class="sxs-lookup"><span data-stu-id="7fbca-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="7fbca-215">在 XAML 中, 您可以將其他物件元素指派為屬性的值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="7fbca-216">此功能是由屬性元素語法所啟用。</span><span class="sxs-lookup"><span data-stu-id="7fbca-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="7fbca-217">屬性會使用*elementTypeName*中的開頭專案標記來指定, 而不是指定為元素標記中的屬性。*propertyName*形式, 屬性的值會在內指定, 然後屬性專案就會關閉。</span><span class="sxs-lookup"><span data-stu-id="7fbca-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="7fbca-218">具體而言, 語法是以左角括弧 (\<) 開頭, 後面緊接著屬性元素語法所包含之類別或結構的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="7fbca-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="7fbca-219">後面緊接著單一點 (.), 然後依屬性的名稱, 再接著右角括弧 (>)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="7fbca-220">如同屬性語法, 該屬性必須存在於所指定類型的宣告公用成員中。</span><span class="sxs-lookup"><span data-stu-id="7fbca-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="7fbca-221">要指派給屬性的值會包含在 property 元素中。</span><span class="sxs-lookup"><span data-stu-id="7fbca-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="7fbca-222">一般來說, 此值會指定為一或多個物件專案, 因為將物件指定為值, 就是屬性專案語法的目的是要處理的案例。</span><span class="sxs-lookup"><span data-stu-id="7fbca-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="7fbca-223">最後, 指定相同*elementTypeName*的對等結束標記。必須提供*propertyName*組合, 以適當的方式與其他專案標記進行嵌套和平衡。</span><span class="sxs-lookup"><span data-stu-id="7fbca-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="7fbca-224">例如, 下列是的<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性<xref:System.Windows.Controls.Button>的屬性專案語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="7fbca-225">如果指定的屬性類型是基本實數值型別 (例如<xref:System.String>) 或列舉 (其中已指定名稱), 則屬性專案中的值也可以指定為內部文字。</span><span class="sxs-lookup"><span data-stu-id="7fbca-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="7fbca-226">這兩種用法並不常見, 因為每個案例也都可以使用較簡單的屬性語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="7fbca-227">以字串填滿屬性專案的其中一個案例是針對不是 XAML 內容屬性, 但仍用於表示 UI 文字的屬性, 而特定的空白字元 (例如, 分行符號) 必須出現在該 UI 文字中。</span><span class="sxs-lookup"><span data-stu-id="7fbca-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="7fbca-228">屬性語法無法保留分行符號, 但屬性專案語法可以, 只要有效的空白字元保留作用 (如需詳細資料, 請參閱[XAML 中的空白字元處理](../../xaml-services/whitespace-processing-in-xaml.md))。</span><span class="sxs-lookup"><span data-stu-id="7fbca-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../xaml-services/whitespace-processing-in-xaml.md)).</span></span> <span data-ttu-id="7fbca-229">另一個情況是, 可以將[x:Uid](../../xaml-services/x-uid-directive.md)指示詞套用至 property 專案, 因此會將中的值標示為應該在 WPF 輸出 BAML 或其他技術中當地語系化的值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-229">Another scenario is so that [x:Uid Directive](../../xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="7fbca-230">屬性元素不會在 WPF 邏輯樹狀結構中表示。</span><span class="sxs-lookup"><span data-stu-id="7fbca-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="7fbca-231">Property 元素只是用來設定屬性的特定語法, 而且不是具有實例或物件支援的元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="7fbca-232">(如需邏輯樹狀概念的詳細資訊, 請參閱[WPF 中](trees-in-wpf.md)的樹狀結構)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="7fbca-233">對於支援屬性和屬性專案語法的屬性而言, 這兩個語法通常會有相同的結果, 但微妙差異 (例如空白字元處理) 可能會在語法上稍有不同。</span><span class="sxs-lookup"><span data-stu-id="7fbca-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="7fbca-234">集合語法</span><span class="sxs-lookup"><span data-stu-id="7fbca-234">Collection Syntax</span></span>  
 <span data-ttu-id="7fbca-235">XAML 規格需要 XAML 處理器執行, 以識別實值型別為集合的屬性。</span><span class="sxs-lookup"><span data-stu-id="7fbca-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="7fbca-236">.NET 中的一般 XAML 處理器執行是以 managed 程式碼和 CLR 為基礎, 而且它會透過下列其中一項來識別集合類型:</span><span class="sxs-lookup"><span data-stu-id="7fbca-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="7fbca-237">類型 implements <xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="7fbca-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="7fbca-238">類型 implements <xref:System.Collections.IDictionary>。</span><span class="sxs-lookup"><span data-stu-id="7fbca-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="7fbca-239">類型衍生自<xref:System.Array> (如需 XAML 中陣列的詳細資訊, 請參閱[x:Array 標記延伸](../../xaml-services/x-array-markup-extension.md))。</span><span class="sxs-lookup"><span data-stu-id="7fbca-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="7fbca-240">如果屬性的類型是集合, 則不需要在標記中將推斷的集合類型指定為 object 元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="7fbca-241">相反地, 要做為集合中專案的元素會指定為 property 元素的一或多個子項目。</span><span class="sxs-lookup"><span data-stu-id="7fbca-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="7fbca-242">每個這類專案會在載入時評估為物件, 並藉由呼叫`Add`隱含集合的方法來新增至集合。</span><span class="sxs-lookup"><span data-stu-id="7fbca-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="7fbca-243">例如, <xref:System.Windows.Style.Triggers%2A>的<xref:System.Windows.Style>屬性會採用特殊化的<xref:System.Collections.IList>集合型<xref:System.Windows.TriggerCollection>別, 它會執行。</span><span class="sxs-lookup"><span data-stu-id="7fbca-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="7fbca-244">不需要在標記中具現<xref:System.Windows.TriggerCollection>化物件元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="7fbca-245">相反地, 您會將一個<xref:System.Windows.Trigger>或多個專案指定`Style.Triggers`為 property 元素中<xref:System.Windows.Trigger>的元素, 其中 (或衍生類別) 是預期為強型別和隱含<xref:System.Windows.TriggerCollection>之專案類型的類型。</span><span class="sxs-lookup"><span data-stu-id="7fbca-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="7fbca-246">屬性可以是集合類型, 以及該類型和衍生類型的 XAML 內容屬性, 這會在本主題的下一節中討論。</span><span class="sxs-lookup"><span data-stu-id="7fbca-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="7fbca-247">隱含的集合元素會在邏輯樹狀結構標記法中建立成員, 即使它不會以專案形式出現在標記中。</span><span class="sxs-lookup"><span data-stu-id="7fbca-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="7fbca-248">通常, 父類型的函式會針對屬於其屬性之一的集合執行具現化, 而初始空集合會成為物件樹狀結構的一部分。</span><span class="sxs-lookup"><span data-stu-id="7fbca-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="7fbca-249">不支援泛型清單和字典介面<xref:System.Collections.Generic.IList%601> ( <xref:System.Collections.Generic.IDictionary%602>和) 進行集合偵測。</span><span class="sxs-lookup"><span data-stu-id="7fbca-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="7fbca-250">不過, <xref:System.Collections.Generic.List%601>您可以使用類別作為基類, 因為<xref:System.Collections.IList>它會直接執行, 或<xref:System.Collections.Generic.Dictionary%602>當做基類, 因為它會<xref:System.Collections.IDictionary>直接實作為。</span><span class="sxs-lookup"><span data-stu-id="7fbca-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="7fbca-251">在集合類型的 .NET 參考頁面中, XAML 語法區段偶爾會以隱含的集合語法的形式, 將此語法視為集合的 object 元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="7fbca-252">除了根項目之外, XAML 檔案中作為另一個專案之子專案的每個物件專案, 實際上都是一個專案, 也就是其父元素的隱含集合屬性的成員。, 或指定父元素之 XAML 上下文屬性值的元素 (即將在後續章節中討論 XAML 內容屬性)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="7fbca-253">換句話說, 在標記頁面中, 父元素和子專案的關聯性實際上是根目錄中的單一物件, 而根目錄底下的每個物件專案都是單一實例, 可提供父系的屬性值或一欄內的其中一個元素。observabledependencyobjectcollection 也是父系的集合型別屬性值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="7fbca-254">這個單一根目錄概念在 XML 中很常見, 而且通常會在載入 XAML (例如) <xref:System.Windows.Markup.XamlReader.Load%2A>的 api 行為中加強。</span><span class="sxs-lookup"><span data-stu-id="7fbca-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="7fbca-255">下列範例是明確指定集合 (<xref:System.Windows.Media.GradientStopCollection>) 之 object 元素的語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="7fbca-256">請注意, 不一定可以明確宣告集合。</span><span class="sxs-lookup"><span data-stu-id="7fbca-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="7fbca-257">例如, 嘗試<xref:System.Windows.TriggerCollection>在先前顯示<xref:System.Windows.Style.Triggers%2A>的範例中明確宣告會失敗。</span><span class="sxs-lookup"><span data-stu-id="7fbca-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="7fbca-258">明確宣告集合需要集合類別必須支援無參數的函式, 而且<xref:System.Windows.TriggerCollection>沒有無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="7fbca-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="7fbca-259">XAML 內容屬性</span><span class="sxs-lookup"><span data-stu-id="7fbca-259">XAML Content Properties</span></span>  
 <span data-ttu-id="7fbca-260">XAML 內容語法是一種語法, 只有在將<xref:System.Windows.Markup.ContentPropertyAttribute>指定為其類別宣告一部分的類別上才會啟用。</span><span class="sxs-lookup"><span data-stu-id="7fbca-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="7fbca-261">會<xref:System.Windows.Markup.ContentPropertyAttribute>參考屬於該元素類型 (包括衍生類別) 之內容屬性的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="7fbca-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="7fbca-262">由 XAML 處理器處理時, 在物件專案的開頭和結束記號之間找到的任何子專案或內部文字, 都會指派為該物件的 XAML 內容屬性值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="7fbca-263">您可以指定 content 屬性的明確屬性專案, 但這種用法通常不會顯示在 .NET 參考的 XAML 語法區段中。</span><span class="sxs-lookup"><span data-stu-id="7fbca-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="7fbca-264">明確/詳細的技巧偶爾會出現標記清晰度或標記樣式的值, 但是內容屬性的目的通常是為了簡化標記, 讓直覺相關的專案可以直接嵌套。</span><span class="sxs-lookup"><span data-stu-id="7fbca-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="7fbca-265">專案上其他屬性的屬性專案標記不會根據嚴格的 XAML 語言定義指派為「內容」;這些是先前在 XAML 剖析器的處理順序中處理, 而且不會被視為「內容」。</span><span class="sxs-lookup"><span data-stu-id="7fbca-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="7fbca-266">XAML 內容屬性值必須是連續的</span><span class="sxs-lookup"><span data-stu-id="7fbca-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="7fbca-267">XAML 內容屬性的值必須在該物件元素上的任何其他屬性專案之前或之後完整指定。</span><span class="sxs-lookup"><span data-stu-id="7fbca-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="7fbca-268">不論 XAML 內容屬性的值是指定為字串, 還是一或多個物件, 都是如此。</span><span class="sxs-lookup"><span data-stu-id="7fbca-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="7fbca-269">例如, 下列標記不會剖析:</span><span class="sxs-lookup"><span data-stu-id="7fbca-269">For example, the following markup does not parse:</span></span>  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="7fbca-270">基本上, 這是不合法的, 因為如果使用 content 屬性的屬性專案語法來明確設定此語法, 則會將 content 屬性設為兩次:</span><span class="sxs-lookup"><span data-stu-id="7fbca-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="7fbca-271">同樣不合法的範例是, 如果 content 屬性是一個集合, 而子項目與屬性專案交錯:</span><span class="sxs-lookup"><span data-stu-id="7fbca-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="7fbca-272">內容屬性和集合語法合併</span><span class="sxs-lookup"><span data-stu-id="7fbca-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="7fbca-273">為了接受一個以上的物件元素做為內容, content 屬性的類型必須特別是集合類型。</span><span class="sxs-lookup"><span data-stu-id="7fbca-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="7fbca-274">類似于集合類型的屬性元素語法, XAML 處理器必須識別屬於集合類型的類型。</span><span class="sxs-lookup"><span data-stu-id="7fbca-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="7fbca-275">如果專案具有 XAML 內容屬性, 而且 XAML 內容屬性的類型是集合, 則隱含的集合類型不需要在標記中指定為物件元素, 而且 XAML 內容屬性不需要指定為 el 屬性。& e).</span><span class="sxs-lookup"><span data-stu-id="7fbca-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="7fbca-276">因此, 標記中的明顯內容模型現在可以將一個以上的子項目指派為內容。</span><span class="sxs-lookup"><span data-stu-id="7fbca-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="7fbca-277">下列為<xref:System.Windows.Controls.Panel>衍生類別的內容語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="7fbca-278">所有<xref:System.Windows.Controls.Panel>衍生類別都會將<xref:System.Windows.Controls.Panel.Children%2A>XAML 內容屬性建立為, 這需要類型<xref:System.Windows.Controls.UIElementCollection>的值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="7fbca-279">請注意, 標記中不需要<xref:System.Windows.Controls.Panel.Children%2A>的屬性專案和的<xref:System.Windows.Controls.UIElementCollection>元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="7fbca-280">這是 XAML 的設計功能, 因此, 定義的[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]以遞迴方式包含的元素會以具有直接父子式專案關聯性的嵌套元素樹狀結構來表示, 而不會有中間的屬性專案標記或集合物件。</span><span class="sxs-lookup"><span data-stu-id="7fbca-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="7fbca-281">事實上, <xref:System.Windows.Controls.UIElementCollection>根據設計, 無法在標記中明確地指定為物件元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="7fbca-282">因為其僅適用于隱含集合, <xref:System.Windows.Controls.UIElementCollection>所以不會公開公用無參數的函式, 因此無法將它具現化為物件元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="7fbca-283">使用 Content 屬性來混合物件中的屬性元素和物件元素</span><span class="sxs-lookup"><span data-stu-id="7fbca-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="7fbca-284">XAML 規格宣告 XAML 處理器可以強制執行用來填入物件專案內 XAML 內容屬性的物件專案, 必須是連續的, 而且不能是混合的。</span><span class="sxs-lookup"><span data-stu-id="7fbca-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="7fbca-285">對混合屬性專案和內容的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]這項限制會由 XAML 處理器強制執行。</span><span class="sxs-lookup"><span data-stu-id="7fbca-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="7fbca-286">您可以將子物件元素做為物件元素中的第一個立即標記。</span><span class="sxs-lookup"><span data-stu-id="7fbca-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="7fbca-287">然後您可以引進屬性元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-287">Then you can introduce property elements.</span></span> <span data-ttu-id="7fbca-288">或者, 您可以指定一或多個屬性專案、[內容]、[其他] 屬性專案。</span><span class="sxs-lookup"><span data-stu-id="7fbca-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="7fbca-289">但是一旦屬性專案遵循內容, 您就無法再引進任何進一步的內容, 您只能加入屬性專案。</span><span class="sxs-lookup"><span data-stu-id="7fbca-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="7fbca-290">此內容/屬性專案順序需求不適用於作為內容的內部文字。</span><span class="sxs-lookup"><span data-stu-id="7fbca-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="7fbca-291">不過, 它仍然是讓內部文字保持連續的良好標記樣式, 因為如果屬性專案與內部文字交錯, 明顯的空白字元將難以在標記中以視覺方式偵測。</span><span class="sxs-lookup"><span data-stu-id="7fbca-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="7fbca-292">XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="7fbca-292">XAML Namespaces</span></span>  
 <span data-ttu-id="7fbca-293">上述語法範例都不會指定預設 XAML 命名空間以外的 XAML 命名空間。</span><span class="sxs-lookup"><span data-stu-id="7fbca-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="7fbca-294">在一般[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]應用程式中, 預設的 XAML 命名空間會指定[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]為命名空間。</span><span class="sxs-lookup"><span data-stu-id="7fbca-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="7fbca-295">除了預設的 XAML 命名空間以外, 您還可以指定 XAML 命名空間, 而且仍然會使用類似的語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="7fbca-296">但是, 在預設的 XAML 命名空間中無法存取名為的類別的任何地方, 該類別名稱前面必須加上 XAML 命名空間的前置詞, 以便對應至對應的 CLR 命名空間。</span><span class="sxs-lookup"><span data-stu-id="7fbca-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="7fbca-297">例如, `<custom:Example/>`是物件專案語法, 用來具現化`Example`類別的實例, 其中包含該類別的 CLR 命名空間 (可能是包含支援類型的外部元件資訊) 先前已對應至`custom`前置詞。</span><span class="sxs-lookup"><span data-stu-id="7fbca-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="7fbca-298">如需 XAML 命名空間的詳細資訊, 請參閱[WPF xaml 的 Xaml 命名空間和命名空間對應](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="7fbca-299">標記延伸</span><span class="sxs-lookup"><span data-stu-id="7fbca-299">Markup Extensions</span></span>  
 <span data-ttu-id="7fbca-300">XAML 會定義標記延伸程式設計實體, 讓您可以從標準的 XAML 處理器處理字串屬性值或物件專案, 並將處理延遲到支援類別。</span><span class="sxs-lookup"><span data-stu-id="7fbca-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="7fbca-301">使用屬性語法時, 識別 XAML 處理器之標記延伸的字元是左大括弧 ({), 後面接著右大括弧 (}) 以外的任何字元。</span><span class="sxs-lookup"><span data-stu-id="7fbca-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="7fbca-302">左大括弧後面的第一個字串必須參考提供特定延伸模組行為的類別, 如果該子字串是真正類別名稱的一部分, 參考可能會省略子字串 "Extension"。</span><span class="sxs-lookup"><span data-stu-id="7fbca-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="7fbca-303">之後, 就會出現一個空格, 然後將每個後續字元當做延伸模組實作為輸入使用, 直到遇到右大括弧為止。</span><span class="sxs-lookup"><span data-stu-id="7fbca-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="7fbca-304">.Net XAML 執行會使用<xref:System.Windows.Markup.MarkupExtension>抽象類別做為所有[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]支援之標記延伸的基礎, 以及其他架構或技術。</span><span class="sxs-lookup"><span data-stu-id="7fbca-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="7fbca-305">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]特別執行的標記延伸通常是用來提供參考其他現有物件的方法, 或對將在執行時間評估的物件進行延遲參考。</span><span class="sxs-lookup"><span data-stu-id="7fbca-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="7fbca-306">例如, 簡單的 WPF 資料系結是藉由指定`{Binding}`標記延伸來取代特定屬性通常會採用的值來完成。</span><span class="sxs-lookup"><span data-stu-id="7fbca-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="7fbca-307">許多 WPF 標記延伸都會啟用屬性的屬性語法, 在此情況下不可能發生屬性語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="7fbca-308">例如, <xref:System.Windows.Style>物件是相當複雜的類型, 其中包含一組嵌套的物件和屬性。</span><span class="sxs-lookup"><span data-stu-id="7fbca-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="7fbca-309">WPF 中的樣式通常會定義為中的資源<xref:System.Windows.ResourceDictionary>, 然後透過要求資源的兩個 WPF 標記延伸中的其中一個來參考。</span><span class="sxs-lookup"><span data-stu-id="7fbca-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="7fbca-310">標記延伸會將屬性值的評估延遲到資源查閱, 並在屬性語法中提供<xref:System.Windows.FrameworkElement.Style%2A>屬性的值 (採用類型<xref:System.Windows.Style>), 如下列範例所示:</span><span class="sxs-lookup"><span data-stu-id="7fbca-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="7fbca-311">在此`StaticResource` , 會<xref:System.Windows.StaticResourceExtension>識別提供標記延伸實作為的類別。</span><span class="sxs-lookup"><span data-stu-id="7fbca-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="7fbca-312">下一個字串`MyStyle`會當做非預設<xref:System.Windows.StaticResourceExtension>的函式的輸入使用, 其中從延伸模組字串取得的參數會宣告所要求<xref:System.Windows.ResourceKey>的。</span><span class="sxs-lookup"><span data-stu-id="7fbca-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="7fbca-313">`MyStyle`應該是<xref:System.Windows.Style>定義為資源之的[x:Key](../../xaml-services/x-key-directive.md)值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-313">`MyStyle` is expected to be the [x:Key](../../xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="7fbca-314">[StaticResource 標記延伸](staticresource-markup-extension.md)使用方式會要求資源用來在載入時透過<xref:System.Windows.Style>靜態資源查閱邏輯提供屬性值。</span><span class="sxs-lookup"><span data-stu-id="7fbca-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="7fbca-315">如需標記延伸的詳細資訊，請參閱[標記延伸和 WPF XAML](markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="7fbca-316">如需在一般 .net XAML 執行中啟用的標記延伸和其他 XAML 程式設計功能的參考[, 請參閱 XAML 命名空間 (x:)語言功能](../../xaml-services/xaml-namespace-x-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../xaml-services/xaml-namespace-x-language-features.md).</span></span> <span data-ttu-id="7fbca-317">如需 WPF 特定的標記延伸, 請參閱[WPF XAML 延伸](wpf-xaml-extensions.md)模組。</span><span class="sxs-lookup"><span data-stu-id="7fbca-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="7fbca-318">附加屬性</span><span class="sxs-lookup"><span data-stu-id="7fbca-318">Attached Properties</span></span>  
 <span data-ttu-id="7fbca-319">附加屬性是 XAML 中引進的程式設計概念, 其中的屬性可由特定類型所擁有和定義, 但設定為任何專案上的屬性或屬性專案。</span><span class="sxs-lookup"><span data-stu-id="7fbca-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="7fbca-320">附加屬性的主要案例是讓標記結構中的子專案向父項目報告資訊, 而不需要在所有專案上有廣泛的共用物件模型。</span><span class="sxs-lookup"><span data-stu-id="7fbca-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="7fbca-321">相反地, 父元素也可以使用附加屬性, 將資訊報告至子項目。</span><span class="sxs-lookup"><span data-stu-id="7fbca-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="7fbca-322">如需附加屬性的用途, 以及如何建立您自己的附加屬性的詳細資訊, 請參閱[附加屬性總覽](attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="7fbca-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="7fbca-323">附加屬性會使用表面上類似屬性專案語法的語法, 您也可以指定*typeName*。*propertyName*組合。</span><span class="sxs-lookup"><span data-stu-id="7fbca-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="7fbca-324">有兩個重大差異：</span><span class="sxs-lookup"><span data-stu-id="7fbca-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="7fbca-325">您可以使用*typeName*。*propertyName*組合, 即使是透過屬性語法設定附加屬性時也一樣。</span><span class="sxs-lookup"><span data-stu-id="7fbca-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="7fbca-326">附加屬性是限定屬性名稱是屬性語法需求的唯一案例。</span><span class="sxs-lookup"><span data-stu-id="7fbca-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="7fbca-327">您也可以使用附加屬性的屬性專案語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="7fbca-328">不過, 針對一般屬性專案語法, 您指定的*typeName*是包含 property 專案的 object 元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="7fbca-329">如果您要參考附加屬性, 則*typeName*是定義附加屬性的類別, 而不是包含的 object 元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="7fbca-330">附加事件</span><span class="sxs-lookup"><span data-stu-id="7fbca-330">Attached Events</span></span>  
 <span data-ttu-id="7fbca-331">附加事件是 XAML 中引進的另一種程式設計概念, 其中事件可以由特定類型定義, 但處理常式可以附加至任何物件元素。</span><span class="sxs-lookup"><span data-stu-id="7fbca-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="7fbca-332">在 WOF 的執行中, 定義附加事件的類型通常是定義服務的靜態類型, 有時這些附加事件是由公開服務之類型中的路由事件別名所公開。</span><span class="sxs-lookup"><span data-stu-id="7fbca-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="7fbca-333">附加事件的處理常式是透過屬性語法來指定。</span><span class="sxs-lookup"><span data-stu-id="7fbca-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="7fbca-334">如同附加事件, 已針對附加事件展開屬性語法以允許*typeName*。事件名稱的用法, 其中*typeName*是提供`Add`和 `Remove`附加事件基礎結構之事件處理常式存取子的類別, 而引發者則是事件名稱。</span><span class="sxs-lookup"><span data-stu-id="7fbca-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="7fbca-335">XAML 根項目的剖析</span><span class="sxs-lookup"><span data-stu-id="7fbca-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="7fbca-336">下表顯示一般 XAML 根項目的細分, 其中顯示根項目的特定屬性:</span><span class="sxs-lookup"><span data-stu-id="7fbca-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="7fbca-337">開啟根項目的 object 元素</span><span class="sxs-lookup"><span data-stu-id="7fbca-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="7fbca-338">預設 ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="7fbca-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="7fbca-339">XAML 語言 XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="7fbca-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="7fbca-340">將標記連接至為部分類別定義之任何程式碼後置的部分類別宣告</span><span class="sxs-lookup"><span data-stu-id="7fbca-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="7fbca-341">根之物件元素的結尾。</span><span class="sxs-lookup"><span data-stu-id="7fbca-341">End of object element for the root.</span></span> <span data-ttu-id="7fbca-342">物件尚未關閉, 因為元素包含子項目</span><span class="sxs-lookup"><span data-stu-id="7fbca-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="7fbca-343">選擇性和非建議 XAML 用法</span><span class="sxs-lookup"><span data-stu-id="7fbca-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="7fbca-344">下列各節描述 XAML 處理器在技術上支援的 XAML 用法, 但會產生詳細資訊或其他美觀問題, 當您開發包含 XAML 來源的應用程式時, 會干擾 XAML 檔案的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="7fbca-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="7fbca-345">選擇性的屬性元素使用方式</span><span class="sxs-lookup"><span data-stu-id="7fbca-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="7fbca-346">選擇性的屬性專案用法包括明確地寫出 XAML 處理器視為隱含的元素內容屬性。</span><span class="sxs-lookup"><span data-stu-id="7fbca-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="7fbca-347">例如, 當您宣告的內容<xref:System.Windows.Controls.Menu>時, 您可以選擇將的<xref:System.Windows.Controls.ItemsControl.Items%2A> <xref:System.Windows.Controls.MenuItem> <xref:System.Windows.Controls.Menu> `<Menu.Items>`集合明確宣告為屬性專案標記, 並將其放在內`<Menu.Items>`, 而非除了使用隱含 XAML 處理器行為, 所有的子<xref:System.Windows.Controls.Menu>專案都必須<xref:System.Windows.Controls.MenuItem>是<xref:System.Windows.Controls.ItemsControl.Items%2A> , 而且會放在集合中。</span><span class="sxs-lookup"><span data-stu-id="7fbca-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="7fbca-348">有時候選擇性的用法有助於以視覺化方式澄清標記中所表示的物件結構。</span><span class="sxs-lookup"><span data-stu-id="7fbca-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="7fbca-349">或有時明確的屬性專案使用方式可以避免在技術上功能上的標記, 但在視覺上令人困惑, 例如屬性值內的嵌套標記延伸。</span><span class="sxs-lookup"><span data-stu-id="7fbca-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="7fbca-350">完整 typeName。成員資格限定屬性</span><span class="sxs-lookup"><span data-stu-id="7fbca-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="7fbca-351">*TypeName*。屬性的*成員名稱*格式實際上比路由事件案例的運作方式更為普遍。</span><span class="sxs-lookup"><span data-stu-id="7fbca-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="7fbca-352">但在其他情況下, 表單是多餘的, 而且您應該避免這種情況, 因為這是因為標記樣式和可讀性的原因。</span><span class="sxs-lookup"><span data-stu-id="7fbca-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="7fbca-353">在下列範例中, <xref:System.Windows.Controls.Control.Background%2A>屬性的三個參考完全相同:</span><span class="sxs-lookup"><span data-stu-id="7fbca-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="7fbca-354">`Button.Background`適用的原因是, 上<xref:System.Windows.Controls.Button>該屬性的限定查閱成功 (<xref:System.Windows.Controls.Control.Background%2A>繼承自 Control), <xref:System.Windows.Controls.Button>而且是物件元素或基類的類別。</span><span class="sxs-lookup"><span data-stu-id="7fbca-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="7fbca-355">`Control.Background`適用于, <xref:System.Windows.Controls.Control>因為類別實際上<xref:System.Windows.Controls.Control.Background%2A>會<xref:System.Windows.Controls.Control>定義, <xref:System.Windows.Controls.Button>而是基類。</span><span class="sxs-lookup"><span data-stu-id="7fbca-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="7fbca-356">不過, 下列*類型名稱*為。*成員名稱*表單範例無法運作, 因此會顯示為批註:</span><span class="sxs-lookup"><span data-stu-id="7fbca-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="7fbca-357"><xref:System.Windows.Controls.Label>是的<xref:System.Windows.Controls.Control>另一個衍生類別, 而且如果您已`Label.Background`在<xref:System.Windows.Controls.Label>物件專案中指定, 則此使用方式會運作。</span><span class="sxs-lookup"><span data-stu-id="7fbca-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="7fbca-358">不過, 因為<xref:System.Windows.Controls.Label>不是的類別或基類<xref:System.Windows.Controls.Button>, 所以指定的 XAML 處理器行為會接著當做附加屬性`Label.Background`來處理。</span><span class="sxs-lookup"><span data-stu-id="7fbca-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="7fbca-359">`Label.Background`不是可用的附加屬性, 而且此使用方式失敗。</span><span class="sxs-lookup"><span data-stu-id="7fbca-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="7fbca-360">基. 成員名稱屬性元素</span><span class="sxs-lookup"><span data-stu-id="7fbca-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="7fbca-361">以類似的方式來使用*typeName*。*成員名稱*形式適用于屬性語法, 也就是*基*。*成員名稱*語法適用于屬性元素語法。</span><span class="sxs-lookup"><span data-stu-id="7fbca-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="7fbca-362">例如, 下列語法可運作:</span><span class="sxs-lookup"><span data-stu-id="7fbca-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="7fbca-363">在這裡, `Control.Background`即使屬性專案是包含在中`Button`, 還是會提供屬性專案。</span><span class="sxs-lookup"><span data-stu-id="7fbca-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="7fbca-364">但是就像*typeName*一樣。屬性的*成員名稱*形式,*基*。*成員名稱*在標記中的樣式不佳, 您應該避免這個情況。</span><span class="sxs-lookup"><span data-stu-id="7fbca-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7fbca-365">另請參閱</span><span class="sxs-lookup"><span data-stu-id="7fbca-365">See also</span></span>

- [<span data-ttu-id="7fbca-366">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="7fbca-366">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="7fbca-367">XAML 命名空間 (x:)語言功能</span><span class="sxs-lookup"><span data-stu-id="7fbca-367">XAML Namespace (x:) Language Features</span></span>](../../xaml-services/xaml-namespace-x-language-features.md)
- [<span data-ttu-id="7fbca-368">WPF XAML 延伸</span><span class="sxs-lookup"><span data-stu-id="7fbca-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="7fbca-369">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="7fbca-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="7fbca-370">TypeConverter 和 XAML</span><span class="sxs-lookup"><span data-stu-id="7fbca-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="7fbca-371">WPF 的 XAML 和自訂類別</span><span class="sxs-lookup"><span data-stu-id="7fbca-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
