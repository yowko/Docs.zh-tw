---
title: WPF XAML 名稱範圍
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: edf5c8a828bea182cd87542276fb7eb2df1908be
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/22/2019
ms.locfileid: "69917330"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="724ec-102">WPF XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="724ec-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="724ec-103">XAML 名稱範圍是識別 XAML 中所定義物件的概念。</span><span class="sxs-lookup"><span data-stu-id="724ec-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="724ec-104">XAML 名稱範圍中的名稱可以用來建立物件的 XAML 定義名稱與其在物件樹狀結構中的執行個體對等項目之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="724ec-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="724ec-105">一般而言，載入 XAML 應用程式的個別 XAML 頁面根時，會建立 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Managed 程式碼中的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="724ec-106">XAML 名稱範圍做為程式設計物件是由<xref:System.Windows.Markup.INameScope>介面所定義, 而且也會由實際<xref:System.Windows.NameScope>類別來執行。</span><span class="sxs-lookup"><span data-stu-id="724ec-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="724ec-107">所載入 XAML 應用程式中的名稱範圍</span><span class="sxs-lookup"><span data-stu-id="724ec-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="724ec-108">在更廣泛的程式設計或電腦科學內容中，程式設計概念通常包括可用來存取物件之唯一識別碼或名稱的原則。</span><span class="sxs-lookup"><span data-stu-id="724ec-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="724ec-109">針對使用識別碼或名稱的系統，在要求該名稱的物件時，名稱範圍會定義程序或技術將在其內搜尋的界限，或是在其中強制執行識別名稱唯一性的界限。</span><span class="sxs-lookup"><span data-stu-id="724ec-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="724ec-110">這些一般原則適用於 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="724ec-111">在 WPF 中，載入 XAML 頁面時，會在頁面的根項目上建立 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="724ec-112">在頁面根開始之 XAML 頁面內所指定的每個名稱都會新增至適當的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="724ec-113">在 WPF XAML 中, 屬於一般根項目 (例如<xref:System.Windows.Controls.Page>和<xref:System.Windows.Window>) 的元素一律會控制 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="724ec-114">如果專案 (例如<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement> ) 是標記中[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]頁面的根項目<xref:System.Windows.Controls.Page> , 則<xref:System.Windows.Controls.Page>處理器會隱含地新增根, 以便提供可運作的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="724ec-115">WPF 建置動作會針對 XAML 生產來建立 XAML 名稱範圍，即使未在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 標記的任何項目上定義 `Name` 或 `x:Name` 屬性也是一樣。</span><span class="sxs-lookup"><span data-stu-id="724ec-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="724ec-116">如果您嘗試在任何 XAML 名稱範圍中使用相同的名稱兩次，則會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="724ec-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="724ec-117">針對具有程式碼後置且為已編譯應用程式一部分的 WPF XAML，在初始標記編譯期間建立頁面的已產生類別時，WPF 建置動作會在建置期間引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="724ec-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="724ec-118">針對未透過任何建置動作進行標記編譯的 XAML，在載入 XAML 時，可能會引發 XAML 名稱範圍問題的相關例外狀況。</span><span class="sxs-lookup"><span data-stu-id="724ec-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="724ec-119">XAML 設計工具也可能預期會在設計階段發生 XAML 名稱範圍問題。</span><span class="sxs-lookup"><span data-stu-id="724ec-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="724ec-120">將物件新增至執行階段物件樹狀結構</span><span class="sxs-lookup"><span data-stu-id="724ec-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="724ec-121">剖析 XAML 的時間點代表建立和定義 WPF XAML 名稱範圍的時間點。</span><span class="sxs-lookup"><span data-stu-id="724ec-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="724ec-122">如果您在剖析已產生該樹狀結構的 XAML 之後的某個時間點，將物件新增至物件樹狀結構，則新物件上的 `Name` 或 `x:Name` 值不會自動更新 XAML 名稱範圍中的資訊。</span><span class="sxs-lookup"><span data-stu-id="724ec-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="724ec-123">若要在載入 xaml 之後, 將物件的名稱加入 WPF XAML 名稱範圍, 您必須<xref:System.Windows.Markup.INameScope.RegisterName%2A>在定義 xaml 名稱範圍的物件上呼叫適當的執行, 這通常是 xaml 頁面根目錄。</span><span class="sxs-lookup"><span data-stu-id="724ec-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="724ec-124">如果未註冊此名稱, 則無法透過方法 (例如<xref:System.Windows.FrameworkElement.FindName%2A>) 參考新增的物件, 而且您無法將該名稱用於動畫目標。</span><span class="sxs-lookup"><span data-stu-id="724ec-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="724ec-125">應用程式開發人員最常見的案例是, 您將<xref:System.Windows.FrameworkElement.RegisterName%2A>使用, 在頁面目前根目錄的 XAML 名稱範圍中註冊名稱。</span><span class="sxs-lookup"><span data-stu-id="724ec-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="724ec-126"><xref:System.Windows.FrameworkElement.RegisterName%2A>屬於以動畫物件為目標之分鏡腳本的重要案例。</span><span class="sxs-lookup"><span data-stu-id="724ec-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="724ec-127">如需詳細資訊，請參閱[分鏡腳本概觀](../graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="724ec-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="724ec-128">如果您呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>的物件不是定義 XAML 名稱範圍的物件, 則該名稱仍會註冊到呼叫物件所在的 xaml 名稱範圍內, 如同您在定義物件的 xaml 名稱<xref:System.Windows.FrameworkElement.RegisterName%2A>範圍中所呼叫。</span><span class="sxs-lookup"><span data-stu-id="724ec-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="724ec-129">程式碼中的 XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="724ec-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="724ec-130">您可以在程式碼中建立 XAML 名稱範圍後來加以使用。</span><span class="sxs-lookup"><span data-stu-id="724ec-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="724ec-131">甚至針對純程式碼用法，與 XAML 名稱範圍建立有關的 API 和概念也會相同，因為 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的 XAML 處理器在處理 XAML 本身時會使用這些 API 和概念。</span><span class="sxs-lookup"><span data-stu-id="724ec-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="724ec-132">概念和 API 的存在目的主要是可以依名稱在物件樹狀結構內找到物件，而物件樹狀結構一般是在 XAML 中部分或完整定義。</span><span class="sxs-lookup"><span data-stu-id="724ec-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="724ec-133">若為以程式設計方式建立, 而不是從載入的 xaml 建立的應用程式, 則定義<xref:System.Windows.Markup.INameScope>xaml 名稱範圍的<xref:System.Windows.FrameworkElement>物件<xref:System.Windows.FrameworkContentElement>必須實作為或衍生類別, 才能支援在其上建立 xaml 名稱範圍數.</span><span class="sxs-lookup"><span data-stu-id="724ec-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="724ec-134">此外，針對 XAML 處理器未載入和處理的任何項目，預設都不會建立或初始化物件的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="724ec-135">您必須針對任何您要註冊名稱的物件，明確建立新的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="724ec-136">若要建立 xaml 名稱範圍, 請呼叫靜態<xref:System.Windows.NameScope.SetNameScope%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="724ec-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="724ec-137">指定將擁有它做為`dependencyObject`參數的物件, 以及做`value`為參數<xref:System.Windows.NameScope.%23ctor%2A>的新的函式呼叫。</span><span class="sxs-lookup"><span data-stu-id="724ec-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="724ec-138">如果為 for <xref:System.Windows.NameScope.SetNameScope%2A>提供的`dependencyObject`物件不是<xref:System.Windows.Markup.INameScope>實作為, <xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>在任何<xref:System.Windows.FrameworkElement.RegisterName%2A>子專案上呼叫, 則不會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="724ec-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="724ec-139">如果您無法明確建立新的 XAML 名稱範圍, 則呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>將會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="724ec-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="724ec-140">如需在程式碼中使用 XAML 名稱範圍 API 的範例，請參閱[定義名稱範圍](../graphics-multimedia/how-to-define-a-name-scope.md)。</span><span class="sxs-lookup"><span data-stu-id="724ec-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="724ec-141">樣式和範本中的 XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="724ec-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="724ec-142">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的樣式和範本可以用更簡單的方式重複使用和重新套用內容。</span><span class="sxs-lookup"><span data-stu-id="724ec-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="724ec-143">不過，樣式和範本可能也包括具有範本層級所定義之 XAML 名稱的項目。</span><span class="sxs-lookup"><span data-stu-id="724ec-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="724ec-144">可能會在頁面中多次使用這個相同的範本。</span><span class="sxs-lookup"><span data-stu-id="724ec-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="724ec-145">因此，樣式和範本都會定義其專屬 XAML 名稱範圍，這與物件樹狀結構中套用樣式或範本的位置無關。</span><span class="sxs-lookup"><span data-stu-id="724ec-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="724ec-146">參考下列範例：</span><span class="sxs-lookup"><span data-stu-id="724ec-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="724ec-147">在這裡，相同的範本會套用至兩個不同的按鈕。</span><span class="sxs-lookup"><span data-stu-id="724ec-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="724ec-148">如果範本沒有離散 XAML 名稱範圍，則範本中所使用的 `TheBorder` 名稱會導致 XAML 名稱範圍中的名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="724ec-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="724ec-149">範本的每個具現化都有其專屬的 XAML 名稱範圍；因此，在此範例中，每個具現化範本的 XAML 名稱範圍都只會包含一個名稱。</span><span class="sxs-lookup"><span data-stu-id="724ec-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="724ec-150">樣式也會定義其專屬的 XAML 名稱範圍；因此，分鏡腳本的各部分一般可以獲指派特定名稱。</span><span class="sxs-lookup"><span data-stu-id="724ec-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="724ec-151">即使已在控制項自訂時重新定義範本，這些名稱還是可以啟用將目標設為該名稱之項目的控制項特定行為。</span><span class="sxs-lookup"><span data-stu-id="724ec-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="724ec-152">因為不同的 XAML 名稱範圍，所以在範本中尋找具名項目會比在頁面中尋找非範本具名項目更具挑戰。</span><span class="sxs-lookup"><span data-stu-id="724ec-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="724ec-153">您必須先取得<xref:System.Windows.Controls.Control.Template%2A>套用範本之控制項的屬性值, 來判斷已套用的範本。</span><span class="sxs-lookup"><span data-stu-id="724ec-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="724ec-154">然後, 呼叫的範本版本<xref:System.Windows.FrameworkTemplate.FindName%2A>, 並將套用範本的控制項傳遞為第二個參數。</span><span class="sxs-lookup"><span data-stu-id="724ec-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="724ec-155">如果您是控制項作者, 而且您正在產生慣例, 而所套用範本中的特定已命名專案是控制項本身所定義之行為的目標, 您可以從控制項執行程式碼<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>使用方法。</span><span class="sxs-lookup"><span data-stu-id="724ec-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="724ec-156"><xref:System.Windows.FrameworkElement.GetTemplateChild%2A>方法受到保護, 因此只有控制項作者可以存取它。</span><span class="sxs-lookup"><span data-stu-id="724ec-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="724ec-157">如果您是從範本內工作, 而且需要取得套用範本的 XAML 名稱範圍, 請取得的值<xref:System.Windows.FrameworkElement.TemplatedParent%2A>, 然後呼叫<xref:System.Windows.FrameworkElement.FindName%2A>該處。</span><span class="sxs-lookup"><span data-stu-id="724ec-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="724ec-158">在範本內運作的範例就是您要撰寫事件處理常式實作，其中，將從已套用範本中的項目引發事件。</span><span class="sxs-lookup"><span data-stu-id="724ec-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="724ec-159">XAML 名稱範圍和名稱相關 API</span><span class="sxs-lookup"><span data-stu-id="724ec-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="724ec-160"><xref:System.Windows.FrameworkElement>具有<xref:System.Windows.FrameworkElement.FindName%2A>、 <xref:System.Windows.FrameworkElement.RegisterName%2A> 和<xref:System.Windows.FrameworkElement.UnregisterName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="724ec-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="724ec-161">如果您在其上呼叫這些方法的物件擁有 XAML 名稱範圍，則方法會呼叫相關 XAML 名稱範圍的方法。</span><span class="sxs-lookup"><span data-stu-id="724ec-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="724ec-162">否則，會檢查父項目，確認它是否擁有 XAML 名稱範圍，而且此程序會遞迴地執行，直到找到 XAML 名稱範圍 (因為 XAML 處理器行為，所以根一定會有 XAML 名稱範圍)。</span><span class="sxs-lookup"><span data-stu-id="724ec-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="724ec-163"><xref:System.Windows.FrameworkContentElement>具有類似的行為, 但不會有<xref:System.Windows.FrameworkContentElement>任何例外狀況會擁有 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="724ec-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="724ec-164">方法存在於<xref:System.Windows.FrameworkContentElement> , 因此可以將呼叫最後轉送<xref:System.Windows.FrameworkElement>至父元素。</span><span class="sxs-lookup"><span data-stu-id="724ec-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="724ec-165"><xref:System.Windows.NameScope.SetNameScope%2A>用來將新的 XAML 名稱範圍對應至現有的物件。</span><span class="sxs-lookup"><span data-stu-id="724ec-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="724ec-166">您可以呼叫<xref:System.Windows.NameScope.SetNameScope%2A>多次, 以便重設或清除 XAML 名稱範圍, 但這不是常見的用法。</span><span class="sxs-lookup"><span data-stu-id="724ec-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="724ec-167">此外, <xref:System.Windows.NameScope.GetNameScope%2A>通常不會從程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="724ec-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="724ec-168">XAML 名稱範圍實作</span><span class="sxs-lookup"><span data-stu-id="724ec-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="724ec-169">下列類別會直接<xref:System.Windows.Markup.INameScope>執行:</span><span class="sxs-lookup"><span data-stu-id="724ec-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="724ec-170"><xref:System.Windows.ResourceDictionary>不使用 XAML 名稱或名稱範圍;它會改為使用索引鍵, 因為它是字典的執行。</span><span class="sxs-lookup"><span data-stu-id="724ec-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="724ec-171">唯一的<xref:System.Windows.ResourceDictionary> <xref:System.Windows.Markup.INameScope>理由是, 它可以引發使用者程式碼的例外狀況, 協助您清楚瞭解真正的<xref:System.Windows.ResourceDictionary> XAML 名稱範圍與如何處理索引鍵, 同時確保 xaml 名稱範圍不會套用至<xref:System.Windows.ResourceDictionary> by 父元素。</span><span class="sxs-lookup"><span data-stu-id="724ec-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="724ec-172"><xref:System.Windows.FrameworkTemplate>和<xref:System.Windows.Style>會<xref:System.Windows.Markup.INameScope>透過明確的介面定義來執行。</span><span class="sxs-lookup"><span data-stu-id="724ec-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="724ec-173">當透過<xref:System.Windows.Markup.INameScope>介面存取 xaml 名稱範圍時, 明確的執行會允許這些 xaml 名稱範圍的行為, 這就是由內部[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]進程來傳達 XAML 名稱範圍的方式。</span><span class="sxs-lookup"><span data-stu-id="724ec-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="724ec-174">但明確的介面定義不是<xref:System.Windows.FrameworkTemplate>和<xref:System.Windows.Style>之傳統 API 表面的一部分, 因為您很<xref:System.Windows.Markup.INameScope>少需要直接在和<xref:System.Windows.Style>上<xref:System.Windows.FrameworkTemplate>呼叫方法, 而是使用其他 API<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>例如。</span><span class="sxs-lookup"><span data-stu-id="724ec-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="724ec-175">下列類別定義自己的 xaml 名稱範圍, 方法是使用<xref:System.Windows.NameScope?displayProperty=nameWithType> helper 類別, 並<xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType>透過附加屬性連接到它的 xaml 名稱範圍執行:</span><span class="sxs-lookup"><span data-stu-id="724ec-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="724ec-176">另請參閱</span><span class="sxs-lookup"><span data-stu-id="724ec-176">See also</span></span>

- [<span data-ttu-id="724ec-177">WPF XAML 的 XAML 命名空間和命名空間對應</span><span class="sxs-lookup"><span data-stu-id="724ec-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="724ec-178">x:Name 指示詞</span><span class="sxs-lookup"><span data-stu-id="724ec-178">x:Name Directive</span></span>](../../xaml-services/x-name-directive.md)
