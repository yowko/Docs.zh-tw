---
title: WPF 中的程式碼後置和 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], code-behind
- code-behind files [WPF], XAML
ms.assetid: 9df6d3c9-aed3-471c-af36-6859b19d999f
ms.openlocfilehash: acd8c9ff0a4ff718dba272958a3e63820bcf1354
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/23/2019
ms.locfileid: "68401616"
---
# <a name="code-behind-and-xaml-in-wpf"></a><span data-ttu-id="ceb8e-102">WPF 中的程式碼後置和 XAML</span><span class="sxs-lookup"><span data-stu-id="ceb8e-102">Code-Behind and XAML in WPF</span></span>
<a name="introduction"></a><span data-ttu-id="ceb8e-103">程式碼後置是一個詞彙, 用來描述當[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]頁面標記編譯時, 與標記定義的物件聯結的程式碼。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-103">Code-behind is a term used to describe the code that is joined with markup-defined objects, when a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] page is markup-compiled.</span></span> <span data-ttu-id="ceb8e-104">本主題描述程式碼後置的需求, 以及中[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]程式碼的替代內嵌程式碼機制。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-104">This topic describes requirements for code-behind as well as an alternative inline code mechanism for code in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="ceb8e-105">本主題包含下列幾節：</span><span class="sxs-lookup"><span data-stu-id="ceb8e-105">This topic contains the following sections:</span></span>  
  
- [<span data-ttu-id="ceb8e-106">必要條件</span><span class="sxs-lookup"><span data-stu-id="ceb8e-106">Prerequisites</span></span>](#Prerequisites)  
  
- [<span data-ttu-id="ceb8e-107">程式碼後置和 XAML 語言</span><span class="sxs-lookup"><span data-stu-id="ceb8e-107">Code-Behind and the XAML Language</span></span>](#codebehind_and_the_xaml_language)  
  
- [<span data-ttu-id="ceb8e-108">WPF 中的程式碼後置、事件處理常式和部分類別需求</span><span class="sxs-lookup"><span data-stu-id="ceb8e-108">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>](#Code_behind__Event_Handler__and_Partial_Class)  
  
- [<span data-ttu-id="ceb8e-109">x:Code</span><span class="sxs-lookup"><span data-stu-id="ceb8e-109">x:Code</span></span>](#x_Code)  
  
- [<span data-ttu-id="ceb8e-110">內嵌程式碼限制</span><span class="sxs-lookup"><span data-stu-id="ceb8e-110">Inline Code Limitations</span></span>](#Inline_Code_Limitations)  
  
<a name="Prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="ceb8e-111">必要條件</span><span class="sxs-lookup"><span data-stu-id="ceb8e-111">Prerequisites</span></span>  
 <span data-ttu-id="ceb8e-112">本主題假設您已閱讀[XAML 總覽 (WPF)](xaml-overview-wpf.md) , 並有一些 CLR 和麵向物件程式設計的基本知識。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-112">This topic assumes that you have read the [XAML Overview (WPF)](xaml-overview-wpf.md) and have some basic knowledge of the CLR and object-oriented programming.</span></span>  
  
<a name="codebehind_and_the_xaml_language"></a>   
## <a name="code-behind-and-the-xaml-language"></a><span data-ttu-id="ceb8e-113">程式碼後置和 XAML 語言</span><span class="sxs-lookup"><span data-stu-id="ceb8e-113">Code-Behind and the XAML Language</span></span>  
 <span data-ttu-id="ceb8e-114">XAML 語言包含語言層級功能, 可讓程式碼檔案與標記檔案建立關聯, 從標記檔案端。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-114">The XAML language includes language-level features that make it possible to associate code files with markup files, from the markup file side.</span></span> <span data-ttu-id="ceb8e-115">具體而言, XAML 語言會定義語言功能[x:Class](../../xaml-services/x-class-directive.md)指示詞、 [x:Subclass](../../xaml-services/x-subclass-directive.md)指示詞和[x:ClassModifier](../../xaml-services/x-classmodifier-directive.md)指示詞。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-115">Specifically, the XAML language defines the language features [x:Class Directive](../../xaml-services/x-class-directive.md), [x:Subclass Directive](../../xaml-services/x-subclass-directive.md), and [x:ClassModifier Directive](../../xaml-services/x-classmodifier-directive.md).</span></span> <span data-ttu-id="ceb8e-116">確切的程式碼的產生方式, 以及如何整合標記和程式碼, 不是 XAML 語言所指定的部分。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-116">Exactly how the code should be produced, and how to integrate markup and code, is not part of what the XAML language specifies.</span></span> <span data-ttu-id="ceb8e-117">它會留給 WPF 這類架構, 以決定如何整合程式碼、如何在應用程式和程式設計模型中使用 XAML, 以及所需的組建動作或其他支援。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-117">It is left up to frameworks such as WPF to determine how to integrate the code, how to use XAML in the application and programming models, and the build actions or other support that all this requires.</span></span>  
  
<a name="Code_behind__Event_Handler__and_Partial_Class"></a>   
## <a name="code-behind-event-handler-and-partial-class-requirements-in-wpf"></a><span data-ttu-id="ceb8e-118">WPF 中的程式碼後置、事件處理常式和部分類別需求</span><span class="sxs-lookup"><span data-stu-id="ceb8e-118">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>  
  
- <span data-ttu-id="ceb8e-119">部分類別必須衍生自支援根項目的類型。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-119">The partial class must derive from the type that backs the root element.</span></span>  
  
- <span data-ttu-id="ceb8e-120">請注意, 在 [標記編譯組建] 動作的預設行為之下, 您可以在程式碼後置的部分類別定義中, 保留空白的衍生。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-120">Note that under the default behavior of the markup compile build actions, you can leave the derivation blank in the partial class definition on the code-behind side.</span></span> <span data-ttu-id="ceb8e-121">編譯的結果會假設頁面根目錄的支援類型是部分類別的基礎, 即使未指定, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-121">The compiled result will assume the page root's backing type to be the basis for the partial class, even if it not specified.</span></span> <span data-ttu-id="ceb8e-122">不過, 依賴此行為並不是最佳作法。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-122">However, relying on this behavior is not a best practice.</span></span>  
  
- <span data-ttu-id="ceb8e-123">您在程式碼後置中撰寫的事件處理常式必須是實例方法, 而且不能是靜態方法。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-123">The event handlers you write in the code-behind must be instance methods and cannot be static methods.</span></span> <span data-ttu-id="ceb8e-124">這些方法必須由所識別`x:Class`之 CLR 命名空間內的部分類別來定義。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-124">These methods must be defined by the partial class within the CLR namespace identified by `x:Class`.</span></span> <span data-ttu-id="ceb8e-125">您無法限定事件處理常式的名稱, 以指示[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]處理器在不同的類別範圍中尋找事件連接的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-125">You cannot qualify the name of an event handler to instruct a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor to look for an event handler for event wiring in a different class scope.</span></span>  
  
- <span data-ttu-id="ceb8e-126">處理常式必須符合支援型別系統中適當事件的委派。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-126">The handler must match the delegate for the appropriate event in the backing type system.</span></span>  
  
- <span data-ttu-id="ceb8e-127">特別針對 Microsoft Visual Basic 語言, 您可以使用特定`Handles`語言的關鍵字, 將處理常式與處理常式宣告中的實例和事件產生關聯, 而不是在中[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]附加具有屬性的處理常式。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-127">For the Microsoft Visual Basic language specifically, you can use the language-specific `Handles` keyword to associate handlers with instances and events in the handler declaration, instead of attaching handlers with attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="ceb8e-128">不過, 這項技術的確有一些限制, `Handles`因為關鍵字無法支援[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]事件系統的所有特定功能, 例如特定的路由事件案例或附加事件。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-128">However, this technique does have some limitations because the `Handles` keyword cannot support all of the specific features of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system, such as certain routed event scenarios or attached events.</span></span> <span data-ttu-id="ceb8e-129">如需詳細資訊, 請參閱[Visual Basic 和 WPF 事件處理](visual-basic-and-wpf-event-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-129">For details, see [Visual Basic and WPF Event Handling](visual-basic-and-wpf-event-handling.md).</span></span>  
  
<a name="x_Code"></a>   
## <a name="xcode"></a><span data-ttu-id="ceb8e-130">x:Code</span><span class="sxs-lookup"><span data-stu-id="ceb8e-130">x:Code</span></span>  
 <span data-ttu-id="ceb8e-131">[x:Code](../../xaml-services/x-code-intrinsic-xaml-type.md)是在中[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]定義的指示詞元素。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-131">[x:Code](../../xaml-services/x-code-intrinsic-xaml-type.md) is a directive element defined in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="ceb8e-132">`x:Code`指示詞元素可以包含內嵌程式設計程式碼。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-132">An `x:Code` directive element can contain inline programming code.</span></span> <span data-ttu-id="ceb8e-133">以內嵌方式定義的程式碼可以與相同[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]頁面上的互動。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-133">The code that is defined inline can interact with the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] on the same page.</span></span> <span data-ttu-id="ceb8e-134">下列範例說明內嵌C#程式碼。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-134">The following example illustrates inline C# code.</span></span> <span data-ttu-id="ceb8e-135">請注意, 此程式碼位於`x:Code`元素內, 而且程式碼必須`<CDATA[`括在 .。。[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]若要對的內容進行轉義, 讓處理器 (解讀架構或架構) 不會嘗試將內容以字面方式解讀為[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]。 `]]>`</span><span class="sxs-lookup"><span data-stu-id="ceb8e-135">Notice that the code is inside the `x:Code` element and that the code must be surrounded by `<CDATA[`...`]]>` to escape the contents for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)], so that a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor (interpreting either the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] schema or the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] schema) will not try to interpret the contents literally as [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)].</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ButtonWithInlineCode](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page4.xaml#buttonwithinlinecode)]  
  
<a name="Inline_Code_Limitations"></a>   
## <a name="inline-code-limitations"></a><span data-ttu-id="ceb8e-136">內嵌程式碼限制</span><span class="sxs-lookup"><span data-stu-id="ceb8e-136">Inline Code Limitations</span></span>  
 <span data-ttu-id="ceb8e-137">您應該考慮避免或限制使用內嵌程式碼。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-137">You should consider avoiding or limiting the use of inline code.</span></span> <span data-ttu-id="ceb8e-138">就架構和編碼原理而言, 維護標記和程式碼後置之間的分隔可讓設計工具和開發人員角色更為獨特。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-138">In terms of architecture and coding philosophy, maintaining a separation between markup and code-behind keeps the designer and developer roles much more distinct.</span></span> <span data-ttu-id="ceb8e-139">在更技術性的層級上, 您針對內嵌程式碼撰寫的程式碼可能很難撰寫, 因為您一律會寫入[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]產生的部分類別, 而且只能使用預設的 XML 命名空間對應。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-139">On a more technical level, the code that you write for inline code can be awkward to write, because you are always writing into the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] generated partial class, and can only use the default XML namespace mappings.</span></span> <span data-ttu-id="ceb8e-140">因為您無法加入`using`語句, 所以您必須完全符合您所做的許多 API 呼叫。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-140">Because you cannot add `using` statements, you must fully qualify many of the API calls that you make.</span></span> <span data-ttu-id="ceb8e-141">預設[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]對應包括[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]元件中所存在的大部分 CLR 命名空間, 而非全部, 而您必須完整限定對包含在其他 clr 命名空間中的類型和成員的呼叫。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-141">The default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] mappings include most but not all CLR namespaces that are present in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] assemblies; you will have to fully qualify calls to types and members contained within the other CLR namespaces.</span></span> <span data-ttu-id="ceb8e-142">您也不能在內嵌程式碼中定義部分類別以外的任何專案, 而且您參考的所有使用者程式碼實體都必須以成員或變數的形式存在於所產生的部分類別內。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-142">You also cannot define anything beyond the partial class in the inline code, and all user code entities you reference must exist as a member or variable within the generated partial class.</span></span> <span data-ttu-id="ceb8e-143">其他語言特定的程式設計功能, 例如宏`#ifdef`或針對全域變數或組建變數, 也無法使用。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-143">Other language specific programming features, such as macros or `#ifdef` against global variables or build variables, are also not available.</span></span> <span data-ttu-id="ceb8e-144">如需詳細資訊, 請參閱 X:Code 內建[XAML 類型](../../xaml-services/x-code-intrinsic-xaml-type.md)。</span><span class="sxs-lookup"><span data-stu-id="ceb8e-144">For more information, see [x:Code Intrinsic XAML Type](../../xaml-services/x-code-intrinsic-xaml-type.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ceb8e-145">另請參閱</span><span class="sxs-lookup"><span data-stu-id="ceb8e-145">See also</span></span>

- [<span data-ttu-id="ceb8e-146">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="ceb8e-146">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="ceb8e-147">x:Code 內建 XAML 類型</span><span class="sxs-lookup"><span data-stu-id="ceb8e-147">x:Code Intrinsic XAML Type</span></span>](../../xaml-services/x-code-intrinsic-xaml-type.md)
- [<span data-ttu-id="ceb8e-148">建置 WPF 應用程式</span><span class="sxs-lookup"><span data-stu-id="ceb8e-148">Building a WPF Application</span></span>](../app-development/building-a-wpf-application-wpf.md)
- [<span data-ttu-id="ceb8e-149">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="ceb8e-149">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
