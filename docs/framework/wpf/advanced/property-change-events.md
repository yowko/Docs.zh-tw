---
title: 屬性變更事件
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], change events
- property value changes [WPF]
- change events [WPF], property
- events [WPF], change in property values
- creating property triggers [WPF]
- property change events [WPF], types of
- property change events [WPF]
- property triggers [WPF]
- identifying changed property events [WPF]
- property triggers [WPF], definition of
ms.assetid: 0a7989df-9674-4cc1-bc50-5d8ef5d9c055
ms.openlocfilehash: f8d0d5e65101ffda0edaaeabdea2870287ba0f1f
ms.sourcegitcommit: 24a4a8eb6d8cfe7b8549fb6d823076d7c697e0c6
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/23/2019
ms.locfileid: "68400849"
---
# <a name="property-change-events"></a><span data-ttu-id="e50a3-102">屬性變更事件</span><span class="sxs-lookup"><span data-stu-id="e50a3-102">Property Change Events</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="e50a3-103">會定義數個要引發來回應屬性值變更的事件。</span><span class="sxs-lookup"><span data-stu-id="e50a3-103">defines several events that are raised in response to a change in the value of a property.</span></span> <span data-ttu-id="e50a3-104">屬性通常是相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="e50a3-104">Often the property is a dependency property.</span></span> <span data-ttu-id="e50a3-105">事件本身有時是路由事件, 有時是標準的 common language runtime (CLR) 事件。</span><span class="sxs-lookup"><span data-stu-id="e50a3-105">The event itself is sometimes a routed event and is sometimes a standard common language runtime (CLR) event.</span></span> <span data-ttu-id="e50a3-106">事件的定義會因案例而異，因為某些屬性變更較適合透過元素樹狀結構進行路由傳送，而其他屬性變更通常只會與變更屬性的物件有關。</span><span class="sxs-lookup"><span data-stu-id="e50a3-106">The definition of the event varies depending on the scenario, because some property changes are more appropriately routed through an element tree, whereas other property changes are generally only of concern to the object where the property changed.</span></span>  
  
## <a name="identifying-a-property-change-event"></a><span data-ttu-id="e50a3-107">識別屬性變更事件</span><span class="sxs-lookup"><span data-stu-id="e50a3-107">Identifying a Property Change Event</span></span>  
 <span data-ttu-id="e50a3-108">並非所有報告屬性變更的事件都會明確識別為屬性已變更的事件，不論是透過簽章模式或命名模式。</span><span class="sxs-lookup"><span data-stu-id="e50a3-108">Not all events that report a property change are explicitly identified as a property changed event, either by virtue of a signature pattern or a naming pattern.</span></span> <span data-ttu-id="e50a3-109">一般而言，[!INCLUDE[TLA#tla_sdk](../../../../includes/tlasharptla-sdk-md.md)] 文件中的事件描述會指出事件是否直接繫結至屬性值變更，並提供屬性與事件之間的交互參考。</span><span class="sxs-lookup"><span data-stu-id="e50a3-109">Generally, the description of the event in the [!INCLUDE[TLA#tla_sdk](../../../../includes/tlasharptla-sdk-md.md)] documentation indicates whether the event is directly tied to a property value change and provides cross-references between the property and event.</span></span>  
  
### <a name="routedpropertychanged-events"></a><span data-ttu-id="e50a3-110">RoutedPropertyChanged 事件</span><span class="sxs-lookup"><span data-stu-id="e50a3-110">RoutedPropertyChanged Events</span></span>  
 <span data-ttu-id="e50a3-111">某些事件會使用明確用於屬性變更事件的事件資料類型和委派。</span><span class="sxs-lookup"><span data-stu-id="e50a3-111">Certain events use an event data type and delegate that are explicitly used for property change events.</span></span> <span data-ttu-id="e50a3-112">事件資料類型為<xref:System.Windows.RoutedPropertyChangedEventArgs%601>, 而委派為。 <xref:System.Windows.RoutedPropertyChangedEventHandler%601></span><span class="sxs-lookup"><span data-stu-id="e50a3-112">The event data type is <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, and the delegate is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>.</span></span> <span data-ttu-id="e50a3-113">事件資料和委派兩者都有一個泛型類型參數，可在您定義處理常式時，指定變更屬性的實際類型。</span><span class="sxs-lookup"><span data-stu-id="e50a3-113">The event data and delegate both have a generic type parameter that is used to specify the actual type of the changing property when you define the handler.</span></span> <span data-ttu-id="e50a3-114">事件資料包含兩個屬性<xref:System.Windows.RoutedPropertyChangedEventArgs%601.OldValue%2A> : <xref:System.Windows.RoutedPropertyChangedEventArgs%601.NewValue%2A>和, 它們接著會當做事件資料中的型別引數傳遞。</span><span class="sxs-lookup"><span data-stu-id="e50a3-114">The event data contains two properties, <xref:System.Windows.RoutedPropertyChangedEventArgs%601.OldValue%2A> and <xref:System.Windows.RoutedPropertyChangedEventArgs%601.NewValue%2A>, which are both then passed as the type argument in the event data.</span></span>  
  
 <span data-ttu-id="e50a3-115">名稱中 "Routed" 的部分表示已將屬性已變更的事件註冊為路由事件。</span><span class="sxs-lookup"><span data-stu-id="e50a3-115">The "Routed" part of the name indicates that the property changed event is registered as a routed event.</span></span> <span data-ttu-id="e50a3-116">路由傳送屬性已變更事件的優點是，如果子元素 (控制項的複合組件) 上的屬性會變更值，控制項的最上層就可以接收屬性已變更的事件。</span><span class="sxs-lookup"><span data-stu-id="e50a3-116">The advantage of routing a property changed event is that the top level of a control can receive property changed events if properties on the child elements (the control's composite parts) change values.</span></span> <span data-ttu-id="e50a3-117">例如, 您可以建立一個包含<xref:System.Windows.Controls.Primitives.RangeBase>控制項 (例如<xref:System.Windows.Controls.Slider>) 的控制項。</span><span class="sxs-lookup"><span data-stu-id="e50a3-117">For instance, you might create a control that incorporates a <xref:System.Windows.Controls.Primitives.RangeBase> control such as a <xref:System.Windows.Controls.Slider>.</span></span> <span data-ttu-id="e50a3-118">如果<xref:System.Windows.Controls.Primitives.RangeBase.Value%2A>屬性的值在滑杆元件上變更, 您可能會想要在父控制項上處理該變更, 而不是在元件上。</span><span class="sxs-lookup"><span data-stu-id="e50a3-118">If the value of the <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> property changes on the slider part, you might want to handle that change on the parent control rather than on the part.</span></span>  
  
 <span data-ttu-id="e50a3-119">由於您有舊值與新值，因此，您可能想要使用此事件處理常式做為屬性值的驗證程式。</span><span class="sxs-lookup"><span data-stu-id="e50a3-119">Because you have an old value and a new value, it might be tempting to use this event handler as a validator for the property value.</span></span> <span data-ttu-id="e50a3-120">不過，大多數屬性已變更事件的設計意圖並不在此。</span><span class="sxs-lookup"><span data-stu-id="e50a3-120">However, that is not the design intention of most property changed events.</span></span> <span data-ttu-id="e50a3-121">一般來說，之所以提供值，是要讓您在程式碼的其他邏輯區域對那些值執行動作，但不建議在事件處理常式內實際變更值，而且根據處理常式的實作方式而定，這可能會導致意外遞迴。</span><span class="sxs-lookup"><span data-stu-id="e50a3-121">Generally, the values are provided so that you can act on those values in other logic areas of your code, but actually changing the values from within the event handler is not advisable, and may cause unintentional recursion depending on how your handler is implemented.</span></span>  
  
 <span data-ttu-id="e50a3-122">如果您的屬性是自訂相依性屬性, 或如果您正在使用已定義具現化程式碼的衍生類別, 則會有更好的機制來追蹤[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]屬性系統內建的屬性變更:屬性系統回呼<xref:System.Windows.CoerceValueCallback>和<xref:System.Windows.PropertyChangedCallback>。</span><span class="sxs-lookup"><span data-stu-id="e50a3-122">If your property is a custom dependency property, or if you are working with a derived class where you have defined the instantiation code, there is a much better mechanism for tracking property changes that is built in to the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system: the property system callbacks <xref:System.Windows.CoerceValueCallback> and <xref:System.Windows.PropertyChangedCallback>.</span></span> <span data-ttu-id="e50a3-123">如需您如何使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 屬性系統進行驗證和強制型轉的詳細資訊，請參閱[相依性屬性回呼和驗證](dependency-property-callbacks-and-validation.md)及[自訂相依性屬性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="e50a3-123">For more details about how you can use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system for validation and coercion, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md) and [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
### <a name="dependencypropertychanged-events"></a><span data-ttu-id="e50a3-124">DependencyPropertyChanged 事件</span><span class="sxs-lookup"><span data-stu-id="e50a3-124">DependencyPropertyChanged Events</span></span>  
 <span data-ttu-id="e50a3-125">另一對屬於屬性已變更事件案例的類型是<xref:System.Windows.DependencyPropertyChangedEventArgs>和。 <xref:System.Windows.DependencyPropertyChangedEventHandler></span><span class="sxs-lookup"><span data-stu-id="e50a3-125">Another pair of types that are part of a property changed event scenario is <xref:System.Windows.DependencyPropertyChangedEventArgs> and <xref:System.Windows.DependencyPropertyChangedEventHandler>.</span></span> <span data-ttu-id="e50a3-126">這些屬性變更的事件不會路由傳送;它們是標準的 CLR 事件。</span><span class="sxs-lookup"><span data-stu-id="e50a3-126">Events for these property changes are not routed; they are standard CLR events.</span></span> <span data-ttu-id="e50a3-127"><xref:System.Windows.DependencyPropertyChangedEventArgs>是不尋常的事件資料包告類型, 因為它不是<xref:System.EventArgs>衍生自;<xref:System.Windows.DependencyPropertyChangedEventArgs>是結構, 而不是類別。</span><span class="sxs-lookup"><span data-stu-id="e50a3-127"><xref:System.Windows.DependencyPropertyChangedEventArgs> is an unusual event data reporting type because it does not derive from <xref:System.EventArgs>; <xref:System.Windows.DependencyPropertyChangedEventArgs> is a structure, not a class.</span></span>  
  
 <span data-ttu-id="e50a3-128">使用<xref:System.Windows.DependencyPropertyChangedEventArgs> `RoutedPropertyChanged`和<xref:System.Windows.DependencyPropertyChangedEventHandler>的事件比事件稍微常見。</span><span class="sxs-lookup"><span data-stu-id="e50a3-128">Events that use <xref:System.Windows.DependencyPropertyChangedEventArgs> and <xref:System.Windows.DependencyPropertyChangedEventHandler> are slightly more common than `RoutedPropertyChanged` events.</span></span> <span data-ttu-id="e50a3-129">使用這些類型的事件範例為<xref:System.Windows.UIElement.IsMouseCapturedChanged>。</span><span class="sxs-lookup"><span data-stu-id="e50a3-129">An example of an event that uses these types is <xref:System.Windows.UIElement.IsMouseCapturedChanged>.</span></span>  
  
 <span data-ttu-id="e50a3-130">就<xref:System.Windows.RoutedPropertyChangedEventArgs%601>像<xref:System.Windows.DependencyPropertyChangedEventArgs>一樣, 也會報告屬性的舊值和新值。</span><span class="sxs-lookup"><span data-stu-id="e50a3-130">Like <xref:System.Windows.RoutedPropertyChangedEventArgs%601>, <xref:System.Windows.DependencyPropertyChangedEventArgs> also reports an old and new value for the property.</span></span> <span data-ttu-id="e50a3-131">此外，能對值執行的動作也適用同樣的考量，一般不建議嘗試在傳送端再次變更值來回應事件。</span><span class="sxs-lookup"><span data-stu-id="e50a3-131">Also, the same considerations about what you can do with the values apply; it is generally not recommended that you attempt to change the values again on the sender in response to the event.</span></span>  
  
## <a name="property-triggers"></a><span data-ttu-id="e50a3-132">屬性觸發程序</span><span class="sxs-lookup"><span data-stu-id="e50a3-132">Property Triggers</span></span>  
 <span data-ttu-id="e50a3-133">與屬性已變更事件密切相關的概念是屬性觸發程序。</span><span class="sxs-lookup"><span data-stu-id="e50a3-133">A closely related concept to a property changed event is a property trigger.</span></span> <span data-ttu-id="e50a3-134">屬性觸發程序建立於樣式或範本內，可讓您根據指派該屬性觸發程序之屬性的值來建立條件式行為。</span><span class="sxs-lookup"><span data-stu-id="e50a3-134">A property trigger is created within a style or template and enables you to create a conditional behavior based on the value of the property where the property trigger is assigned.</span></span>  
  
 <span data-ttu-id="e50a3-135">屬性觸發程序的屬性必須是相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="e50a3-135">The property for a property trigger must be a dependency property.</span></span> <span data-ttu-id="e50a3-136">它可以 (而且通常) 是唯讀的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="e50a3-136">It can be (and frequently is) a read-only dependency property.</span></span> <span data-ttu-id="e50a3-137">當控制項所公開的相依性屬性至少有部分設計為屬性觸發程序時，可以從屬性名稱是否以 "Is" 開頭來辨識。</span><span class="sxs-lookup"><span data-stu-id="e50a3-137">A good indicator for when a dependency property exposed by a control is at least partially designed to be a property trigger is if the property name begins with "Is".</span></span> <span data-ttu-id="e50a3-138">以此命名的屬性通常是唯讀的布林值相依性屬性，屬性的主要用途是報告可能對即時 UI 產生影響的控制項狀態，因此可做為屬性觸發程序候選項目。</span><span class="sxs-lookup"><span data-stu-id="e50a3-138">Properties that have this naming are often a read-only Boolean dependency property where the primary scenario for the property is reporting control state that might have consequences to the real-time UI and is thus a property trigger candidate.</span></span>  
  
 <span data-ttu-id="e50a3-139">這其中部分屬性也會有專用的屬性已變更事件。</span><span class="sxs-lookup"><span data-stu-id="e50a3-139">Some of these properties also have a dedicated property changed event.</span></span> <span data-ttu-id="e50a3-140">例如, 屬性<xref:System.Windows.UIElement.IsMouseCaptured%2A>有屬性已變更事件<xref:System.Windows.UIElement.IsMouseCapturedChanged>。</span><span class="sxs-lookup"><span data-stu-id="e50a3-140">For instance, the property <xref:System.Windows.UIElement.IsMouseCaptured%2A> has a property changed event <xref:System.Windows.UIElement.IsMouseCapturedChanged>.</span></span> <span data-ttu-id="e50a3-141">屬性本身是唯讀的, 其值會由輸入系統調整, 而輸入系統會在每個即時<xref:System.Windows.UIElement.IsMouseCapturedChanged>變更時引發。</span><span class="sxs-lookup"><span data-stu-id="e50a3-141">The property itself is read-only, with its value adjusted by the input system, and the input system raises <xref:System.Windows.UIElement.IsMouseCapturedChanged> on each real-time change.</span></span>  
  
 <span data-ttu-id="e50a3-142">相較於真正的屬性已變更事件，使用屬性觸發程序對屬性變更採取動作有一些限制。</span><span class="sxs-lookup"><span data-stu-id="e50a3-142">Compared to a true property changed event, using a property trigger to act on a property change has some limitations.</span></span>  
  
 <span data-ttu-id="e50a3-143">屬性觸發程序可透過精確比對邏輯來運作。</span><span class="sxs-lookup"><span data-stu-id="e50a3-143">Property triggers work through an exact match logic.</span></span> <span data-ttu-id="e50a3-144">您會指定屬性和值，指出觸發程序將執行動作的特定值。例如：`<Setter Property="IsMouseCaptured" Value="true"> ... </Setter>`。</span><span class="sxs-lookup"><span data-stu-id="e50a3-144">You specify a property and a value that indicates the specific value for which the trigger will act. For instance: `<Setter Property="IsMouseCaptured" Value="true"> ... </Setter>`.</span></span> <span data-ttu-id="e50a3-145">由於此限制，屬性觸發程序多用於布林值屬性，或是接受專用列舉值的屬性，其中的可能值範圍容易管理，可為每種情況定義觸發程序。</span><span class="sxs-lookup"><span data-stu-id="e50a3-145">Because of this limitation, the majority of property trigger usages will be for Boolean properties, or properties that take a dedicated enumeration value, where the possible value range is manageable enough to define a trigger for each case.</span></span> <span data-ttu-id="e50a3-146">或者，屬性觸發程序只能用於特殊值，例如，當項目計數到達零，且沒有任何觸發程序負責當屬性值再從零變成其他數字的情況 (這裡不使用適用所有情況的觸發程序，您在此處可能需要一個程式碼事件處理常式，或是當值為非零值時，再次從觸發程序狀態切換回來的預設行為)。</span><span class="sxs-lookup"><span data-stu-id="e50a3-146">Or property triggers might exist only for special values, such as when an items count reaches zero, and there would be no trigger that accounts for the cases when the property value changes away from zero again (instead of triggers for all cases, you might need a code event handler here, or a default behavior that toggles back from the trigger state again when the value is nonzero).</span></span>  
  
 <span data-ttu-id="e50a3-147">屬性觸發程序語法類似於程式設計中的 "if" 陳述式。</span><span class="sxs-lookup"><span data-stu-id="e50a3-147">The property trigger syntax is analogous to an "if" statement in programming.</span></span> <span data-ttu-id="e50a3-148">如果觸發程序條件為 true，接著就會「執行」屬性觸發程序的「主體」。</span><span class="sxs-lookup"><span data-stu-id="e50a3-148">If the trigger condition is true, then the "body" of the property trigger is "executed".</span></span> <span data-ttu-id="e50a3-149">屬性觸發程序的「主體」不是程式碼，而是標記。</span><span class="sxs-lookup"><span data-stu-id="e50a3-149">The "body" of a property trigger is not code, it is markup.</span></span> <span data-ttu-id="e50a3-150">該標記僅限於使用一或多個<xref:System.Windows.Setter>元素來設定套用樣式或範本之物件的其他屬性。</span><span class="sxs-lookup"><span data-stu-id="e50a3-150">That markup is limited to using one or more <xref:System.Windows.Setter> elements to set other properties of the object where the style or template is being applied.</span></span>  
  
 <span data-ttu-id="e50a3-151">若要位移具有各種可能值之屬性觸發程式的「if」條件, 通常建議使用<xref:System.Windows.Setter>來將相同的屬性值設定為預設值。</span><span class="sxs-lookup"><span data-stu-id="e50a3-151">To offset the "if" condition of a property trigger that has a wide variety of possible values, it is generally advisable to set that same property value to a default by using a <xref:System.Windows.Setter>.</span></span> <span data-ttu-id="e50a3-152">如此一來, <xref:System.Windows.Trigger>當觸發條件為 true 時, 包含的 setter 會有優先順序, <xref:System.Windows.Setter>而如果觸發條件為<xref:System.Windows.Trigger> false, 則不在內的會有優先順序。</span><span class="sxs-lookup"><span data-stu-id="e50a3-152">This way, the <xref:System.Windows.Trigger> contained setter will have precedence when the trigger condition is true, and the <xref:System.Windows.Setter> that is not within a <xref:System.Windows.Trigger> will have precedence whenever the trigger condition is false.</span></span>  
  
 <span data-ttu-id="e50a3-153">一般適合使用屬性觸發程序的情況是，一或多個外觀屬性會根據同一個元素上的其他屬性狀態而變更。</span><span class="sxs-lookup"><span data-stu-id="e50a3-153">Property triggers are generally appropriate for scenarios where one or more appearance properties should change, based on the state of another property on the same element.</span></span>  
  
 <span data-ttu-id="e50a3-154">若要深入了解屬性觸發程序，請參閱[設定樣式和範本](../controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="e50a3-154">To learn more about property triggers, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e50a3-155">另請參閱</span><span class="sxs-lookup"><span data-stu-id="e50a3-155">See also</span></span>

- [<span data-ttu-id="e50a3-156">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="e50a3-156">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="e50a3-157">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="e50a3-157">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
