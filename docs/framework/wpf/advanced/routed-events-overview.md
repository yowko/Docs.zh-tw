---
title: 路由事件概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached events [WPF]
- grouped button set [WPF]
- routed events [WPF]
- events [WPF], routed
- tunneling [WPF]
- events [WPF], attached
- routing strategies for events [WPF]
- button set [WPF], grouped
- bubbling [WPF]
ms.assetid: 1a2189ae-13b4-45b0-b12c-8de2e49c29d2
ms.openlocfilehash: 7712ed02d20d692842267464a645bfc93ca8fd73
ms.sourcegitcommit: ca2ca60e6f5ea327f164be7ce26d9599e0f85fe4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/06/2019
ms.locfileid: "65063899"
---
# <a name="routed-events-overview"></a><span data-ttu-id="67e1f-102">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="67e1f-102">Routed Events Overview</span></span>
<span data-ttu-id="67e1f-103">本主題說明 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中路由事件的概念。</span><span class="sxs-lookup"><span data-stu-id="67e1f-103">This topic describes the concept of routed events in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="67e1f-104">本主題會定義路由事件的術語、說明如何透過元素的樹狀結構路由傳送路由事件、摘要說明如何處理路由事件，以及介紹如何建立您自己的自訂路由事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-104">The topic defines routed events terminology, describes how routed events are routed through a tree of elements, summarizes how you handle routed events, and introduces how to create your own custom routed events.</span></span>
  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="67e1f-105">必要條件</span><span class="sxs-lookup"><span data-stu-id="67e1f-105">Prerequisites</span></span>  
 <span data-ttu-id="67e1f-106">本主題假設您具備 [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 和物件導向程式設計的基本知識，以及如何將 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 元素之間的關聯性概念化為樹狀結構的概念。</span><span class="sxs-lookup"><span data-stu-id="67e1f-106">This topic assumes that you have basic knowledge of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] and object-oriented programming, as well as the concept of how the relationships between [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] elements can be conceptualized as a tree.</span></span> <span data-ttu-id="67e1f-107">若要遵循本主題中的範例，您也應該了解 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]，並知道如何撰寫非常基本的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式或頁面。</span><span class="sxs-lookup"><span data-stu-id="67e1f-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write very basic [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications or pages.</span></span> <span data-ttu-id="67e1f-108">如需詳細資訊，請參閱[逐步解說：我第一個 WPF 桌面應用程式](../getting-started/walkthrough-my-first-wpf-desktop-application.md)並[XAML 概觀 (WPF)](xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-108">For more information, see [Walkthrough: My first WPF desktop application](../getting-started/walkthrough-my-first-wpf-desktop-application.md) and [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="routing"></a>   
## <a name="what-is-a-routed-event"></a><span data-ttu-id="67e1f-109">什麼是路由事件？</span><span class="sxs-lookup"><span data-stu-id="67e1f-109">What Is a Routed Event?</span></span>  
 <span data-ttu-id="67e1f-110">您可以從功能或實作觀點來考量路由事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-110">You can think about routed events either from a functional or implementation perspective.</span></span> <span data-ttu-id="67e1f-111">此處說明這兩個定義，讓使用者能夠選擇較實用的定義。</span><span class="sxs-lookup"><span data-stu-id="67e1f-111">Both definitions are presented here, because some people find one or the other definition more useful.</span></span>  
  
 <span data-ttu-id="67e1f-112">功能定義：路由的事件是事件的一種可以叫用處理常式項目樹狀結構中的多個接聽程式上，而不是事件的只會在引發事件的物件上。</span><span class="sxs-lookup"><span data-stu-id="67e1f-112">Functional definition: A routed event is a type of event that can invoke handlers on multiple listeners in an element tree, rather than just on the object that raised the event.</span></span>  
  
 <span data-ttu-id="67e1f-113">實作定義：路由的事件是[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]的執行個體做為後盾的事件<xref:System.Windows.RoutedEvent>類別，而且由處理[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]事件系統。</span><span class="sxs-lookup"><span data-stu-id="67e1f-113">Implementation definition: A routed event is a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that is backed by an instance of the <xref:System.Windows.RoutedEvent> class and is processed by the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] event system.</span></span>  
  
 <span data-ttu-id="67e1f-114">一般的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式包含許多元素。</span><span class="sxs-lookup"><span data-stu-id="67e1f-114">A typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application contains many elements.</span></span> <span data-ttu-id="67e1f-115">不論是在程式碼中建立或是在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中宣告，這些元素均存在於彼此間的元素樹狀結構關聯性中。</span><span class="sxs-lookup"><span data-stu-id="67e1f-115">Whether created in code or declared in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], these elements exist in an element tree relationship to each other.</span></span> <span data-ttu-id="67e1f-116">事件路由的周遊方向取決於事件定義，但通常路由會從來源元素開始周遊，然後透過元素樹狀結構向上執行「事件反昇」，直到它到達元素樹狀結構根元素 (通常是頁面或視窗) 為止。</span><span class="sxs-lookup"><span data-stu-id="67e1f-116">The event route can travel in one of two directions depending on the event definition, but generally the route travels from the source element and then "bubbles" upward through the element tree until it reaches the element tree root (typically a page or a window).</span></span> <span data-ttu-id="67e1f-117">如果您先前曾用過 DHTML 物件模型，可能很熟悉這個事件反昇概念。</span><span class="sxs-lookup"><span data-stu-id="67e1f-117">This bubbling concept might be familiar to you if you have worked with the DHTML object model previously.</span></span>  
  
 <span data-ttu-id="67e1f-118">請考慮下列簡單的元素樹狀結構：</span><span class="sxs-lookup"><span data-stu-id="67e1f-118">Consider the following simple element tree:</span></span>  
  
 [!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]  
  
 <span data-ttu-id="67e1f-119">這個元素樹狀結構會產生如下的畫面：</span><span class="sxs-lookup"><span data-stu-id="67e1f-119">This element tree produces something like the following:</span></span>  
  
 <span data-ttu-id="67e1f-120">![[是]、[否] 和 [取消] 按鈕](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")</span><span class="sxs-lookup"><span data-stu-id="67e1f-120">![Yes, No, and Cancel buttons](./media/routedevent-ovw-1.gif "RoutedEvent_ovw_1")</span></span>  
  
 <span data-ttu-id="67e1f-121">在這個簡化的項目樹狀目錄中的來源<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件是其中一個<xref:System.Windows.Controls.Button>項目，以及兩者<xref:System.Windows.Controls.Button>已按下是有機會處理事件的第一個項目。</span><span class="sxs-lookup"><span data-stu-id="67e1f-121">In this simplified element tree, the source of a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event is one of the <xref:System.Windows.Controls.Button> elements, and whichever <xref:System.Windows.Controls.Button> was clicked is the first element that has the opportunity to handle the event.</span></span> <span data-ttu-id="67e1f-122">但是，如果沒有處理常式附加至<xref:System.Windows.Controls.Button>處理程式碼事件，則事件會往上為反昇<xref:System.Windows.Controls.Button>中的項目樹狀結構，也就是父系<xref:System.Windows.Controls.StackPanel>。</span><span class="sxs-lookup"><span data-stu-id="67e1f-122">But if no handler attached to the <xref:System.Windows.Controls.Button> acts on the event, then the event will bubble upwards to the <xref:System.Windows.Controls.Button> parent in the element tree, which is the <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="67e1f-123">甚至是事件反昇至<xref:System.Windows.Controls.Border>，然後超越元素樹狀結構 （未顯示） 的頁面根。</span><span class="sxs-lookup"><span data-stu-id="67e1f-123">Potentially, the event bubbles to <xref:System.Windows.Controls.Border>, and then beyond to the page root of the element tree (not shown).</span></span>  
  
 <span data-ttu-id="67e1f-124">換句話說，這個事件路由<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件：</span><span class="sxs-lookup"><span data-stu-id="67e1f-124">In other words, the event route for this <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event is:</span></span>  
  
 <span data-ttu-id="67e1f-125">Button-->StackPanel-->Border-->...</span><span class="sxs-lookup"><span data-stu-id="67e1f-125">Button-->StackPanel-->Border-->...</span></span>  
  
### <a name="top-level-scenarios-for-routed-events"></a><span data-ttu-id="67e1f-126">路由事件的最上層案例</span><span class="sxs-lookup"><span data-stu-id="67e1f-126">Top-level Scenarios for Routed Events</span></span>  
 <span data-ttu-id="67e1f-127">以下是激發路由事件概念的案例簡單摘要，以及為什麼一般的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件無法滿足這些案例的原因：</span><span class="sxs-lookup"><span data-stu-id="67e1f-127">The following is a brief summary of the scenarios that motivated the routed event concept, and why a typical [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event was not adequate for these scenarios:</span></span>  
  
 <span data-ttu-id="67e1f-128">**控制項組合和封裝：** 中的各種控制項[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]有豐富的內容模型。</span><span class="sxs-lookup"><span data-stu-id="67e1f-128">**Control composition and encapsulation:** Various controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] have a rich content model.</span></span> <span data-ttu-id="67e1f-129">例如，您可以在其中放置內的映像<xref:System.Windows.Controls.Button>，其有效地擴展按鈕的視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="67e1f-129">For example, you can place an image inside of a <xref:System.Windows.Controls.Button>, which effectively extends the visual tree of the button.</span></span> <span data-ttu-id="67e1f-130">不過，已新增的影像不得中斷點擊測試行為，讓按鈕回應<xref:System.Windows.Controls.Primitives.ButtonBase.Click>其內容，即使使用者在技術上屬於影像的像素為單位。</span><span class="sxs-lookup"><span data-stu-id="67e1f-130">However, the added image must not break the hit-testing behavior that causes a button to respond to a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> of its content, even if the user clicks on pixels that are technically part of the image.</span></span>  
  
 <span data-ttu-id="67e1f-131">**單一處理常式附加點：** 在  [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]，您必須多次附加相同的處理常式，來處理無法從多個元素引發的事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-131">**Singular handler attachment points:** In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)], you would have to attach the same handler multiple times to process events that could be raised from multiple elements.</span></span> <span data-ttu-id="67e1f-132">路由事件可讓您只需附加該處理常式一次 (如上一個範例中所示)，然後就能視需要使用處理常式邏輯判斷此事件來自何處。</span><span class="sxs-lookup"><span data-stu-id="67e1f-132">Routed events enable you to attach that handler only once, as was shown in the previous example, and use handler logic to determine where the event came from if necessary.</span></span> <span data-ttu-id="67e1f-133">例如，這可能是先前所示之 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 的處理常式：</span><span class="sxs-lookup"><span data-stu-id="67e1f-133">For instance, this might be the handler for the previously shown [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]:</span></span>  
  
 [!code-csharp[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#groupbuttoncodebehind)]
 [!code-vb[EventOvwSupport#GroupButtonCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#groupbuttoncodebehind)]  
  
 <span data-ttu-id="67e1f-134">**類別處理：** 路由事件允許類別所定義的靜態處理常式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-134">**Class handling:** Routed events permit a static handler that is defined by the class.</span></span> <span data-ttu-id="67e1f-135">這個類別處理常式有機會在任何附加的執行個體處理常式之前處理事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-135">This class handler has the opportunity to handle an event before any attached instance handlers can.</span></span>  
  
 <span data-ttu-id="67e1f-136">**參考事件，但不使用反映：** 某些程式碼和標記技術需要識別特定事件的方法。</span><span class="sxs-lookup"><span data-stu-id="67e1f-136">**Referencing an event without reflection:** Certain code and markup techniques require a way to identify a specific event.</span></span> <span data-ttu-id="67e1f-137">路由的事件會建立<xref:System.Windows.RoutedEvent>欄位做為識別項，可提供不需要靜態或執行階段反映的強大事件識別技術。</span><span class="sxs-lookup"><span data-stu-id="67e1f-137">A routed event creates a <xref:System.Windows.RoutedEvent> field as an identifier, which provides a robust event identification technique that does not require static or run-time reflection.</span></span>  
  
### <a name="how-routed-events-are-implemented"></a><span data-ttu-id="67e1f-138">路由事件的實作方式</span><span class="sxs-lookup"><span data-stu-id="67e1f-138">How Routed Events Are Implemented</span></span>  
 <span data-ttu-id="67e1f-139">路由的事件是[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]的執行個體做為後盾的事件<xref:System.Windows.RoutedEvent>類別，並向[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]事件系統。</span><span class="sxs-lookup"><span data-stu-id="67e1f-139">A routed event is a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event that is backed by an instance of the <xref:System.Windows.RoutedEvent> class and registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="67e1f-140"><xref:System.Windows.RoutedEvent>註冊取得的執行個體通常會被保留為`public` `static` `readonly`欄位成員之類別的註冊，並因此 「 擁有 」 路由的事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-140">The <xref:System.Windows.RoutedEvent> instance obtained from registration is typically retained as a `public` `static` `readonly` field member of the class that registers and thus "owns" the routed event.</span></span> <span data-ttu-id="67e1f-141">與名稱完全相同之 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件 (有時稱為「包裝函式」事件) 的關聯，可藉由覆寫 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件的 `add` 和 `remove` 實作來完成。</span><span class="sxs-lookup"><span data-stu-id="67e1f-141">The connection to the identically named [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event (which is sometimes termed the "wrapper" event) is accomplished by overriding the `add` and `remove` implementations for the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event.</span></span> <span data-ttu-id="67e1f-142">一般而言，`add` 和 `remove` 會保留為隱含的預設值，以使用適當的語言特定事件語法來加入和移除該事件的處理常式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-142">Ordinarily, the `add` and `remove` are left as an implicit default that uses the appropriate language-specific event syntax for adding and removing handlers of that event.</span></span> <span data-ttu-id="67e1f-143">路由的事件支援與關聯機制在概念上類似相依性屬性有何[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]屬性，並受到<xref:System.Windows.DependencyProperty>類別，並向[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]屬性系統。</span><span class="sxs-lookup"><span data-stu-id="67e1f-143">The routed event backing and connection mechanism is conceptually similar to how a dependency property is a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] property that is backed by the <xref:System.Windows.DependencyProperty> class and registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system.</span></span>  
  
 <span data-ttu-id="67e1f-144">下列範例示範自訂宣告`Tap`路由的事件，包括註冊和公開<xref:System.Windows.RoutedEvent>識別項欄位和`add`並`remove`實作`Tap` [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-144">The following example shows the declaration for a custom `Tap` routed event, including the registration and exposure of the <xref:System.Windows.RoutedEvent> identifier field and the `add` and `remove` implementations for the `Tap` [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event.</span></span>  
  
 [!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
### <a name="routed-event-handlers-and-xaml"></a><span data-ttu-id="67e1f-145">路由事件處理常式和 XAML</span><span class="sxs-lookup"><span data-stu-id="67e1f-145">Routed Event Handlers and XAML</span></span>  
 <span data-ttu-id="67e1f-146">若要使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 加入事件的處理常式，您可以宣告事件名稱做為屬於事件接聽程式之元素上的屬性。</span><span class="sxs-lookup"><span data-stu-id="67e1f-146">To add a handler for an event using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], you declare the event name as an attribute on the element that is an event listener.</span></span> <span data-ttu-id="67e1f-147">屬性的值是您所實作之處理常式方法的名稱，此名稱必須存在於程式碼後置檔案的部分類別中。</span><span class="sxs-lookup"><span data-stu-id="67e1f-147">The value of the attribute is the name of your implemented handler method, which must exist in the partial class of the code-behind file.</span></span>  
  
 [!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]  
  
 <span data-ttu-id="67e1f-148">加入標準 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件處理常式的 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 語法，與加入路由事件處理常式一樣，因為您真的要將處理常式加入到 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件包裝函式，底下具有路由事件實作。</span><span class="sxs-lookup"><span data-stu-id="67e1f-148">The [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax for adding standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event handlers is the same for adding routed event handlers, because you are really adding handlers to the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event wrapper, which has a routed event implementation underneath.</span></span> <span data-ttu-id="67e1f-149">如需在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中加入事件處理常式的詳細資訊，請參閱 [XAML 概觀 (WPF)](xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-149">For more information about adding event handlers in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], see [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="routing_strategies"></a>   
## <a name="routing-strategies"></a><span data-ttu-id="67e1f-150">路由傳送策略</span><span class="sxs-lookup"><span data-stu-id="67e1f-150">Routing Strategies</span></span>  
 <span data-ttu-id="67e1f-151">路由事件會使用下列其中一個路由傳送策略：</span><span class="sxs-lookup"><span data-stu-id="67e1f-151">Routed events use one of three routing strategies:</span></span>  
  
- <span data-ttu-id="67e1f-152">**事件反昇：** 在 事件來源的事件處理常式會叫用。</span><span class="sxs-lookup"><span data-stu-id="67e1f-152">**Bubbling:** Event handlers on the event source are invoked.</span></span> <span data-ttu-id="67e1f-153">路由事件接著會路由傳送到後續的父元素，直到其到達元素樹狀結構的根元素為止。</span><span class="sxs-lookup"><span data-stu-id="67e1f-153">The routed event then routes to successive parent elements until reaching the element tree root.</span></span> <span data-ttu-id="67e1f-154">大部分的路由事件會使用事件反昇路由傳送策略。</span><span class="sxs-lookup"><span data-stu-id="67e1f-154">Most routed events use the bubbling routing strategy.</span></span> <span data-ttu-id="67e1f-155">事件反昇的路由事件通常是用來報告來自不同控制項或其他 UI 元素的輸入或狀態變更。</span><span class="sxs-lookup"><span data-stu-id="67e1f-155">Bubbling routed events are generally used to report input or state changes from distinct controls or other UI elements.</span></span>  
  
- <span data-ttu-id="67e1f-156">**直接：** 只有來源元素本身就有機會叫用處理常式以回應。</span><span class="sxs-lookup"><span data-stu-id="67e1f-156">**Direct:** Only the source element itself is given the opportunity to invoke handlers in response.</span></span> <span data-ttu-id="67e1f-157">這類似於 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 針對事件所使用的「路由傳送」。</span><span class="sxs-lookup"><span data-stu-id="67e1f-157">This is analogous to the "routing" that [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] uses for events.</span></span> <span data-ttu-id="67e1f-158">不過，與標準不同[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]事件，直接路由的事件支援類別處理 （類別處理將在後續章節中說明），可供<xref:System.Windows.EventSetter>和<xref:System.Windows.EventTrigger>。</span><span class="sxs-lookup"><span data-stu-id="67e1f-158">However, unlike a standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event, direct routed events support class handling (class handling is explained in an upcoming section) and can be used by <xref:System.Windows.EventSetter> and <xref:System.Windows.EventTrigger>.</span></span>  
  
- <span data-ttu-id="67e1f-159">**通道：** 一開始，在元素樹狀結構根的事件處理常式會叫用。</span><span class="sxs-lookup"><span data-stu-id="67e1f-159">**Tunneling:** Initially, event handlers at the element tree root are invoked.</span></span> <span data-ttu-id="67e1f-160">路由事件接著會在路由中朝向屬於路由事件來源的節點元素 (會引發路由事件的元素) 移動，以透過後續的子元素周遊該路由。</span><span class="sxs-lookup"><span data-stu-id="67e1f-160">The routed event then travels a route through successive child elements along the route, towards the node element that is the routed event source (the element that raised the routed event).</span></span> <span data-ttu-id="67e1f-161">通道路由事件時常會做為複合控制項的一部分來使用或處理，這類來自複合組件的事件可利用專用於該完整控制項的事件來刻意隱藏或取代。</span><span class="sxs-lookup"><span data-stu-id="67e1f-161">Tunneling routed events are often used or handled as part of the compositing for a control, such that events from composite parts can be deliberately suppressed or replaced by events that are specific to the complete control.</span></span> <span data-ttu-id="67e1f-162">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中提供的輸入事件通常會實作為成對的通道/事件反昇組合。</span><span class="sxs-lookup"><span data-stu-id="67e1f-162">Input events provided in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] often come implemented as a tunneling/bubbling pair.</span></span> <span data-ttu-id="67e1f-163">由於用於配對的命名慣例，通道事件有時也稱為預覽事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-163">Tunneling events are also sometimes referred to as Preview events, because of a naming convention that is used for the pairs.</span></span>  
  
<a name="why_use"></a>   
## <a name="why-use-routed-events"></a><span data-ttu-id="67e1f-164">為什麼要使用路由事件？</span><span class="sxs-lookup"><span data-stu-id="67e1f-164">Why Use Routed Events?</span></span>  
 <span data-ttu-id="67e1f-165">身為應用程式開發人員，您不一定需要知道或在意要將您正在處理的事件實作為路由事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-165">As an application developer, you do not always need to know or care that the event you are handling is implemented as a routed event.</span></span> <span data-ttu-id="67e1f-166">路由事件都有特殊的行為，但是，如果您正在引發事件的元素上處理該事件，則大多不會看見該行為。</span><span class="sxs-lookup"><span data-stu-id="67e1f-166">Routed events have special behavior, but that behavior is largely invisible if you are handling an event on the element where it is raised.</span></span>  
  
 <span data-ttu-id="67e1f-167">路由事件變成功能強大之處在於，您是否使用任何建議的案例︰在一般的根元素上定義一般的處理常式、組合自己的控制項，或定義自己的控制項類別。</span><span class="sxs-lookup"><span data-stu-id="67e1f-167">Where routed events become powerful is if you use any of the suggested scenarios: defining common handlers at a common root, compositing your own control, or defining your own custom control class.</span></span>  
  
 <span data-ttu-id="67e1f-168">路由事件接聽程式和路由事件來源不需要在其階層中共用一般事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-168">Routed event listeners and routed event sources do not need to share a common event in their hierarchy.</span></span> <span data-ttu-id="67e1f-169">任何<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>可以是任何路由事件的事件接聽程式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-169">Any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> can be an event listener for any routed event.</span></span> <span data-ttu-id="67e1f-170">因此，您可以使用可在設為概念性「介面」的整個運作中 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 內使用的整組路由事件，讓應用程式中的不同元素可以交換事件資訊。</span><span class="sxs-lookup"><span data-stu-id="67e1f-170">Therefore, you can use the full set of routed events available throughout the working [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] set as a conceptual "interface" whereby disparate elements in the application can exchange event information.</span></span> <span data-ttu-id="67e1f-171">路由事件的這個「介面」概念特別適用於輸入事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-171">This "interface" concept for routed events is particularly applicable for input events.</span></span>  
  
 <span data-ttu-id="67e1f-172">路由事件也可用來透過元素樹狀結構進行通訊，因為事件的事件資料會永久存在於路由的每個元素中。</span><span class="sxs-lookup"><span data-stu-id="67e1f-172">Routed events can also be used to communicate through the element tree, because the event data for the event is perpetuated to each element in the route.</span></span> <span data-ttu-id="67e1f-173">一個元素可以變更事件資料中的某些內容，而該變更可供路由中的下一個元素使用。</span><span class="sxs-lookup"><span data-stu-id="67e1f-173">One element could change something in the event data, and that change would be available to the next element in the route.</span></span>  
  
 <span data-ttu-id="67e1f-174">從路由層面以外的觀點來看，兩個其他因素讓任何指定的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件可能實作為路由事件，而不是標準 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-174">Other than the routing aspect, there are two other reasons that any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event might be implemented as a routed event instead of a standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event.</span></span> <span data-ttu-id="67e1f-175">如果您要實作自己的事件，也可以考慮這些準則：</span><span class="sxs-lookup"><span data-stu-id="67e1f-175">If you are implementing your own events, you might also consider these principles:</span></span>  
  
- <span data-ttu-id="67e1f-176">某些[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]設定樣式和範本的功能，例如<xref:System.Windows.EventSetter>和<xref:System.Windows.EventTrigger>需要參考的事件是路由的事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-176">Certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] styling and templating features such as <xref:System.Windows.EventSetter> and <xref:System.Windows.EventTrigger> require the referenced event to be a routed event.</span></span> <span data-ttu-id="67e1f-177">這是先前所述的事件識別碼案例。</span><span class="sxs-lookup"><span data-stu-id="67e1f-177">This is the event identifier scenario mentioned earlier.</span></span>  
  
- <span data-ttu-id="67e1f-178">路由事件支援類別處理機制，此類別可藉以指定靜態方法，有機會在任何已註冊的執行個體處理常式可存取路由事件之前處理它們。</span><span class="sxs-lookup"><span data-stu-id="67e1f-178">Routed events support a class handling mechanism whereby the class can specify static methods that have the opportunity to handle routed events before any registered instance handlers can access them.</span></span> <span data-ttu-id="67e1f-179">這在控制項設計中非常有用，因為您的類別可以強制執行事件驅動的類別行為，您無法藉由處理執行個體上的事件來附帶隱藏這類行為。</span><span class="sxs-lookup"><span data-stu-id="67e1f-179">This is very useful in control design, because your class can enforce event-driven class behaviors that cannot be accidentally suppressed by handling an event on an instance.</span></span>  
  
 <span data-ttu-id="67e1f-180">上述每個考量都會在本主題的不同小節中加以討論。</span><span class="sxs-lookup"><span data-stu-id="67e1f-180">Each of the above considerations is discussed in a separate section of this topic.</span></span>  
  
<a name="event_handing"></a>   
## <a name="adding-and-implementing-an-event-handler-for-a-routed-event"></a><span data-ttu-id="67e1f-181">加入和實作路由事件的事件處理常式</span><span class="sxs-lookup"><span data-stu-id="67e1f-181">Adding and Implementing an Event Handler for a Routed Event</span></span>  
 <span data-ttu-id="67e1f-182">若要在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中加入事件處理常式，您只需將事件名稱加入至元素做為屬性，並將屬性值設為實作適當委派的事件處理常式名稱，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="67e1f-182">To add an event handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], you simply add the event name to an element as an attribute and set the attribute value as the name of the event handler that implements an appropriate delegate, as in the following example.</span></span>  
  
 [!code-xaml[EventOvwSupport#SimplestSyntax](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#simplestsyntax)]  
  
 <span data-ttu-id="67e1f-183">`b1SetColor` 實作包含處理的程式碼的處理常式名稱<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-183">`b1SetColor` is the name of the implemented handler that contains the code that handles the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="67e1f-184">`b1SetColor` 必須有相同的簽章<xref:System.Windows.RoutedEventHandler>委派，它是事件處理常式委派的<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-184">`b1SetColor` must have the same signature as the <xref:System.Windows.RoutedEventHandler> delegate, which is the event handler delegate for the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="67e1f-185">所有路由事件處理常式委派的第一個參數會指定要加入事件處理常式的元素，而第二個參數會指定事件的資料。</span><span class="sxs-lookup"><span data-stu-id="67e1f-185">The first parameter of all routed event handler delegates specifies the element to which the event handler is added, and the second parameter specifies the data for the event.</span></span>  
  
[!code-csharp[EventOvwSupport#SimpleHandlerA](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#simplehandlera)]
[!code-vb[EventOvwSupport#SimpleHandlerA](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#simplehandlera)]  
  
 <span data-ttu-id="67e1f-186"><xref:System.Windows.RoutedEventHandler> 是基本的路由的事件處理常式委派。</span><span class="sxs-lookup"><span data-stu-id="67e1f-186"><xref:System.Windows.RoutedEventHandler> is the basic routed event handler delegate.</span></span> <span data-ttu-id="67e1f-187">如果是針對特定控制項或案例特製化的路由事件，用於路由事件處理常式的委派也可能會變得更特製化，讓它們能夠傳輸特製化的事件資料。</span><span class="sxs-lookup"><span data-stu-id="67e1f-187">For routed events that are specialized for certain controls or scenarios, the delegates to use for the routed event handlers also might become more specialized, so that they can transmit specialized event data.</span></span> <span data-ttu-id="67e1f-188">比方說，在一般的輸入案例中，您可能會處理<xref:System.Windows.UIElement.DragEnter>路由的事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-188">For instance, in a common input scenario, you might handle a <xref:System.Windows.UIElement.DragEnter> routed event.</span></span> <span data-ttu-id="67e1f-189">您的處理常式應該實作<xref:System.Windows.DragEventHandler>委派。</span><span class="sxs-lookup"><span data-stu-id="67e1f-189">Your handler should implement the <xref:System.Windows.DragEventHandler> delegate.</span></span> <span data-ttu-id="67e1f-190">您可以藉由使用最特定的委派，來處理<xref:System.Windows.DragEventArgs>中的處理常式和讀取<xref:System.Windows.DragEventArgs.Data%2A>屬性，其中包含拖曳作業的剪貼簿承載。</span><span class="sxs-lookup"><span data-stu-id="67e1f-190">By using the most specific delegate, you can process the <xref:System.Windows.DragEventArgs> in the handler and read the <xref:System.Windows.DragEventArgs.Data%2A> property, which contains the clipboard payload of the drag operation.</span></span>  
  
 <span data-ttu-id="67e1f-191">如需如何使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 來將事件處理常式加入至元素的完整範例，請參閱[處理路由事件](how-to-handle-a-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-191">For a complete example of how to add an event handler to an element using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], see [Handle a Routed Event](how-to-handle-a-routed-event.md).</span></span>  
  
 <span data-ttu-id="67e1f-192">在使用程式碼建立的應用程式中加入路由事件的處理常式很簡單。</span><span class="sxs-lookup"><span data-stu-id="67e1f-192">Adding a handler for a routed event in an application that is created in code is straightforward.</span></span> <span data-ttu-id="67e1f-193">路由的事件處理常式一律透過 helper 方法會新增<xref:System.Windows.UIElement.AddHandler%2A>(這是現有支援呼叫相同方法`add`。)不過，現有的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 路由事件通常支援實作 `add` 和 `remove` 邏輯，以允許透過語言特有的事件語法來加入路由事件的處理常式，此語法是比 Helper 方法更直覺的語法。</span><span class="sxs-lookup"><span data-stu-id="67e1f-193">Routed event handlers can always be added through a helper method <xref:System.Windows.UIElement.AddHandler%2A> (which is the same method that the existing backing calls for `add`.) However, existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events generally have backing implementations of `add` and `remove` logic that allow the handlers for routed events to be added by a language-specific event syntax, which is more intuitive syntax than the helper method.</span></span> <span data-ttu-id="67e1f-194">以下是 Helper 方法的使用方式範例：</span><span class="sxs-lookup"><span data-stu-id="67e1f-194">The following is an example usage of the helper method:</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerCode](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlercode)]
 [!code-vb[EventOvwSupport#AddHandlerCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlercode)]  
  
 <span data-ttu-id="67e1f-195">下一個範例顯示C#運算子 （Visual Basic 也有因其處理取值稍有不同的運算子語法） 的語法：</span><span class="sxs-lookup"><span data-stu-id="67e1f-195">The next example shows the C# operator syntax (Visual Basic has slightly different operator syntax because of its handling of dereferencing):</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml.cs#addhandlerplusequals)]
 [!code-vb[EventOvwSupport#AddHandlerPlusEquals](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/default.xaml.vb#addhandlerplusequals)]  
  
 <span data-ttu-id="67e1f-196">如需如何在程式碼中加入事件處理常式的範例，請參閱[使用程式碼加入事件處理常式](how-to-add-an-event-handler-using-code.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-196">For an example of how to add an event handler in code, see [Add an Event Handler Using Code](how-to-add-an-event-handler-using-code.md).</span></span>  
  
 <span data-ttu-id="67e1f-197">如果您使用 Visual Basic，您也可以使用`Handles`關鍵字來新增處理常式的處理常式宣告的一部分。</span><span class="sxs-lookup"><span data-stu-id="67e1f-197">If you are using Visual Basic, you can also use the `Handles` keyword to add handlers as part of the handler declarations.</span></span> <span data-ttu-id="67e1f-198">如需詳細資訊，請參閱 [Visual Basic 和 WPF 事件處理](visual-basic-and-wpf-event-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-198">For more information, see [Visual Basic and WPF Event Handling](visual-basic-and-wpf-event-handling.md).</span></span>  
  
<a name="concept_handled"></a>   
### <a name="the-concept-of-handled"></a><span data-ttu-id="67e1f-199">已處理的概念</span><span class="sxs-lookup"><span data-stu-id="67e1f-199">The Concept of Handled</span></span>  
 <span data-ttu-id="67e1f-200">所有的路由的事件都會共用一般事件資料基底類別， <xref:System.Windows.RoutedEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="67e1f-200">All routed events share a common event data base class, <xref:System.Windows.RoutedEventArgs>.</span></span> <span data-ttu-id="67e1f-201"><xref:System.Windows.RoutedEventArgs> 定義<xref:System.Windows.RoutedEventArgs.Handled%2A>屬性接受布林值。</span><span class="sxs-lookup"><span data-stu-id="67e1f-201"><xref:System.Windows.RoutedEventArgs> defines the <xref:System.Windows.RoutedEventArgs.Handled%2A> property, which takes a Boolean value.</span></span> <span data-ttu-id="67e1f-202">目的<xref:System.Windows.RoutedEventArgs.Handled%2A>屬性是要讓任何標示為路由的事件路由的事件處理常式*處理*，藉由設定的值<xref:System.Windows.RoutedEventArgs.Handled%2A>到`true`。</span><span class="sxs-lookup"><span data-stu-id="67e1f-202">The purpose of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is to enable any event handler along the route to mark the routed event as *handled*, by setting the value of <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span> <span data-ttu-id="67e1f-203">透過處理常式在路由中的某一個元素上進行處理之後，就會再次向路由中的每一個接聽程式報告共用的事件資料。</span><span class="sxs-lookup"><span data-stu-id="67e1f-203">After being processed by the handler at one element along the route, the shared event data is again reported to each listener along the route.</span></span>  
  
 <span data-ttu-id="67e1f-204">值<xref:System.Windows.RoutedEventArgs.Handled%2A>會影響路由的事件會報告或處理傳送如何進一步路由。</span><span class="sxs-lookup"><span data-stu-id="67e1f-204">The value of <xref:System.Windows.RoutedEventArgs.Handled%2A> affects how a routed event is reported or processed as it travels further along the route.</span></span> <span data-ttu-id="67e1f-205">如果<xref:System.Windows.RoutedEventArgs.Handled%2A>是`true`在事件路由的事件，然後接聽其他元素上該路由事件的處理常式的資料通常不會再叫用該特定事件執行個體。</span><span class="sxs-lookup"><span data-stu-id="67e1f-205">If <xref:System.Windows.RoutedEventArgs.Handled%2A> is `true` in the event data for a routed event, then handlers that listen for that routed event on other elements are generally no longer invoked for that particular event instance.</span></span> <span data-ttu-id="67e1f-206">此情況適用於 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中附加的處理常式，以及適用於利用語言特定之事件處理常式附加語法 (例如 `+=` 或 `Handles`) 所加入的處理常式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-206">This is true both for handlers attached in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and for handlers added by language-specific event handler attachment syntaxes such as `+=` or `Handles`.</span></span> <span data-ttu-id="67e1f-207">最常見的處理常式案例中，將事件標示為已處理，藉由設定<xref:System.Windows.RoutedEventArgs.Handled%2A>至`true`會 「 停止 」 通道路由或事件反昇的路由，以及類別處理常式所處理之路由中的某一點的任何事件的路由。</span><span class="sxs-lookup"><span data-stu-id="67e1f-207">For most common handler scenarios, marking an event as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true` will "stop" routing for either a tunneling route or a bubbling route, and also for any event that is handled at a point in the route by a class handler.</span></span>  
  
 <span data-ttu-id="67e1f-208">不過，還有"handledEventsToo"機制，藉此讓接聽程式仍然可以執行處理常式回應路由事件在何處<xref:System.Windows.RoutedEventArgs.Handled%2A>是`true`事件資料中。</span><span class="sxs-lookup"><span data-stu-id="67e1f-208">However, there is a "handledEventsToo" mechanism whereby listeners can still run handlers in response to routed events where <xref:System.Windows.RoutedEventArgs.Handled%2A> is `true` in the event data.</span></span> <span data-ttu-id="67e1f-209">換句話說，事件路由無法藉由將事件資料標示為已處理來真正停止。</span><span class="sxs-lookup"><span data-stu-id="67e1f-209">In other words, the event route is not truly stopped by marking the event data as handled.</span></span> <span data-ttu-id="67e1f-210">您只可以在程式碼，或使用 handledEventsToo 機制<xref:System.Windows.EventSetter>:</span><span class="sxs-lookup"><span data-stu-id="67e1f-210">You can only use the handledEventsToo mechanism in code, or in an <xref:System.Windows.EventSetter>:</span></span>  
  
- <span data-ttu-id="67e1f-211">在程式碼，而不是使用一般的運作方式的語言特有的事件語法[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]事件，呼叫[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]方法<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>加入您的處理常式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-211">In code, instead of using a language-specific event syntax that works for general [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events, call the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] method <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> to add your handler.</span></span> <span data-ttu-id="67e1f-212">將 `handledEventsToo` 的值指定為 `true`。</span><span class="sxs-lookup"><span data-stu-id="67e1f-212">Specify the value of `handledEventsToo` as `true`.</span></span>  
  
- <span data-ttu-id="67e1f-213">在  <xref:System.Windows.EventSetter>，將<xref:System.Windows.EventSetter.HandledEventsToo%2A>屬性設為`true`。</span><span class="sxs-lookup"><span data-stu-id="67e1f-213">In an <xref:System.Windows.EventSetter>, set the <xref:System.Windows.EventSetter.HandledEventsToo%2A> attribute to be `true`.</span></span>  
  
 <span data-ttu-id="67e1f-214">除了行為之外，<xref:System.Windows.RoutedEventArgs.Handled%2A>路由事件的概念中的狀態會產生<xref:System.Windows.RoutedEventArgs.Handled%2A>有影響，您應該在設計您的應用程式及撰寫事件處理常式程式碼。</span><span class="sxs-lookup"><span data-stu-id="67e1f-214">In addition to the behavior that <xref:System.Windows.RoutedEventArgs.Handled%2A> state produces in routed events, the concept of <xref:System.Windows.RoutedEventArgs.Handled%2A> has implications for how you should design your application and write the event handler code.</span></span> <span data-ttu-id="67e1f-215">您可以將概念化<xref:System.Windows.RoutedEventArgs.Handled%2A>作為路由事件所公開的簡單通訊協定。</span><span class="sxs-lookup"><span data-stu-id="67e1f-215">You can conceptualize <xref:System.Windows.RoutedEventArgs.Handled%2A> as being a simple protocol that is exposed by routed events.</span></span> <span data-ttu-id="67e1f-216">您使用此通訊協定是由您，但如需概念的設計值<xref:System.Windows.RoutedEventArgs.Handled%2A>旨在使用如下所示：</span><span class="sxs-lookup"><span data-stu-id="67e1f-216">Exactly how you use this protocol is up to you, but the conceptual design for how the value of <xref:System.Windows.RoutedEventArgs.Handled%2A> is intended to be used is as follows:</span></span>  
  
- <span data-ttu-id="67e1f-217">如果將路由事件標示為已處理，則不需再次透過該路由中的其他元素來處理它。</span><span class="sxs-lookup"><span data-stu-id="67e1f-217">If a routed event is marked as handled, then it does not need to be handled again by other elements along that route.</span></span>  
  
- <span data-ttu-id="67e1f-218">如果路由的事件不會標示為已處理，則路由中先前的其他接聽程式已選擇不到註冊處理常式或已註冊的選擇不要管理事件資料和設定的處理常式<xref:System.Windows.RoutedEventArgs.Handled%2A>至`true`。</span><span class="sxs-lookup"><span data-stu-id="67e1f-218">If a routed event is not marked as handled, then other listeners that were earlier along the route have chosen either not to register a handler, or the handlers that were registered chose not to manipulate the event data and set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span> <span data-ttu-id="67e1f-219">(或者，當然有可能目前的接聽程式為路由中的第一個點)。目前接聽程式上的處理常式現在有三個可能的做法：</span><span class="sxs-lookup"><span data-stu-id="67e1f-219">(Or, it is of course possible that the current listener is the first point in the route.) Handlers on the current listener now have three possible courses of action:</span></span>  
  
    - <span data-ttu-id="67e1f-220">不採取任何動作；事件會保持未處理狀態，而事件會路由傳送到下一個接聽程式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-220">Take no action at all; the event remains unhandled, and the event routes to the next listener.</span></span>  
  
    - <span data-ttu-id="67e1f-221">執行程式碼以回應事件，但判定採取的動作後續不足以保證會將事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="67e1f-221">Execute code in response to the event, but make the determination that the action taken was not substantial enough to warrant marking the event as handled.</span></span> <span data-ttu-id="67e1f-222">事件會路由傳送到下一個接聽程式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-222">The event routes to the next listener.</span></span>  
  
    - <span data-ttu-id="67e1f-223">執行程式碼以回應事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-223">Execute code in response to the event.</span></span> <span data-ttu-id="67e1f-224">在傳遞至處理常式的事件資料中將事件標示為已處理，因為已將所採取的動作視為後續不足以保證會標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="67e1f-224">Mark the event as handled in the event data passed to the handler, because the action taken was deemed substantial enough to warrant marking as handled.</span></span> <span data-ttu-id="67e1f-225">事件仍會路由傳送至下一個接聽程式，但<xref:System.Windows.RoutedEventArgs.Handled%2A> = `true`其事件資料，因此只有在`handledEventsToo`接聽程式有機會進一步叫用處理常式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-225">The event still routes to the next listener, but with <xref:System.Windows.RoutedEventArgs.Handled%2A>=`true` in its event data, so only `handledEventsToo` listeners have the opportunity to invoke further handlers.</span></span>  
  
 <span data-ttu-id="67e1f-226">這個概念性設計根據稍早所述的路由行為的： 它是更困難 （儘管還是有可能在程式碼或樣式） 附加路由事件即使路由中的前一個處理常式 již nastavena叫用的處理常式<xref:System.Windows.RoutedEventArgs.Handled%2A>至`true`。</span><span class="sxs-lookup"><span data-stu-id="67e1f-226">This conceptual design is reinforced by the routing behavior mentioned earlier: it is more difficult (although still possible in code or styles) to attach handlers for routed events that are invoked even if a previous handler along the route has already set <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`.</span></span>  
  
 <span data-ttu-id="67e1f-227">如需詳細資訊<xref:System.Windows.RoutedEventArgs.Handled%2A>的類別處理路由事件，且需時建議適當的 做為路由的事件標示<xref:System.Windows.RoutedEventArgs.Handled%2A>，請參閱[將路由事件標記為已處理以及類別處理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-227">For more information about <xref:System.Windows.RoutedEventArgs.Handled%2A>, class handling of routed events, and recommendations about when it is appropriate to mark a routed event as <xref:System.Windows.RoutedEventArgs.Handled%2A>, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="67e1f-228">在應用程式中，只在引發事件反昇路由事件的物件上處理該事件是相當常見的，而這並不完全與事件的路由特性有關。</span><span class="sxs-lookup"><span data-stu-id="67e1f-228">In applications, it is quite common to just handle a bubbling routed event on the object that raised it, and not be concerned with the event's routing characteristics at all.</span></span> <span data-ttu-id="67e1f-229">不過，它仍是在事件資料中將路由事件標示為已處理的最佳做法，萬一元素樹狀結構中進一步向上的元素也具有已針對該相同路由事件附加的處理常式時，可避免發生未預期的副作用。</span><span class="sxs-lookup"><span data-stu-id="67e1f-229">However, it is still a good practice to mark the routed event as handled in the event data, to prevent unanticipated side effects just in case an element that is further up the element tree also has a handler attached for that same routed event.</span></span>  
  
<a name="class_handlers"></a>   
## <a name="class-handlers"></a><span data-ttu-id="67e1f-230">類別處理常式</span><span class="sxs-lookup"><span data-stu-id="67e1f-230">Class Handlers</span></span>  
 <span data-ttu-id="67e1f-231">如果您要定義衍生的類別，以某種方式從<xref:System.Windows.DependencyObject>，您也可以定義並附加路由事件的類別宣告或繼承事件成員的類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-231">If you are defining a class that derives in some way from <xref:System.Windows.DependencyObject>, you can also define and attach a class handler for a routed event that is a declared or inherited event member of your class.</span></span> <span data-ttu-id="67e1f-232">每當路由事件到達其路由中的元素執行個體時，就可以在任何附加至該類別執行個體的執行個體接聽程式處理常式之前叫用類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-232">Class handlers are invoked before any instance listener handlers that are attached to an instance of that class, whenever a routed event reaches an element instance in its route.</span></span>  
  
 <span data-ttu-id="67e1f-233">某些 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控制項具有適用於特定路由事件的繼承類別處理。</span><span class="sxs-lookup"><span data-stu-id="67e1f-233">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls have inherent class handling for certain routed events.</span></span> <span data-ttu-id="67e1f-234">這可能會造成表面上未曾引發過路由事件，但實際上卻已處理過類別的情況，而且，如果您使用某些技術，您的執行個體處理常式可能仍會處理該路由事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-234">This might give the outward appearance that the routed event is not ever raised, but in reality it is being class handled, and the routed event can potentially still be handled by your instance handlers if you use certain techniques.</span></span> <span data-ttu-id="67e1f-235">此外，許多基底類別和控制項會公開可用於覆寫類別處理行為的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="67e1f-235">Also, many base classes and controls expose virtual methods that can be used to override class handling behavior.</span></span> <span data-ttu-id="67e1f-236">如需如何因應不想要的類別處理，並在自訂類別中定義您自己之類別處理的詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-236">For more information both on how to work around undesired class handling and on defining your own class handling in a custom class, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events-in-wpf"></a><span data-ttu-id="67e1f-237">在 WPF 中附加事件</span><span class="sxs-lookup"><span data-stu-id="67e1f-237">Attached Events in WPF</span></span>  
 <span data-ttu-id="67e1f-238">[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 語言也會定義稱為「附加事件」的特定事件類型。</span><span class="sxs-lookup"><span data-stu-id="67e1f-238">The [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] language also defines a special type of event called an *attached event*.</span></span> <span data-ttu-id="67e1f-239">附加事件可讓您將特殊事件的處理常式加入至任意元素。</span><span class="sxs-lookup"><span data-stu-id="67e1f-239">An attached event enables you to add a handler for a particular event to an arbitrary element.</span></span> <span data-ttu-id="67e1f-240">處理事件的元素不需要定義或繼承附加事件，而物件不可能引發事件，且目的地處理執行個體也不需定義或「擁有」該事件做為類別成員。</span><span class="sxs-lookup"><span data-stu-id="67e1f-240">The element handling the event need not define or inherit the attached event, and neither the object potentially raising the event nor the destination handling instance must define or otherwise "own" that event as a class member.</span></span>  
  
 <span data-ttu-id="67e1f-241">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 輸入系統會廣泛使用附加事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-241">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input system uses attached events extensively.</span></span> <span data-ttu-id="67e1f-242">不過，幾乎這所有的附加事件都會轉送到基底元素。</span><span class="sxs-lookup"><span data-stu-id="67e1f-242">However, nearly all of these attached events are forwarded through base elements.</span></span> <span data-ttu-id="67e1f-243">輸入事件接著會顯示為對等的非附加路由事件，其為基底元素類別的成員。</span><span class="sxs-lookup"><span data-stu-id="67e1f-243">The input events then appear as equivalent non-attached routed events that are members of the base element class.</span></span> <span data-ttu-id="67e1f-244">比方說，基礎附加事件<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>可以更輕鬆地處理任何給定<xref:System.Windows.UIElement>利用<xref:System.Windows.UIElement.MouseDown>上的<xref:System.Windows.UIElement>而不處理附加的事件語法中[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]或程式碼。</span><span class="sxs-lookup"><span data-stu-id="67e1f-244">For instance, the underlying attached event <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> can more easily be handled on any given <xref:System.Windows.UIElement> by using <xref:System.Windows.UIElement.MouseDown> on that <xref:System.Windows.UIElement> rather than dealing with attached event syntax either in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>  
  
 <span data-ttu-id="67e1f-245">如需 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中附加事件的詳細資訊，請參閱[附加事件概觀](attached-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-245">For more information about attached events in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [Attached Events Overview](attached-events-overview.md).</span></span>  
  
<a name="Qualifying_Event_Names_in_XAML_for_Anticipated_Routing"></a>   
## <a name="qualified-event-names-in-xaml"></a><span data-ttu-id="67e1f-246">XAML 中的完整事件名稱</span><span class="sxs-lookup"><span data-stu-id="67e1f-246">Qualified Event Names in XAML</span></span>  
 <span data-ttu-id="67e1f-247">類似 *typename*.*eventname* 附加事件語法的另一種語法用法 (但嚴格來說，它不是附加事件的使用方式) 是，當您連接由子元素所引發之路由事件的處理常式時。</span><span class="sxs-lookup"><span data-stu-id="67e1f-247">Another syntax usage that resembles *typename*.*eventname* attached event syntax but is not strictly speaking an attached event usage is when you attach handlers for routed events that are raised by child elements.</span></span> <span data-ttu-id="67e1f-248">您可將處理常式附加到共同父項，以利用事件路由，即使共同父項可能沒有相關的路由事件做為成員。</span><span class="sxs-lookup"><span data-stu-id="67e1f-248">You attach the handlers to a common parent, to take advantage of event routing, even though the common parent might not have the relevant routed event as a member.</span></span> <span data-ttu-id="67e1f-249">再看一下這個範例：</span><span class="sxs-lookup"><span data-stu-id="67e1f-249">Consider this example again:</span></span>  
  
 [!code-xaml[EventOvwSupport#GroupButton](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/default.xaml#groupbutton)]  
  
 <span data-ttu-id="67e1f-250">其中會加入處理常式的父元素接聽程式如下<xref:System.Windows.Controls.StackPanel>。</span><span class="sxs-lookup"><span data-stu-id="67e1f-250">Here, the parent element listener where the handler is added is a <xref:System.Windows.Controls.StackPanel>.</span></span> <span data-ttu-id="67e1f-251">不過，它會加入已宣告且將藉由引發路由事件的處理常式<xref:System.Windows.Controls.Button>類別 (<xref:System.Windows.Controls.Primitives.ButtonBase>實際上，但若要使用<xref:System.Windows.Controls.Button>透過繼承)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-251">However, it is adding a handler for a routed event that was declared and will be raised by the <xref:System.Windows.Controls.Button> class (<xref:System.Windows.Controls.Primitives.ButtonBase> actually, but available to <xref:System.Windows.Controls.Button> through inheritance).</span></span> <span data-ttu-id="67e1f-252"><xref:System.Windows.Controls.Button> 「 擁有 」 事件，但路由的事件系統允許處理常式附加至任何任何路由事件<xref:System.Windows.UIElement>或是<xref:System.Windows.ContentElement>可能會附加接聽程式的執行個體接聽程式[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-252"><xref:System.Windows.Controls.Button> "owns" the event, but the routed event system permits handlers for any routed event to be attached to any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> instance listener that could otherwise attach listeners for a [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] event.</span></span> <span data-ttu-id="67e1f-253">這些完整事件屬性名稱的預設 xmlns 命名空間通常是預設的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xmlns 命名空間，但您也可以針對自訂路由事件指定有前置詞的命名空間。</span><span class="sxs-lookup"><span data-stu-id="67e1f-253">The default xmlns namespace for these qualified event attribute names is typically the default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xmlns namespace, but you can also specify prefixed namespaces for custom routed events.</span></span> <span data-ttu-id="67e1f-254">如需 xmlns 的詳細資訊，請參閱 [WPF XAML 的 XAML 命名空間和命名空間對應](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-254">For more information about xmlns, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="how_event_processing_works"></a>   
## <a name="wpf-input-events"></a><span data-ttu-id="67e1f-255">WPF 輸入事件</span><span class="sxs-lookup"><span data-stu-id="67e1f-255">WPF Input Events</span></span>  
 <span data-ttu-id="67e1f-256">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 平台中有一個路由事件的常用應用程式適用於輸入事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-256">One frequent application of routed events within the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] platform is for input events.</span></span> <span data-ttu-id="67e1f-257">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，通道路由事件名稱前面依慣例會加上 "Preview" 這個字。</span><span class="sxs-lookup"><span data-stu-id="67e1f-257">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], tunneling routed events names are prefixed with the word "Preview" by convention.</span></span> <span data-ttu-id="67e1f-258">輸入事件通常會成對出現，其中一個是事件反昇事件，另一個則是通道事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-258">Input events often come in pairs, with one being the bubbling event and the other being the tunneling event.</span></span> <span data-ttu-id="67e1f-259">例如，<xref:System.Windows.ContentElement.KeyDown>事件和<xref:System.Windows.ContentElement.PreviewKeyDown>事件擁有相同的簽章，前者是事件反昇輸入的事件和第二個通道輸入事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-259">For example, the <xref:System.Windows.ContentElement.KeyDown> event and the <xref:System.Windows.ContentElement.PreviewKeyDown> event have the same signature, with the former being the bubbling input event and the latter being the tunneling input event.</span></span> <span data-ttu-id="67e1f-260">有時，輸入事件只會有事件反昇版本，或可能只有直接路由版本。</span><span class="sxs-lookup"><span data-stu-id="67e1f-260">Occasionally, input events only have a bubbling version, or perhaps only a direct routed version.</span></span> <span data-ttu-id="67e1f-261">在文件中，路由事件主題會交互參考具備替代路由傳送策略的類似路由事件 (如果這類路由事件存在)，而受管理參考頁面中的章節會釐清每個路由事件的路由傳送策略。</span><span class="sxs-lookup"><span data-stu-id="67e1f-261">In the documentation, routed event topics cross-reference similar routed events with alternative routing strategies if such routed events exist, and sections in the managed reference pages clarify the routing strategy of each routed event.</span></span>  
  
 <span data-ttu-id="67e1f-262">系統會實作成對出現的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 輸入事件，讓來自輸入的單一使用者動作 (例如按下滑鼠按鈕) 將依序引發配對中的這兩個路由事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-262">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input events that come in pairs are implemented so that a single user action from input, such as a mouse button press, will raise both routed events of the pair in sequence.</span></span> <span data-ttu-id="67e1f-263">首先，引發通道事件，並周遊其路由。</span><span class="sxs-lookup"><span data-stu-id="67e1f-263">First, the tunneling event is raised and travels its route.</span></span> <span data-ttu-id="67e1f-264">接著，引發事件反昇事件，並周遊其路由。</span><span class="sxs-lookup"><span data-stu-id="67e1f-264">Then the bubbling event is raised and travels its route.</span></span> <span data-ttu-id="67e1f-265">兩個事件實際上會共用相同的事件資料執行個體，因為<xref:System.Windows.UIElement.RaiseEvent%2A>中實作的類別引發事件反昇事件的方法呼叫會接聽來自通道事件的事件資料，並重複新引發的事件中。</span><span class="sxs-lookup"><span data-stu-id="67e1f-265">The two events literally share the same event data instance, because the <xref:System.Windows.UIElement.RaiseEvent%2A> method call in the implementing class that raises the bubbling event listens for the event data from the tunneling event and reuses it in the new raised event.</span></span> <span data-ttu-id="67e1f-266">具有通道事件處理常式的接聽程式有機會優先將路由事件標示為已處理 (第一個是類別處理常式，然後是執行個體處理常式)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-266">Listeners with handlers for the tunneling event have the first opportunity to mark the routed event handled (class handlers first, then instance handlers).</span></span> <span data-ttu-id="67e1f-267">如果將通道路由中的元素標示為已處理，則已經處理的事件資料就會針對事件反昇事件進行傳送，而且將不會叫用基於對等事件反昇輸入事件附加的一般處理常式。</span><span class="sxs-lookup"><span data-stu-id="67e1f-267">If an element along the tunneling route marked the routed event as handled, the already-handled event data is sent on for the bubbling event, and typical handlers attached for the equivalent bubbling input events will not be invoked.</span></span> <span data-ttu-id="67e1f-268">表面上來看，就如同未曾引發過已處理的事件反昇事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-268">To outward appearances it will be as if the handled bubbling event has not even been raised.</span></span> <span data-ttu-id="67e1f-269">這個處理行為非常適用於控制項複合，您可能想要讓您的最終控制項 (而不是它的複合組件) 報告所有以點擊測試為基礎的輸入事件或以焦點為基礎的輸入事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-269">This handling behavior is useful for control compositing, where you might want all hit-test based input events or focus-based input events to be reported by your final control, rather than its composite parts.</span></span> <span data-ttu-id="67e1f-270">最後一個控制項元素更接近複合中的根元素，因此有機會優先對通道事件進行類別處理，而且，或許可利用更專屬於控制項的事件，做為支援控制項類別的程式碼一部分來「取代」該路由事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-270">The final control element is closer to the root in the compositing, and therefore has the opportunity to class handle the tunneling event first and perhaps to "replace" that routed event with a more control-specific event, as part of the code that backs the control class.</span></span>  
  
 <span data-ttu-id="67e1f-271">如需輸入事件處理如何運作的圖表說明，請考量下列輸入事件範例。</span><span class="sxs-lookup"><span data-stu-id="67e1f-271">As an illustration of how input event processing works, consider the following input event example.</span></span> <span data-ttu-id="67e1f-272">在下列樹狀結構圖中，`leaf element #2`做為來源的同時`PreviewMouseDown`，然後`MouseDown`事件：</span><span class="sxs-lookup"><span data-stu-id="67e1f-272">In the following tree illustration, `leaf element #2` is the source of both a `PreviewMouseDown` and then a `MouseDown` event:</span></span>  
  
 ![事件路由圖表](./media/routed-events-overview/input-event-routing.png)  
  
 <span data-ttu-id="67e1f-274">事件處理的順序如下：</span><span class="sxs-lookup"><span data-stu-id="67e1f-274">The order of event processing is as follows:</span></span>  
  
1. <span data-ttu-id="67e1f-275">根元素上的 `PreviewMouseDown` (通道)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-275">`PreviewMouseDown` (tunnel) on root element.</span></span>  
  
2. <span data-ttu-id="67e1f-276">中繼元素 #1 上的 `PreviewMouseDown` (通道)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-276">`PreviewMouseDown` (tunnel) on intermediate element #1.</span></span>  
  
3. <span data-ttu-id="67e1f-277">來源元素 #2 上的 `PreviewMouseDown` (通道)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-277">`PreviewMouseDown` (tunnel) on source element #2.</span></span>  
  
4. <span data-ttu-id="67e1f-278">來源元素 #2 上的 `MouseDown` (事件反昇)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-278">`MouseDown` (bubble) on source element #2.</span></span>  
  
5. <span data-ttu-id="67e1f-279">中繼元素 #1 上的 `MouseDown` (事件反昇)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-279">`MouseDown` (bubble) on intermediate element #1.</span></span>  
  
6. <span data-ttu-id="67e1f-280">根元素上的 `MouseDown` (事件反昇)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-280">`MouseDown` (bubble) on root element.</span></span>  
  
 <span data-ttu-id="67e1f-281">路由事件處理常式委派提供對兩個物件的參考︰引發事件的物件，以及已叫用處理常式的物件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-281">A routed event handler delegate provides references to two objects: the object that raised the event and the object where the handler was invoked.</span></span> <span data-ttu-id="67e1f-282">已叫用處理常式的物件是 `sender` 參數所報告的物件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-282">The object where the handler was invoked is the object reported by the `sender` parameter.</span></span> <span data-ttu-id="67e1f-283">第一次引發事件的物件由報告<xref:System.Windows.RoutedEventArgs.Source%2A>事件資料中的屬性。</span><span class="sxs-lookup"><span data-stu-id="67e1f-283">The object where the event was first raised is reported by the <xref:System.Windows.RoutedEventArgs.Source%2A> property in the event data.</span></span> <span data-ttu-id="67e1f-284">路由的事件可以仍會引發並處理相同的物件，在此情況下`sender`和<xref:System.Windows.RoutedEventArgs.Source%2A>都相同 （這是步驟 3 和 4 在事件處理範例清單的情況）。</span><span class="sxs-lookup"><span data-stu-id="67e1f-284">A routed event can still be raised and handled by the same object, in which case `sender` and <xref:System.Windows.RoutedEventArgs.Source%2A> are identical (this is the case with Steps 3 and 4 in the event processing example list).</span></span>  
  
 <span data-ttu-id="67e1f-285">因為通道和事件反昇，父項目會接收輸入的事件其中<xref:System.Windows.RoutedEventArgs.Source%2A>是其中一個子元素。</span><span class="sxs-lookup"><span data-stu-id="67e1f-285">Because of tunneling and bubbling, parent elements receive input events where the <xref:System.Windows.RoutedEventArgs.Source%2A> is one of their child elements.</span></span> <span data-ttu-id="67e1f-286">一定要知道來源項目時，您可以藉由存取識別來源項目<xref:System.Windows.RoutedEventArgs.Source%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="67e1f-286">When it is important to know what the source element is, you can identify the source element by accessing the <xref:System.Windows.RoutedEventArgs.Source%2A> property.</span></span>  
  
 <span data-ttu-id="67e1f-287">通常，一旦輸入的事件被標記為<xref:System.Windows.RoutedEventArgs.Handled%2A>，進一步處理常式不會叫用。</span><span class="sxs-lookup"><span data-stu-id="67e1f-287">Usually, once the input event is marked <xref:System.Windows.RoutedEventArgs.Handled%2A>, further handlers are not invoked.</span></span> <span data-ttu-id="67e1f-288">一般而言，您應該在叫用處理常式來處理代表輸入事件意義之應用程式特定的邏輯處理之後，儘速將輸入事件標示為已處理。</span><span class="sxs-lookup"><span data-stu-id="67e1f-288">Typically, you should mark input events as handled as soon as a handler is invoked that addresses your application-specific logical handling of the meaning of the input event.</span></span>  
  
 <span data-ttu-id="67e1f-289">關於這個一般陳述式的例外狀況<xref:System.Windows.RoutedEventArgs.Handled%2A>狀態時的輸入事件處理常式的註冊來刻意忽略<xref:System.Windows.RoutedEventArgs.Handled%2A>事件資料的狀態仍會叫用這任一個路由。</span><span class="sxs-lookup"><span data-stu-id="67e1f-289">The exception to this general statement about <xref:System.Windows.RoutedEventArgs.Handled%2A> state is that input event handlers that are registered to deliberately ignore <xref:System.Windows.RoutedEventArgs.Handled%2A> state of the event data would still be invoked along either route.</span></span> <span data-ttu-id="67e1f-290">如需詳細資訊，請參閱[預覽事件](preview-events.md)或[將路由事件標記為已處理以及類別處理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-290">For more information, see [Preview Events](preview-events.md) or [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="67e1f-291">通道事件與事件反昇事件之間共用的事件資料模型，以及後續引發的第一個通道事件，然後是事件反昇事件，不是一般適用於所有路由事件的概念。</span><span class="sxs-lookup"><span data-stu-id="67e1f-291">The shared event data model between tunneling and bubbling events, and the sequential raising of first tunneling then bubbling events, is not a concept that is generally true for all routed events.</span></span> <span data-ttu-id="67e1f-292">該行為特別是透過 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 輸入裝置如何選擇引發並連接輸入事件配對的方式來實作。</span><span class="sxs-lookup"><span data-stu-id="67e1f-292">That behavior is specifically implemented by how [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input devices choose to raise and connect the input event pairs.</span></span> <span data-ttu-id="67e1f-293">實作您自己的輸入事件是一個進階案例，但您也可以選擇針對自己的輸入事件遵循該模型。</span><span class="sxs-lookup"><span data-stu-id="67e1f-293">Implementing your own input events is an advanced scenario, but you might choose to follow that model for your own input events also.</span></span>  
  
 <span data-ttu-id="67e1f-294">某些類別會選擇對特定輸入事件進行類別處理，一般的用意是重新定義特定使用者驅動的輸入事件在該控制項內所代表的意義，然後引發新的事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-294">Certain classes choose to class-handle certain input events, usually with the intent of redefining what a particular user-driven input event means within that control and raising a new event.</span></span> <span data-ttu-id="67e1f-295">如需詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-295">For more information, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="67e1f-296">如需輸入以及在一般應用程式案例中輸入如何與事件互動的詳細資訊，請參閱[輸入概觀](input-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-296">For more information on input and how input and events interact in typical application scenarios, see [Input Overview](input-overview.md).</span></span>  
  
<a name="events_styles"></a>   
## <a name="eventsetters-and-eventtriggers"></a><span data-ttu-id="67e1f-297">EventSetters 和 EventTriggers</span><span class="sxs-lookup"><span data-stu-id="67e1f-297">EventSetters and EventTriggers</span></span>  
 <span data-ttu-id="67e1f-298">在樣式中，您可以包含一些預先宣告[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]事件處理中標記的語法就使用<xref:System.Windows.EventSetter>。</span><span class="sxs-lookup"><span data-stu-id="67e1f-298">In styles, you can include some pre-declared [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] event handling syntax in the markup by using an <xref:System.Windows.EventSetter>.</span></span> <span data-ttu-id="67e1f-299">套用樣式時，會將參考的處理常式加入至樣式執行個體。</span><span class="sxs-lookup"><span data-stu-id="67e1f-299">When the style is applied, the referenced handler is added to the styled instance.</span></span> <span data-ttu-id="67e1f-300">您可以宣告<xref:System.Windows.EventSetter>只針對路由事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-300">You can declare an <xref:System.Windows.EventSetter> only for a routed event.</span></span> <span data-ttu-id="67e1f-301">下列為範例。</span><span class="sxs-lookup"><span data-stu-id="67e1f-301">The following is an example.</span></span> <span data-ttu-id="67e1f-302">請注意，此處參考的 `b1SetColor` 方法位於程式碼後置檔案中。</span><span class="sxs-lookup"><span data-stu-id="67e1f-302">Note that the `b1SetColor` method referenced here is in a code-behind file.</span></span>  
  
 [!code-xaml[EventOvwSupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 <span data-ttu-id="67e1f-303">這裡所獲得的好處是樣式可能包含大量的其他資訊，可以套用至您的應用程式中的任何按鈕而<xref:System.Windows.EventSetter>屬於該樣式會升級程式碼重複使用，即使在標記層級。</span><span class="sxs-lookup"><span data-stu-id="67e1f-303">The advantage gained here is that the style is likely to contain a great deal of other information that could apply to any button in your application, and having the <xref:System.Windows.EventSetter> be part of that style promotes code reuse even at the markup level.</span></span> <span data-ttu-id="67e1f-304">此外，<xref:System.Windows.EventSetter>抽象化為處理常式進一步遠離一般應用程式和頁面標記的方法名稱。</span><span class="sxs-lookup"><span data-stu-id="67e1f-304">Also, an <xref:System.Windows.EventSetter> abstracts method names for handlers one step further away from the general application and page markup.</span></span>  
  
 <span data-ttu-id="67e1f-305">另一個組合的路由的事件和動畫功能的特定的語法[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是<xref:System.Windows.EventTrigger>。</span><span class="sxs-lookup"><span data-stu-id="67e1f-305">Another specialized syntax that combines the routed event and animation features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is an <xref:System.Windows.EventTrigger>.</span></span> <span data-ttu-id="67e1f-306">如同<xref:System.Windows.EventSetter>，只有路由的事件可用於<xref:System.Windows.EventTrigger>。</span><span class="sxs-lookup"><span data-stu-id="67e1f-306">As with <xref:System.Windows.EventSetter>, only routed events may be used for an <xref:System.Windows.EventTrigger>.</span></span> <span data-ttu-id="67e1f-307">通常<xref:System.Windows.EventTrigger>宣告為樣式的一部分，但是<xref:System.Windows.EventTrigger>也可以宣告在頁面層級項目上的一部分<xref:System.Windows.FrameworkElement.Triggers%2A>集合，或在<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="67e1f-307">Typically, an <xref:System.Windows.EventTrigger> is declared as part of a style, but an <xref:System.Windows.EventTrigger> can also be declared on page-level elements as part of the <xref:System.Windows.FrameworkElement.Triggers%2A> collection, or in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="67e1f-308"><xref:System.Windows.EventTrigger>可讓您指定<xref:System.Windows.Media.Animation.Storyboard>每當路由的事件到達其路由中的項目，執行會宣告<xref:System.Windows.EventTrigger>該事件。</span><span class="sxs-lookup"><span data-stu-id="67e1f-308">An <xref:System.Windows.EventTrigger> enables you to specify a <xref:System.Windows.Media.Animation.Storyboard> that runs whenever a routed event reaches an element in its route that declares an <xref:System.Windows.EventTrigger> for that event.</span></span> <span data-ttu-id="67e1f-309">善用<xref:System.Windows.EventTrigger>透過只處理事件，並導致其啟動現有分鏡腳本是<xref:System.Windows.EventTrigger>更完善地控制分鏡腳本和其執行階段行為。</span><span class="sxs-lookup"><span data-stu-id="67e1f-309">The advantage of an <xref:System.Windows.EventTrigger> over just handling the event and causing it to start an existing storyboard is that an <xref:System.Windows.EventTrigger> provides better control over the storyboard and its run-time behavior.</span></span> <span data-ttu-id="67e1f-310">如需詳細資訊，請參閱[在分鏡腳本開始後使用事件觸發程式進行控制](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-310">For more information, see [Use Event Triggers to Control a Storyboard After It Starts](../graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md).</span></span>  
  
<a name="more_about"></a>   
## <a name="more-about-routed-events"></a><span data-ttu-id="67e1f-311">深入了解路由事件</span><span class="sxs-lookup"><span data-stu-id="67e1f-311">More About Routed Events</span></span>  
 <span data-ttu-id="67e1f-312">本主題主要是從描述基本概念並提供如何及何時回應路由事件的觀點來討論路由事件，而路由事件已經存在於各種基底元素和控制項中。</span><span class="sxs-lookup"><span data-stu-id="67e1f-312">This topic mainly discusses routed events from the perspective of describing the basic concepts and offering guidance on how and when to respond to the routed events that are already present in the various base elements and controls.</span></span> <span data-ttu-id="67e1f-313">不過，您可以在自訂類別上建立自己的路由事件以及所有必要的支援，例如特製化的事件資料類別和委派。</span><span class="sxs-lookup"><span data-stu-id="67e1f-313">However, you can create your own routed event on your custom class along with all the necessary support, such as specialized event data classes and delegates.</span></span> <span data-ttu-id="67e1f-314">路由的事件擁有者可以是任何類別，但必須引發路由的事件，並由<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>衍生類別才能發揮作用。</span><span class="sxs-lookup"><span data-stu-id="67e1f-314">The routed event owner can be any class, but routed events must be raised by and handled by <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement> derived classes in order to be useful.</span></span> <span data-ttu-id="67e1f-315">如需自訂事件的詳細資訊，請參閱[建立自訂路由事件](how-to-create-a-custom-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="67e1f-315">For more information about custom events, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="67e1f-316">另請參閱</span><span class="sxs-lookup"><span data-stu-id="67e1f-316">See also</span></span>

- <xref:System.Windows.EventManager>
- <xref:System.Windows.RoutedEvent>
- <xref:System.Windows.RoutedEventArgs>
- [<span data-ttu-id="67e1f-317">將路由事件標記為已處理以及類別處理</span><span class="sxs-lookup"><span data-stu-id="67e1f-317">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="67e1f-318">輸入概觀</span><span class="sxs-lookup"><span data-stu-id="67e1f-318">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="67e1f-319">命令概觀</span><span class="sxs-lookup"><span data-stu-id="67e1f-319">Commanding Overview</span></span>](commanding-overview.md)
- [<span data-ttu-id="67e1f-320">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="67e1f-320">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="67e1f-321">WPF 中的樹狀結構</span><span class="sxs-lookup"><span data-stu-id="67e1f-321">Trees in WPF</span></span>](trees-in-wpf.md)
- [<span data-ttu-id="67e1f-322">弱式事件模式</span><span class="sxs-lookup"><span data-stu-id="67e1f-322">Weak Event Patterns</span></span>](weak-event-patterns.md)
