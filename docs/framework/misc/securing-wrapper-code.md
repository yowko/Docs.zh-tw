---
title: 設定包裝函式程式碼的安全性
ms.date: 03/30/2017
helpviewer_keywords:
- security [.NET Framework], wrapper code
- wrapper code, securing
- secure coding, wrapper code
- code security, wrapper code
ms.assetid: 1df6c516-5bba-48bd-b450-1070e04b7389
author: mairaw
ms.author: mairaw
ms.openlocfilehash: e824fd686176d83c26ca2c042348c9423fbcc884
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/22/2019
ms.locfileid: "69910745"
---
# <a name="securing-wrapper-code"></a><span data-ttu-id="60da3-102">設定包裝函式程式碼的安全性</span><span class="sxs-lookup"><span data-stu-id="60da3-102">Securing Wrapper Code</span></span>
[!INCLUDE[net_security_note](../../../includes/net-security-note-md.md)]  
  
 <span data-ttu-id="60da3-103">包裝函式程式碼可能會導致出現一組獨特的安全性弱點，特別是當包裝函式的信任層級高於使用該包裝函式的程式碼時。</span><span class="sxs-lookup"><span data-stu-id="60da3-103">Wrapper code, especially where the wrapper has higher trust than code that uses it, can open a unique set of security weaknesses.</span></span> <span data-ttu-id="60da3-104">代表呼叫端執行任何作業時，由於適當的安全性檢查中不會包含呼叫端的限制權限，因此任何作業都有可能成為被惡意探索的弱點。</span><span class="sxs-lookup"><span data-stu-id="60da3-104">Anything done on behalf of a caller, where the caller's limited permissions are not included in the appropriate security check, is a potential weakness to be exploited.</span></span>  
  
 <span data-ttu-id="60da3-105">所以絕對不要透過包裝函式執行呼叫端本身無法執行的作業。</span><span class="sxs-lookup"><span data-stu-id="60da3-105">Never enable something through the wrapper that the caller could not do itself.</span></span> <span data-ttu-id="60da3-106">當執行的作業涉及有限制的安全性檢查時 (相對於完整堆疊查核行程要求)，這樣做會特別危險。</span><span class="sxs-lookup"><span data-stu-id="60da3-106">This is a special danger when doing something that involves a limited security check, as opposed to a full stack walk demand.</span></span> <span data-ttu-id="60da3-107">需要單一層級的檢查時，如果在真正的呼叫端和有問題的應用程式開發介面項目之間插入包裝函式程式碼，很容易造成安全性檢查在不該成功時卻成功完成，因而降低安全性。</span><span class="sxs-lookup"><span data-stu-id="60da3-107">When single-level checks are involved, interposing the wrapper code between the real caller and the API element in question can easily cause the security check to succeed when it should not, thereby weakening security.</span></span>  
  
## <a name="delegates"></a><span data-ttu-id="60da3-108">委派</span><span class="sxs-lookup"><span data-stu-id="60da3-108">Delegates</span></span>  
 <span data-ttu-id="60da3-109">不同的 .NET Framework 版本各有不同的委派安全性。</span><span class="sxs-lookup"><span data-stu-id="60da3-109">Delegate security differs between versions of the .NET Framework.</span></span>  <span data-ttu-id="60da3-110">本節說明不同的委派行為及相關的安全性考量。</span><span class="sxs-lookup"><span data-stu-id="60da3-110">This section describes the different delegate behaviors and associated security considerations.</span></span>  
  
### <a name="in-version-10-and-11-of-the-net-framework"></a><span data-ttu-id="60da3-111">在 .NET Framework 1.0 和 1.1 版中</span><span class="sxs-lookup"><span data-stu-id="60da3-111">In version 1.0 and 1.1 of the .NET Framework</span></span>  
 <span data-ttu-id="60da3-112">.NET Framework 1.0 和 1.1 版會對委派建立者和委派呼叫端執行下列安全性動作。</span><span class="sxs-lookup"><span data-stu-id="60da3-112">Version 1.0 and 1.1 of the .NET Framework perform the following security actions against a delegate creator and a delegate caller.</span></span>  
  
- <span data-ttu-id="60da3-113">建立委派時，會對委派建立者的授權集執行委派目標方法上的安全性連結要求。</span><span class="sxs-lookup"><span data-stu-id="60da3-113">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="60da3-114">無法滿足安全性動作會導致 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="60da3-114">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
- <span data-ttu-id="60da3-115">叫用委派時，會執行委派呼叫端上任何現有的安全性要求。</span><span class="sxs-lookup"><span data-stu-id="60da3-115">When the delegate is invoked, any existing security demands on the delegate caller are performed.</span></span>  
  
 <span data-ttu-id="60da3-116">當您的程式碼從可能呼叫它的較不受信任的程式碼接受 <xref:System.Delegate> 時，請務必不要讓較不受信任的程式碼提高它的權限。</span><span class="sxs-lookup"><span data-stu-id="60da3-116">Whenever your code takes a <xref:System.Delegate> from less-trusted code that might call it, make sure that you are not enabling the less-trusted code to escalate its permissions.</span></span> <span data-ttu-id="60da3-117">如果您接受委派並在稍後使用它，建立該委派的程式碼就不會在呼叫堆疊上，而且如果委派中或之下的程式碼嘗試執行受保護的作業，也不會測試該程式碼的權限。</span><span class="sxs-lookup"><span data-stu-id="60da3-117">If you take a delegate and use it later, the code that created the delegate is not on the call stack and its permissions will not be tested if code in or under the delegate attempts a protected operation.</span></span> <span data-ttu-id="60da3-118">如果您的程式碼和呼叫端程式碼具有高於建立者的權限，則建立者不需要是呼叫堆疊的一部分，便可調整呼叫路徑。</span><span class="sxs-lookup"><span data-stu-id="60da3-118">If your code and the caller code have higher privileges than the creator, the creator can orchestrate the call path without being part of the call stack.</span></span>  
  
### <a name="in-version-20-and-later-versions-of-the-net-framework"></a><span data-ttu-id="60da3-119">在2.0 版和更新版本的 .NET Framework</span><span class="sxs-lookup"><span data-stu-id="60da3-119">In version 2.0 and later versions of the .NET Framework</span></span>  
 <span data-ttu-id="60da3-120">與舊版不同的是, 版本2.0 和更新版本的 .NET Framework 會在建立和呼叫委派時, 對委派建立者執行安全性動作。</span><span class="sxs-lookup"><span data-stu-id="60da3-120">Unlike previous versions, version 2.0 and later versions of the .NET Framework performs security action against the delegate creator when the delegate is created and called.</span></span>  
  
- <span data-ttu-id="60da3-121">建立委派時，會對委派建立者的授權集執行委派目標方法上的安全性連結要求。</span><span class="sxs-lookup"><span data-stu-id="60da3-121">When a delegate is created, security link demands on the delegate target method are performed against the grant set of the delegate creator.</span></span>  <span data-ttu-id="60da3-122">無法滿足安全性動作會導致 <xref:System.Security.SecurityException>。</span><span class="sxs-lookup"><span data-stu-id="60da3-122">Failure to satisfy the security action results in a <xref:System.Security.SecurityException>.</span></span>  
  
- <span data-ttu-id="60da3-123">委派建立期間也會擷取委派建立者的授權集，並與委派一起儲存。</span><span class="sxs-lookup"><span data-stu-id="60da3-123">The delegate creator's grant set is also captured during delegate creation and stored with the delegate.</span></span>  
  
- <span data-ttu-id="60da3-124">叫用委派時，如果委派建立者和呼叫端各屬於不同的組件，就會先對目前內容中的任何要求評估委派建立者所擷取的授權集。</span><span class="sxs-lookup"><span data-stu-id="60da3-124">When the delegate is invoked, the delegate creator's captured grant set is first evaluated against any demands in the current context if the delegate creator and caller belong to different assemblies.</span></span>  <span data-ttu-id="60da3-125">接著，便會執行委派呼叫端上任何現有的安全性要求。</span><span class="sxs-lookup"><span data-stu-id="60da3-125">Next, any existing security demands on the delegate caller are performed.</span></span>  
  
## <a name="link-demands-and-wrappers"></a><span data-ttu-id="60da3-126">連結要求和包裝函式</span><span class="sxs-lookup"><span data-stu-id="60da3-126">Link demands and wrappers</span></span>  
 <span data-ttu-id="60da3-127">我們已在安全性基礎結構中增強連結要求的特殊保護案例，但它仍然是您的程式碼中潛在弱點的來源。</span><span class="sxs-lookup"><span data-stu-id="60da3-127">A special protection case with link demands has been strengthened in the security infrastructure, but it is still a source of possible weakness in your code.</span></span>  
  
 <span data-ttu-id="60da3-128">如果完全信任的程式碼呼叫由[LinkDemand](../../../docs/framework/misc/link-demands.md)保護的屬性、事件或方法, 當滿足呼叫端的**LinkDemand**許可權檢查時, 呼叫就會成功。</span><span class="sxs-lookup"><span data-stu-id="60da3-128">If fully trusted code calls a property, event, or method protected by a [LinkDemand](../../../docs/framework/misc/link-demands.md), the call succeeds if the **LinkDemand** permission check for the caller is satisfied.</span></span> <span data-ttu-id="60da3-129">此外, 如果完全信任的程式碼公開採用屬性名稱的類別, 並使用反映呼叫其**get**存取子, 即使使用者程式碼沒有存取這個屬性的許可權, **get**存取子的呼叫還是會成功。</span><span class="sxs-lookup"><span data-stu-id="60da3-129">Additionally, if the fully trusted code exposes a class that takes the name of a property and calls its **get** accessor using reflection, that call to the **get** accessor succeeds even though the user code does not have the right to access this property.</span></span> <span data-ttu-id="60da3-130">這是因為**LinkDemand**只會檢查立即呼叫端, 也就是完全受信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="60da3-130">This is because the **LinkDemand** checks only the immediate caller, which is the fully trusted code.</span></span> <span data-ttu-id="60da3-131">本質上，完全受信任的程式碼是代表使用者程式碼進行有權限的呼叫，因此不需要確定使用者程式碼是否具有進行該呼叫的權限。</span><span class="sxs-lookup"><span data-stu-id="60da3-131">In essence, the fully trusted code is making a privileged call on behalf of user code without making sure that the user code has the right to make that call.</span></span>  
  
 <span data-ttu-id="60da3-132">為了協助防止這類安全性漏洞, 通用語言執行平臺會在任何間接呼叫由**LinkDemand**保護的方法、函式、屬性或事件時, 將檢查延伸至完整的堆疊流覽需求。</span><span class="sxs-lookup"><span data-stu-id="60da3-132">To help prevent such security holes, the common language runtime extends the check into a full stack-walking demand on any indirect call to a method, constructor, property, or event protected by a **LinkDemand**.</span></span> <span data-ttu-id="60da3-133">這項保護措施會稍微降低效能，也會變更安全性檢查的語意；較快的單一層級檢查可以通過的地方，完整堆疊查核行程要求卻有可能會失敗。</span><span class="sxs-lookup"><span data-stu-id="60da3-133">This protection incurs some performance costs and changes the semantics of the security check; the full stack-walk demand might fail where the faster, one-level check would have passed.</span></span>  
  
## <a name="assembly-loading-wrappers"></a><span data-ttu-id="60da3-134">組件載入包裝函式</span><span class="sxs-lookup"><span data-stu-id="60da3-134">Assembly loading wrappers</span></span>  
 <span data-ttu-id="60da3-135">有幾種用來載入 Managed 程式碼的方法 (包括 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>) 會使用呼叫端的辨識項載入組件。</span><span class="sxs-lookup"><span data-stu-id="60da3-135">Several methods used to load managed code, including <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>, load assemblies with the evidence of the caller.</span></span> <span data-ttu-id="60da3-136">如果您包裝任何方法，安全性系統就可以使用您的程式碼的權限授權 (而不是您包裝函式呼叫端的權限) 來載入組件。</span><span class="sxs-lookup"><span data-stu-id="60da3-136">If you wrap any of these methods, the security system could use your code's permission grant, instead of the permissions of the caller to your wrapper, to load the assemblies.</span></span> <span data-ttu-id="60da3-137">您不應該允許較不受信任的程式碼載入權限高於您包裝函式呼叫端的程式碼。</span><span class="sxs-lookup"><span data-stu-id="60da3-137">You should not allow less-trusted code to load code that is granted higher permissions than those of the caller to your wrapper.</span></span>  
  
 <span data-ttu-id="60da3-138">擁有完全信任、或是比潛在呼叫端 (包括網際網路權限層級呼叫端) 更受信任的任何程式碼，都有可能因而降低安全性。</span><span class="sxs-lookup"><span data-stu-id="60da3-138">Any code that has full trust or significantly higher trust than a potential caller (including an Internet-permissions-level caller) could weaken security in this way.</span></span> <span data-ttu-id="60da3-139">如果您的程式碼具有取得位元組陣列的公用方法, 並將它傳遞給**Assembly**, 則會代表呼叫端建立元件, 因而可能會破壞安全性。</span><span class="sxs-lookup"><span data-stu-id="60da3-139">If your code has a public method that takes a byte array and passes it to **Assembly.Load**, thereby creating an assembly on the caller's behalf, it might break security.</span></span>  
  
 <span data-ttu-id="60da3-140">這個問題會發生於下列應用程式開發介面項目：</span><span class="sxs-lookup"><span data-stu-id="60da3-140">This issue applies to the following API elements:</span></span>  
  
- <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType>  
  
- <xref:System.AppDomain.Load%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>  
  
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>  
  
## <a name="demand-vs-linkdemand"></a><span data-ttu-id="60da3-141">Demand 與LinkDemand 的比較</span><span class="sxs-lookup"><span data-stu-id="60da3-141">Demand vs. LinkDemand</span></span>  
 <span data-ttu-id="60da3-142">宣告式安全性提供兩種安全性檢查，這兩種安全性檢查雖然類似，但卻執行非常不同的檢查。</span><span class="sxs-lookup"><span data-stu-id="60da3-142">Declarative security offers two kinds of security checks that are similar but perform very different checks.</span></span> <span data-ttu-id="60da3-143">您應該了解這兩種形式，因為選擇錯誤可能導致安全性或效能低落。</span><span class="sxs-lookup"><span data-stu-id="60da3-143">You should understand both forms because the wrong choice can result in weak security or performance loss.</span></span>  
  
 <span data-ttu-id="60da3-144">宣告式安全性提供下列安全性檢查：</span><span class="sxs-lookup"><span data-stu-id="60da3-144">Declarative security offers the following security checks:</span></span>  
  
- <span data-ttu-id="60da3-145"><xref:System.Security.Permissions.SecurityAction.Demand> 指定程式碼存取安全性堆疊查核行程。</span><span class="sxs-lookup"><span data-stu-id="60da3-145"><xref:System.Security.Permissions.SecurityAction.Demand> specifies the code access security stack walk.</span></span> <span data-ttu-id="60da3-146">堆疊上的所有呼叫端都必須具有指定的權限或識別，才能通過。</span><span class="sxs-lookup"><span data-stu-id="60da3-146">All callers on the stack must have the specified permission or identity to pass.</span></span> <span data-ttu-id="60da3-147">每次呼叫都會發生**需求**, 因為堆疊可能包含不同的呼叫端。</span><span class="sxs-lookup"><span data-stu-id="60da3-147">**Demand** occurs on every call because the stack might contain different callers.</span></span> <span data-ttu-id="60da3-148">如果您重複呼叫一個方法，則每呼叫一次就會執行這個安全性檢查一次。</span><span class="sxs-lookup"><span data-stu-id="60da3-148">If you call a method repeatedly, this security check occurs each time.</span></span> <span data-ttu-id="60da3-149">**需求**是對引誘攻擊的良好保護;偵測到未經授權的程式碼, 將會偵測到它的嘗試。</span><span class="sxs-lookup"><span data-stu-id="60da3-149">**Demand** is good protection against luring attacks; unauthorized code trying to get through it will be detected.</span></span>  
  
- <span data-ttu-id="60da3-150">[LinkDemand](../../../docs/framework/misc/link-demands.md)會在即時 (JIT) 編譯時期進行, 並且只會檢查立即呼叫端。</span><span class="sxs-lookup"><span data-stu-id="60da3-150">[LinkDemand](../../../docs/framework/misc/link-demands.md) happens at just-in-time (JIT) compilation time and checks only the immediate caller.</span></span> <span data-ttu-id="60da3-151">這項安全性檢查不會檢查呼叫端的呼叫端。</span><span class="sxs-lookup"><span data-stu-id="60da3-151">This security check does not check the caller's caller.</span></span> <span data-ttu-id="60da3-152">一旦通過這項檢查，不論呼叫端可能呼叫的次數為何，都不會再增加額外的安全性負荷。</span><span class="sxs-lookup"><span data-stu-id="60da3-152">Once this check passes, there is no additional security overhead no matter how many times the caller might call.</span></span> <span data-ttu-id="60da3-153">不過，這也無法防止引誘攻擊。</span><span class="sxs-lookup"><span data-stu-id="60da3-153">However, there is also no protection from luring attacks.</span></span> <span data-ttu-id="60da3-154">透過**LinkDemand**, 通過測試並可以參考您程式碼的任何程式碼, 都可以藉由允許惡意程式碼使用授權的程式碼呼叫來中斷安全性。</span><span class="sxs-lookup"><span data-stu-id="60da3-154">With **LinkDemand**, any code that passes the test and can reference your code can potentially break security by allowing malicious code to call using the authorized code.</span></span> <span data-ttu-id="60da3-155">因此, 除非可以徹底避免所有可能的弱點, 否則請勿使用**LinkDemand** 。</span><span class="sxs-lookup"><span data-stu-id="60da3-155">Therefore, do not use **LinkDemand** unless all the possible weaknesses can be thoroughly avoided.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="60da3-156">在 .NET Framework 4 中, 連結要求已由元件中<xref:System.Security.SecurityCriticalAttribute> <xref:System.Security.SecurityRuleSet.Level2>的屬性所取代。</span><span class="sxs-lookup"><span data-stu-id="60da3-156">In the .NET Framework 4, link demands have been replaced by the <xref:System.Security.SecurityCriticalAttribute> attribute in <xref:System.Security.SecurityRuleSet.Level2> assemblies.</span></span> <span data-ttu-id="60da3-157"><xref:System.Security.SecurityCriticalAttribute>相當於完全信任的連結要求; 不過, 它也會影響繼承規則。</span><span class="sxs-lookup"><span data-stu-id="60da3-157">The <xref:System.Security.SecurityCriticalAttribute> is equivalent to a link demand for full trust; however, it also affects inheritance rules.</span></span> <span data-ttu-id="60da3-158">如需這種變更的詳細資訊, 請參閱[安全性透明程式碼, 層級 2](../../../docs/framework/misc/security-transparent-code-level-2.md)。</span><span class="sxs-lookup"><span data-stu-id="60da3-158">For more information about this change, see [Security-Transparent Code, Level 2](../../../docs/framework/misc/security-transparent-code-level-2.md).</span></span>  
  
 <span data-ttu-id="60da3-159">使用**LinkDemand**時所需的額外預防措施必須個別進行設計;安全性系統有助於強制執行。</span><span class="sxs-lookup"><span data-stu-id="60da3-159">The extra precautions required when using **LinkDemand** must be programmed individually; the security system can help with enforcement.</span></span> <span data-ttu-id="60da3-160">任何錯誤都可能會導致出現安全性弱點。</span><span class="sxs-lookup"><span data-stu-id="60da3-160">Any mistake opens a security weakness.</span></span> <span data-ttu-id="60da3-161">使用您程式碼的所有授權程式碼都必須負責執行下列作業，以實作額外的安全性：</span><span class="sxs-lookup"><span data-stu-id="60da3-161">All authorized code that uses your code must be responsible for implementing additional security by doing the following:</span></span>  
  
- <span data-ttu-id="60da3-162">限制呼叫的程式碼對類別或組件的存取。</span><span class="sxs-lookup"><span data-stu-id="60da3-162">Restricting the calling code's access to the class or assembly.</span></span>  
  
- <span data-ttu-id="60da3-163">對呼叫的程式碼，套用出現在所呼叫之程式碼上的相同安全性檢查，並強制其呼叫端執行這項作業。</span><span class="sxs-lookup"><span data-stu-id="60da3-163">Placing the same security checks on the calling code that appear on the code being called and obligating its callers to do so.</span></span> <span data-ttu-id="60da3-164">例如, 如果您撰寫的程式碼會呼叫以的**LinkDemand**來保護的<xref:System.Security.Permissions.SecurityPermission>方法, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>並指定了旗標, 則您的方法也應該為此建立一個**linkdemand** (或更強的**需求**)許可權.</span><span class="sxs-lookup"><span data-stu-id="60da3-164">For example, if you write code that calls a method that is protected with a **LinkDemand** for the <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode> flag specified, your method should also make a **LinkDemand** (or **Demand**, which is stronger) for this permission.</span></span> <span data-ttu-id="60da3-165">例外狀況是, 如果您的程式碼以有限的方式使用受**LinkDemand**保護的方法, 但您在程式碼中指定了其他安全性保護機制 (例如要求), 則會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="60da3-165">The exception is if your code uses the **LinkDemand**-protected method in a limited way that you decide is safe, given other security protection mechanisms (such as demands) in your code.</span></span> <span data-ttu-id="60da3-166">在這種例外狀況下，呼叫端會導致基礎程式碼的安全性保護變弱。</span><span class="sxs-lookup"><span data-stu-id="60da3-166">In this exceptional case, the caller takes responsibility in weakening the security protection on the underlying code.</span></span>  
  
- <span data-ttu-id="60da3-167">確保您程式碼的呼叫端無法引誘您的程式碼代表呼叫端呼叫受保護的程式碼。</span><span class="sxs-lookup"><span data-stu-id="60da3-167">Ensuring that your code's callers cannot trick your code into calling the protected code on their behalf.</span></span> <span data-ttu-id="60da3-168">換句話說，呼叫端無法強制授權程式碼將特定參數傳遞給受保護的程式碼，或從中傳回結果。</span><span class="sxs-lookup"><span data-stu-id="60da3-168">In other words, callers cannot force the authorized code to pass specific parameters to the protected code, or to get results back from it.</span></span>  
  
### <a name="interfaces-and-link-demands"></a><span data-ttu-id="60da3-169">介面和連結要求</span><span class="sxs-lookup"><span data-stu-id="60da3-169">Interfaces and Link Demands</span></span>  
 <span data-ttu-id="60da3-170">如果具有**LinkDemand**的虛擬方法、屬性或事件會覆寫基類方法, 則基類方法也必須具有相同的**linkdemand** , 才能讓覆寫的方法生效。</span><span class="sxs-lookup"><span data-stu-id="60da3-170">If a virtual method, property, or event with **LinkDemand** overrides a base class method, the base class method must also have the same **LinkDemand** for the overridden method in order to be effective.</span></span> <span data-ttu-id="60da3-171">惡意程式碼可能會轉換回基底類型，並呼叫基底類別方法。</span><span class="sxs-lookup"><span data-stu-id="60da3-171">It is possible for malicious code to cast back to the base type and call the base class method.</span></span> <span data-ttu-id="60da3-172">另請注意，連結要求可以隱含加入沒有 <xref:System.Security.AllowPartiallyTrustedCallersAttribute> 組件層級屬性的組件。</span><span class="sxs-lookup"><span data-stu-id="60da3-172">Also note that link demands can be added implicitly to assemblies that do not have the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> assembly-level attribute.</span></span>  
  
 <span data-ttu-id="60da3-173">最佳做法是在介面方法也有連結要求時，使用連結要求來保護方法實作。</span><span class="sxs-lookup"><span data-stu-id="60da3-173">It is a good practice to protect method implementations with link demands when interface methods also have link demands.</span></span> <span data-ttu-id="60da3-174">請注意下列有關搭配介面使用連結要求的資訊：</span><span class="sxs-lookup"><span data-stu-id="60da3-174">Note the following about using link demands with interfaces:</span></span>  
  
- <span data-ttu-id="60da3-175">如果您將**LinkDemand**放在執行介面方法之類別的公用方法上, 則當您接著轉型為介面並呼叫方法時, 不會強制執行**linkdemand** 。</span><span class="sxs-lookup"><span data-stu-id="60da3-175">If you place a **LinkDemand** on a public method of a class that implements an interface method, the **LinkDemand** will not be enforced if you then cast to the interface and call the method.</span></span> <span data-ttu-id="60da3-176">在此情況下, 因為您是根據介面來連結, 所以只接受介面上的**LinkDemand** 。</span><span class="sxs-lookup"><span data-stu-id="60da3-176">In this case, because you linked against the interface, only the **LinkDemand** on the interface is honored.</span></span>  
  
 <span data-ttu-id="60da3-177">請檢閱下列安全性問題項目：</span><span class="sxs-lookup"><span data-stu-id="60da3-177">Review the following items for security issues:</span></span>  
  
- <span data-ttu-id="60da3-178">介面方法上的明確連結要求。</span><span class="sxs-lookup"><span data-stu-id="60da3-178">Explicit link demands on interface methods.</span></span> <span data-ttu-id="60da3-179">確定這些連結要求提供預期的保護。</span><span class="sxs-lookup"><span data-stu-id="60da3-179">Make sure these link demands offer the expected protection.</span></span> <span data-ttu-id="60da3-180">判斷惡意程式碼是否可以使用轉型來避開上述的連結要求。</span><span class="sxs-lookup"><span data-stu-id="60da3-180">Determine whether malicious code can use a cast to get around the link demands as described previously.</span></span>  
  
- <span data-ttu-id="60da3-181">套用連結要求的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="60da3-181">Virtual methods with link demands applied.</span></span>  
  
- <span data-ttu-id="60da3-182">虛擬方法所實作的類型和介面。</span><span class="sxs-lookup"><span data-stu-id="60da3-182">Types and the interfaces they implement.</span></span> <span data-ttu-id="60da3-183">這些類型和介面應該一致地使用連結要求。</span><span class="sxs-lookup"><span data-stu-id="60da3-183">These should use link demands consistently.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="60da3-184">另請參閱</span><span class="sxs-lookup"><span data-stu-id="60da3-184">See also</span></span>

- [<span data-ttu-id="60da3-185">安全程式碼撰寫方針</span><span class="sxs-lookup"><span data-stu-id="60da3-185">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
