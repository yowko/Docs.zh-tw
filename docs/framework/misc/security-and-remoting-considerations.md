---
title: 安全性和遠端處理考量
ms.date: 03/30/2017
helpviewer_keywords:
- code security, remoting
- remoting, security
- security [.NET Framework], remoting
- secure coding, remoting
ms.assetid: 125d2ab8-55a4-4e5f-af36-a7d401a37ab0
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 2d4d3b009e5792685ea39a3bcc2a15e082e1b8de
ms.sourcegitcommit: 2d792961ed48f235cf413d6031576373c3050918
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/31/2019
ms.locfileid: "70206092"
---
# <a name="security-and-remoting-considerations"></a><span data-ttu-id="9f371-102">安全性和遠端處理考量</span><span class="sxs-lookup"><span data-stu-id="9f371-102">Security and Remoting Considerations</span></span>
<span data-ttu-id="9f371-103">遠端處理可讓您設定應用程式定義域、處理序或電腦之間的透明呼叫。</span><span class="sxs-lookup"><span data-stu-id="9f371-103">Remoting allows you to set up transparent calling between application domains, processes, or computers.</span></span> <span data-ttu-id="9f371-104">不過，程式碼存取安全性堆疊查核行程無法跨處理序或電腦界限 (只會在同一個處理序的不同應用程式定義域之間套用)。</span><span class="sxs-lookup"><span data-stu-id="9f371-104">However, the code access security stack walk cannot cross process or machine boundaries (it does apply between application domains of the same process).</span></span>  
  
 <span data-ttu-id="9f371-105">所有可遠端處理的類別 (衍生自 <xref:System.MarshalByRefObject> 類別) 都必須確保安全。</span><span class="sxs-lookup"><span data-stu-id="9f371-105">Any class that is remotable (derived from a <xref:System.MarshalByRefObject> class) needs to take responsibility for security.</span></span> <span data-ttu-id="9f371-106">程式碼應該只在可隱含信任呼叫端程式碼的封閉式環境中使用，或者遠端處理呼叫的設計方式，應該使受保護的程式碼不容易遭到惡意使用之外部項目的攻擊。</span><span class="sxs-lookup"><span data-stu-id="9f371-106">Either the code should be used only in closed environments where the calling code can be implicitly trusted, or remoting calls should be designed so that they do not subject protected code to outside entry that could be used maliciously.</span></span>  
  
 <span data-ttu-id="9f371-107">一般來說, 您絕對不應該公開受宣告式[LinkDemand](link-demands.md)和<xref:System.Security.Permissions.SecurityAction.InheritanceDemand>安全性檢查保護的方法、屬性或事件。</span><span class="sxs-lookup"><span data-stu-id="9f371-107">Generally, you should never expose methods, properties, or events that are protected by declarative [LinkDemand](link-demands.md) and <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> security checks.</span></span> <span data-ttu-id="9f371-108">進行遠端處理時，系統不會強制執行這些檢查。</span><span class="sxs-lookup"><span data-stu-id="9f371-108">With remoting, these checks are not enforced.</span></span> <span data-ttu-id="9f371-109">其他安全性檢查 (例如<xref:System.Security.Permissions.SecurityAction.Demand>、 [Assert](using-the-assert-method.md)等) 可在進程內的應用程式域之間執行, 但不能在跨進程或跨電腦的情況下使用。</span><span class="sxs-lookup"><span data-stu-id="9f371-109">Other security checks, such as <xref:System.Security.Permissions.SecurityAction.Demand>, [Assert](using-the-assert-method.md), and so on, work between application domains within a process but do not work in cross-process or cross-machine scenarios.</span></span>  
  
## <a name="protected-objects"></a><span data-ttu-id="9f371-110">受保護的物件</span><span class="sxs-lookup"><span data-stu-id="9f371-110">Protected objects</span></span>  
 <span data-ttu-id="9f371-111">某些物件本身有安全性狀態。</span><span class="sxs-lookup"><span data-stu-id="9f371-111">Some objects hold security state in themselves.</span></span> <span data-ttu-id="9f371-112">這些物件不應該傳遞至不受信任的程式碼，這類程式碼可能會接著取得超出其所有權限的安全性授權。</span><span class="sxs-lookup"><span data-stu-id="9f371-112">These objects should not be passed to untrusted code, which would then acquire security authorization beyond its own permissions.</span></span>  
  
 <span data-ttu-id="9f371-113">建立 <xref:System.IO.FileStream> 物件即為一例。</span><span class="sxs-lookup"><span data-stu-id="9f371-113">One example is creating a <xref:System.IO.FileStream> object.</span></span> <span data-ttu-id="9f371-114">建立該物件時需要 <xref:System.Security.Permissions.FileIOPermission>；如果成功，則會傳回檔案物件。</span><span class="sxs-lookup"><span data-stu-id="9f371-114">The <xref:System.Security.Permissions.FileIOPermission> is demanded at the time of creation and, if it succeeds, the file object is returned.</span></span> <span data-ttu-id="9f371-115">不過，如果在未提供檔案權限的情況下，將這個物件參考傳遞至程式碼，則能夠從這個特定檔案讀取物件並將物件寫入檔案。</span><span class="sxs-lookup"><span data-stu-id="9f371-115">However, if this object reference is passed to code without file permissions, the object will be able to read and write to this particular file.</span></span>  
  
 <span data-ttu-id="9f371-116">這類物件最簡單的防禦, 就是要求任何程式碼的相同**FileIOPermission** , 以透過公用 API 元素取得物件參考。</span><span class="sxs-lookup"><span data-stu-id="9f371-116">The simplest defense for such an object is to demand the same **FileIOPermission** of any code that seeks to get the object reference through a public API element.</span></span>  
  
## <a name="application-domain-crossing-issues"></a><span data-ttu-id="9f371-117">跨應用程式定義域的問題</span><span class="sxs-lookup"><span data-stu-id="9f371-117">Application domain crossing issues</span></span>  
 <span data-ttu-id="9f371-118">若要將程式碼隔離到 Managed 裝載環境中，通常會產生多個子應用程式定義域，這些應用程式定義域具有降低各種組件之權限層級的明確原則。</span><span class="sxs-lookup"><span data-stu-id="9f371-118">To isolate code in managed hosting environments, it is common to generate multiple child application domains with explicit policy reducing the permission levels for various assemblies.</span></span> <span data-ttu-id="9f371-119">不過，這些組件的原則在預設應用程式定義域中會保持不變。</span><span class="sxs-lookup"><span data-stu-id="9f371-119">However, the policy for those assemblies remains unchanged in the default application domain.</span></span> <span data-ttu-id="9f371-120">如果其中一個子應用程式定義域可強制預設應用程式定義域載入組件，則會失去程式碼隔離的效果，而且強制載入之組件中的類型將能夠在較高的信任層級執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="9f371-120">If one of the child application domains can force the default application domain to load an assembly, the effect of code isolation is lost and types in the forcibly loaded assembly will be able to run code at a higher level of trust.</span></span>  
  
 <span data-ttu-id="9f371-121">應用程式定義域可強制另一個應用程式定義域載入組件，並透過呼叫另一個應用程式定義域所裝載的物件 Proxy，來執行包含在組件中的程式碼。</span><span class="sxs-lookup"><span data-stu-id="9f371-121">An application domain can force another application domain to load an assembly and run code contained therein by calling a proxy to an object hosted in the other application domain.</span></span> <span data-ttu-id="9f371-122">若要取得跨應用程式定義域的 Proxy，裝載該物件的應用程式定義域必須透過方法呼叫參數或傳回值來發佈一個 Proxy。</span><span class="sxs-lookup"><span data-stu-id="9f371-122">To obtain a cross-application-domain proxy, the application domain hosting the object must distribute one through a method call parameter or return value.</span></span> <span data-ttu-id="9f371-123">或者，如果剛建立應用程式定義域，則建立者預設會有 <xref:System.AppDomain> 物件的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="9f371-123">Or, if the application domain was just created, the creator has a proxy to the <xref:System.AppDomain> object by default.</span></span> <span data-ttu-id="9f371-124">因此，為了避免破壞程式碼隔離，信任層級較高的應用程式定義域不應該將以傳址方式封送處理的物件參考 (衍生自 <xref:System.MarshalByRefObject> 的類別執行個體)，從其定義域散發到信任層級較低的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="9f371-124">Thus, to avoid breaking code isolation, an application domain with a higher level of trust should not distribute references to marshaled-by-reference objects (instances of classes derived from <xref:System.MarshalByRefObject>) in its domain to application domains with lower levels of trust.</span></span>  
  
 <span data-ttu-id="9f371-125">預設應用程式定義域在建立子應用程式定義域時，通常會在每個子應用程式定義域中包含一個控制項物件。</span><span class="sxs-lookup"><span data-stu-id="9f371-125">Usually, the default application domain creates the child application domains with a control object in each one.</span></span> <span data-ttu-id="9f371-126">這個控制項物件會管理新的應用程式定義域，有時會接受來自預設應用程式定義域的命令，但實際上不會直接連絡定義域。</span><span class="sxs-lookup"><span data-stu-id="9f371-126">The control object manages the new application domain and occasionally takes orders from the default application domain, but it cannot actually contact the domain directly.</span></span> <span data-ttu-id="9f371-127">預設應用程式定義域有時會對控制項物件呼叫其 Proxy。</span><span class="sxs-lookup"><span data-stu-id="9f371-127">Occasionally, the default application domain calls its proxy to the control object.</span></span> <span data-ttu-id="9f371-128">不過也有些情況，必須對預設應用程式定義域回呼控制項物件。</span><span class="sxs-lookup"><span data-stu-id="9f371-128">However, there might be cases in which it is necessary for the control object to call back to the default application domain.</span></span> <span data-ttu-id="9f371-129">在這些情況下，預設應用程式定義域會將以傳址方式封送處理的回呼物件，傳遞給控制項物件的建構函式。</span><span class="sxs-lookup"><span data-stu-id="9f371-129">In these cases, the default application domain passes a marshal-by-reference callback object to the constructor of the control object.</span></span> <span data-ttu-id="9f371-130">再由控制項物件負責保護這個 Proxy。</span><span class="sxs-lookup"><span data-stu-id="9f371-130">It is the responsibility of the control object to protect this proxy.</span></span> <span data-ttu-id="9f371-131">如果控制項物件將 Proxy 放在公用類別的公用靜態欄位上，或公開 Proxy，可能會危害機制，導致對預設應用程式定義域回呼其他程式碼。</span><span class="sxs-lookup"><span data-stu-id="9f371-131">If the control object were to place the proxy on a public static field of a public class, or otherwise publicly expose the proxy, this would open up a dangerous mechanism for other code to call back into the default application domain.</span></span> <span data-ttu-id="9f371-132">因此，控制項物件一律會受到隱含信任，以保密 Proxy。</span><span class="sxs-lookup"><span data-stu-id="9f371-132">For this reason, control objects are always implicitly trusted to keep the proxy private.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9f371-133">另請參閱</span><span class="sxs-lookup"><span data-stu-id="9f371-133">See also</span></span>

- [<span data-ttu-id="9f371-134">安全程式碼撰寫方針</span><span class="sxs-lookup"><span data-stu-id="9f371-134">Secure Coding Guidelines</span></span>](../../standard/security/secure-coding-guidelines.md)
