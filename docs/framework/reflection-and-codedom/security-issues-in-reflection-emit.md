---
title: 反映發出中的安全性問題
ms.date: 03/30/2017
helpviewer_keywords:
- partially trusted code
- emitting dynamic assemblies, security
- reflection emit, security
- reflection emit, partial trust scenarios
- partial trust,emitting dynamic methods
- anonymously hosted dynamic methods [.NET Framework]
- emitting dynamic assemblies,partial trust scenarios
- dynamic assemblies, security
ms.assetid: 0f8bf8fa-b993-478f-87ab-1a1a7976d298
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 57db77b64ddcbe282fed035b52bb122901383ca4
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
ms.locfileid: "33398868"
---
# <a name="security-issues-in-reflection-emit"></a><span data-ttu-id="97cd2-102">反映發出中的安全性問題</span><span class="sxs-lookup"><span data-stu-id="97cd2-102">Security Issues in Reflection Emit</span></span>
<span data-ttu-id="97cd2-103">[!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 提供三種發出 Microsoft 中繼語言 (MSIL) 的方式，每種都有它自己的安全性問題：</span><span class="sxs-lookup"><span data-stu-id="97cd2-103">The [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] provides three ways to emit Microsoft intermediate language (MSIL), each with its own security issues:</span></span>  
  
-   [<span data-ttu-id="97cd2-104">動態組件</span><span class="sxs-lookup"><span data-stu-id="97cd2-104">Dynamic assemblies</span></span>](#Dynamic_Assemblies)  
  
-   [<span data-ttu-id="97cd2-105">匿名裝載的動態方法</span><span class="sxs-lookup"><span data-stu-id="97cd2-105">Anonymously hosted dynamic methods</span></span>](#Anonymously_Hosted_Dynamic_Methods)  
  
-   [<span data-ttu-id="97cd2-106">與現有組件建立關聯的動態方法</span><span class="sxs-lookup"><span data-stu-id="97cd2-106">Dynamic methods associated with existing assemblies</span></span>](#Dynamic_Methods_Associated_with_Existing_Assemblies)  
  
 <span data-ttu-id="97cd2-107">無論您產生動態程式碼的方式為何，執行產生的程式碼需要所有權限，這些是產生的程式碼所使用之類型和方法所需的。</span><span class="sxs-lookup"><span data-stu-id="97cd2-107">Regardless of the way you generate dynamic code, executing the generated code requires all the permissions that are required by the types and methods the generated code uses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="97cd2-108">反映在程式碼上以及發出程式碼所需的權限已在 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 的後續發行中變更。</span><span class="sxs-lookup"><span data-stu-id="97cd2-108">The permissions that are required for reflecting on code and emitting code have changed with succeeding releases of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="97cd2-109">請參閱本主題稍後的[版本資訊](#Version_Information)。</span><span class="sxs-lookup"><span data-stu-id="97cd2-109">See [Version Information](#Version_Information), later in this topic.</span></span>  
  
<a name="Dynamic_Assemblies"></a>   
## <a name="dynamic-assemblies"></a><span data-ttu-id="97cd2-110">動態組件</span><span class="sxs-lookup"><span data-stu-id="97cd2-110">Dynamic Assemblies</span></span>  
 <span data-ttu-id="97cd2-111">使用 <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType> 方法的多載來建立動態組件。</span><span class="sxs-lookup"><span data-stu-id="97cd2-111">Dynamic assemblies are created by using overloads of the <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="97cd2-112">由於刪除全機器安全性原則，這個方法的大部分多載已在 [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)] 中遭取代。</span><span class="sxs-lookup"><span data-stu-id="97cd2-112">Most overloads of this method are deprecated in the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], because of the elimination of machine-wide security policy.</span></span> <span data-ttu-id="97cd2-113">(請參閱[安全性變更](../../../docs/framework/security/security-changes.md)。)無論信任層級為何，剩餘的多載可由任何程式碼執行。</span><span class="sxs-lookup"><span data-stu-id="97cd2-113">(See [Security Changes](../../../docs/framework/security/security-changes.md).) The remaining overloads can be executed by any code, regardless of trust level.</span></span> <span data-ttu-id="97cd2-114">這些多載可分為兩個群組：當建立動態組件時，指定要套用至動態組件的屬性清單，以及不套用至動態組件的屬性清單。</span><span class="sxs-lookup"><span data-stu-id="97cd2-114">These overloads fall into two groups: those that specify a list of attributes to apply to the dynamic assembly when it is created, and those that do not.</span></span> <span data-ttu-id="97cd2-115">當您建立組件時，如果您未套用 <xref:System.Security.SecurityRulesAttribute> 屬性來指定組件的透明度模型，則透明度模型會繼承自發出的組件。</span><span class="sxs-lookup"><span data-stu-id="97cd2-115">If you do not specify the transparency model for the assembly, by applying the <xref:System.Security.SecurityRulesAttribute> attribute when you create it, the transparency model is inherited from the emitting assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="97cd2-116">動態組件建立後，使用 <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> 方法套用至動態組件的屬性並不會生效，直到組件已儲存至磁碟並再次載入記憶體中。</span><span class="sxs-lookup"><span data-stu-id="97cd2-116">Attributes that you apply to the dynamic assembly after it is created, by using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method, do not take effect until the assembly has been saved to disk and loaded into memory again.</span></span>  
  
 <span data-ttu-id="97cd2-117">動態組件中的程式碼可以存取可見的類型和其他組件中的成員。</span><span class="sxs-lookup"><span data-stu-id="97cd2-117">Code in a dynamic assembly can access visible types and members in other assemblies.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="97cd2-118">動態組件不使用允許存取非公用類型和成員之動態方法的 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標。</span><span class="sxs-lookup"><span data-stu-id="97cd2-118">Dynamic assemblies do not use the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> and <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flags that allow dynamic methods to access nonpublic types and members.</span></span>  
  
 <span data-ttu-id="97cd2-119">暫時性動態組件會在記憶體中建立，並永遠不會儲存到磁碟，所以它們不需要檔案存取權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-119">Transient dynamic assemblies are created in memory and never saved to disk, so they require no file access permissions.</span></span> <span data-ttu-id="97cd2-120">儲存動態組件至磁碟需要具有適當旗標的 <xref:System.Security.Permissions.FileIOPermission>。</span><span class="sxs-lookup"><span data-stu-id="97cd2-120">Saving a dynamic assembly to disk requires <xref:System.Security.Permissions.FileIOPermission> with the appropriate flags.</span></span>  
  
### <a name="generating-dynamic-assemblies-from-partially-trusted-code"></a><span data-ttu-id="97cd2-121">從部分信任的程式碼產生動態組件</span><span class="sxs-lookup"><span data-stu-id="97cd2-121">Generating Dynamic Assemblies from Partially Trusted Code</span></span>  
 <span data-ttu-id="97cd2-122">請考慮具有網際網路權限的組件可產生暫時性動態組件並執行其程式碼的條件：</span><span class="sxs-lookup"><span data-stu-id="97cd2-122">Consider the conditions in which an assembly with Internet permissions can generate a transient dynamic assembly and execute its code:</span></span>  
  
-   <span data-ttu-id="97cd2-123">動態組件只會使用公用類型和其他組件的成員。</span><span class="sxs-lookup"><span data-stu-id="97cd2-123">The dynamic assembly uses only public types and members of other assemblies.</span></span>  
  
-   <span data-ttu-id="97cd2-124">在部分信任組件的授權集中包含這些類型和成員所要求的權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-124">The permissions demanded by those types and members are included in the grant set of the partially trusted assembly.</span></span>  
  
-   <span data-ttu-id="97cd2-125">該組件不會儲存到磁碟。</span><span class="sxs-lookup"><span data-stu-id="97cd2-125">The assembly is not saved to disk.</span></span>  
  
-   <span data-ttu-id="97cd2-126">不會產生偵錯符號。</span><span class="sxs-lookup"><span data-stu-id="97cd2-126">Debug symbols are not generated.</span></span> <span data-ttu-id="97cd2-127">(`Internet` 和 `LocalIntranet` 權限集合不包含必要的權限。)</span><span class="sxs-lookup"><span data-stu-id="97cd2-127">(`Internet` and `LocalIntranet` permission sets do not include the necessary permissions.)</span></span>  
  
<a name="Anonymously_Hosted_Dynamic_Methods"></a>   
## <a name="anonymously-hosted-dynamic-methods"></a><span data-ttu-id="97cd2-128">匿名裝載的動態方法</span><span class="sxs-lookup"><span data-stu-id="97cd2-128">Anonymously Hosted Dynamic Methods</span></span>  
 <span data-ttu-id="97cd2-129">匿名裝載的動態方法可用兩個 <xref:System.Reflection.Emit.DynamicMethod> 建構函式建立，該函式並未指定相關聯的類型或模組、<xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%29> 和 <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>。</span><span class="sxs-lookup"><span data-stu-id="97cd2-129">Anonymously hosted dynamic methods are created by using the two <xref:System.Reflection.Emit.DynamicMethod> constructors that do not specify an associated type or module, <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%29> and <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="97cd2-130">這些建構函式會將動態方法置於系統提供、完全受信任的安全性透明組件中。</span><span class="sxs-lookup"><span data-stu-id="97cd2-130">These constructors place the dynamic methods in a system-provided, fully trusted, security-transparent assembly.</span></span> <span data-ttu-id="97cd2-131">使用這些建構函式，或發出動態方法的程式碼不需要權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-131">No permissions are required to use these constructors or to emit code for the dynamic methods.</span></span>  
  
 <span data-ttu-id="97cd2-132">相反地，當建立匿名裝載的動態方法時，會擷取呼叫堆疊。</span><span class="sxs-lookup"><span data-stu-id="97cd2-132">Instead, when an anonymously hosted dynamic method is created, the call stack is captured.</span></span> <span data-ttu-id="97cd2-133">當建構方法時，會對已擷取的呼叫堆疊提出安全性要求。</span><span class="sxs-lookup"><span data-stu-id="97cd2-133">When the method is constructed, security demands are made against the captured call stack.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="97cd2-134">就觀念上而言，會在方法建構期間提出要求。</span><span class="sxs-lookup"><span data-stu-id="97cd2-134">Conceptually, demands are made during the construction of the method.</span></span> <span data-ttu-id="97cd2-135">也就是當發出每個 MSIL 指示時，可提出要求。</span><span class="sxs-lookup"><span data-stu-id="97cd2-135">That is, demands could be made as each MSIL instruction is emitted.</span></span> <span data-ttu-id="97cd2-136">在目前的實作中，當 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A?displayProperty=nameWithType> 方法被呼叫，或是當 Just-In-Time (JIT) 編譯器被叫用時，如果此方法被叫用卻沒有呼叫 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>，就會提出所有的要求。</span><span class="sxs-lookup"><span data-stu-id="97cd2-136">In the current implementation, all demands are made when the <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A?displayProperty=nameWithType> method is called or when the just-in-time (JIT) compiler is invoked, if the method is invoked without calling <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>.</span></span>  
  
 <span data-ttu-id="97cd2-137">如果應用程式定義域允許，則匿名裝載的動態方法可以跳過 JIT 可見度檢查，且受下列限制：由匿名裝載的動態方法存取的非公用類型和成員必須位於組件中，且該組件的授權集與發出呼叫堆疊的授權集相等，或是為其子集。</span><span class="sxs-lookup"><span data-stu-id="97cd2-137">If the application domain permits it, anonymously hosted dynamic methods can skip JIT visibility checks, subject to the following restriction: The nonpublic types and members accessed by an anonymously hosted dynamic method must be in assemblies whose grant sets are equal to, or subsets of, the grant set of the emitting call stack.</span></span> <span data-ttu-id="97cd2-138">如果應用程式定義域對 <xref:System.Security.Permissions.ReflectionPermission> 授與 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標，則會啟用這項跳過 JIT 可見度檢查的限制功能。</span><span class="sxs-lookup"><span data-stu-id="97cd2-138">This restricted ability to skip JIT visibility checks is enabled if the application domain grants <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
-   <span data-ttu-id="97cd2-139">如果您的方法只使用公用類型和成員，則在建構期間不需要權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-139">If your method uses only public types and members, no permissions are required during construction.</span></span>  
  
-   <span data-ttu-id="97cd2-140">如果您指定 JIT 可見度檢查應該要跳過，則在建構方法時提出的要求會包含具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>以及包含正在存取非公用成員之組件的授權集。</span><span class="sxs-lookup"><span data-stu-id="97cd2-140">If you specify that JIT visibility checks should be skipped, the demand that is made when the method is constructed includes <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and the grant set of the assembly that contains the nonpublic member that is being accessed.</span></span>  
  
 <span data-ttu-id="97cd2-141">因為非公用成員的授權集已納入考慮，所以已授與 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 的部分信任程式碼無法藉由執行受信任組件的非公用成員來提高權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-141">Because the grant set of the nonpublic member is taken into consideration, partially trusted code that has been granted <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> cannot elevate its privileges by executing nonpublic members of trusted assemblies.</span></span>  
  
 <span data-ttu-id="97cd2-142">與任何其他發出程式碼一樣，執行動態方法需要動態方法所使用之方法要求的任何權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-142">As with any other emitted code, executing the dynamic method requires whatever permissions are demanded by the methods the dynamic method uses.</span></span>  
  
 <span data-ttu-id="97cd2-143">裝載匿名裝載動態方法的系統組件會使用 <xref:System.Security.SecurityRuleSet.Level1?displayProperty=nameWithType> 透明度模型，這是在 [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] 之前的 .NET Framework 中所使用的透明度模型 。</span><span class="sxs-lookup"><span data-stu-id="97cd2-143">The system assembly that hosts anonymously-hosted dynamic methods uses the <xref:System.Security.SecurityRuleSet.Level1?displayProperty=nameWithType> transparency model, which is the transparency model that was used in the .NET Framework before the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)].</span></span>  
  
 <span data-ttu-id="97cd2-144">如需詳細資訊，請參閱 <xref:System.Reflection.Emit.DynamicMethod> 類別。</span><span class="sxs-lookup"><span data-stu-id="97cd2-144">For more information, see the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
### <a name="generating-anonymously-hosted-dynamic-methods-from-partially-trusted-code"></a><span data-ttu-id="97cd2-145">從部分信任的程式碼產生匿名裝載的動態方法</span><span class="sxs-lookup"><span data-stu-id="97cd2-145">Generating Anonymously Hosted Dynamic Methods from Partially Trusted Code</span></span>  
 <span data-ttu-id="97cd2-146">請考慮具有網際網路權限的組件可產生匿名裝載的動態方法並予以執行的條件：</span><span class="sxs-lookup"><span data-stu-id="97cd2-146">Consider the conditions in which an assembly with Internet permissions can generate an anonymously hosted dynamic method and execute it:</span></span>  
  
-   <span data-ttu-id="97cd2-147">動態方法只會使用公用類型和成員。</span><span class="sxs-lookup"><span data-stu-id="97cd2-147">The dynamic method uses only public types and members.</span></span> <span data-ttu-id="97cd2-148">如果其授權集包含 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>，則它可以使用授權集為發出組件授權集子集或與其相等的任何組件之非公用類型與成員。</span><span class="sxs-lookup"><span data-stu-id="97cd2-148">If its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>, it can use nonpublic types and members of any assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly.</span></span>  
  
-   <span data-ttu-id="97cd2-149">部分信任組件的授權集包含動態方法所使用的所有類型及成員所需的權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-149">The permissions that are required by all the types and members used by the dynamic method are included in the grant set of the partially trusted assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="97cd2-150">動態方法並不支援偵錯符號。</span><span class="sxs-lookup"><span data-stu-id="97cd2-150">Dynamic methods do not support debug symbols.</span></span>  
  
<a name="Dynamic_Methods_Associated_with_Existing_Assemblies"></a>   
## <a name="dynamic-methods-associated-with-existing-assemblies"></a><span data-ttu-id="97cd2-151">與現有組件相關聯的動態方法</span><span class="sxs-lookup"><span data-stu-id="97cd2-151">Dynamic Methods Associated with Existing Assemblies</span></span>  
 <span data-ttu-id="97cd2-152">若要將動態方法和現有組件中的類型或模組相關聯，請使用任何一種指定相關聯的類型或模組的 <xref:System.Reflection.Emit.DynamicMethod> 建構函式。</span><span class="sxs-lookup"><span data-stu-id="97cd2-152">To associate a dynamic method with a type or module in an existing assembly, use any of the <xref:System.Reflection.Emit.DynamicMethod> constructors that specify the associated type or module.</span></span> <span data-ttu-id="97cd2-153">呼叫這些建構函式所需的權限有所不同，因為將動態方法與現有類型或模組產生關聯會讓動態方法存取非公用類型和成員：</span><span class="sxs-lookup"><span data-stu-id="97cd2-153">The permissions that are required to call these constructors vary, because associating a dynamic method with an existing type or module gives the dynamic method access to nonpublic types and members:</span></span>  
  
-   <span data-ttu-id="97cd2-154">與類型相關聯的動態方法可以存取所有該類型的成員，甚至是私用成員，且能存取包含相關聯的類型之組件中的所有內部類型和成員。</span><span class="sxs-lookup"><span data-stu-id="97cd2-154">A dynamic method that is associated with a type has access to all members of that type, even private members, and to all internal types and members in the assembly that contains the associated type.</span></span>  
  
-   <span data-ttu-id="97cd2-155">與模組相關聯的動態方法可存取模組中所有 `internal` 類型和成員 (在 Visual Basic 中為 `Friend`，在 Common Language Runtime 中繼資料中為 `assembly`)。</span><span class="sxs-lookup"><span data-stu-id="97cd2-155">A dynamic method that is associated with a module has access to all the `internal` types and members (`Friend` in Visual Basic, `assembly` in common language runtime metadata) in the module.</span></span>  
  
 <span data-ttu-id="97cd2-156">此外，您可以使用會指定略過 JIT 編譯器可見度檢查能力的建構函式。</span><span class="sxs-lookup"><span data-stu-id="97cd2-156">In addition, you can use a constructor that specifies the ability to skip the visibility checks of the JIT compiler.</span></span> <span data-ttu-id="97cd2-157">這樣可讓您的動態方法在所有組件中存取所有類型和成員，不論存取層級為何。</span><span class="sxs-lookup"><span data-stu-id="97cd2-157">Doing so gives your dynamic method access to all types and members in all assemblies, regardless of access level.</span></span>  
  
 <span data-ttu-id="97cd2-158">建構函式所要求的權限取決於您決定要授與動態方法多少的存取權：</span><span class="sxs-lookup"><span data-stu-id="97cd2-158">The permissions demanded by the constructor depend on how much access you decide to give your dynamic method:</span></span>  
  
-   <span data-ttu-id="97cd2-159">如果您的方法只使用公用類型和成員，而且您將它和您自己的類型或模組產生關聯，則不需要任何權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-159">If your method uses only public types and members, and you associate it with your own type or your own module, no permissions are required.</span></span>  
  
-   <span data-ttu-id="97cd2-160">如果您指定應該略過 JIT 可見度檢查，則建構函式會要求具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="97cd2-160">If you specify that JIT visibility checks should be skipped, the constructor demands <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
-   <span data-ttu-id="97cd2-161">如果您將動態方法與其他類型產生關聯，甚至是在您自己的組件中的另一個類型，則建構函式會要求具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission> 和具有 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.SecurityPermission>。</span><span class="sxs-lookup"><span data-stu-id="97cd2-161">If you associate the dynamic method with another type, even another type in your own assembly, the constructor demands <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag and <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag.</span></span>  
  
-   <span data-ttu-id="97cd2-162">如果您將動態方法和其他組件中的類型或模組產生關聯，則建構函式會要求兩項事物：具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission> 及包含其他模組之組件的授權集。</span><span class="sxs-lookup"><span data-stu-id="97cd2-162">If you associate the dynamic method with a type or module in another assembly, the constructor demands two things: <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag, and the grant set of the assembly that contains the other module.</span></span> <span data-ttu-id="97cd2-163">也就是您的呼叫堆疊必須包含所有在目標模組授權集中的權限，加上 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="97cd2-163">That is, your call stack must include all the permissions in the grant set of the target module, plus <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="97cd2-164">為了回溯相容性，如果目標授權集加上 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 的要求失敗，則建構函式會要求具有 <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.SecurityPermission>。</span><span class="sxs-lookup"><span data-stu-id="97cd2-164">For backward compatibility, if the demand for the target grant set plus <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> fails, the constructor demands <xref:System.Security.Permissions.SecurityPermission> with the <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="97cd2-165">雖然這份清單中的項目係依據發出的組件之授權集而描述，請記得這會對完整呼叫堆疊提出需求，包含應用程式定義域界限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-165">Although the items in this list are described in terms of the grant set of the emitting assembly, remember that the demands are made against the full call stack, including the application domain boundary.</span></span>  
  
 <span data-ttu-id="97cd2-166">如需詳細資訊，請參閱 <xref:System.Reflection.Emit.DynamicMethod> 類別。</span><span class="sxs-lookup"><span data-stu-id="97cd2-166">For more information, see the <xref:System.Reflection.Emit.DynamicMethod> class.</span></span>  
  
### <a name="generating-dynamic-methods-from-partially-trusted-code"></a><span data-ttu-id="97cd2-167">從部分信任的程式碼產生動態方法</span><span class="sxs-lookup"><span data-stu-id="97cd2-167">Generating Dynamic Methods from Partially Trusted Code</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="97cd2-168">從部分信任的程式碼產生動態方法的建議方式是使用[匿名裝載的動態方法](#Anonymously_Hosted_Dynamic_Methods)。</span><span class="sxs-lookup"><span data-stu-id="97cd2-168">The recommended way to generate dynamic methods from partially trusted code is to use [anonymously hosted dynamic methods](#Anonymously_Hosted_Dynamic_Methods).</span></span>  
  
 <span data-ttu-id="97cd2-169">請考慮具有網際網路權限的組件可產生動態方法並予以執行的條件：</span><span class="sxs-lookup"><span data-stu-id="97cd2-169">Consider the conditions in which an assembly with Internet permissions can generate a dynamic method and execute it:</span></span>  
  
-   <span data-ttu-id="97cd2-170">與動態方法發出的模組或類型相關聯的動態方法，或是其授權集會包含 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>，且這會與組件中的模組相關聯，該組件的授權集為發出組件授權集子集或與其相等。</span><span class="sxs-lookup"><span data-stu-id="97cd2-170">Either the dynamic method is associated with the module or type that emits it, or its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> and it is associated with a module in an assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly.</span></span>  
  
-   <span data-ttu-id="97cd2-171">動態方法只會使用公用類型和成員。</span><span class="sxs-lookup"><span data-stu-id="97cd2-171">The dynamic method uses only public types and members.</span></span> <span data-ttu-id="97cd2-172">如果其授權集包含 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>，而且與組件中的模組相關聯，該組件的授權集為發出組件授權集子集或與其相等，則它可以在相關聯的模組中使用標示為 `internal` 的類型和成員 (在 Visual Basic 中為 `Friend`，在 Common Language Runtime 中繼資料中為 `assembly`)。</span><span class="sxs-lookup"><span data-stu-id="97cd2-172">If its grant set includes <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> and it is associated with a module in an assembly whose grant set is equal to, or a subset of, the grant set of the emitting assembly, it can use types and members marked `internal` (`Friend` in Visual Basic, `assembly` in common language runtime metadata) in the associated module.</span></span>  
  
-   <span data-ttu-id="97cd2-173">部分信任組件的授權集包含動態方法所使用的所有類型及成員所要求的權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-173">The permissions demanded by all the types and members used by the dynamic method are included in the grant set of the partially trusted assembly.</span></span>  
  
-   <span data-ttu-id="97cd2-174">該動態方法不會略過 JIT 可見度檢查。</span><span class="sxs-lookup"><span data-stu-id="97cd2-174">The dynamic method does not skip JIT visibility checks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="97cd2-175">動態方法並不支援偵錯符號。</span><span class="sxs-lookup"><span data-stu-id="97cd2-175">Dynamic methods do not support debug symbols.</span></span>  
  
<a name="Version_Information"></a>   
## <a name="version-information"></a><span data-ttu-id="97cd2-176">版本資訊</span><span class="sxs-lookup"><span data-stu-id="97cd2-176">Version Information</span></span>  
 <span data-ttu-id="97cd2-177">從 [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)] 開始，淘汰全機器的安全性原則，且安全性透明度變成預設強制機制。</span><span class="sxs-lookup"><span data-stu-id="97cd2-177">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], machine-wide security policy is eliminated and security transparency becomes the default enforcement mechanism.</span></span> <span data-ttu-id="97cd2-178">請參閱[安全性變更](../../../docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="97cd2-178">See [Security Changes](../../../docs/framework/security/security-changes.md).</span></span>  
  
 <span data-ttu-id="97cd2-179">從 [!INCLUDE[net_v20SP1_long](../../../includes/net-v20sp1-long-md.md)] 開始，當發出動態組件和動態方法時，不再需要具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="97cd2-179">Starting with the [!INCLUDE[net_v20SP1_long](../../../includes/net-v20sp1-long-md.md)], <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag is no longer required when emitting dynamic assemblies and dynamic methods.</span></span> <span data-ttu-id="97cd2-180">在所有舊版 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 中需要此旗標。</span><span class="sxs-lookup"><span data-stu-id="97cd2-180">This flag is required in all earlier versions of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="97cd2-181">根據預設，具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission> 包含在 `FullTrust` 和 `LocalIntranet` 具名權限集合，而不是 `Internet` 權限集合。</span><span class="sxs-lookup"><span data-stu-id="97cd2-181"><xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> flag is included by default in the `FullTrust` and `LocalIntranet` named permission sets, but not in the `Internet` permission set.</span></span> <span data-ttu-id="97cd2-182">因此，在舊版的 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 中，僅當程式庫執行針對 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> 的 <xref:System.Security.PermissionSet.Assert%2A> 時，程式庫才可搭配網際網路權限使用。</span><span class="sxs-lookup"><span data-stu-id="97cd2-182">Therefore, in earlier versions of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)], a library can be used with Internet permissions only if it executes an <xref:System.Security.PermissionSet.Assert%2A> for <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>.</span></span> <span data-ttu-id="97cd2-183">這類程式庫需要仔細的安全性檢閱，因為編碼錯誤可能會造成安全性漏洞。</span><span class="sxs-lookup"><span data-stu-id="97cd2-183">Such libraries require careful security review because coding errors could result in security holes.</span></span> <span data-ttu-id="97cd2-184">[!INCLUDE[net_v20SP1_short](../../../includes/net-v20sp1-short-md.md)] 允許在部分信任案例中發出程式碼，而不需提出任何安全性要求，因為產生的程式碼本質上並非有權限的作業。</span><span class="sxs-lookup"><span data-stu-id="97cd2-184">The [!INCLUDE[net_v20SP1_short](../../../includes/net-v20sp1-short-md.md)] allows code to be emitted in partial trust scenarios without issuing any security demands, because generating code is not inherently a privileged operation.</span></span> <span data-ttu-id="97cd2-185">也就是產生的程式碼之權限不會比發出程式碼的組件還多。</span><span class="sxs-lookup"><span data-stu-id="97cd2-185">That is, the generated code has no more permissions than the assembly that emits it.</span></span> <span data-ttu-id="97cd2-186">這可讓程式庫發出安全性透明的程式碼，並可免除 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit> 判斷提示的需要，這可簡化撰寫安全程式庫的工作。</span><span class="sxs-lookup"><span data-stu-id="97cd2-186">This allows libraries that emit code to be security transparent and removes the need to assert <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>, which simplifies the task of writing a secure library.</span></span>  
  
 <span data-ttu-id="97cd2-187">此外，[!INCLUDE[net_v20SP1_short](../../../includes/net-v20sp1-short-md.md)] 導入了 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> 旗標，用來從部分信任的動態方法中存取非公用類型和成員。</span><span class="sxs-lookup"><span data-stu-id="97cd2-187">In addition, the [!INCLUDE[net_v20SP1_short](../../../includes/net-v20sp1-short-md.md)] introduces the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag for accessing nonpublic types and members from partially trusted dynamic methods.</span></span> <span data-ttu-id="97cd2-188">對於會存取非公用類型和成員的動態方法，舊版的 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 需要 <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> 旗標；這是永遠不該授與部分信任程式碼的權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-188">Earlier versions of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] require the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag for dynamic methods that access nonpublic types and members; this is a permission that should never be granted to partially trusted code.</span></span>  
  
 <span data-ttu-id="97cd2-189">最後，[!INCLUDE[net_v20SP1_short](../../../includes/net-v20sp1-short-md.md)] 導入了匿名裝載的方法。</span><span class="sxs-lookup"><span data-stu-id="97cd2-189">Finally, the [!INCLUDE[net_v20SP1_short](../../../includes/net-v20sp1-short-md.md)] introduces anonymously hosted methods.</span></span>  
  
### <a name="obtaining-information-on-types-and-members"></a><span data-ttu-id="97cd2-190">取得類型和成員資訊</span><span class="sxs-lookup"><span data-stu-id="97cd2-190">Obtaining Information on Types and Members</span></span>  
 <span data-ttu-id="97cd2-191">從 [!INCLUDE[dnprdnlong](../../../includes/dnprdnlong-md.md)] 開始，取得非公用類型和成員的相關資訊不需要權限。</span><span class="sxs-lookup"><span data-stu-id="97cd2-191">Starting with the [!INCLUDE[dnprdnlong](../../../includes/dnprdnlong-md.md)], no permissions are required to obtain information about nonpublic types and members.</span></span> <span data-ttu-id="97cd2-192">反映會用來取得發出動態方法需要的資訊。</span><span class="sxs-lookup"><span data-stu-id="97cd2-192">Reflection is used to obtain information needed to emit dynamic methods.</span></span> <span data-ttu-id="97cd2-193">例如，<xref:System.Reflection.MethodInfo> 物件會用來發出方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="97cd2-193">For example, <xref:System.Reflection.MethodInfo> objects are used to emit method calls.</span></span> <span data-ttu-id="97cd2-194">舊版的 [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 需要具有 <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> 旗標的 <xref:System.Security.Permissions.ReflectionPermission>。</span><span class="sxs-lookup"><span data-stu-id="97cd2-194">Earlier versions of the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] require <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.TypeInformation?displayProperty=nameWithType> flag.</span></span> <span data-ttu-id="97cd2-195">如需詳細資訊，請參閱[反映的安全性考量](../../../docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="97cd2-195">For more information, see [Security Considerations for Reflection](../../../docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="97cd2-196">請參閱</span><span class="sxs-lookup"><span data-stu-id="97cd2-196">See Also</span></span>  
 [<span data-ttu-id="97cd2-197">反映的安全性考量</span><span class="sxs-lookup"><span data-stu-id="97cd2-197">Security Considerations for Reflection</span></span>](../../../docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)  
 [<span data-ttu-id="97cd2-198">發出動態方法和組件</span><span class="sxs-lookup"><span data-stu-id="97cd2-198">Emitting Dynamic Methods and Assemblies</span></span>](../../../docs/framework/reflection-and-codedom/emitting-dynamic-methods-and-assemblies.md)
