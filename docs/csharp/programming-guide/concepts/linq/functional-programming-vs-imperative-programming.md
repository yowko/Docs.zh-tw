---
title: 功能性程式設計與命令式程式設計的比較 (C#)
ms.date: 07/20/2015
ms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57
ms.openlocfilehash: 2b6a53943ea2363869530ae773c19a52b5578b56
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/28/2019
ms.locfileid: "64596711"
---
# <a name="functional-programming-vs-imperative-programming-c"></a><span data-ttu-id="b1d5c-102">功能性程式設計與命令式程式設計的比較 (C#)</span><span class="sxs-lookup"><span data-stu-id="b1d5c-102">Functional Programming vs. Imperative Programming (C#)</span></span>
<span data-ttu-id="b1d5c-103">本主題比較與對照功能性程式設計與更傳統的命令性 (程序性) 程式設計。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="b1d5c-104">功能性程式設計與命令式程式設計</span><span class="sxs-lookup"><span data-stu-id="b1d5c-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="b1d5c-105">明確建立「功能性程式設計」開發架構時，可支援解決問題的純功能性方法。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="b1d5c-106">功能性程式設計是一種「宣告式程式設計」。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="b1d5c-107">相較之下，多數主流語言 (包括物件導向程式設計 (OOP) 語言，例如 C#、Visual Basic、C++ 與 Java) 的設計主要支援「命令性」(程序性) 程式設計。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="b1d5c-108">利用命令性方法，開發人員可以撰寫詳細描寫電腦必須採取之步驟以達成目標的程式碼。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="b1d5c-109">這有時候稱為「演算法」程式設計。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="b1d5c-110">相較之下，功能性方法包含將問題撰寫成要執行的一組函式。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="b1d5c-111">您可以仔細定義每個函式的輸入，以及每個函式會傳回的東西。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="b1d5c-112">下表描述這兩種方法之間的幾項一般差異。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="b1d5c-113">特性</span><span class="sxs-lookup"><span data-stu-id="b1d5c-113">Characteristic</span></span>|<span data-ttu-id="b1d5c-114">命令性方法</span><span class="sxs-lookup"><span data-stu-id="b1d5c-114">Imperative approach</span></span>|<span data-ttu-id="b1d5c-115">功能性方法</span><span class="sxs-lookup"><span data-stu-id="b1d5c-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="b1d5c-116">程式設計人員焦點</span><span class="sxs-lookup"><span data-stu-id="b1d5c-116">Programmer focus</span></span>|<span data-ttu-id="b1d5c-117">如何執行工作 (演算法) 以及如何追蹤狀態的變更。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="b1d5c-118">想要的資訊與需要的轉換。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="b1d5c-119">狀態變更</span><span class="sxs-lookup"><span data-stu-id="b1d5c-119">State changes</span></span>|<span data-ttu-id="b1d5c-120">重要。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-120">Important.</span></span>|<span data-ttu-id="b1d5c-121">非存在。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-121">Non-existent.</span></span>|  
|<span data-ttu-id="b1d5c-122">執行的順序</span><span class="sxs-lookup"><span data-stu-id="b1d5c-122">Order of execution</span></span>|<span data-ttu-id="b1d5c-123">重要。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-123">Important.</span></span>|<span data-ttu-id="b1d5c-124">重要性低。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-124">Low importance.</span></span>|  
|<span data-ttu-id="b1d5c-125">主要流量控制</span><span class="sxs-lookup"><span data-stu-id="b1d5c-125">Primary flow control</span></span>|<span data-ttu-id="b1d5c-126">迴圈、條件與函式 (方法) 呼叫。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="b1d5c-127">函式呼叫，包括遞迴。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="b1d5c-128">主要操作單位</span><span class="sxs-lookup"><span data-stu-id="b1d5c-128">Primary manipulation unit</span></span>|<span data-ttu-id="b1d5c-129">結構或類別的執行個體。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-129">Instances of structures or classes.</span></span>|<span data-ttu-id="b1d5c-130">當做第一級物件與資料集合的函式。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="b1d5c-131">雖然多數語言的設計在於支援特定的程式設計開發架構，但許多一般的語言還是有足夠的彈性，可以支援多種開發架構。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="b1d5c-132">例如，包含函式指標的多數語言可用於確實支援功能性程式設計。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="b1d5c-133">此外，C# 加入明確的語言擴充功能，以支援功能性程式設計，包括 Lambda 運算式與型別推斷。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-133">Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="b1d5c-134">LINQ 技術是一種宣告式功能性程式設計。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="b1d5c-135">使用 XSLT 的功能性程式設計</span><span class="sxs-lookup"><span data-stu-id="b1d5c-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="b1d5c-136">許多 XSLT 開發人員都很熟悉純功能性方法。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="b1d5c-137">開發 XSLT 樣式表最有效的方式，就是將每個範本都視為可組合的隔離轉換。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="b1d5c-138">執行順序完全不重視。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="b1d5c-139">XSLT 不允許副作用 (除非執行程序性程式碼的溢出機制可以產生導致非純功能性的副作用)。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="b1d5c-140">不過，雖然 XSLT 是一個有效的工具，但是有些特性並不是最好的。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="b1d5c-141">例如，在 XML 中表示程式設計建構會使程式碼相當詳細，因此難以維護。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="b1d5c-142">同時，大量依賴流量控制遞迴可能會使程式碼難以讀取。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="b1d5c-143">如需 XSLT 的詳細資訊，請參閱 [XSLT 轉換](../../../../standard/data/xml/xslt-transformations.md)。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="b1d5c-144">不過，XSLT 已經證明使用純功能性方法將 XML 從一個組織結構轉換為另一個組織結構的值。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="b1d5c-145">包含 LINQ to XML 的純功能性程式設計類似於 XSLT 的許多方法。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="b1d5c-146">不過，LINQ to XML 和 C# 所引進的程式設計建構可讓您撰寫比 XSLT 更容易讀取與維護的純功能性轉換。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-146">However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="b1d5c-147">純虛擬函式的優點</span><span class="sxs-lookup"><span data-stu-id="b1d5c-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="b1d5c-148">實作功能性轉換做為純虛擬函式的主要原因是純虛擬函式是可組合的：也就是說，純虛擬函式是獨立的，而且沒有狀態 (Stateless)。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="b1d5c-149">這些特性帶來很多益處，包括：</span><span class="sxs-lookup"><span data-stu-id="b1d5c-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
- <span data-ttu-id="b1d5c-150">增加可讀性和可維護性。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-150">Increased readability and maintainability.</span></span> <span data-ttu-id="b1d5c-151">這是因為每個函式都是針對完成已知其引數的特定工作而設計。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="b1d5c-152">此函式不會依賴任何外部狀態。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-152">The function does not rely on any external state.</span></span>  
  
- <span data-ttu-id="b1d5c-153">反覆開發更容易。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-153">Easier reiterative development.</span></span> <span data-ttu-id="b1d5c-154">由於程式碼更容易重構，針對設計所做的變更通常也更容易實作。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="b1d5c-155">例如，假設您撰寫一個複雜的轉換，接著了解特定程式碼會在轉換中重複數次。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="b1d5c-156">如果您透過純虛擬方法重構，您可以隨意呼叫您的純虛擬方法，而不用擔心副作用。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
- <span data-ttu-id="b1d5c-157">測試與偵錯更容易。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-157">Easier testing and debugging.</span></span> <span data-ttu-id="b1d5c-158">純虛擬函式可以更輕易地接受獨立測試，因此，您可以利用一般值、有效的邊緣案例以及無效的邊緣案例撰寫呼叫純虛擬函式的測試程式碼。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="b1d5c-159">OOP 開發人員的轉換</span><span class="sxs-lookup"><span data-stu-id="b1d5c-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="b1d5c-160">在傳統的物件導向程式設計 (OOP) 中，多數開發人員都習慣以命令性/程序性的方式進行程式設計。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="b1d5c-161">若要切換到以純功能性方式開發，他們必須轉換其思考方式及其開發方法。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="b1d5c-162">為解決問題，OOP 開發人員會設計類別階層、著重於適當的封裝，以及根據類別合約思考。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="b1d5c-163">物件型別的行為與狀態是最重要的，而所提供的語言功能 (例如，類別、介面、繼承與多型 (Polymorphism)) 則用於處理這些考量。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="b1d5c-164">相較之下，功能性程式設計會考慮運算問題，做為評估資料集合之純功能性轉換的練習。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="b1d5c-165">功能性程式設計會避免狀態與可變動的資料，而強調函式的應用。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="b1d5c-166">幸而 C# 不需要完全跳到功能性程式設計，因為它同時支援命令性與功能性程式設計方法。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-166">Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="b1d5c-167">開發人員可以選擇哪個方法最適合特定的案例。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="b1d5c-168">事實上，程式通常會結合這兩種方法。</span><span class="sxs-lookup"><span data-stu-id="b1d5c-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b1d5c-169">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b1d5c-169">See also</span></span>

- [<span data-ttu-id="b1d5c-170">純功能性轉換簡介 (C#)</span><span class="sxs-lookup"><span data-stu-id="b1d5c-170">Introduction to Pure Functional Transformations (C#)</span></span>](../../../../csharp/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="b1d5c-171">XSLT 轉換</span><span class="sxs-lookup"><span data-stu-id="b1d5c-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="b1d5c-172">重構為純虛擬函式 (C#)</span><span class="sxs-lookup"><span data-stu-id="b1d5c-172">Refactoring Into Pure Functions (C#)</span></span>](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)
