---
title: "匿名類型 (C# 程式設計手冊)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- anonymous types [C#]
- C# Language, anonymous types
ms.assetid: 59c9d7a4-3b0e-475e-b620-0ab86c088e9b
caps.latest.revision: "28"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 24ebf1c98e14eaf74572a6143ea6865d89735a6e
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
# <a name="anonymous-types-c-programming-guide"></a><span data-ttu-id="4e51e-102">匿名類型 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="4e51e-102">Anonymous Types (C# Programming Guide)</span></span>
<span data-ttu-id="4e51e-103">匿名類型提供一個便利的方法，將一組唯讀屬性封裝成一個物件，而不需要事先明確定義類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-103">Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first.</span></span> <span data-ttu-id="4e51e-104">類型名稱會由編譯器產生，並且無法在原始程式碼層級使用。</span><span class="sxs-lookup"><span data-stu-id="4e51e-104">The type name is generated by the compiler and is not available at the source code level.</span></span> <span data-ttu-id="4e51e-105">每個屬性的類型會由編譯器推斷。</span><span class="sxs-lookup"><span data-stu-id="4e51e-105">The type of each property is inferred by the compiler.</span></span>  
  
 <span data-ttu-id="4e51e-106">您可以搭配物件初始設定式使用 [new](../../../csharp/language-reference/keywords/new.md) 運算子，來建立匿名型別。</span><span class="sxs-lookup"><span data-stu-id="4e51e-106">You create anonymous types by using the [new](../../../csharp/language-reference/keywords/new.md) operator together with an object initializer.</span></span> <span data-ttu-id="4e51e-107">如需物件初始設定式的詳細資訊，請參閱[物件和集合初始設定式](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)。</span><span class="sxs-lookup"><span data-stu-id="4e51e-107">For more information about object initializers, see [Object and Collection Initializers](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md).</span></span>  
  
 <span data-ttu-id="4e51e-108">下列範例顯示以兩個名為 `Amount` 和 `Message` 的屬性初始化的匿名類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-108">The following example shows an anonymous type that is initialized with two properties named `Amount` and `Message`.</span></span>  
  
```csharp  
var v = new { Amount = 108, Message = "Hello" };  
  
// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message);  
```  
  
 <span data-ttu-id="4e51e-109">您通常可以在查詢運算式的 [select](../../../csharp/language-reference/keywords/select-clause.md) 子句中使用匿名型別，以從來源序列中的每個物件傳回屬性子集。</span><span class="sxs-lookup"><span data-stu-id="4e51e-109">Anonymous types typically are used in the [select](../../../csharp/language-reference/keywords/select-clause.md) clause of a query expression to return a subset of the properties from each object in the source sequence.</span></span> <span data-ttu-id="4e51e-110">如需查詢的詳細資訊，請參閱 [LINQ 查詢運算式](../../../csharp/programming-guide/linq-query-expressions/index.md)。</span><span class="sxs-lookup"><span data-stu-id="4e51e-110">For more information about queries, see [LINQ Query Expressions](../../../csharp/programming-guide/linq-query-expressions/index.md).</span></span>  
  
 <span data-ttu-id="4e51e-111">匿名類型包含一個或多個公用唯讀屬性。</span><span class="sxs-lookup"><span data-stu-id="4e51e-111">Anonymous types contain one or more public read-only properties.</span></span> <span data-ttu-id="4e51e-112">其他類型的類別成員 (例如方法或事件) 則無效。</span><span class="sxs-lookup"><span data-stu-id="4e51e-112">No other kinds of class members, such as methods or events, are valid.</span></span> <span data-ttu-id="4e51e-113">用於初始化屬性的運算式不可以是 `null`、匿名函式或指標類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-113">The expression that is used to initialize a property cannot be `null`, an anonymous function, or a pointer type.</span></span>  
  
 <span data-ttu-id="4e51e-114">最常見的情況是使用其他類型的屬性來初始化匿名類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-114">The most common scenario is to initialize an anonymous type with properties from another type.</span></span> <span data-ttu-id="4e51e-115">下列範例假設存在一個名為 `Product` 的類別。</span><span class="sxs-lookup"><span data-stu-id="4e51e-115">In the following example, assume that a class exists that is named `Product`.</span></span> <span data-ttu-id="4e51e-116">`Product` 類別包含 `Color` 和 `Price` 屬性，以及您不感興趣的其他屬性。</span><span class="sxs-lookup"><span data-stu-id="4e51e-116">Class `Product` includes `Color` and `Price` properties, together with other properties that you are not interested in.</span></span> <span data-ttu-id="4e51e-117">變數 `products` 是 `Product` 物件的集合。</span><span class="sxs-lookup"><span data-stu-id="4e51e-117">Variable `products` is a collection of `Product` objects.</span></span> <span data-ttu-id="4e51e-118">匿名類型宣告的開頭為 `new` 關鍵字。</span><span class="sxs-lookup"><span data-stu-id="4e51e-118">The anonymous type declaration starts with the `new` keyword.</span></span> <span data-ttu-id="4e51e-119">宣告會初始化新類型，只使用 `Product` 中的兩個屬性。</span><span class="sxs-lookup"><span data-stu-id="4e51e-119">The declaration initializes a new type that uses only two properties from `Product`.</span></span> <span data-ttu-id="4e51e-120">這會使查詢中傳回較小的資料量。</span><span class="sxs-lookup"><span data-stu-id="4e51e-120">This causes a smaller amount of data to be returned in the query.</span></span>  
  
 <span data-ttu-id="4e51e-121">如果未在匿名類型中指定成員名稱，編譯器會為匿名類型成員指定與用於初始化類型之屬性相同的名稱。</span><span class="sxs-lookup"><span data-stu-id="4e51e-121">If you do not specify member names in the anonymous type, the compiler gives the anonymous type members the same name as the property being used to initialize them.</span></span> <span data-ttu-id="4e51e-122">您必須為以運算式初始化的屬性提供一個名稱，如上述範例所示。</span><span class="sxs-lookup"><span data-stu-id="4e51e-122">You must provide a name for a property that is being initialized with an expression, as shown in the previous example.</span></span> <span data-ttu-id="4e51e-123">在下列範例中，匿名類型的屬性名稱是 `Color` 和 `Price`。</span><span class="sxs-lookup"><span data-stu-id="4e51e-123">In the following example, the names of the properties of the anonymous type are `Color` and `Price`.</span></span>  
  
 [!code-csharp[csRef30Features#81](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/anonymous-types_1.cs)]  
  
 <span data-ttu-id="4e51e-124">一般而言，當您使用匿名型別初始化變數時，您可以使用 [var](../../../csharp/language-reference/keywords/var.md) 將變數宣告為隱含型別區域變數。</span><span class="sxs-lookup"><span data-stu-id="4e51e-124">Typically, when you use an anonymous type to initialize a variable, you declare the variable as an implicitly typed local variable by using [var](../../../csharp/language-reference/keywords/var.md).</span></span> <span data-ttu-id="4e51e-125">由於只有編譯器可以存取匿名類型的基本名稱，因此無法在變數宣告中指定類型名稱。</span><span class="sxs-lookup"><span data-stu-id="4e51e-125">The type name cannot be specified in the variable declaration because only the compiler has access to the underlying name of the anonymous type.</span></span> <span data-ttu-id="4e51e-126">如需 `var` 的詳細資訊，請參閱[隱含類型區域變數](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md)。</span><span class="sxs-lookup"><span data-stu-id="4e51e-126">For more information about `var`, see [Implicitly Typed Local Variables](../../../csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
 <span data-ttu-id="4e51e-127">您可以如下列範例所示，合併隱含類型區域變數和隱含類型陣列，以建立匿名類型項目的陣列。</span><span class="sxs-lookup"><span data-stu-id="4e51e-127">You can create an array of anonymously typed elements by combining an implicitly typed local variable and an implicitly typed array, as shown in the following example.</span></span>  
  
```csharp  
var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};  
```  
  
## <a name="remarks"></a><span data-ttu-id="4e51e-128">備註</span><span class="sxs-lookup"><span data-stu-id="4e51e-128">Remarks</span></span>  
 <span data-ttu-id="4e51e-129">匿名型別是直接衍生自 [object](../../../csharp/language-reference/keywords/object.md)，並且無法轉換成 [object](../../../csharp/language-reference/keywords/object.md) 以外之任何類型的 [class](../../../csharp/language-reference/keywords/class.md) 類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-129">Anonymous types are [class](../../../csharp/language-reference/keywords/class.md) types that derive directly from [object](../../../csharp/language-reference/keywords/object.md), and that cannot be cast to any type except [object](../../../csharp/language-reference/keywords/object.md).</span></span> <span data-ttu-id="4e51e-130">編譯器提供每種匿名類型的名稱，不過您的應用程式無法存取此名稱。</span><span class="sxs-lookup"><span data-stu-id="4e51e-130">The compiler provides a name for each anonymous type, although your application cannot access it.</span></span> <span data-ttu-id="4e51e-131">對 Common Language Runtime 來說，匿名類型與其他任何參考類型並無不同。</span><span class="sxs-lookup"><span data-stu-id="4e51e-131">From the perspective of the common language runtime, an anonymous type is no different from any other reference type.</span></span>  
  
 <span data-ttu-id="4e51e-132">如果組件中有兩個或多個匿名物件初始設定式，指定了順序相同並具有相同名稱和類型的屬性序列，編譯器會將這些物件視為相同類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e51e-132">If two or more anonymous object initializers in an assembly specify a sequence of properties that are in the same order and that have the same names and types, the compiler treats the objects as instances of the same type.</span></span> <span data-ttu-id="4e51e-133">這些物件會共用編譯器產生的相同類型資訊。</span><span class="sxs-lookup"><span data-stu-id="4e51e-133">They share the same compiler-generated type information.</span></span>  
  
 <span data-ttu-id="4e51e-134">您無法將欄位、屬性、事件或方法的傳回類型，宣告為具有匿名類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-134">You cannot declare a field, a property, an event, or the return type of a method as having an anonymous type.</span></span> <span data-ttu-id="4e51e-135">同樣地，您無法將方法、屬性、建構函式或索引子的型式參數宣告為具有匿名類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-135">Similarly, you cannot declare a formal parameter of a method, property, constructor, or indexer as having an anonymous type.</span></span> <span data-ttu-id="4e51e-136">若要以方法引數的形式來傳遞匿名類型或含有匿名類型的集合，您可以將參數宣告為 object 類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-136">To pass an anonymous type, or a collection that contains anonymous types, as an argument to a method, you can declare the parameter as type object.</span></span> <span data-ttu-id="4e51e-137">但是，這樣做將失去強式類型的目的。</span><span class="sxs-lookup"><span data-stu-id="4e51e-137">However, doing this defeats the purpose of strong typing.</span></span> <span data-ttu-id="4e51e-138">如果您必須在方法界限外儲存或傳遞查詢結果，請考慮使用一般具名結構或類別來取代匿名類型。</span><span class="sxs-lookup"><span data-stu-id="4e51e-138">If you must store query results or pass them outside the method boundary, consider using an ordinary named struct or class instead of an anonymous type.</span></span>  
  
 <span data-ttu-id="4e51e-139">由於匿名類型上的 <xref:System.Object.Equals%2A> 和 <xref:System.Object.GetHashCode%2A> 方法會以屬性的 `Equals` 和 `GetHashCode` 方法來定義，相同匿名類型的兩個執行個體僅在其所有屬性都相等時，這兩個執行個體才相等。</span><span class="sxs-lookup"><span data-stu-id="4e51e-139">Because the <xref:System.Object.Equals%2A> and <xref:System.Object.GetHashCode%2A> methods on anonymous types are defined in terms of the `Equals` and `GetHashCode` methods of the properties, two instances of the same anonymous type are equal only if all their properties are equal.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4e51e-140">另請參閱</span><span class="sxs-lookup"><span data-stu-id="4e51e-140">See Also</span></span>  
 [<span data-ttu-id="4e51e-141">C# 程式設計指南</span><span class="sxs-lookup"><span data-stu-id="4e51e-141">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="4e51e-142">物件和集合初始設定式</span><span class="sxs-lookup"><span data-stu-id="4e51e-142">Object and Collection Initializers</span></span>](../../../csharp/programming-guide/classes-and-structs/object-and-collection-initializers.md)  
 [<span data-ttu-id="4e51e-143">開始使用 C# 中的 LINQ</span><span class="sxs-lookup"><span data-stu-id="4e51e-143">Getting Started with LINQ in C#</span></span>](../../../csharp/programming-guide/concepts/linq/getting-started-with-linq.md)  
 [<span data-ttu-id="4e51e-144">LINQ 查詢運算式</span><span class="sxs-lookup"><span data-stu-id="4e51e-144">LINQ Query Expressions</span></span>](../../../csharp/programming-guide/linq-query-expressions/index.md)
