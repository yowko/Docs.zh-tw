---
title: 編譯器錯誤 CS1540
ms.date: 07/20/2015
f1_keywords:
- CS1540
helpviewer_keywords:
- CS1540
ms.assetid: f35bbeb9-e2b2-4644-a7e6-cc2dbce1bd44
ms.openlocfilehash: 5ae3975ebe44b0159ee8274fd09998619fd484ca
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54697929"
---
# <a name="compiler-error-cs1540"></a><span data-ttu-id="c3351-102">編譯器錯誤 CS1540</span><span class="sxs-lookup"><span data-stu-id="c3351-102">Compiler Error CS1540</span></span>
<span data-ttu-id="c3351-103">無法經由類型 'type1' 的限定詞來存取受保護的成員 'member'，必須經由類型 'type2' (或從其衍生的類型) 的限定詞。</span><span class="sxs-lookup"><span data-stu-id="c3351-103">Cannot access protected member 'member' via a qualifier of type 'type1'; the qualifier must be of type 'type2' (or derived from it)</span></span>  
  
 <span data-ttu-id="c3351-104">衍生的[類別](../../../csharp/language-reference/keywords/class.md)無法透過基底類別的執行個體存取其基底類別的受保護成員。</span><span class="sxs-lookup"><span data-stu-id="c3351-104">A derived [class](../../../csharp/language-reference/keywords/class.md) cannot access protected members of its base class through an instance of the base class.</span></span> <span data-ttu-id="c3351-105">在衍生類別中宣告的基底類別執行個體，在執行階段可能是衍生自相同基底的另一種類型執行個體，但除此以外與衍生類別無關。</span><span class="sxs-lookup"><span data-stu-id="c3351-105">An instance of the base class declared in the derived class might, at run time, be an instance of another type that is derived from the same base but is not otherwise related to the derived class.</span></span> <span data-ttu-id="c3351-106">因為受保護的成員僅能由衍生類型存取，所以任何在執行階段存取可能無效的受保護成員的嘗試，編譯器都會標示為無效。</span><span class="sxs-lookup"><span data-stu-id="c3351-106">Because protected members can be accessed only by derived types, any attempts to access protected members that might not be valid at run time are marked by the compiler as not valid.</span></span>  
  
 <span data-ttu-id="c3351-107">在下例的 `Employee` 類別中，`emp2` 和 `emp3` 在編譯時間都有類型 `Person`，但 `emp2` 在執行階段有類型 `Manager`。</span><span class="sxs-lookup"><span data-stu-id="c3351-107">In the `Employee` class in the following example, `emp2` and `emp3` both have type `Person` at compile time, but `emp2` has type `Manager` at run time.</span></span> <span data-ttu-id="c3351-108">因為 `Employee` 不是衍生自 `Manager`，所以無法透過 `Manager` 類別的執行個體存取基底類別 `Person` 的受保護成員。</span><span class="sxs-lookup"><span data-stu-id="c3351-108">Because `Employee` is not derived from `Manager`, it cannot access the protected members of the base class, `Person`, through an instance of the `Manager` class.</span></span> <span data-ttu-id="c3351-109">編譯器無法判斷兩個 `Person` 物件的執行階段類型會為何。</span><span class="sxs-lookup"><span data-stu-id="c3351-109">The compiler cannot determine what the run-time type of the two `Person` objects will be.</span></span> <span data-ttu-id="c3351-110">因此，來自 `emp2` 的兩個呼叫和來自 `emp3` 的呼叫都會造成編譯器錯誤 CS1540。</span><span class="sxs-lookup"><span data-stu-id="c3351-110">Therefore, both the call from `emp2` and the call from `emp3` cause compiler error CS1540.</span></span>  
  
```csharp  
using System;  
using System.Text;  
  
namespace CS1540  
{  
    class Program1  
    {  
        static void Main()  
        {  
            Employee.PreparePayroll();  
        }  
    }  
  
    class Person  
    {  
        protected virtual void CalculatePay()   
        {  
            Console.WriteLine("CalculatePay in Person class.");  
        }  
    }  
  
    class Manager : Person  
    {  
        protected override void CalculatePay()   
        {  
            Console.WriteLine("CalculatePay in Manager class.");   
  
        }  
    }  
  
    class Employee : Person  
    {  
        public static void PreparePayroll()  
        {  
            Employee emp1 = new Employee();  
            Person emp2 = new Manager();  
            Person emp3 = new Employee();  
            // The following line calls the method in the Employee base class,  
            // Person.  
            emp1.CalculatePay();   
  
            // The following lines cause compiler error CS1540. The compiler   
            // cannot determine at compile time what the run-time types of   
            // emp2 and emp3 will be.  
            //emp2.CalculatePay();   
            //emp3.CalculatePay();  
  
        }  
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="c3351-111">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c3351-111">See also</span></span>

- [<span data-ttu-id="c3351-112">繼承</span><span class="sxs-lookup"><span data-stu-id="c3351-112">Inheritance</span></span>](../../../csharp/programming-guide/classes-and-structs/inheritance.md)
- [<span data-ttu-id="c3351-113">多型</span><span class="sxs-lookup"><span data-stu-id="c3351-113">Polymorphism</span></span>](../../../csharp/programming-guide/classes-and-structs/polymorphism.md)
- [<span data-ttu-id="c3351-114">存取修飾詞</span><span class="sxs-lookup"><span data-stu-id="c3351-114">Access Modifiers</span></span>](../../../csharp/programming-guide/classes-and-structs/access-modifiers.md)
- [<span data-ttu-id="c3351-115">抽象和密封類別以及類別成員</span><span class="sxs-lookup"><span data-stu-id="c3351-115">Abstract and Sealed Classes and Class Members</span></span>](../../../csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.md)
