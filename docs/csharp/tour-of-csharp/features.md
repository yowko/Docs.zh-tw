---
title: 'C # 主要語言區域教學課程'
description: 第一次接觸 C#？ 了解該語言的基本概念。
ms.date: 08/06/2020
ms.openlocfilehash: a73399643ada05a4bfb17fadd17bf3267514e99d
ms.sourcegitcommit: 48466b8fb7332ececff5dc388f19f6b3ff503dd4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/05/2020
ms.locfileid: "93400744"
---
# <a name="major-language-areas"></a><span data-ttu-id="3c6a1-104">主要語言區域</span><span class="sxs-lookup"><span data-stu-id="3c6a1-104">Major language areas</span></span>

## <a name="arrays-collections-and-linq"></a><span data-ttu-id="3c6a1-105">陣列、集合和 LINQ</span><span class="sxs-lookup"><span data-stu-id="3c6a1-105">Arrays, collections, and LINQ</span></span>

<span data-ttu-id="3c6a1-106">C # 和 .NET 提供許多不同的集合類型。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-106">C# and .NET provide many different collection types.</span></span> <span data-ttu-id="3c6a1-107">陣列具有由語言定義的語法。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-107">Arrays have syntax defined by the language.</span></span> <span data-ttu-id="3c6a1-108">泛型集合類型會列在 <xref:System.Collections.Generic?displayProperty=fullName> 命名空間中。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-108">Generic collection types are listed in the <xref:System.Collections.Generic?displayProperty=fullName> namespace.</span></span> <span data-ttu-id="3c6a1-109">特製化集合包含用 <xref:System.Span%601?displayProperty=nameWithType> 來存取堆疊框架上的連續記憶體，以及 <xref:System.Memory%601?displayProperty=nameWithType> 存取 managed 堆積上的連續記憶體。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-109">Specialized collections include <xref:System.Span%601?displayProperty=nameWithType> for accessing continuous memory on the stack frame, and <xref:System.Memory%601?displayProperty=nameWithType> for accessing continuous memory on the managed heap.</span></span> <span data-ttu-id="3c6a1-110">所有集合（包括陣列） <xref:System.Span%601> 和都會 <xref:System.Memory%601> 共用反覆運算的統一原則。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-110">All collections, including arrays, <xref:System.Span%601>, and <xref:System.Memory%601> share a unifying principle for iteration.</span></span> <span data-ttu-id="3c6a1-111">您可以使用此 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 介面。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-111">You use the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="3c6a1-112">這個統一的原則表示任何集合類型都可以搭配 LINQ 查詢或其他演算法使用。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-112">This unifying principle means that any of the collection types can be used with LINQ queries or other algorithms.</span></span> <span data-ttu-id="3c6a1-113">您可以使用撰寫方法 <xref:System.Collections.Generic.IEnumerable%601> ，而這些演算法會搭配任何集合使用。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-113">You write methods using <xref:System.Collections.Generic.IEnumerable%601> and those algorithms work with any collection.</span></span>

### <a name="arrays"></a><span data-ttu-id="3c6a1-114">陣列</span><span class="sxs-lookup"><span data-stu-id="3c6a1-114">Arrays</span></span>

<span data-ttu-id="3c6a1-115">[ \* **陣列** _](../programming-guide/arrays/index.md)是一種資料結構，其中包含透過計算索引所存取的一些變數。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-115">An [\***array** _](../programming-guide/arrays/index.md) is a data structure that contains a number of variables that are accessed through computed indices.</span></span> <span data-ttu-id="3c6a1-116">陣列中包含的變數（也稱為陣列的 _\*_元素_\*_ ）全都是相同的類型。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-116">The variables contained in an array, also called the _*_elements_*_ of the array, are all of the same type.</span></span> <span data-ttu-id="3c6a1-117">此類型稱為陣列的 _\*_元素類型_\*_ 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-117">This type is called the _*_element type_*_ of the array.</span></span>

<span data-ttu-id="3c6a1-118">陣列型別是參考型別，而陣列變數的宣告只是預留空間給陣列執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-118">Array types are reference types, and the declaration of an array variable simply sets aside space for a reference to an array instance.</span></span> <span data-ttu-id="3c6a1-119">實際的陣列實例會在執行時間使用運算子動態建立 `new` 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-119">Actual array instances are created dynamically at runtime using the `new` operator.</span></span> <span data-ttu-id="3c6a1-120">作業 `new` 會指定新陣列實例的 _\*_長度_\*_ ，然後針對實例的存留期進行修正。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-120">The `new` operation specifies the _*_length_*_ of the new array instance, which is then fixed for the lifetime of the instance.</span></span> <span data-ttu-id="3c6a1-121">陣列元素的索引範圍在 `0` 到 `Length - 1` 之間。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-121">The indices of the elements of an array range from `0` to `Length - 1`.</span></span> <span data-ttu-id="3c6a1-122">`new` 運算子會自動將陣列的元素初始化為其預設值，例如，針對所有數值型別，此值為零，而針對所有參考型別，此值為 `null`。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-122">The `new` operator automatically initializes the elements of an array to their default value, which, for example, is zero for all numeric types and `null` for all reference types.</span></span>

<span data-ttu-id="3c6a1-123">下列範例會建立 `int` 元素的陣列、初始化陣列，並印出陣列的內容。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-123">The following example creates an array of `int` elements, initializes the array, and prints out the contents of the array.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArraysSample":::

<span data-ttu-id="3c6a1-124">這個範例會在一 _\*_維陣列_\*_ 上建立和操作。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-124">This example creates and operates on a _*_single-dimensional array_*_.</span></span> <span data-ttu-id="3c6a1-125">C # 也支援 _\*_多維度陣列_\*_ 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-125">C# also supports _*_multi-dimensional arrays_*_.</span></span> <span data-ttu-id="3c6a1-126">陣列類型的維度數目（也稱為陣列類型的 _\*_等級_\*_ ）是一加在陣列類型的方括弧之間所寫入的逗號數目。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-126">The number of dimensions of an array type, also known as the _*_rank_*_ of the array type, is one plus the number of commas written between the square brackets of the array type.</span></span> <span data-ttu-id="3c6a1-127">下列範例會分別配置一個單維、一個二維和一個三維陣列。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-127">The following example allocates a single-dimensional, a two-dimensional, and a three-dimensional array, respectively.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DeclareArrays":::

<span data-ttu-id="3c6a1-128">`a1` 陣列包含 10 個元素、`a2`陣列包含 50 (10 × 5) 個元素，`a3` 陣列包含 100 (10 × 5 × 2) 個元素。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-128">The `a1` array contains 10 elements, the `a2` array contains 50 (10 × 5) elements, and the `a3` array contains 100 (10 × 5 × 2) elements.</span></span>
<span data-ttu-id="3c6a1-129">陣列的元素型別可以是任一型別，包括陣列型別。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-129">The element type of an array can be any type, including an array type.</span></span> <span data-ttu-id="3c6a1-130">陣列類型元素的陣列有時稱為 _\*_不規則陣列_\*_ ，因為元素陣列的長度不一定相同。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-130">An array with elements of an array type is sometimes called a _*_jagged array_*_ because the lengths of the element arrays don't all have to be the same.</span></span> <span data-ttu-id="3c6a1-131">下列範例會配置一個 `int` 型別的陣列：</span><span class="sxs-lookup"><span data-stu-id="3c6a1-131">The following example allocates an array of arrays of `int`:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ArrayOfArrays":::

<span data-ttu-id="3c6a1-132">第一行建立包含三個元素的陣列，每個元素的型別均為 `int[]`，每個元素的初始值均為 `null`。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-132">The first line creates an array with three elements, each of type `int[]` and each with an initial value of `null`.</span></span> <span data-ttu-id="3c6a1-133">接下來的幾行則會初始化具有不同長度之個別陣列實例參考的三個元素。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-133">The next lines then initialize the three elements with references to individual array instances of varying lengths.</span></span>

<span data-ttu-id="3c6a1-134">`new`運算子允許使用 _\*_陣列初始化_\*_ 運算式來指定陣列元素的初始值，也就是在分隔符號和之間寫入的運算式清單 `{` `}` 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-134">The `new` operator permits the initial values of the array elements to be specified using an _*_array initializer_*_ , which is a list of expressions written between the delimiters `{` and `}`.</span></span> <span data-ttu-id="3c6a1-135">下列範例使用三個元素配置並初始化 `int[]`。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-135">The following example allocates and initializes an `int[]` with three elements.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeArray":::

<span data-ttu-id="3c6a1-136">陣列的長度是從和之間的運算式數目推斷而來 `{` `}` 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-136">The length of the array is inferred from the number of expressions between `{` and `}`.</span></span> <span data-ttu-id="3c6a1-137">您可以進一步縮短陣列初始化，這樣就不需要先重新開機陣列型別。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-137">Array initialization can be shortened further such that the array type doesn't have to be restated.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeShortened":::

<span data-ttu-id="3c6a1-138">上述兩個範例都相當於下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="3c6a1-138">Both of the previous examples are equivalent to the following code:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="InitializeGenerated":::

<span data-ttu-id="3c6a1-139">`foreach`語句可以用來列舉任何集合的元素。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-139">The `foreach` statement can be used to enumerate the elements of any collection.</span></span> <span data-ttu-id="3c6a1-140">下列程式碼會列舉上述範例中的陣列：</span><span class="sxs-lookup"><span data-stu-id="3c6a1-140">The following code enumerates the array from the preceding example:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="EnumerateArray":::

<span data-ttu-id="3c6a1-141">`foreach`語句 <xref:System.Collections.Generic.IEnumerable%601> 會使用介面，因此可以使用任何集合。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-141">The `foreach` statement uses the <xref:System.Collections.Generic.IEnumerable%601> interface, so can work with any collection.</span></span>

## <a name="string-interpolation"></a><span data-ttu-id="3c6a1-142">字串插補</span><span class="sxs-lookup"><span data-stu-id="3c6a1-142">String interpolation</span></span>

<span data-ttu-id="3c6a1-143">C # [_\*_字串插補_\*_](../language-reference/tokens/interpolated.md) 可讓您藉由定義將結果放置在格式字串中的運算式，來格式化字串。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-143">C# [_*_string interpolation_*_](../language-reference/tokens/interpolated.md) enables you to format strings by defining expressions whose results are placed in a format string.</span></span> <span data-ttu-id="3c6a1-144">例如，下列範例會從一組氣象資料列印指定日期的溫度：</span><span class="sxs-lookup"><span data-stu-id="3c6a1-144">For example, the following example prints the temperature on a given day from a set of weather data:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="StringInterpolation":::

<span data-ttu-id="3c6a1-145">插入字串是使用 token 來宣告 `$` 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-145">An interpolated string is declared using the `$` token.</span></span> <span data-ttu-id="3c6a1-146">字串插補會評估和之間的運算式 `{` `}` ，然後將結果轉換成 `string` ，並將括弧之間的文字取代為運算式的字串結果。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-146">String interpolation evaluates the expressions between `{` and `}`, then converts the result to a `string`, and replaces the text between the brackets with the string result of the expression.</span></span> <span data-ttu-id="3c6a1-147">`:`第一個運算式中的會 `{weatherData.Date:MM-DD-YYYY}` 指定 _format 字串 \*。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-147">The `:` in the first expression, `{weatherData.Date:MM-DD-YYYY}` specifies the _format string\*.</span></span> <span data-ttu-id="3c6a1-148">在上述範例中，它會指定應以 "MM-yyyy-mm-dd" 格式列印日期。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-148">In the preceding example, it specifies that the date should be printed in "MM-DD-YYYY" format.</span></span>

## <a name="pattern-matching"></a><span data-ttu-id="3c6a1-149">模式比對</span><span class="sxs-lookup"><span data-stu-id="3c6a1-149">Pattern matching</span></span>

<span data-ttu-id="3c6a1-150">C # 語言提供 [ \* **模式**](../pattern-matching.md)比對 _ 運算式來查詢物件的狀態，並根據該狀態執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-150">The C# language provides [\***pattern matching** _](../pattern-matching.md) expressions to query the state of an object and execute code based on that state.</span></span> <span data-ttu-id="3c6a1-151">您可以檢查屬性和欄位的類型和值，以判斷要採取的動作。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-151">You can inspect types and the values of properties and fields to determine which action to take.</span></span> <span data-ttu-id="3c6a1-152">`switch`運算式是適用于模式比對的主要運算式。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-152">The `switch` expression is the primary expression for pattern matching.</span></span>

## <a name="delegates-and-lambda-expressions"></a><span data-ttu-id="3c6a1-153">委派和 lambda 運算式</span><span class="sxs-lookup"><span data-stu-id="3c6a1-153">Delegates and lambda expressions</span></span>

<span data-ttu-id="3c6a1-154">[_\*_委派型_\*_](../delegates-overview.md)別代表具有特定參數清單和傳回型別之方法的參考。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-154">A [_*_delegate type_*_](../delegates-overview.md) represents references to methods with a particular parameter list and return type.</span></span> <span data-ttu-id="3c6a1-155">委派讓您可將方法視為實體，而實體能指派給變數或當作參數來傳遞。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-155">Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters.</span></span> <span data-ttu-id="3c6a1-156">委派類似于某些其他語言中的函式指標概念。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-156">Delegates are similar to the concept of function pointers found in some other languages.</span></span> <span data-ttu-id="3c6a1-157">與函式指標不同的是，委派是物件導向且型別安全的。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-157">Unlike function pointers, delegates are object-oriented and type-safe.</span></span>

<span data-ttu-id="3c6a1-158">下列範例會宣告並使用名為 `Function` 的委派型別。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-158">The following example declares and uses a delegate type named `Function`.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DelegateExample":::

<span data-ttu-id="3c6a1-159">`Function` 委派型別的執行個體可以參考任何採用 `double` 引數並傳回 `double` 值的方法。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-159">An instance of the `Function` delegate type can reference any method that takes a `double` argument and returns a `double` value.</span></span> <span data-ttu-id="3c6a1-160">`Apply`方法會將指定的套用 `Function` 至的元素 `double[]` ，並傳回 `double[]` 包含結果的。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-160">The `Apply` method applies a given `Function` to the elements of a `double[]`, returning a `double[]` with the results.</span></span> <span data-ttu-id="3c6a1-161">在 `Main` 方法中，是使用 `Apply` 將三個不同的函式套用到 `double[]`。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-161">In the `Main` method, `Apply` is used to apply three different functions to a `double[]`.</span></span>

<span data-ttu-id="3c6a1-162">委派可以參考靜態方法 (例如上一個範例中的 `Square` 或 `Math.Sin`)，或是參考執行個體方法 (例如上一個範例中的 `m.Multiply`)。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-162">A delegate can reference either a static method (such as `Square` or `Math.Sin` in the previous example) or an instance method (such as `m.Multiply` in the previous example).</span></span> <span data-ttu-id="3c6a1-163">參考執行個體方法的委派也會參考特定的物件，而且透過委派來叫用執行個體方法時，該物件就會變成叫用中的 `this`。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-163">A delegate that references an instance method also references a particular object, and when the instance method is invoked through the delegate, that object becomes `this` in the invocation.</span></span>

<span data-ttu-id="3c6a1-164">您也可以使用匿名函式（宣告時所建立的「內嵌方法」）來建立委派。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-164">Delegates can also be created using anonymous functions, which are "inline methods" that are created when declared.</span></span> <span data-ttu-id="3c6a1-165">匿名函式可以看見周圍方法的區域變數。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-165">Anonymous functions can see the local variables of the surrounding methods.</span></span> <span data-ttu-id="3c6a1-166">下列範例不會建立類別：</span><span class="sxs-lookup"><span data-stu-id="3c6a1-166">The following example doesn't create a class:</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseDelegate":::

<span data-ttu-id="3c6a1-167">委派不知道或在意它所參考之方法的類別。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-167">A delegate doesn't know or care about the class of the method it references.</span></span> <span data-ttu-id="3c6a1-168">重點是，參考的方法與委派具有相同的參數和傳回型別。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-168">All that matters is that the referenced method has the same parameters and return type as the delegate.</span></span>

## <a name="async--await"></a><span data-ttu-id="3c6a1-169">async/await</span><span class="sxs-lookup"><span data-stu-id="3c6a1-169">async / await</span></span>

<span data-ttu-id="3c6a1-170">C # 支援具有兩個關鍵字的非同步程式： `async` 和 `await` 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-170">C# supports asynchronous programs with two keywords: `async` and `await`.</span></span> <span data-ttu-id="3c6a1-171">您將修飾詞加入 `async` 至方法宣告，以宣告方法是非同步。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-171">You add the `async` modifier to a method declaration to declare the method is asynchronous.</span></span> <span data-ttu-id="3c6a1-172">`await`運算子會指示編譯器以非同步方式等待結果完成。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-172">The `await` operator tells the compiler to asynchronously await for a result to finish.</span></span> <span data-ttu-id="3c6a1-173">控制權會傳回給呼叫端，而此方法會傳回結構來管理非同步工作的狀態。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-173">Control is returned to the caller, and the method returns a structure that manages the state of the asynchronous work.</span></span> <span data-ttu-id="3c6a1-174">結構通常是 <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> ，但可以是任何支援 awaiter 模式的型別。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-174">The structure is typically a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, but can be any type that supports the awaiter pattern.</span></span> <span data-ttu-id="3c6a1-175">這些功能可讓您撰寫程式碼，以讀取為其同步對應，但以非同步方式執行。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-175">These features enable you to write code that reads as its synchronous counterpart, but executes asynchronously.</span></span> <span data-ttu-id="3c6a1-176">例如，下列程式碼會下載 [Microsoft](/)檔的首頁：</span><span class="sxs-lookup"><span data-stu-id="3c6a1-176">For example, the following code downloads the home page for [Microsoft docs](/):</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="AsyncExample":::

<span data-ttu-id="3c6a1-177">此小範例顯示非同步程式設計的主要功能：</span><span class="sxs-lookup"><span data-stu-id="3c6a1-177">This small sample shows the major features for asynchronous programming:</span></span>

- <span data-ttu-id="3c6a1-178">方法宣告包含修飾詞 `async` 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-178">The method declaration includes the `async` modifier.</span></span>
- <span data-ttu-id="3c6a1-179">方法的主體傳回 `await` `GetByteArrayAsync` 方法。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-179">The body of the method `await`s the return of the `GetByteArrayAsync` method.</span></span>
- <span data-ttu-id="3c6a1-180">語句中指定的型別 `return` 與方法的宣告中的型別引數相符 `Task<T>` 。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-180">The type specified in the `return` statement matches the type argument in the `Task<T>` declaration for the method.</span></span> <span data-ttu-id="3c6a1-181"> (傳回的方法 `Task` 會使用 `return` 沒有任何引數) 的語句。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-181">(A method that returns a `Task` would use `return` statements without any argument).</span></span>

## <a name="attributes"></a><span data-ttu-id="3c6a1-182">屬性</span><span class="sxs-lookup"><span data-stu-id="3c6a1-182">Attributes</span></span>

<span data-ttu-id="3c6a1-183">C# 程式中的型別、成員和其他實體支援控制其某方面行為的修飾詞。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-183">Types, members, and other entities in a C# program support modifiers that control certain aspects of their behavior.</span></span> <span data-ttu-id="3c6a1-184">例如，方法的協助工具是使用 `public`、`protected`、`internal` 和 `private` 修飾詞控制。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-184">For example, the accessibility of a method is controlled using the `public`, `protected`, `internal`, and `private` modifiers.</span></span> <span data-ttu-id="3c6a1-185">C# 將此能力一般化，宣告式資訊的使用者定義型別才能附加至程式實體，並在執行階段擷取。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-185">C# generalizes this capability such that user-defined types of declarative information can be attached to program entities and retrieved at run-time.</span></span> <span data-ttu-id="3c6a1-186">程式會藉由定義和使用 [_ *_屬性_* \*](../programming-guide/concepts/attributes/index.md)來指定此額外的宣告式資訊。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-186">Programs specify this additional declarative information by defining and using [_ *_attributes_*\*](../programming-guide/concepts/attributes/index.md).</span></span>

<span data-ttu-id="3c6a1-187">下列範例宣告的 `HelpAttribute` 屬性可置於程式實體，以提供其相關文件的連結。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-187">The following example declares a `HelpAttribute` attribute that can be placed on program entities to provide links to their associated documentation.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="DefineAttribute":::

<span data-ttu-id="3c6a1-188">所有屬性類別都是衍生自 <xref:System.Attribute> .net 程式庫所提供的基類。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-188">All attribute classes derive from the <xref:System.Attribute> base class provided by the .NET library.</span></span> <span data-ttu-id="3c6a1-189">在相關聯的宣告之前，於方括弧中提供屬性的名稱 (及任何引數) 即可套用屬性。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-189">Attributes can be applied by giving their name, along with any arguments, inside square brackets just before the associated declaration.</span></span> <span data-ttu-id="3c6a1-190">如果屬性名稱的結尾是 `Attribute`，則參考該屬性時可以省略該部分名稱。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-190">If an attribute’s name ends in `Attribute`, that part of the name can be omitted when the attribute is referenced.</span></span> <span data-ttu-id="3c6a1-191">例如，`HelpAttribute` 可以下列方式使用。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-191">For example, the `HelpAttribute` can be used as follows.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="UseAttributes":::

<span data-ttu-id="3c6a1-192">這個範例會將 `HelpAttribute` 附加至 `Widget` 類別。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-192">This example attaches a `HelpAttribute` to the `Widget` class.</span></span> <span data-ttu-id="3c6a1-193">它會在類別的 `Display` 方法中加入另一個 `HelpAttribute`。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-193">It adds another `HelpAttribute` to the `Display` method in the class.</span></span> <span data-ttu-id="3c6a1-194">屬性類別的公用建構函式控制將屬性附加至程式實體時必須提供的資訊。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-194">The public constructors of an attribute class control the information that must be provided when the attribute is attached to a program entity.</span></span> <span data-ttu-id="3c6a1-195">透過參考屬性類別的公用讀寫屬性可提供其他資訊 (例如先前對 `Topic` 的參考 )。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-195">Additional information can be provided by referencing public read-write properties of the attribute class (such as the reference to the `Topic` property previously).</span></span>

<span data-ttu-id="3c6a1-196">由屬性定義的中繼資料可在執行階段使用反射來讀取及操控。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-196">The metadata defined by attributes can be read and manipulated at runtime using reflection.</span></span> <span data-ttu-id="3c6a1-197">使用此技巧要求特定的屬性時，會以程式來源中提供的資訊叫用屬性類別的建構函式，並傳回產生的屬性執行個體。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-197">When a particular attribute is requested using this technique, the constructor for the attribute class is invoked with the information provided in the program source, and the resulting attribute instance is returned.</span></span> <span data-ttu-id="3c6a1-198">如果是透過屬性提供其他資訊，傳回屬性執行個體之前，這些屬性會設為指定的值。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-198">If additional information was provided through properties, those properties are set to the given values before the attribute instance is returned.</span></span>

<span data-ttu-id="3c6a1-199">下列程式碼範例示範如何取得與 `Widget` 類別關聯的 `HelpAttribute` 執行個體與其 `Display` 方法。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-199">The following code sample demonstrates how to get the `HelpAttribute` instances associated to the `Widget` class and its `Display` method.</span></span>

:::code language="csharp" source="./snippets/shared/Features.cs" ID="ReadAttributes":::

## <a name="learn-more"></a><span data-ttu-id="3c6a1-200">深入了解</span><span class="sxs-lookup"><span data-stu-id="3c6a1-200">Learn more</span></span>

<span data-ttu-id="3c6a1-201">您可以試用我們的其中一個 [教學](../tutorials/index.md)課程，以深入瞭解 c #。</span><span class="sxs-lookup"><span data-stu-id="3c6a1-201">You can explore more about C# by trying one of our [tutorials](../tutorials/index.md).</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="3c6a1-202">[[上一步]](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="3c6a1-202">[Previous](program-building-blocks.md)</span></span>
