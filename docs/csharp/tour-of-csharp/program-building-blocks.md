---
title: 'C # 程式的組建區塊」'
description: '深入瞭解 c # 成員、運算式和語句。 類型包含您撰寫的成員。 這些成員是從語句和運算式所建立。'
ms.date: 08/06/2020
ms.openlocfilehash: 0ac45eee180b60062a328fca9ab5c63a1537debe
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216612"
---
# <a name="program-building-blocks"></a><span data-ttu-id="fd054-105">程式建置區塊</span><span class="sxs-lookup"><span data-stu-id="fd054-105">Program building blocks</span></span>

<span data-ttu-id="fd054-106">前一篇文章中所述的型別是使用這些組建區塊所建立： [ \* **成員** _](../programming-guide/classes-and-structs/members.md)、 [_\*_運算式_\*_ 和 _\*_語句_\*_](../programming-guide/statements-expressions-operators/index.md)。</span><span class="sxs-lookup"><span data-stu-id="fd054-106">The types described in the previous article are built using these building blocks: [\***members** _](../programming-guide/classes-and-structs/members.md), [_*_expressions_*_, and _*_statements_*_](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="fd054-107">成員</span><span class="sxs-lookup"><span data-stu-id="fd054-107">Members</span></span>

<span data-ttu-id="fd054-108">的成員 `class` 可以是 _\*_靜態成員_\*_ 或 _\*_實例成員_\*_。</span><span class="sxs-lookup"><span data-stu-id="fd054-108">The members of a `class` are either _*_static members_*_ or _*_instance members_*_.</span></span> <span data-ttu-id="fd054-109">靜態成員隸屬於類別，而執行個體成員則隸屬於物件 (類別的執行個體)。</span><span class="sxs-lookup"><span data-stu-id="fd054-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="fd054-110">下列清單概要說明類別可包含的成員種類。</span><span class="sxs-lookup"><span data-stu-id="fd054-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="fd054-111">_ \* 常數 \* \*：與類別相關聯的常數值</span><span class="sxs-lookup"><span data-stu-id="fd054-111">_\*Constants\*\*: Constant values associated with the class</span></span>
- <span data-ttu-id="fd054-112">**欄位**：與類別相關聯的變數</span><span class="sxs-lookup"><span data-stu-id="fd054-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="fd054-113">**方法**：可由類別執行的動作</span><span class="sxs-lookup"><span data-stu-id="fd054-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="fd054-114">**屬性**：與讀取和寫入類別的命名屬性相關聯的動作</span><span class="sxs-lookup"><span data-stu-id="fd054-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="fd054-115">**索引子**：與類別的索引實例相關聯的動作，例如陣列</span><span class="sxs-lookup"><span data-stu-id="fd054-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="fd054-116">**事件**：可由類別產生的通知</span><span class="sxs-lookup"><span data-stu-id="fd054-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="fd054-117">**運算子**：類別支援的轉換和運算式運算子</span><span class="sxs-lookup"><span data-stu-id="fd054-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="fd054-118">函 **式：初始化** 類別或類別本身的實例所需的動作</span><span class="sxs-lookup"><span data-stu-id="fd054-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="fd054-119">完成 **項：永久** 捨棄類別實例之前所執行的動作</span><span class="sxs-lookup"><span data-stu-id="fd054-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="fd054-120">**類型**：類別所宣告的巢狀型別</span><span class="sxs-lookup"><span data-stu-id="fd054-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="fd054-121">協助工具選項</span><span class="sxs-lookup"><span data-stu-id="fd054-121">Accessibility</span></span>

<span data-ttu-id="fd054-122">類別的每個成員都有相關聯的存取範圍，可控制可存取成員的程式文字區域。</span><span class="sxs-lookup"><span data-stu-id="fd054-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="fd054-123">存取能力有六種可能的形式。</span><span class="sxs-lookup"><span data-stu-id="fd054-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="fd054-124">存取修飾詞的摘要如下所示。</span><span class="sxs-lookup"><span data-stu-id="fd054-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="fd054-125">`public`：存取不受限制。</span><span class="sxs-lookup"><span data-stu-id="fd054-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="fd054-126">`private`：存取僅限於此類別。</span><span class="sxs-lookup"><span data-stu-id="fd054-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="fd054-127">`protected`：存取僅限於此類別或衍生自這個類別的類別。</span><span class="sxs-lookup"><span data-stu-id="fd054-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="fd054-128">`internal`：存取限於目前元件 (`.exe` 或 `.dll`) 。</span><span class="sxs-lookup"><span data-stu-id="fd054-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="fd054-129">`protected internal`：存取僅限於此類別、衍生自這個類別的類別，或相同元件中的類別。</span><span class="sxs-lookup"><span data-stu-id="fd054-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="fd054-130">`private protected`：存取權僅限於此類別或在相同元件中衍生自此類型的類別。</span><span class="sxs-lookup"><span data-stu-id="fd054-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="fd054-131">欄位</span><span class="sxs-lookup"><span data-stu-id="fd054-131">Fields</span></span>

<span data-ttu-id="fd054-132">「欄位」是與類別或類別執行個體關聯的變數。</span><span class="sxs-lookup"><span data-stu-id="fd054-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="fd054-133">使用 static 修飾詞來宣告的欄位會定義靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="fd054-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="fd054-134">靜態欄位只會識別一個儲存位置。</span><span class="sxs-lookup"><span data-stu-id="fd054-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="fd054-135">無論類別的實例建立多少，靜態欄位都只會有一個複本。</span><span class="sxs-lookup"><span data-stu-id="fd054-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="fd054-136">未使用 static 修飾詞來宣告的欄位會定義執行個體欄位。</span><span class="sxs-lookup"><span data-stu-id="fd054-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="fd054-137">每個類別執行個體都包含一個該類別所有執行個體欄位的個別複本。</span><span class="sxs-lookup"><span data-stu-id="fd054-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="fd054-138">在下列範例中，類別的每個實例 `Color` 都有 `R` 、 `G` 和實例欄位的個別複本 `B` ，但只有一個 `Black` 、、 `White` `Red` 、 `Green` 和 `Blue` 靜態欄位的複本：</span><span class="sxs-lookup"><span data-stu-id="fd054-138">In the following example, each instance of the `Color` class has a separate copy of the `R`, `G`, and `B` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="fd054-139">如先前的範例所示，可以使用 `readonly` 修飾詞來宣告「唯讀欄位」。</span><span class="sxs-lookup"><span data-stu-id="fd054-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="fd054-140">只有在欄位的宣告或相同類別的函式中，才會將指派指派給唯讀欄位。</span><span class="sxs-lookup"><span data-stu-id="fd054-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="fd054-141">方法</span><span class="sxs-lookup"><span data-stu-id="fd054-141">Methods</span></span>

<span data-ttu-id="fd054-142">「方法」是實作物件或類別所能執行之計算或動作的成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="fd054-143">存取「靜態方法」時，是透過類別來存取。</span><span class="sxs-lookup"><span data-stu-id="fd054-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="fd054-144">存取「執行個體方法」時，是透過類別的執行個體來存取。</span><span class="sxs-lookup"><span data-stu-id="fd054-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="fd054-145">方法可以有參數清單，這些 *參數* 代表傳遞給方法的值或變數參考。</span><span class="sxs-lookup"><span data-stu-id="fd054-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="fd054-146">方法具有傳回 *型* 別，可指定方法所計算和傳回值的型別。</span><span class="sxs-lookup"><span data-stu-id="fd054-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="fd054-147">如果方法的傳回型別不會傳回值，則為 `void` 。</span><span class="sxs-lookup"><span data-stu-id="fd054-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="fd054-148">與型別相同，方法也可能有一組型別參數，而呼叫方法時，必須為這些參數指定型別引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="fd054-149">與型別不同的是，型別引數通常可以從方法呼叫的引數推斷，而不需要明確指定。</span><span class="sxs-lookup"><span data-stu-id="fd054-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="fd054-150">在宣告方法的類別中，方法的「簽章」必須是唯一的。</span><span class="sxs-lookup"><span data-stu-id="fd054-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="fd054-151">方法的簽章包含方法的名稱、類型參數的數目，以及其參數的數目、修飾詞和類型。</span><span class="sxs-lookup"><span data-stu-id="fd054-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="fd054-152">方法的簽章不包含傳回型別。</span><span class="sxs-lookup"><span data-stu-id="fd054-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="fd054-153">當方法主體是單一運算式時，可以使用壓縮運算式格式來定義方法，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="fd054-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override string ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="fd054-154">參數</span><span class="sxs-lookup"><span data-stu-id="fd054-154">Parameters</span></span>

<span data-ttu-id="fd054-155">參數是用來將值或變數參考傳遞給方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="fd054-156">方法的參數會從叫用方法時所指定的「引數」取得其實際值。</span><span class="sxs-lookup"><span data-stu-id="fd054-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="fd054-157">參數有四種：值參數、參考參數、輸出參數，以及參數陣列。</span><span class="sxs-lookup"><span data-stu-id="fd054-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="fd054-158">「值參數」適用於傳遞輸入引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="fd054-159">值參數會對應至區域變數，此變數會從針對參數傳遞的引數取得其初始值。</span><span class="sxs-lookup"><span data-stu-id="fd054-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="fd054-160">對值參數的修改不會影響針對參數傳遞的引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="fd054-161">只要指定預設值，值參數便可以成為選用參數，如此即可省略對應的引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="fd054-162">「參考參數」適用於以參考方式傳遞引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="fd054-163">傳遞給參考參數的引數必須是具有明確值的變數。</span><span class="sxs-lookup"><span data-stu-id="fd054-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="fd054-164">在方法執行期間，參考參數表示與引數變數相同的儲存位置。</span><span class="sxs-lookup"><span data-stu-id="fd054-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="fd054-165">宣告參考參數時，是使用 `ref` 修飾詞來宣告。</span><span class="sxs-lookup"><span data-stu-id="fd054-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="fd054-166">下列範例示範 `ref` 參數的用法。</span><span class="sxs-lookup"><span data-stu-id="fd054-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="fd054-167">「輸出參數」適用於以參考方式傳遞引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="fd054-168">其類似於參考參數，只不過它並不需要您明確指派值給呼叫端提供的引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="fd054-169">宣告輸出參數時，是使用 `out` 修飾詞來宣告。</span><span class="sxs-lookup"><span data-stu-id="fd054-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="fd054-170">下列範例示範如何使用 C# 7 中所引入的語法來利用 `out` 參數。</span><span class="sxs-lookup"><span data-stu-id="fd054-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="fd054-171">「參數陣列」可允許將數目不固定的引數傳遞給方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="fd054-172">宣告參數陣列時，是使用 `params` 修飾詞來宣告。</span><span class="sxs-lookup"><span data-stu-id="fd054-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="fd054-173">只有方法的最後一個參數可以是參數陣列，而參數陣列的型別必須是單一維度陣列型別。</span><span class="sxs-lookup"><span data-stu-id="fd054-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="fd054-174">`Write`類別的和 `WriteLine` 方法 <xref:System.Console?displayProperty=nameWithType> 是參數陣列使用方式的良好範例。</span><span class="sxs-lookup"><span data-stu-id="fd054-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="fd054-175">這些宣告如下所示。</span><span class="sxs-lookup"><span data-stu-id="fd054-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="fd054-176">在使用參數陣列的方法內，參數陣列的行為與陣列型別的一般參數完全相同。</span><span class="sxs-lookup"><span data-stu-id="fd054-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="fd054-177">不過，在具有參數陣列的方法調用中，可以傳遞參數陣列類型的單一引數，或參數陣列的元素類型之任何數目的引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="fd054-178">在後者的案例中，會自動建立陣列執行個體並以指定的引數將其初始化。</span><span class="sxs-lookup"><span data-stu-id="fd054-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="fd054-179">以下範例</span><span class="sxs-lookup"><span data-stu-id="fd054-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="fd054-180">等同於撰寫下列程式碼。</span><span class="sxs-lookup"><span data-stu-id="fd054-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="fd054-181">方法主體和區域變數</span><span class="sxs-lookup"><span data-stu-id="fd054-181">Method body and local variables</span></span>

<span data-ttu-id="fd054-182">方法的主體會指定叫用方法時所要執行的陳述式。</span><span class="sxs-lookup"><span data-stu-id="fd054-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="fd054-183">方法主體可以宣告方法叫用專屬的變數。</span><span class="sxs-lookup"><span data-stu-id="fd054-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="fd054-184">這類變數稱為「區域變數」。</span><span class="sxs-lookup"><span data-stu-id="fd054-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="fd054-185">區域變數宣告會指定型別名稱、變數名稱，還可能指定初始值。</span><span class="sxs-lookup"><span data-stu-id="fd054-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="fd054-186">下列範例會宣告一個初始值為零的區域變數 `i`，以及一個沒有初始值的區域變數 `j`。</span><span class="sxs-lookup"><span data-stu-id="fd054-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="fd054-187">C# 要求必須「明確指派」區域變數，才能取得其值。</span><span class="sxs-lookup"><span data-stu-id="fd054-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="fd054-188">例如，如果先前的宣告 `i` 不包含初始值，則編譯器會回報稍後使用的錯誤， `i` 因為 `i` 不會在程式中的那些點明確指派。</span><span class="sxs-lookup"><span data-stu-id="fd054-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="fd054-189">方法可以使用 `return` 陳述式將控制權交還給其呼叫端。</span><span class="sxs-lookup"><span data-stu-id="fd054-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="fd054-190">在傳回的方法中 `void` ， `return` 語句無法指定運算式。</span><span class="sxs-lookup"><span data-stu-id="fd054-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="fd054-191">在傳回非 void 的方法中，`return` 陳述式必須包含會計算傳回值的運算式。</span><span class="sxs-lookup"><span data-stu-id="fd054-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="fd054-192">靜態和執行個體方法</span><span class="sxs-lookup"><span data-stu-id="fd054-192">Static and instance methods</span></span>

<span data-ttu-id="fd054-193">使用修飾詞宣告的方法 `static` 是 *靜態方法*。</span><span class="sxs-lookup"><span data-stu-id="fd054-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="fd054-194">靜態方法不會在特定的實例上運作，而且只能直接存取靜態成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="fd054-195">未使用修飾詞宣告的方法 `static` 是 *實例方法*。</span><span class="sxs-lookup"><span data-stu-id="fd054-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="fd054-196">執行個體方法會在特定的執行個體上運作，並且既可存取靜態成員也可存取執行個體成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="fd054-197">透過 `this` 可以明確存取叫用執行個體方法時所在的執行個體。</span><span class="sxs-lookup"><span data-stu-id="fd054-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="fd054-198">`this`在靜態方法中參考的是錯誤。</span><span class="sxs-lookup"><span data-stu-id="fd054-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="fd054-199">下列 `Entity` 類別同時含有靜態成員和執行個體成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="fd054-200">每個 `Entity` 實例都包含序號 (，且應該有一些其他不會在這裡顯示的資訊) 。</span><span class="sxs-lookup"><span data-stu-id="fd054-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="fd054-201">`Entity` 建構函式 (類似於執行個體方法) 會將具有下一個可用序號的新執行個體初始化。</span><span class="sxs-lookup"><span data-stu-id="fd054-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="fd054-202">因為此函式是實例成員，所以允許存取 `_serialNo` 實例欄位和 `s_nextSerialNo` 靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="fd054-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="fd054-203">`GetNextSerialNo` 和 `SetNextSerialNo` 靜態方法可以存取 `s_nextSerialNo` 靜態欄位，但如果直接存取 `_serialNo` 執行個體欄位，則會產生錯誤。</span><span class="sxs-lookup"><span data-stu-id="fd054-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="fd054-204">下列範例示範如何使用 `Entity` 類別。</span><span class="sxs-lookup"><span data-stu-id="fd054-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="fd054-205">`SetNextSerialNo`和 `GetNextSerialNo` 靜態方法是在類別上叫用，而 `GetSerialNo` 實例方法則是在類別的實例上叫用。</span><span class="sxs-lookup"><span data-stu-id="fd054-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="fd054-206">虛擬、覆寫及抽象方法</span><span class="sxs-lookup"><span data-stu-id="fd054-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="fd054-207">當執行個體方法宣告包含 `virtual` 修飾詞時，該方法即稱為「虛擬方法」。</span><span class="sxs-lookup"><span data-stu-id="fd054-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="fd054-208">當沒有任何 virtual 修飾詞存在時，該方法則稱為「非虛擬方法」。</span><span class="sxs-lookup"><span data-stu-id="fd054-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="fd054-209">叫用虛擬方法時，叫用所針對之執行個體的「執行階段型別」會決定要叫用的實際方法實作。</span><span class="sxs-lookup"><span data-stu-id="fd054-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="fd054-210">在非虛擬方法叫用中，決定因素則是執行個體的「編譯階段型別」。</span><span class="sxs-lookup"><span data-stu-id="fd054-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="fd054-211">在衍生類別中可以「覆寫」虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="fd054-212">當執行個體方法宣告包含 override 修飾詞時，該方法會覆寫具有相同簽章的已繼承虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="fd054-213">虛擬方法宣告導入了新的方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-213">A virtual method declaration introduces a new method.</span></span> <span data-ttu-id="fd054-214">覆寫方法宣告會提供該方法的新實作為，專門為現有的繼承虛擬方法特製化。</span><span class="sxs-lookup"><span data-stu-id="fd054-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="fd054-215">「抽象方法」係指不含實作的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="fd054-216">抽象方法是以修飾詞宣告 `abstract` ，而且只允許在抽象類別中。</span><span class="sxs-lookup"><span data-stu-id="fd054-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="fd054-217">抽象方法必須在每個非抽象的衍生類別中被覆寫。</span><span class="sxs-lookup"><span data-stu-id="fd054-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="fd054-218">下列範例會宣告一個抽象類別 `Expression` 和三個衍生的類別 `Constant`、`VariableReference` 及 `Operation`，前者代表一個運算式樹狀架構節點，後者則會實作常數、變數參考及算數運算式的運算式樹狀架構節點。</span><span class="sxs-lookup"><span data-stu-id="fd054-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="fd054-219"> (此範例類似，但與) 的運算式樹狀架構類型無關。</span><span class="sxs-lookup"><span data-stu-id="fd054-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="fd054-220">先前的四個類別可用來建構算數運算式的模型。</span><span class="sxs-lookup"><span data-stu-id="fd054-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="fd054-221">例如，在使用這些類別執行個體的情況下，可以將運算式 `x + 3` 表示如下。</span><span class="sxs-lookup"><span data-stu-id="fd054-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="fd054-222">系統會叫用 `Expression` 執行個體的 `Evaluate` 方法來評估指定的運算式並產生 `double` 值。</span><span class="sxs-lookup"><span data-stu-id="fd054-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="fd054-223">此方法會採用包含變數名稱 (作為項目的索引鍵) 和值 (作為項目的值) 的 `Dictionary` 引數。</span><span class="sxs-lookup"><span data-stu-id="fd054-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="fd054-224">因為 `Evaluate` 是一種抽象方法，所以衍生自 `Expression` 的非抽象類別必須覆寫 `Evaluate`。</span><span class="sxs-lookup"><span data-stu-id="fd054-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="fd054-225">`Constant` 的 `Evaluate` 實作會直接傳回預存的常數。</span><span class="sxs-lookup"><span data-stu-id="fd054-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="fd054-226">`VariableReference` 的實作會查詢字典中的變數名稱並傳回產生的值。</span><span class="sxs-lookup"><span data-stu-id="fd054-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="fd054-227">`Operation` 的實作會先評估左邊和右邊的運算元 (透過以遞迴方式叫用其 `Evaluate` 方法)，然後才執行指定的算數運算。</span><span class="sxs-lookup"><span data-stu-id="fd054-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="fd054-228">下列程式會使用 `Expression` 類別來評估不同 `x` 和 `y` 值的 `x * (y + 2)` 運算式。</span><span class="sxs-lookup"><span data-stu-id="fd054-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="fd054-229">方法多載</span><span class="sxs-lookup"><span data-stu-id="fd054-229">Method overloading</span></span>

<span data-ttu-id="fd054-230">方法「多載」可允許相同類別中的多個方法擁有相同的名稱，只要它們的簽章是唯一的即可。</span><span class="sxs-lookup"><span data-stu-id="fd054-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="fd054-231">編譯多載方法的叫用時，編譯器會使用「多載解析」來判斷要叫用的特定方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="fd054-232">多載解析會尋找最符合引數的方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="fd054-233">如果找不到單一最佳相符項，則會回報錯誤。</span><span class="sxs-lookup"><span data-stu-id="fd054-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="fd054-234">下列範例示範多載解析的實際運作情況。</span><span class="sxs-lookup"><span data-stu-id="fd054-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="fd054-235">方法中每個調用的批註 `UsageExample` 會顯示叫用的方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="fd054-236">如範例所示，一律將引數轉換成確切的參數類型和類型引數，藉以選取特定的方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="fd054-237">其他函式成員</span><span class="sxs-lookup"><span data-stu-id="fd054-237">Other function members</span></span>

<span data-ttu-id="fd054-238">包含可執行程式碼的成員統稱為類別的「函式成員」。</span><span class="sxs-lookup"><span data-stu-id="fd054-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="fd054-239">上一節說明方法，也就是函數成員的主要類型。</span><span class="sxs-lookup"><span data-stu-id="fd054-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="fd054-240">本節將說明 C# 所支援的其他函式成員類型：建構函式、屬性、索引子、事件、運算子及完成項。</span><span class="sxs-lookup"><span data-stu-id="fd054-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="fd054-241">下列範例顯示名為的泛型類別 `MyList<T>` ，它會實可成長物件清單。</span><span class="sxs-lookup"><span data-stu-id="fd054-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="fd054-242">此類別包含數個最常見的函式成員類型。</span><span class="sxs-lookup"><span data-stu-id="fd054-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="fd054-243">建構函式</span><span class="sxs-lookup"><span data-stu-id="fd054-243">Constructors</span></span>

<span data-ttu-id="fd054-244">C# 同時支援執行個體建構函式和靜態建構函式。</span><span class="sxs-lookup"><span data-stu-id="fd054-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="fd054-245">「執行個體建構函式」是實作將類別執行個體初始化所需之動作的成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="fd054-246">*靜態* 的函式是一種成員，它會執行第一次載入類別本身時所需的動作。</span><span class="sxs-lookup"><span data-stu-id="fd054-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="fd054-247">建構函式的宣告方式與方法類似，但不含傳回型別且名稱會與包含它的類別相同。</span><span class="sxs-lookup"><span data-stu-id="fd054-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="fd054-248">如果函式宣告包含修飾詞 `static` ，就會宣告靜態的函式。</span><span class="sxs-lookup"><span data-stu-id="fd054-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="fd054-249">否則，所宣告的會是執行個體建構函式。</span><span class="sxs-lookup"><span data-stu-id="fd054-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="fd054-250">執行個體建構函式可以多載，且可以具有選擇性參數。</span><span class="sxs-lookup"><span data-stu-id="fd054-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="fd054-251">例如，`MyList<T>` 類別會使用單一選擇性 `int` 參數來宣告一個執行個體建構函式。</span><span class="sxs-lookup"><span data-stu-id="fd054-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="fd054-252">叫用執行個體建構函式時，是使用 `new` 運算子來叫用。</span><span class="sxs-lookup"><span data-stu-id="fd054-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="fd054-253">下列陳述式會使用 `MyList` 類別的建構函式搭配或不搭配選用的引數來配置兩個 `MyList<string>` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="fd054-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="fd054-254">不同于其他成員，實例的函式不會被繼承。</span><span class="sxs-lookup"><span data-stu-id="fd054-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="fd054-255">類別沒有任何實例的函式，而不是實際在類別中宣告的函式。</span><span class="sxs-lookup"><span data-stu-id="fd054-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="fd054-256">如果沒有為類別提供任何執行個體建構函式，則會自動提供一個沒有任何參數的空建構函式。</span><span class="sxs-lookup"><span data-stu-id="fd054-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="fd054-257">屬性</span><span class="sxs-lookup"><span data-stu-id="fd054-257">Properties</span></span>

<span data-ttu-id="fd054-258">「屬性」是欄位的自然延伸。</span><span class="sxs-lookup"><span data-stu-id="fd054-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="fd054-259">兩者都是具有關聯型別的具名成員，並且用來存取欄位和屬性的語法是相同的。</span><span class="sxs-lookup"><span data-stu-id="fd054-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="fd054-260">不過，不同于欄位，屬性不代表儲存位置。</span><span class="sxs-lookup"><span data-stu-id="fd054-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="fd054-261">相反地，屬性具有 *存取* 子，可指定讀取或寫入其值時所執行的語句。</span><span class="sxs-lookup"><span data-stu-id="fd054-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="fd054-262">屬性的宣告方式與欄位類似，不同之處在于宣告的結尾是 get 存取子，或是在分隔符號之間撰寫的 set 存取子 `{` ， `}` 而不是以分號結尾。</span><span class="sxs-lookup"><span data-stu-id="fd054-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="fd054-263">具有 get 存取子和 set 存取子的屬性是 *讀寫屬性*。</span><span class="sxs-lookup"><span data-stu-id="fd054-263">A property that has both a get accessor and a set accessor is a *read-write property*.</span></span> <span data-ttu-id="fd054-264">只有 get 存取子的屬性是 *唯讀屬性*。</span><span class="sxs-lookup"><span data-stu-id="fd054-264">A property that has only a get accessor is a *read-only property*.</span></span> <span data-ttu-id="fd054-265">只有一個 set 存取子的屬性是一個僅限 *寫入的屬性*。</span><span class="sxs-lookup"><span data-stu-id="fd054-265">A property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="fd054-266">get 存取子會與傳回值屬於屬性型別的無參數方法對應。</span><span class="sxs-lookup"><span data-stu-id="fd054-266">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="fd054-267">set 存取子會與具有單一參數具名值且沒有任何傳回型別的方法對應。</span><span class="sxs-lookup"><span data-stu-id="fd054-267">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="fd054-268">Get 存取子會計算屬性的值。</span><span class="sxs-lookup"><span data-stu-id="fd054-268">The get accessor computes the value of the property.</span></span> <span data-ttu-id="fd054-269">Set 存取子會提供新的屬性值。</span><span class="sxs-lookup"><span data-stu-id="fd054-269">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="fd054-270">當屬性是指派的目標或或的運算元時， `++` `--` 就會叫用 set 存取子。</span><span class="sxs-lookup"><span data-stu-id="fd054-270">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="fd054-271">在參考屬性的其他情況下，則會叫用 get 存取子。</span><span class="sxs-lookup"><span data-stu-id="fd054-271">In other cases where the property is referenced, the get accessor is invoked.</span></span>

<span data-ttu-id="fd054-272">`MyList<T>` 類別會宣告 `Count` 和 `Capacity` 這兩個屬性，它們分別是唯讀屬性和讀寫屬性。</span><span class="sxs-lookup"><span data-stu-id="fd054-272">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="fd054-273">下列程式碼是使用這些屬性的範例：</span><span class="sxs-lookup"><span data-stu-id="fd054-273">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="fd054-274">與欄位和方法類似，C# 也同時支援執行個體屬性和靜態屬性。</span><span class="sxs-lookup"><span data-stu-id="fd054-274">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="fd054-275">宣告靜態屬性時，是使用 static 修飾詞來宣告，而宣告執行個體屬性時，則不使用該修飾詞。</span><span class="sxs-lookup"><span data-stu-id="fd054-275">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="fd054-276">屬性的存取子可以是虛擬的。</span><span class="sxs-lookup"><span data-stu-id="fd054-276">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="fd054-277">當屬性宣告包含 `virtual`、`abstract` 或 `override` 修飾詞時，會套用至該屬性的存取子。</span><span class="sxs-lookup"><span data-stu-id="fd054-277">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="fd054-278">索引子</span><span class="sxs-lookup"><span data-stu-id="fd054-278">Indexers</span></span>

<span data-ttu-id="fd054-279">「索引子」是可讓物件以和陣列相同的方式進行索引編製的成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-279">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="fd054-280">索引子的宣告方式與屬性類似，不同之處在於成員的名稱是 `this`，後面接著在 `[` 與 `]` 分隔符號之間撰寫的參數清單。</span><span class="sxs-lookup"><span data-stu-id="fd054-280">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="fd054-281">索引子的存取子中會提供參數。</span><span class="sxs-lookup"><span data-stu-id="fd054-281">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="fd054-282">與屬性類似，索引子可以是讀寫、唯讀及唯寫的，而索引子的存取子可以是虛擬的。</span><span class="sxs-lookup"><span data-stu-id="fd054-282">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="fd054-283">`MyList<T>` 類別會宣告一個採用 `int` 參數的單一讀寫索引子。</span><span class="sxs-lookup"><span data-stu-id="fd054-283">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="fd054-284">此索引子使得系統能夠以 `int` 值編製 `MyList<T>` 執行個體的索引。</span><span class="sxs-lookup"><span data-stu-id="fd054-284">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="fd054-285">例如：</span><span class="sxs-lookup"><span data-stu-id="fd054-285">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="fd054-286">索引子可以多載。</span><span class="sxs-lookup"><span data-stu-id="fd054-286">Indexers can be overloaded.</span></span> <span data-ttu-id="fd054-287">類別可以宣告多個索引子，只要其參數的數目或類型不同。</span><span class="sxs-lookup"><span data-stu-id="fd054-287">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="fd054-288">事件</span><span class="sxs-lookup"><span data-stu-id="fd054-288">Events</span></span>

<span data-ttu-id="fd054-289">「事件」是可讓類別或物件提供通知的成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-289">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="fd054-290">事件的宣告方式與欄位類似，不同之處在于宣告 `event` 會包含關鍵字，而類型必須是委派類型。</span><span class="sxs-lookup"><span data-stu-id="fd054-290">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="fd054-291">在宣告事件成員的類別中，事件的行為就像委派型別的欄位一樣 (前提是事件不是抽象的，也不會) 宣告存取子。</span><span class="sxs-lookup"><span data-stu-id="fd054-291">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="fd054-292">欄位會儲存對委派項目的參考，該委派項目代表已新增到事件中的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="fd054-292">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="fd054-293">如果沒有任何事件處理常式存在，欄位就會是 `null`。</span><span class="sxs-lookup"><span data-stu-id="fd054-293">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="fd054-294">`MyList<T>` 類別會宣告一個名為 `Changed` 的單一事件成員，此成員會指出新項目已新增到清單中。</span><span class="sxs-lookup"><span data-stu-id="fd054-294">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="fd054-295">Changed 事件是由 `OnChanged` 虛擬方法所引發，此方法會先檢查事件是否為 `null` (意謂著沒有任何處理常式存在)。</span><span class="sxs-lookup"><span data-stu-id="fd054-295">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="fd054-296">引發事件的概念相當於叫用事件所代表的委派。</span><span class="sxs-lookup"><span data-stu-id="fd054-296">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="fd054-297">沒有可引發事件的特殊語言結構。</span><span class="sxs-lookup"><span data-stu-id="fd054-297">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="fd054-298">用戶端是透過「事件處理常式」來對事件進行反應。</span><span class="sxs-lookup"><span data-stu-id="fd054-298">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="fd054-299">附加事件處理常式時，是使用 `+=` 運算子，移除時，則是使用 `-=` 運算子。</span><span class="sxs-lookup"><span data-stu-id="fd054-299">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="fd054-300">下列範例會將事件處理常式附加到 `MyList<string>` 的 `Changed` 事件。</span><span class="sxs-lookup"><span data-stu-id="fd054-300">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="fd054-301">針對需要控制事件基礎儲存的 advanced 案例，事件宣告可以明確提供 `add` 和 `remove` 存取子，類似于 `set` 屬性的存取子。</span><span class="sxs-lookup"><span data-stu-id="fd054-301">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="fd054-302">運算子</span><span class="sxs-lookup"><span data-stu-id="fd054-302">Operators</span></span>

<span data-ttu-id="fd054-303">「運算子」是定義將特定運算式運算子套用到類別執行個體之意義的成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-303">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="fd054-304">可定義的運算子有三種：一元運算子、二元運算子及轉換運算子。</span><span class="sxs-lookup"><span data-stu-id="fd054-304">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="fd054-305">所有運算子都必須宣告為 `public` 和 `static`。</span><span class="sxs-lookup"><span data-stu-id="fd054-305">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="fd054-306">類別會宣告 `MyList<T>` 兩個運算子： `operator ==` 和 `operator !=` 。</span><span class="sxs-lookup"><span data-stu-id="fd054-306">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="fd054-307">這些覆寫的運算子會對將這些運算子套用至實例的運算式提供新意義 `MyList` 。</span><span class="sxs-lookup"><span data-stu-id="fd054-307">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="fd054-308">具體而言，運算子會定義兩個 `MyList<T>` 實例是否相等，以使用其方法來比較每個包含的物件 `Equals` 。</span><span class="sxs-lookup"><span data-stu-id="fd054-308">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="fd054-309">下列範例會使用 `==` 運算子來比較兩個 `MyList<int>` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="fd054-309">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="fd054-310">第一個 `Console.WriteLine` 會輸出 `True`，因為兩個清單所包含物件的數目相同、值相同且順序相同。</span><span class="sxs-lookup"><span data-stu-id="fd054-310">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="fd054-311">如果 `MyList<T>` 並未定義 `operator ==`，則第一個 `Console.WriteLine` 所輸出的會是 `False`，因為 `a` 和 `b` 參考不同的 `MyList<int>` 執行個體。</span><span class="sxs-lookup"><span data-stu-id="fd054-311">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="fd054-312">完成項</span><span class="sxs-lookup"><span data-stu-id="fd054-312">Finalizers</span></span>

<span data-ttu-id="fd054-313">「完成項」是實作將類別執行個體完成所需之動作的成員。</span><span class="sxs-lookup"><span data-stu-id="fd054-313">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="fd054-314">通常，需要完成項才能釋放非受控資源。</span><span class="sxs-lookup"><span data-stu-id="fd054-314">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="fd054-315">完成項不能有參數，它們不能有存取範圍修飾詞，而且無法明確地叫用。</span><span class="sxs-lookup"><span data-stu-id="fd054-315">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="fd054-316">系統會在記憶體回收期間自動叫用執行個體的完成項。</span><span class="sxs-lookup"><span data-stu-id="fd054-316">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="fd054-317">如需詳細資訊，請參閱有關 [完成項的](../programming-guide/classes-and-structs/destructors.md)文章。</span><span class="sxs-lookup"><span data-stu-id="fd054-317">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="fd054-318">記憶體回收行程有相當大的自由來決定何時回收物件並執行完成項。</span><span class="sxs-lookup"><span data-stu-id="fd054-318">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="fd054-319">具體而言，完成項調用的時間並不具決定性，而且可以在任何執行緒上執行完成項。</span><span class="sxs-lookup"><span data-stu-id="fd054-319">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="fd054-320">基於這些及其他理由，類別應該只有在沒有任何其他解決方案可行時，才實作完成項。</span><span class="sxs-lookup"><span data-stu-id="fd054-320">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="fd054-321">`using` 陳述式提供較佳的物件解構方法。</span><span class="sxs-lookup"><span data-stu-id="fd054-321">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="fd054-322">運算式</span><span class="sxs-lookup"><span data-stu-id="fd054-322">Expressions</span></span>

<span data-ttu-id="fd054-323">「運算式」是由「運算元」和「運算子」建構而成。</span><span class="sxs-lookup"><span data-stu-id="fd054-323">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="fd054-324">運算式的運算子會指出要將哪些運算套用到運算元。</span><span class="sxs-lookup"><span data-stu-id="fd054-324">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="fd054-325">運算子範例包括 `+`、`-`、`*`、`/` 及 `new`。</span><span class="sxs-lookup"><span data-stu-id="fd054-325">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="fd054-326">運算元範例包括常值、欄位、區域變數及運算式。</span><span class="sxs-lookup"><span data-stu-id="fd054-326">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="fd054-327">當運算式包含多個運算子時，運算子的「優先順序」會控制個別運算子的評估順序。</span><span class="sxs-lookup"><span data-stu-id="fd054-327">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="fd054-328">例如，運算式 `x + y * z` 會評估為 `x + (y * z)`，因為 `*` 運算子的優先順序高於 `+` 運算子。</span><span class="sxs-lookup"><span data-stu-id="fd054-328">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="fd054-329">當兩個優先順序相同的運算子之間有運算元時，運算子的「關聯性」會控制執行運算的順序：</span><span class="sxs-lookup"><span data-stu-id="fd054-329">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="fd054-330">除了指派和 null 聯合運算子之外，所有二元運算子都是 *左方關聯* 的，這表示作業是由左至右執行。</span><span class="sxs-lookup"><span data-stu-id="fd054-330">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="fd054-331">例如，`x + y + z` 會判斷值為 `(x + y) + z`。</span><span class="sxs-lookup"><span data-stu-id="fd054-331">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="fd054-332">指派運算子、null `??` `??=` 聯合和運算子和條件運算子 `?:` 是 *右向關聯* 的，這表示作業是由右至左執行。</span><span class="sxs-lookup"><span data-stu-id="fd054-332">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="fd054-333">例如，`x = y = z` 會判斷值為 `x = (y = z)`。</span><span class="sxs-lookup"><span data-stu-id="fd054-333">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="fd054-334">您可以使用括弧來控制優先順序和關聯性。</span><span class="sxs-lookup"><span data-stu-id="fd054-334">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="fd054-335">例如，`x + y * z` 會先將 `y` 乘以 `z`，然後再將結果加到 `x`，而 `(x + y) * z` 則會先將 `x` 與 `y` 相加，然後再將結果乘以 `z`。</span><span class="sxs-lookup"><span data-stu-id="fd054-335">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="fd054-336">大部分的運算子都可以[「多載」](../language-reference/operators/operator-overloading.md)。</span><span class="sxs-lookup"><span data-stu-id="fd054-336">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="fd054-337">運算子多載可允許針對一個運算元屬於 (或兩個運算元都屬於) 使用者定義之類別或結構型別的運算式，指定使用者定義的運算子實作。</span><span class="sxs-lookup"><span data-stu-id="fd054-337">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="fd054-338">C# 提供數個運算子，用於執行[算術](../language-reference/operators/arithmetic-operators.md)、[邏輯](../language-reference/operators/boolean-logical-operators.md)、[位元和移位](../language-reference/operators/bitwise-and-shift-operators.md)作業以及[相等](../language-reference/operators/equality-operators.md)和[順序](../language-reference/operators/comparison-operators.md)比較。</span><span class="sxs-lookup"><span data-stu-id="fd054-338">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="fd054-339">如需按優先順序層級排序的 C# 運算子完整清單，請參閱 [C# 運算子](../language-reference/operators/index.md)。</span><span class="sxs-lookup"><span data-stu-id="fd054-339">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="fd054-340">陳述式</span><span class="sxs-lookup"><span data-stu-id="fd054-340">Statements</span></span>

<span data-ttu-id="fd054-341">程式的動作是藉由 *陳述式* 來表達。</span><span class="sxs-lookup"><span data-stu-id="fd054-341">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="fd054-342">C# 支援數種不同類型的陳述式，其中一些是以內嵌陳述式來定義。</span><span class="sxs-lookup"><span data-stu-id="fd054-342">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="fd054-343">「區塊」可允許在許可單一陳述式的內容中撰寫多個陳述式。</span><span class="sxs-lookup"><span data-stu-id="fd054-343">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="fd054-344">區塊是由在 `{` 與 `}` 分隔符號之間撰寫的陳述式清單所組成。</span><span class="sxs-lookup"><span data-stu-id="fd054-344">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="fd054-345">「宣告陳述式」可用來宣告區域變數和常數。</span><span class="sxs-lookup"><span data-stu-id="fd054-345">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="fd054-346">「運算式陳述式」可用來評估運算式。</span><span class="sxs-lookup"><span data-stu-id="fd054-346">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="fd054-347">可用來作為陳述式的運算式包括方法叫用、使用 `new` 運算子的物件配置、使用 `=` 和複合指派運算子的指派、使用 `++` 和 `--` 運算子的遞增和遞減運算，以及 `await` 運算。</span><span class="sxs-lookup"><span data-stu-id="fd054-347">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="fd054-348">「選取範圍陳述式」可用來選取一些可能陳述式的其中之一，以根據某個運算式的值來執行。</span><span class="sxs-lookup"><span data-stu-id="fd054-348">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="fd054-349">這個群組包含 `if` 和 `switch` 語句。</span><span class="sxs-lookup"><span data-stu-id="fd054-349">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="fd054-350">「反覆運算陳述式」可用來重複執行內嵌的陳述式。</span><span class="sxs-lookup"><span data-stu-id="fd054-350">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="fd054-351">這個群組包含 `while` 、 `do` 、 `for` 和 `foreach` 語句。</span><span class="sxs-lookup"><span data-stu-id="fd054-351">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="fd054-352">「跳躍陳述式」可用來轉移控制項。</span><span class="sxs-lookup"><span data-stu-id="fd054-352">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="fd054-353">這個群組包含 `break` 、 `continue` 、 `goto` 、 `throw` 、 `return` 和 `yield` 語句。</span><span class="sxs-lookup"><span data-stu-id="fd054-353">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="fd054-354">`try`...`catch` 陳述式可用來攔截在執行區塊時發生的例外狀況，而 `try`...`finally` 陳述式則可用來指定不論是否發生例外狀況都一律會執行的最終處理程式碼。</span><span class="sxs-lookup"><span data-stu-id="fd054-354">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="fd054-355">`checked` 和 `unchecked` 陳述式可用來控制整數型別算術運算和轉換的溢位檢查內容。</span><span class="sxs-lookup"><span data-stu-id="fd054-355">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="fd054-356">`lock` 陳述式可用來取得所指定物件的互斥鎖定、執行陳述式，然後釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="fd054-356">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="fd054-357">`using` 陳述式可用來取得資源、執行陳述式，然後處置該資源。</span><span class="sxs-lookup"><span data-stu-id="fd054-357">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="fd054-358">以下列出可以使用的語句種類：</span><span class="sxs-lookup"><span data-stu-id="fd054-358">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="fd054-359">區域變數宣告。</span><span class="sxs-lookup"><span data-stu-id="fd054-359">Local variable declaration.</span></span>
* <span data-ttu-id="fd054-360">本機常數宣告。</span><span class="sxs-lookup"><span data-stu-id="fd054-360">Local constant declaration.</span></span>
* <span data-ttu-id="fd054-361">運算式語句。</span><span class="sxs-lookup"><span data-stu-id="fd054-361">Expression statement.</span></span>
* <span data-ttu-id="fd054-362">`if` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-362">`if` statement.</span></span>
* <span data-ttu-id="fd054-363">`switch` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-363">`switch` statement.</span></span>
* <span data-ttu-id="fd054-364">`while` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-364">`while` statement.</span></span>
* <span data-ttu-id="fd054-365">`do` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-365">`do` statement.</span></span>
* <span data-ttu-id="fd054-366">`for` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-366">`for` statement.</span></span>
* <span data-ttu-id="fd054-367">`foreach` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-367">`foreach` statement.</span></span>
* <span data-ttu-id="fd054-368">`break` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-368">`break` statement.</span></span>
* <span data-ttu-id="fd054-369">`continue` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-369">`continue` statement.</span></span>
* <span data-ttu-id="fd054-370">`goto` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-370">`goto` statement.</span></span>
* <span data-ttu-id="fd054-371">`return` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-371">`return` statement.</span></span>
* <span data-ttu-id="fd054-372">`yield` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-372">`yield` statement.</span></span>
* <span data-ttu-id="fd054-373">`throw` 語句和 `try` 語句。</span><span class="sxs-lookup"><span data-stu-id="fd054-373">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="fd054-374">`checked` 和 `unchecked` 語句。</span><span class="sxs-lookup"><span data-stu-id="fd054-374">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="fd054-375">`lock` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-375">`lock` statement.</span></span>
* <span data-ttu-id="fd054-376">`using` 聲明。</span><span class="sxs-lookup"><span data-stu-id="fd054-376">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="fd054-377">[上一個](types.md) 
>[下一步](features.md)</span><span class="sxs-lookup"><span data-stu-id="fd054-377">[Previous](types.md)
[Next](features.md)</span></span>
