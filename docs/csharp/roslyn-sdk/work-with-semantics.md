---
title: "使用 .NET Compiler Platform SDK 語意模型"
description: "此概觀可讓您了解用來了解和管理程式碼語意模型的類型。"
author: billwagner
ms.author: wiwagn
ms.date: 10/15/2017
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 28366093c516f5367d82c0bdfc53749e764361ef
ms.sourcegitcommit: d095094e942eedf09530ea5636fbaf9029853027
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/19/2017
---
# <a name="work-with-semantics"></a>使用語意

[語法樹狀結構](work-with-syntax.md)代表原始程式碼的語彙和語法結構。 雖然只要這項資訊就足以描述來源中的所有宣告和邏輯，但其資訊卻不足以識別所要參考的項目。 名稱可能代表：

- 類型
- 欄位
- 方法
- 區域變數

雖然上述所有項目都是唯一且不同的，但是判斷識別碼實際所參考的項目通常需要深入了解語言規則。 

原始程式碼中具有程式項目，而且程式也可以參考以組件檔封裝的先前已編譯程式庫。 雖然沒有原始程式碼可用於組件，因而沒有語法節點或樹狀結構，但是程式仍然可以參考其內的項目。

針對這些工作，您需要**語意模型**。

除了原始程式碼的語法模型之外，語意模型還會封裝語言規則，讓您輕鬆且正確地比對識別碼與所參考的正確程式項目。

## <a name="compilation"></a>編譯

編譯會呈現編譯 C# 或 Visual Basic 程式所需的所有項目，以包含所有組件參考、編譯器選項和原始程式檔。 

因為所有這些資訊都是在同一個地方，所以可以詳細描述原始程式碼中包含的項目。 編譯會將每個宣告類型、成員或變數呈現為符號。 編譯包含各種方法，協助您尋找並關聯已宣告於原始程式碼或從組件中匯入為中繼資料的符號。

與語法樹狀結構類似，編譯為不可變。 建立編譯之後，您或可能與其共用的其他人就無法變更它。 不過，您可以從現有編譯建立新的編譯，並指定這麼做的變更。 例如，您可以建立與現有編譯完全相同的編譯，差異在於它可以包含其他原始程式檔或組件參考。

## <a name="symbols"></a>Symbol

符號代表由原始程式碼所宣告或從組件中匯入為中繼資料的相異項目。 每個命名空間、類型、方法、屬性、欄位、事件、參數或區域變數都是以符號呈現。 

<xref:Microsoft.CodeAnalysis.Compilation> 類型上的各種不同方法和屬性可協助您尋找符號。 例如，您可以依其一般中繼資料名稱來找到已宣告類型的符號。 您也可以存取整個符號表作為全域命名空間之根符號的樹狀結構。

符號也會包含編譯器從來源或中繼資料判斷而來的其他資訊，例如其他參考的符號。 每種符號都是由衍生自 <xref:Microsoft.CodeAnalysis.ISymbol> 的個別介面所代表，而每個介面都有詳述編譯器所收集資訊的專屬方法和屬性。 其中許多屬性都是直接參考其他符號。 例如，<xref:Microsoft.CodeAnalysis.IMethodSymbol.ReturnType?displayProperty=nameWithType> 屬性會告知方法宣告所參考的實際類型符號。

符號會呈現原始程式碼與中繼資料間之命名空間、類型和成員的一般表示。 例如，在原始程式碼中宣告的方法以及從中繼資料匯入的方法，都是使用具有相同屬性的 <xref:Microsoft.CodeAnalysis.IMethodSymbol> 所呈現。

符號的概念類似 <xref:System.Reflection> API 所呈現的 CLR 類型系統，但它們不只是將類型模型化。 命名空間、區域變數和標籤都是符號。 此外，符號是語言概念的呈現，而不是 CLR 概念。 有很多重疊，但也有許多有意義的區別。 例如，C# 或 Visual Basic 中的迭代器方法是單一符號。 不過，迭代器方法轉譯為 CLR 中繼資料時，它就是類型和多個方法。

## <a name="semantic-model"></a>語意模型

語意模型代表單一原始程式檔的所有語意資訊。 您可以使用它來探索下列項目： 

* 來源中特定位置所參考的符號。
* 任何運算式的結果類型。
* 所有診斷，也就是錯誤和警告。
* 變數如何流入和流出來源的區域。
* 更推測性問題的答案。
