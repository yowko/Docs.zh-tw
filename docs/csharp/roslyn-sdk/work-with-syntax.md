---
title: "使用 .NET Compiler Platform SDK 語法模型"
description: "此概觀說明您使用的類型，以了解與管理語法節點。"
author: billwagner
ms.author: wiwagn
ms.date: 10/15/2017
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: fa3b7af871380d4f18ebe7ef4f5bc5963cc247c4
ms.sourcegitcommit: 2142a4732bb4ff519b9817db4c24a237b9810d4b
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/05/2018
---
# <a name="work-with-syntax"></a><span data-ttu-id="8469c-103">使用語法</span><span class="sxs-lookup"><span data-stu-id="8469c-103">Work with syntax</span></span>

<span data-ttu-id="8469c-104">**語法樹**是編譯器 API 公開的基本資料結構。</span><span class="sxs-lookup"><span data-stu-id="8469c-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="8469c-105">這些樹狀結構代表原始程式碼的語彙和語法結構。</span><span class="sxs-lookup"><span data-stu-id="8469c-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="8469c-106">它們有兩個重要用途：</span><span class="sxs-lookup"><span data-stu-id="8469c-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="8469c-107">允許 IDE、增益集、程式碼分析工具及重構等工具查看與處理使用者專案中的原始程式碼語法結構。</span><span class="sxs-lookup"><span data-stu-id="8469c-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="8469c-108">讓重構和 IDE 等工具以自然的方式建立、修改及重新整理原始程式碼，不用直接編輯文字。</span><span class="sxs-lookup"><span data-stu-id="8469c-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="8469c-109">透過建立和管理樹狀結構，工具可以輕鬆建立及重新整理程式碼。</span><span class="sxs-lookup"><span data-stu-id="8469c-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="8469c-110">語法樹</span><span class="sxs-lookup"><span data-stu-id="8469c-110">Syntax trees</span></span>

<span data-ttu-id="8469c-111">語法樹是用於編譯、程式碼分析、繫結、重構、IDE 功能與產生程式碼的主要結構。</span><span class="sxs-lookup"><span data-stu-id="8469c-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="8469c-112">若不先找到並分類成許多已知的結構化語言項目之一，原始程式碼的任何部分均無法解讀。</span><span class="sxs-lookup"><span data-stu-id="8469c-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span> 

<span data-ttu-id="8469c-113">語法樹有三個索引鍵屬性。</span><span class="sxs-lookup"><span data-stu-id="8469c-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="8469c-114">第一個屬性是語法樹完整保存所有來源資訊不失真。</span><span class="sxs-lookup"><span data-stu-id="8469c-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="8469c-115">這表示語法樹包含在原始程式文字中找到的所有資訊片段、所有文法建構、所有語彙權杖，以及介於兩者之間的所有其他項目，包括空白字元、註解和前置處理器指示詞。</span><span class="sxs-lookup"><span data-stu-id="8469c-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including whitespace, comments, and preprocessor directives.</span></span> <span data-ttu-id="8469c-116">例如，來源中提及的每個常值都和鍵入的一般無二。</span><span class="sxs-lookup"><span data-stu-id="8469c-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="8469c-117">當程式因為表示語法樹中的略過或遺漏權杖而不完整或格式不正確時，語法樹也代表原始程式碼中的錯誤。</span><span class="sxs-lookup"><span data-stu-id="8469c-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>  

<span data-ttu-id="8469c-118">這會啟用語法樹的第二個屬性。</span><span class="sxs-lookup"><span data-stu-id="8469c-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="8469c-119">從剖析器取得的語法樹會產生其剖析來源的確切文字。</span><span class="sxs-lookup"><span data-stu-id="8469c-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="8469c-120">從任何語法節點，都有可能取得以該節點為根的子樹狀結構的文字表示。</span><span class="sxs-lookup"><span data-stu-id="8469c-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="8469c-121">這表示語法樹可以用來建構和編輯原始程式文字。</span><span class="sxs-lookup"><span data-stu-id="8469c-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="8469c-122">建立以隱含方式建立對等文字的樹狀結構，以及編輯語法樹，從現有的樹狀結構變更中製造新的樹狀結構，實際上即已編輯文字。</span><span class="sxs-lookup"><span data-stu-id="8469c-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span> 

<span data-ttu-id="8469c-123">語法樹的第三個屬性是它們為不可變且具備執行緒安全。</span><span class="sxs-lookup"><span data-stu-id="8469c-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="8469c-124">這表示取得樹狀結構之後，它就是目前程式碼狀態的快照集，永遠不會變更。</span><span class="sxs-lookup"><span data-stu-id="8469c-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="8469c-125">這可讓多位使用者在不同的執行緒中同時與同一語法樹互動，不會鎖定或重複。</span><span class="sxs-lookup"><span data-stu-id="8469c-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="8469c-126">因為樹狀結構是不變的，而且不能直接對樹狀結構進行任何修改，所以 Factory 方法透過建立樹狀結構的其他快照集來協助建立和修改語法樹。</span><span class="sxs-lookup"><span data-stu-id="8469c-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="8469c-127">樹狀結構重複使用基礎節點很有效率，因此新版本重建迅速且只佔一點額外的記憶體。</span><span class="sxs-lookup"><span data-stu-id="8469c-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="8469c-128">語法樹實際上是樹狀資料結構，在此，其他項目的父代為非結尾結構化項目。</span><span class="sxs-lookup"><span data-stu-id="8469c-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="8469c-129">每一個語法樹都是由節點、權杖和邏輯所組成。</span><span class="sxs-lookup"><span data-stu-id="8469c-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>  

## <a name="syntax-nodes"></a><span data-ttu-id="8469c-130">語法節點</span><span class="sxs-lookup"><span data-stu-id="8469c-130">Syntax nodes</span></span>

<span data-ttu-id="8469c-131">語法節點是語法樹主要項目的其中之一。</span><span class="sxs-lookup"><span data-stu-id="8469c-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="8469c-132">這些節點代表語法建構，例如宣告、陳述式、子句和運算式。</span><span class="sxs-lookup"><span data-stu-id="8469c-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="8469c-133">每個語法節點類別都是由衍生自 <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> 的個別類別代表。</span><span class="sxs-lookup"><span data-stu-id="8469c-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8469c-134">節點類別集不可擴充。</span><span class="sxs-lookup"><span data-stu-id="8469c-134">The set of node classes is not extensible.</span></span> 

<span data-ttu-id="8469c-135">所有語法節點都是語法樹中的非結尾節點，這表示它們一律有其他子系節點和權杖。</span><span class="sxs-lookup"><span data-stu-id="8469c-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="8469c-136">身為另一個節點的子系，每個節點都有父節點，可透過 <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> 屬性存取。</span><span class="sxs-lookup"><span data-stu-id="8469c-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8469c-137">因為節點和樹狀結構不可變，所以節點的父代永遠不會變更。</span><span class="sxs-lookup"><span data-stu-id="8469c-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="8469c-138">樹狀結構的根有 null 父代。</span><span class="sxs-lookup"><span data-stu-id="8469c-138">The root of the tree has a null parent.</span></span>  

<span data-ttu-id="8469c-139">每個節點都有 <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> 方法，根據子節點在原始程式文字中的位置，傳回它們的循序清單。</span><span class="sxs-lookup"><span data-stu-id="8469c-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="8469c-140">本清單不包含權杖。</span><span class="sxs-lookup"><span data-stu-id="8469c-140">This list does not contain tokens.</span></span> <span data-ttu-id="8469c-141">每個節點也有方法可檢查子系，例如 <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>、<xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A> 或 <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A>，代表所有節點、權杖或邏輯的清單，存在於以該節點為根的子樹狀結構中。</span><span class="sxs-lookup"><span data-stu-id="8469c-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia, that exist in the sub-tree rooted by that node.</span></span>  

<span data-ttu-id="8469c-142">此外，每個語法節點的子類別會透過強型別屬性公開所有相同的子系。</span><span class="sxs-lookup"><span data-stu-id="8469c-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="8469c-143">例如，<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> 節點類別有三個針對二元運算子的額外屬性：<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> 和 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>。</span><span class="sxs-lookup"><span data-stu-id="8469c-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="8469c-144"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> 和 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> 的類型是 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>，<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> 的類型是 <xref:Microsoft.CodeAnalysis.SyntaxToken>。</span><span class="sxs-lookup"><span data-stu-id="8469c-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="8469c-145">某些語法節點有選擇性的子系。</span><span class="sxs-lookup"><span data-stu-id="8469c-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="8469c-146">例如，<xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> 有選擇性的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>。</span><span class="sxs-lookup"><span data-stu-id="8469c-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="8469c-147">如果子系不存在，則屬性會傳回 null。</span><span class="sxs-lookup"><span data-stu-id="8469c-147">If the child is not present, the property returns null.</span></span> 

## <a name="syntax-tokens"></a><span data-ttu-id="8469c-148">語法權杖</span><span class="sxs-lookup"><span data-stu-id="8469c-148">Syntax tokens</span></span>

<span data-ttu-id="8469c-149">語法權杖是語言文法的結尾，代表最小的程式碼語法片段。</span><span class="sxs-lookup"><span data-stu-id="8469c-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="8469c-150">它們永遠不是其他節點或權杖的父代。</span><span class="sxs-lookup"><span data-stu-id="8469c-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="8469c-151">語法權杖是由關鍵字、識別碼、常值和標點符號所組成。</span><span class="sxs-lookup"><span data-stu-id="8469c-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span> 

<span data-ttu-id="8469c-152">基於效率考量，<xref:Microsoft.CodeAnalysis.SyntaxToken> 類型是 CLR 值類型。</span><span class="sxs-lookup"><span data-stu-id="8469c-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="8469c-153">因此，不像語法節點，所有種類的混合屬性權杖只有一種結構，這些屬性具有依賴要代表之權杖種類的意義。</span><span class="sxs-lookup"><span data-stu-id="8469c-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="8469c-154">例如，整數常值權杖代表數值。</span><span class="sxs-lookup"><span data-stu-id="8469c-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="8469c-155">除了權杖跨越的未經處理原始程式文字，常值權杖有 <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> 屬性會告訴您精確的已解碼整數值。</span><span class="sxs-lookup"><span data-stu-id="8469c-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="8469c-156">此屬性歸類為 <xref:System.Object>，因為它可能是眾多基本類型之一。</span><span class="sxs-lookup"><span data-stu-id="8469c-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="8469c-157"><xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> 屬性告訴您的資訊和 <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> 屬性一樣，但這個屬性一律歸類為 <xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="8469c-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="8469c-158">C# 原始程式文字中的識別碼可能包含 Unicode 逸出字元，但逸出序列本身的語法不視為識別碼名稱的一部分。</span><span class="sxs-lookup"><span data-stu-id="8469c-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="8469c-159">所以，雖然權杖跨越的原始文字確實包含逸出序列，但 <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> 屬性則否。</span><span class="sxs-lookup"><span data-stu-id="8469c-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="8469c-160">它反而會包含逸出所識別的 Unicode 字元。</span><span class="sxs-lookup"><span data-stu-id="8469c-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="8469c-161">例如，如果原始程式文字包含寫為 `\u03C0` 的識別碼，則此權杖的 <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> 屬性會傳回 `π`。</span><span class="sxs-lookup"><span data-stu-id="8469c-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="8469c-162">語法邏輯</span><span class="sxs-lookup"><span data-stu-id="8469c-162">Syntax trivia</span></span>

<span data-ttu-id="8469c-163">語法邏輯代表的原始程式文字部分，主要是一般的程式碼，例如空白字元、註解和前置處理器指示詞。</span><span class="sxs-lookup"><span data-stu-id="8469c-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as whitespace, comments, and preprocessor directives.</span></span> <span data-ttu-id="8469c-164">像語法權杖一樣，邏輯為實值型別。</span><span class="sxs-lookup"><span data-stu-id="8469c-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="8469c-165">單一 <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> 類型用以描述所有種類的邏輯。</span><span class="sxs-lookup"><span data-stu-id="8469c-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="8469c-166">因為邏輯不屬於一般的語言語法，而且會出現在任兩個權杖之間的任何位置，所以它們未被納入語法樹成為子節點。</span><span class="sxs-lookup"><span data-stu-id="8469c-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="8469c-167">但因為它們在實作重構等功能以維護完整的原始程式文字不失真時很重要，所以它們又是語法樹的一部分。</span><span class="sxs-lookup"><span data-stu-id="8469c-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="8469c-168">您可以檢查權杖的 <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> 或 <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> 集合來存取邏輯。</span><span class="sxs-lookup"><span data-stu-id="8469c-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="8469c-169">剖析原始程式文字後，邏輯的順序就與權杖產生關聯。</span><span class="sxs-lookup"><span data-stu-id="8469c-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="8469c-170">一般情況下，權杖擁有自同一行到下一個權杖的任何邏輯。</span><span class="sxs-lookup"><span data-stu-id="8469c-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="8469c-171">該行之後的所有邏輯都與接續的權杖建立關聯。</span><span class="sxs-lookup"><span data-stu-id="8469c-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="8469c-172">原始程式檔中的第一個權杖取得所有初始邏輯，檔案中邏輯的最後一個序列會跟到檔案結尾的權杖，這本來會是零寬度。</span><span class="sxs-lookup"><span data-stu-id="8469c-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="8469c-173">不同於語法節點和權杖，語法邏輯沒有父代。</span><span class="sxs-lookup"><span data-stu-id="8469c-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="8469c-174">但因為它們屬於樹狀結構，而且每一個都與單一權杖建立關聯，所以您可以存取它使用 <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> 屬性來建立關聯的權杖。</span><span class="sxs-lookup"><span data-stu-id="8469c-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="8469c-175">跨越</span><span class="sxs-lookup"><span data-stu-id="8469c-175">Spans</span></span>

<span data-ttu-id="8469c-176">每個節點、權杖或邏輯都知道其在原始程式文字內的位置及其組成字元數。</span><span class="sxs-lookup"><span data-stu-id="8469c-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="8469c-177">文字位置是以 32 位元的整數表示，也就是以零起始的 `char` 索引。</span><span class="sxs-lookup"><span data-stu-id="8469c-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="8469c-178"><xref:Microsoft.CodeAnalysis.Text.TextSpan> 物件是起始位置和字元計數，兩個都以整數表示。</span><span class="sxs-lookup"><span data-stu-id="8469c-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="8469c-179">如果 <xref:Microsoft.CodeAnalysis.Text.TextSpan> 長度為零，即指兩個字元之間的位置。</span><span class="sxs-lookup"><span data-stu-id="8469c-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="8469c-180">每個節點都有兩個 <xref:Microsoft.CodeAnalysis.Text.TextSpan> 屬性：<xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> 和 <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>。</span><span class="sxs-lookup"><span data-stu-id="8469c-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span*> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan*>.</span></span> 

<span data-ttu-id="8469c-181"><xref:Microsoft.CodeAnalysis.SyntaxNode.Span\*> 屬性是從節點子樹狀結構的第一個權杖開頭到最後一個權杖結尾的文字。</span><span class="sxs-lookup"><span data-stu-id="8469c-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span\*> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="8469c-182">此範圍不包含任何開頭或尾端邏輯。</span><span class="sxs-lookup"><span data-stu-id="8469c-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="8469c-183"><xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan\*> 屬性是包含節點正常範圍的文字範圍，加上任何開頭或尾端邏輯的範圍。</span><span class="sxs-lookup"><span data-stu-id="8469c-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan\*> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="8469c-184">例如: </span><span class="sxs-lookup"><span data-stu-id="8469c-184">For example:</span></span> 

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="8469c-185">區塊內的陳述式節點有單一分隔號 (|) 所指示的範圍。</span><span class="sxs-lookup"><span data-stu-id="8469c-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="8469c-186">它包括字元 `throw new Exception("Not right.");`。</span><span class="sxs-lookup"><span data-stu-id="8469c-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="8469c-187">完整範圍以雙分隔號 (|) 表示。</span><span class="sxs-lookup"><span data-stu-id="8469c-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="8469c-188">當範圍和字元與開頭和尾端邏輯建立關聯時，它會包含相同字元。</span><span class="sxs-lookup"><span data-stu-id="8469c-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="8469c-189">種類</span><span class="sxs-lookup"><span data-stu-id="8469c-189">Kinds</span></span>

<span data-ttu-id="8469c-190">每個節點、權杖或邏輯都有 <xref:System.Int32?displayProperty=fullName> 類型的 <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> 屬性，可識別所代表的確切語法項目。</span><span class="sxs-lookup"><span data-stu-id="8469c-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=fullName>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="8469c-191">這個值可以轉換成特定語言的列舉。每種語言，C# 或 VB，都有單一 `SyntaxKind` 列舉 (分別是 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=fullName> 和 <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=fullName>)，會列出文法中所有可能的節點、權杖和邏輯項目。</span><span class="sxs-lookup"><span data-stu-id="8469c-191">This value can be cast to a language-specific enumeration; each language, C# or VB, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=fullName> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=fullName>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="8469c-192">存取 <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> 或 <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> 擴充方法可自動完成此轉換。</span><span class="sxs-lookup"><span data-stu-id="8469c-192">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind*?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind*?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="8469c-193"><xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> 屬性允許共用相同節點類別的語法節點類型簡單去除混淆。</span><span class="sxs-lookup"><span data-stu-id="8469c-193">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="8469c-194">對權杖和邏輯而言，這個屬性是區別某項目類型的唯一方式。</span><span class="sxs-lookup"><span data-stu-id="8469c-194">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span> 

<span data-ttu-id="8469c-195">例如，單一 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> 類別有 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>、<xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> 和 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> 子系。</span><span class="sxs-lookup"><span data-stu-id="8469c-195">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="8469c-196"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind\*> 屬性可區別其為 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>、<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression> 或 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> 種類的語法節點。</span><span class="sxs-lookup"><span data-stu-id="8469c-196">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind\*> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="8469c-197">錯誤</span><span class="sxs-lookup"><span data-stu-id="8469c-197">Errors</span></span>

<span data-ttu-id="8469c-198">即使原始程式文字包含語法錯誤，仍會公開可往返來源的完整語法樹。</span><span class="sxs-lookup"><span data-stu-id="8469c-198">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="8469c-199">當剖析器遇到不符合已定義語言語法的程式碼時，它會使用兩種技術之一來建立語法樹。</span><span class="sxs-lookup"><span data-stu-id="8469c-199">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="8469c-200">首先，如果剖析器找不到預期的特定種類權杖，它可能會將遺漏的權杖插入到語法樹中該權杖本應出現的位置。</span><span class="sxs-lookup"><span data-stu-id="8469c-200">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="8469c-201">遺漏的權杖代表預期的實際權杖，但具有空的範圍，且其 <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> 屬性會傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="8469c-201">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="8469c-202">第二，剖析器可能會略過權杖，直到它找到可繼續剖析的權杖。</span><span class="sxs-lookup"><span data-stu-id="8469c-202">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="8469c-203">在此情況下，略過的權杖會附加為種類為 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia> 的邏輯節點。</span><span class="sxs-lookup"><span data-stu-id="8469c-203">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
