---
title: 開始使用語法轉換 (Roslyn API)
description: 周遊、查詢和查核語法樹狀結構的簡介。
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: acba7ac590154ad8458d0d9a8abac55a12e96265
ms.sourcegitcommit: fb78d8abbdb87144a3872cf154930157090dd933
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/01/2018
ms.locfileid: "47400786"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="dd638-103">開始使用語法轉換</span><span class="sxs-lookup"><span data-stu-id="dd638-103">Get started with syntax transformation</span></span>

<span data-ttu-id="dd638-104">[開始使用語法分析](syntax-analysis.md)與[開始使用語意分析](semantic-analysis.md) 快速入門中所探索的概念與技術，乃是此教學課程的基礎。</span><span class="sxs-lookup"><span data-stu-id="dd638-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="dd638-105">若您尚未完成那些快速入門，則應該在開始此教學課程之前先完成。</span><span class="sxs-lookup"><span data-stu-id="dd638-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="dd638-106">在此快速入門中，您會探索用於建立及轉換語法樹狀結構的技術。</span><span class="sxs-lookup"><span data-stu-id="dd638-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="dd638-107">結合您在先前的快速入門中所學到的技術之後，就可以建立第一個命令列重構！</span><span class="sxs-lookup"><span data-stu-id="dd638-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="dd638-108">不變性與 .NET 編譯器平台</span><span class="sxs-lookup"><span data-stu-id="dd638-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="dd638-109">**不變性**是 .NET 編譯器平台的基本原則。</span><span class="sxs-lookup"><span data-stu-id="dd638-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="dd638-110">在固定資料結構建立之後，即無法變更。</span><span class="sxs-lookup"><span data-stu-id="dd638-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="dd638-111">固定資料結構可以同時由多個取用者安全地共用及分析。</span><span class="sxs-lookup"><span data-stu-id="dd638-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="dd638-112">不會有某個取用者意外影響另一個取用者的風險。</span><span class="sxs-lookup"><span data-stu-id="dd638-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="dd638-113">您的分析器不需要進行鎖定或採用其他並行措施。</span><span class="sxs-lookup"><span data-stu-id="dd638-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="dd638-114">此規則適用於語法樹狀結構、編譯、符號、語意模型，以及您遇到的任何資料結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="dd638-115">API 不會修改現有的結構，而是會根據指定給舊物件的差異來建立新物件。</span><span class="sxs-lookup"><span data-stu-id="dd638-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="dd638-116">您會將此概念套用到語法樹狀結構，以使用轉換來建立新的樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="dd638-117">建立及轉換樹狀結構</span><span class="sxs-lookup"><span data-stu-id="dd638-117">Create and transform trees</span></span>

<span data-ttu-id="dd638-118">您會選擇語法轉換的兩個策略之一。</span><span class="sxs-lookup"><span data-stu-id="dd638-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="dd638-119">當您搜尋要取代的特定節點或要插入新節點的位置時，**Factory 方法**是最佳選項。</span><span class="sxs-lookup"><span data-stu-id="dd638-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="dd638-120">當您要掃描整個專案以尋找要取代的程式碼模式時，**重寫器**是最佳選項。</span><span class="sxs-lookup"><span data-stu-id="dd638-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="dd638-121">使用 Factory 方法建立節點</span><span class="sxs-lookup"><span data-stu-id="dd638-121">Create nodes with factory methods</span></span>

<span data-ttu-id="dd638-122">第一個語法轉換將會示範 Factory 方法。</span><span class="sxs-lookup"><span data-stu-id="dd638-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="dd638-123">您會使用 `using System.Collections.Generic;` 陳述式取代 `using System.Collections;` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="dd638-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="dd638-124">此範例示範如何使用 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> Factory 方法建立 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> 物件。</span><span class="sxs-lookup"><span data-stu-id="dd638-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="dd638-125">針對每種**節點**、**權杖**或 **Trivia**，會有一個建立該型別執行個體的 Factory 方法。</span><span class="sxs-lookup"><span data-stu-id="dd638-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="dd638-126">您會透過由下往上撰寫節點的方式來建立語法樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="dd638-127">然後，使用您建立的新樹狀結構來取代現有節點，以轉換現有的程式。</span><span class="sxs-lookup"><span data-stu-id="dd638-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="dd638-128">啟動 Visual Studio，然後建立新的 C# **獨立程式碼分析工具**專案。</span><span class="sxs-lookup"><span data-stu-id="dd638-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="dd638-129">在 Visual Studio 中，選擇 [檔案] > [新增] > [專案] 來顯示 [新增專案] 對話方塊。</span><span class="sxs-lookup"><span data-stu-id="dd638-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="dd638-130">在 [Visual C#] > [擴充性] 下，選擇 [獨立程式碼分析工具]。</span><span class="sxs-lookup"><span data-stu-id="dd638-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="dd638-131">此快速入門有兩個範例專案，因此請將方案命名為 **SyntaxTransformationQuickStart**，並將專案命名為 **ConstructionCS**。</span><span class="sxs-lookup"><span data-stu-id="dd638-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="dd638-132">按一下 [確定 **Deploying Office Solutions**]。</span><span class="sxs-lookup"><span data-stu-id="dd638-132">Click **OK**.</span></span>

<span data-ttu-id="dd638-133">此專案使用 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> 類別方法來建構代表 `System.Collections.Generic` 命名空間的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="dd638-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="dd638-134">將下列 using 指示詞加入到 `Program.cs` 檔案頂端，以匯入 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> 類別的 Factory 方法與 <xref:System.Console> 的方法，以便您稍後可以在不需要為其進行限定的情況下使用它們：</span><span class="sxs-lookup"><span data-stu-id="dd638-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="dd638-135">您將會建立**名稱語法節點**以建置將代表 `using System.Collections.Generic;` 陳述式的樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="dd638-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> 是適用於 C# 中所出現四個名稱型別的基底類別。</span><span class="sxs-lookup"><span data-stu-id="dd638-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="dd638-137">您會將這四個名稱型別撰寫在一起，以建立可以出現在 C# 語言中的任何名稱：</span><span class="sxs-lookup"><span data-stu-id="dd638-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="dd638-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>，它代表簡單單一識別碼名稱，例如 `System` 與 `Microsoft`。</span><span class="sxs-lookup"><span data-stu-id="dd638-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="dd638-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>，它代表泛型型別或方法名稱，例如 `List<int>`。</span><span class="sxs-lookup"><span data-stu-id="dd638-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="dd638-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>，它代表格式為 `<left-name>.<right-identifier-or-generic-name>` 的限定名稱，例如 `System.IO`。</span><span class="sxs-lookup"><span data-stu-id="dd638-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="dd638-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>，它代表使用組件外部別名的名稱，例如 `LibraryV2::Foo`。</span><span class="sxs-lookup"><span data-stu-id="dd638-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="dd638-142">您會使用 <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> 方法來建立 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> 節點。</span><span class="sxs-lookup"><span data-stu-id="dd638-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="dd638-143">在 `Program.cs` 中的 `Main` 方法中加入下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="dd638-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="dd638-144">上述程式碼會建立 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> 物件並將它指派給變數 `name`。</span><span class="sxs-lookup"><span data-stu-id="dd638-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="dd638-145">許多 Roslyn API 都會傳回基底類別，讓您更容易搭配相關型別使用。</span><span class="sxs-lookup"><span data-stu-id="dd638-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="dd638-146">變數 `name` 是一個 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>，此變數可以在您建置 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> 時重複使用。</span><span class="sxs-lookup"><span data-stu-id="dd638-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="dd638-147">建置範例時不要使用型別推斷。</span><span class="sxs-lookup"><span data-stu-id="dd638-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="dd638-148">您將會在此專案中將該步驟自動化。</span><span class="sxs-lookup"><span data-stu-id="dd638-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="dd638-149">您已建立名稱。</span><span class="sxs-lookup"><span data-stu-id="dd638-149">You've created the name.</span></span> <span data-ttu-id="dd638-150">現在，您可以透過建置 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>，以在樹狀結構中建置更多節點。</span><span class="sxs-lookup"><span data-stu-id="dd638-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="dd638-151">新的樹狀結構使用 `name` 做為名稱左邊的部分，並使用 `Collections` 命名空間的新 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> 做為 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> 右邊的部分。</span><span class="sxs-lookup"><span data-stu-id="dd638-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="dd638-152">將下列程式碼新增至 `program.cs`：</span><span class="sxs-lookup"><span data-stu-id="dd638-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="dd638-153">重新執行程式碼，並查看結果。</span><span class="sxs-lookup"><span data-stu-id="dd638-153">Run the code again, and see the results.</span></span> <span data-ttu-id="dd638-154">您是在建置代表程式碼的節點樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="dd638-155">您將會繼續使用此模式為命名空間 `System.Collections.Generic` 建置 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>。</span><span class="sxs-lookup"><span data-stu-id="dd638-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="dd638-156">將下列程式碼新增至 `Program.cs`：</span><span class="sxs-lookup"><span data-stu-id="dd638-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="dd638-157">重新執行程式，以查看您是否已針對要加入的程式碼建置樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-157">Run the program again to see that you've build the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="dd638-158">建立已修改的樹狀結構</span><span class="sxs-lookup"><span data-stu-id="dd638-158">Create a modified tree</span></span>

<span data-ttu-id="dd638-159">您已建置包含一個陳述式的小型語法樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="dd638-160">使用 API 來建立新節點是建立單一陳述式或其他小型程式碼區塊的正確選擇。</span><span class="sxs-lookup"><span data-stu-id="dd638-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="dd638-161">不過，若要建置較大的程式碼區塊，您所使用的方法，應該要取代現有樹狀結構中節點或將節點插入到現有樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="dd638-162">請記住，語法樹狀結構是固定的。</span><span class="sxs-lookup"><span data-stu-id="dd638-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="dd638-163">**語法 API** 不提供任何可讓您在建構語法樹狀結構之後修改任何現有語法樹狀結構的機制。</span><span class="sxs-lookup"><span data-stu-id="dd638-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="dd638-164">但是它提供一個方法，可用來根據對現有樹狀結構的變更建立新的樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="dd638-165">`With*` 方法定義在衍生自 <xref:Microsoft.CodeAnalysis.SyntaxNode> 的實體類別中，或定義在 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> 類別中所宣告的擴充方法中。</span><span class="sxs-lookup"><span data-stu-id="dd638-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="dd638-166">這些方法會透過套用對現有節點子屬性所做的變更，來建立新節點。</span><span class="sxs-lookup"><span data-stu-id="dd638-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="dd638-167">此外，<xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 擴充方法也可以用來取代子樹狀結構中的子代節點。</span><span class="sxs-lookup"><span data-stu-id="dd638-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="dd638-168">此方法也會更新父系以指向新建立的子系，並在整個樹狀結構中重複此程序，此程序稱為樹狀結構 _Re-spining_。</span><span class="sxs-lookup"><span data-stu-id="dd638-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spining_ the tree.</span></span>

<span data-ttu-id="dd638-169">下一個步驟是建立代表整個 (小型) 程式的樹狀結構，然後修改它。</span><span class="sxs-lookup"><span data-stu-id="dd638-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="dd638-170">將下列程式碼加入到 `Program` 類別的開頭：</span><span class="sxs-lookup"><span data-stu-id="dd638-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="dd638-171">範例程式碼使用 `System.Collections` 命名空間，而非 `System.Collections.Generic` 命名空間。</span><span class="sxs-lookup"><span data-stu-id="dd638-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="dd638-172">接著，將下列程式碼加入到 `Main` 方法底部，以剖析文字並建議樹狀結構：</span><span class="sxs-lookup"><span data-stu-id="dd638-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="dd638-173">此範例使用 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> 方法，將 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> 節點中的名稱取代為您在上述程式碼中建構的名稱。</span><span class="sxs-lookup"><span data-stu-id="dd638-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="dd638-174">使用 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> 方法建立新的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> 節點，以將 `System.Collections` 名稱更新為您在上述程式碼中建立的名稱。</span><span class="sxs-lookup"><span data-stu-id="dd638-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="dd638-175">將下列程式碼加入到 `Main` 方法的底部：</span><span class="sxs-lookup"><span data-stu-id="dd638-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="dd638-176">執行程式並仔細查看輸出。</span><span class="sxs-lookup"><span data-stu-id="dd638-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="dd638-177">`newusing` 尚未放置在根樹狀結構中。</span><span class="sxs-lookup"><span data-stu-id="dd638-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="dd638-178">原始樹狀結構尚未變更。</span><span class="sxs-lookup"><span data-stu-id="dd638-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="dd638-179">使用 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 擴充方法加入下列程式碼，以建立新樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="dd638-180">新樹狀結構是使用已更新 `newUsing` 節點來取代現有匯入的結果。</span><span class="sxs-lookup"><span data-stu-id="dd638-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="dd638-181">您會將這個新樹狀結構指派給現有的 `root` 變數：</span><span class="sxs-lookup"><span data-stu-id="dd638-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="dd638-182">再次執行程式。</span><span class="sxs-lookup"><span data-stu-id="dd638-182">Run the program again.</span></span> <span data-ttu-id="dd638-183">這次樹狀結構現在會正確地匯入 `System.Collections.Generic` 命名空間。</span><span class="sxs-lookup"><span data-stu-id="dd638-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="dd638-184">使用 `SyntaxRewriters` 轉換樹狀結構</span><span class="sxs-lookup"><span data-stu-id="dd638-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="dd638-185">`With*` 與 <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> 方法提供簡便的方式讓您轉換語法樹狀結構的個別分支。</span><span class="sxs-lookup"><span data-stu-id="dd638-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="dd638-186"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> 類別會在語法樹狀結構上執行多次轉換。</span><span class="sxs-lookup"><span data-stu-id="dd638-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="dd638-187"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> 類別是 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType> 的子類別。</span><span class="sxs-lookup"><span data-stu-id="dd638-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="dd638-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> 會將轉換套用到 <xref:Microsoft.CodeAnalysis.SyntaxNode> 的特定型別。</span><span class="sxs-lookup"><span data-stu-id="dd638-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="dd638-189">您可以將轉換套用到多種型別的 <xref:Microsoft.CodeAnalysis.SyntaxNode> 物件 (當它們出現在語法樹狀結構中時)。</span><span class="sxs-lookup"><span data-stu-id="dd638-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="dd638-190">此快速入門中的第二個目標是建立命令列重構，以移除可以使用型別推斷之處的區域變數宣告中的明確型別。</span><span class="sxs-lookup"><span data-stu-id="dd638-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="dd638-191">建立新的 C# **獨立程式碼分析工具**專案。</span><span class="sxs-lookup"><span data-stu-id="dd638-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="dd638-192">在 Visual Studio 中，以滑鼠右鍵按一下 `SyntaxTransformationQuickStart` 方案節點。</span><span class="sxs-lookup"><span data-stu-id="dd638-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="dd638-193">選擇 [加入][新增專案] >  以顯示 [新增專案] 對話方塊。</span><span class="sxs-lookup"><span data-stu-id="dd638-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="dd638-194">在 **Visual C#** > **擴充性**下，選擇 [獨立程式碼分析工具]。</span><span class="sxs-lookup"><span data-stu-id="dd638-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="dd638-195">將您的專案命名為 `TransformationCS`，然後按一下 [確定]。</span><span class="sxs-lookup"><span data-stu-id="dd638-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="dd638-196">第一個步驟是建立衍生自 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> 的類別以執行轉換。</span><span class="sxs-lookup"><span data-stu-id="dd638-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="dd638-197">將新類別檔案加入到專案中。</span><span class="sxs-lookup"><span data-stu-id="dd638-197">Add a new class file to the project.</span></span> <span data-ttu-id="dd638-198">在 Visual Studio 中，選擇 [專案] > [新增類別]。在 [加入新項目] 對話方塊中，輸入 `TypeInferenceRewriter.cs` 做為檔案名稱。</span><span class="sxs-lookup"><span data-stu-id="dd638-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="dd638-199">將下列 using 指示詞加入到 `TypeInferenceRewriter.cs` 檔案中：</span><span class="sxs-lookup"><span data-stu-id="dd638-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="dd638-200">接著，讓 `TypeInferenceRewriter` 類別延伸 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> 類別：</span><span class="sxs-lookup"><span data-stu-id="dd638-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="dd638-201">加入下列程式碼宣告私用唯讀欄位以存放 <xref:Microsoft.CodeAnalysis.SemanticModel>，並在建構函式中將它初始化。</span><span class="sxs-lookup"><span data-stu-id="dd638-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="dd638-202">稍後您將需要此欄位來判斷可以使用型別推斷之處：</span><span class="sxs-lookup"><span data-stu-id="dd638-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="dd638-203">覆寫 <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> 方法：</span><span class="sxs-lookup"><span data-stu-id="dd638-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```C#
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="dd638-204">許多 Roslyn API 所宣告的傳回型別，都是所傳回實際執行階段型別的基底類別。</span><span class="sxs-lookup"><span data-stu-id="dd638-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="dd638-205">在許多案例中，一種類型的節點可能可以由另一種類型的節點完全取代，或甚至移除。</span><span class="sxs-lookup"><span data-stu-id="dd638-205">n many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="dd638-206">在此範例中，<xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> 方法會傳回 <xref:Microsoft.CodeAnalysis.SyntaxNode>，而非 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> 的衍生型別。</span><span class="sxs-lookup"><span data-stu-id="dd638-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="dd638-207">此重寫器會根據現有節點傳回新的 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> 節點。</span><span class="sxs-lookup"><span data-stu-id="dd638-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="dd638-208">此快速入門會處理區域變數宣告。</span><span class="sxs-lookup"><span data-stu-id="dd638-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="dd638-209">您可以將它延伸到其他宣告，例如 `foreach` 迴圈、`for` 迴圈、LINQ 運算式，以及 lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="dd638-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="dd638-210">此外，此重寫器只會轉換具有最簡單格式的宣告：</span><span class="sxs-lookup"><span data-stu-id="dd638-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="dd638-211">若要自行探索，請考慮針對這些類型的變數宣告延伸已完成的範例：</span><span class="sxs-lookup"><span data-stu-id="dd638-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="dd638-212">將下列程式碼加入到 `VisitLocalDeclarationStatement` 方法的主體，以跳過重寫這些格式的宣告：</span><span class="sxs-lookup"><span data-stu-id="dd638-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="dd638-213">此方法會透過傳回未經修改的 `node` 參數，以指出沒有發生任何重寫工作。</span><span class="sxs-lookup"><span data-stu-id="dd638-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="dd638-214">若那些 `if` 運算式中沒有任何運算式的評估結果為 True，則節點代表初始化內的可能宣告。</span><span class="sxs-lookup"><span data-stu-id="dd638-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="dd638-215">加入這些陳述式以擷取宣告中所指定的型別名稱，並使用 <xref:Microsoft.CodeAnalysis.SemanticModel> 欄位繫結它以取得型別符號：</span><span class="sxs-lookup"><span data-stu-id="dd638-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="dd638-216">現在，加入此陳述式以繫結初始設定式運算式：</span><span class="sxs-lookup"><span data-stu-id="dd638-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="dd638-217">最後，加入下列 `if` 陳述式以在初始設定式運算式符合所指定型別時，使用 `var` 關鍵字取代現有的型別名稱：</span><span class="sxs-lookup"><span data-stu-id="dd638-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Replace the initializer node")]

<span data-ttu-id="dd638-218">條件句是必要項目，因為宣告可能會將初始設定式運算式轉換為基底類別或介面。</span><span class="sxs-lookup"><span data-stu-id="dd638-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="dd638-219">若這是預期情況，則位於指派左邊與右邊的型別會不相符。</span><span class="sxs-lookup"><span data-stu-id="dd638-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="dd638-220">在這些案例中移除明確型別會使得程式的語意變更。</span><span class="sxs-lookup"><span data-stu-id="dd638-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="dd638-221">`var` 是指定為識別碼而非關鍵字，因為 `var` 是內容關鍵字。</span><span class="sxs-lookup"><span data-stu-id="dd638-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="dd638-222">前置與結尾 Trivia (空白字元) 會從舊類型名稱轉換為 `var` 關鍵字，以維持垂直空白字元與縮排。</span><span class="sxs-lookup"><span data-stu-id="dd638-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="dd638-223">相較於 `With*`，使用 `ReplaceNode` 可以更容易轉換 <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>，因為型別名稱實際上是宣告陳述式的下下層。</span><span class="sxs-lookup"><span data-stu-id="dd638-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="dd638-224">您已完成 `TypeInferenceRewriter`。</span><span class="sxs-lookup"><span data-stu-id="dd638-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="dd638-225">現在返回您的 `Program.cs` 檔案以完成範例。</span><span class="sxs-lookup"><span data-stu-id="dd638-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="dd638-226">建立測試 <xref:Microsoft.CodeAnalysis.Compilation> 並從它取得 <xref:Microsoft.CodeAnalysis.SemanticModel>。</span><span class="sxs-lookup"><span data-stu-id="dd638-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="dd638-227">使用該 <xref:Microsoft.CodeAnalysis.SemanticModel> 來嘗試您的 `TypeInferenceRewriter`。</span><span class="sxs-lookup"><span data-stu-id="dd638-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="dd638-228">您最後才執行此步驟。</span><span class="sxs-lookup"><span data-stu-id="dd638-228">You'll do this step last.</span></span> <span data-ttu-id="dd638-229">同時，請宣告代表您的測試編譯的預留位置變數：</span><span class="sxs-lookup"><span data-stu-id="dd638-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="dd638-230">暫停一小段時間之後，您應該會看到出現錯誤 Squiggle (語意錯誤通知)，此錯誤回報沒有任何 `CreateTestCompilation` 方法存在。</span><span class="sxs-lookup"><span data-stu-id="dd638-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="dd638-231">按 **Ctrl+句點** 以開啟燈泡功能表，然後按 Enter 以叫用 [產生方法 Stub] 命令。</span><span class="sxs-lookup"><span data-stu-id="dd638-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="dd638-232">此命令將會針對 `Program` 類別中的 `CreateTestCompilation` 方法產生方法 Stub。</span><span class="sxs-lookup"><span data-stu-id="dd638-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="dd638-233">您稍後將必須回來填寫此方法：</span><span class="sxs-lookup"><span data-stu-id="dd638-233">You'll come back to fill in this method later:</span></span>

![C# 從使用產生方法](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="dd638-235">撰寫下列程式碼，逐一查看測試 <xref:Microsoft.CodeAnalysis.Compilation> 中的每個 <xref:Microsoft.CodeAnalysis.SyntaxTree>。</span><span class="sxs-lookup"><span data-stu-id="dd638-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="dd638-236">針對每個項目，使用該樹狀結構的 <xref:Microsoft.CodeAnalysis.SemanticModel> 初始化新的 `TypeInferenceRewriter`：</span><span class="sxs-lookup"><span data-stu-id="dd638-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="dd638-237">在您建立的 `foreach` 陳述式內，加入下列程式碼以在每個來源樹狀結構上執行轉換。</span><span class="sxs-lookup"><span data-stu-id="dd638-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="dd638-238">若進行任何編輯，此程式碼會根據條件寫出新轉換的樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="dd638-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="dd638-239">您的重寫器應該只有在遇到一或多個可使用型別推斷簡化的區域變數宣告時，才會修改樹狀結構：</span><span class="sxs-lookup"><span data-stu-id="dd638-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="dd638-240">您應該會在 `File.WriteAllText` 程式碼下面看到 Squiggle (通知)。</span><span class="sxs-lookup"><span data-stu-id="dd638-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="dd638-241">選取燈泡，然後新增所需的 `using System.IO;` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="dd638-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="dd638-242">只差一點!</span><span class="sxs-lookup"><span data-stu-id="dd638-242">You're almost done!</span></span> <span data-ttu-id="dd638-243">還剩下一個步驟：建立測試 <xref:Microsoft.CodeAnalysis.Compilation>。</span><span class="sxs-lookup"><span data-stu-id="dd638-243">There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="dd638-244">因為您完全沒有在此快速入門中使用任何型別推斷，它將會讓您有一個完美的測試案例。</span><span class="sxs-lookup"><span data-stu-id="dd638-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="dd638-245">但很可惜，從 C# 專案檔案建立編譯不在此逐步解說的範圍內。</span><span class="sxs-lookup"><span data-stu-id="dd638-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="dd638-246">但是，若您仔細依照下列指示，就有希望。</span><span class="sxs-lookup"><span data-stu-id="dd638-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="dd638-247">以下列程式碼取代 `CreateTestCompilation` 方法的內容。</span><span class="sxs-lookup"><span data-stu-id="dd638-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="dd638-248">它會建立一個測試編譯，根據條件比對此快速入門中所述的專案：</span><span class="sxs-lookup"><span data-stu-id="dd638-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="dd638-249">祝好運，執行該專案。</span><span class="sxs-lookup"><span data-stu-id="dd638-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="dd638-250">在 Visual Studio 中，選擇 [偵錯] > [開始偵錯]。</span><span class="sxs-lookup"><span data-stu-id="dd638-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="dd638-251">Visual Studio 應該會提示您專案中的檔案已變更。</span><span class="sxs-lookup"><span data-stu-id="dd638-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="dd638-252">按一 [全部皆是] 以重新載入已修改的檔案。</span><span class="sxs-lookup"><span data-stu-id="dd638-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="dd638-253">檢查它們。</span><span class="sxs-lookup"><span data-stu-id="dd638-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="dd638-254">請注意，即使沒有那些明確與多餘的型別規範，程式碼看起來也非常簡潔。</span><span class="sxs-lookup"><span data-stu-id="dd638-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="dd638-255">恭喜您！</span><span class="sxs-lookup"><span data-stu-id="dd638-255">Congratulations!</span></span> <span data-ttu-id="dd638-256">您已使用**編譯器 API** 來撰寫自己的重構，以在 C# 專案的所有檔案中搜尋特定語法模式、針對符合這些模式的原始程式碼來分析其語意，並加以轉換。</span><span class="sxs-lookup"><span data-stu-id="dd638-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="dd638-257">您現在已經成為正式的重構作者！</span><span class="sxs-lookup"><span data-stu-id="dd638-257">You're now officially refactoring author!</span></span>